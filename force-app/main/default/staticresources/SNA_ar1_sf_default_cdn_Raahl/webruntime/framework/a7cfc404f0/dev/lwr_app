LWR.define("webruntime/app/v/1", ["exports", "lwr/loaderLegacy/v/0_9_0", "lwc/v/2_41_4", "@app/authenticationCookieName/v/1", "webruntime/transport/v/1_66_319-244_0", "@app/basePath/v/1", "@app/uiBasePath/v/1", "@app/routes/v/1", "@app/viewToThemeLayoutMap/v/1", "webruntime/o11y/v/1_66_319-244_0", "@app/extraRouteParams/v/1", "@app/apiBasePath/v/1", "@salesforce/i18n/lang/v/1", "@app/apexApiBasePath/v/1", "@app/isMobileAppMode/v/1", "@app/isDesignMode/v/1", "@app/guestUuidCookieName/v/1"], function(exports, _0_9_0, _2_41_4, authenticationCookieName, _1_66_319244_0$1, basePath, basePath$1, routes, viewToThemeLayoutMap, _1_66_319244_0, extraRouteParams, _1, _1$1, apexApiBasePath, isMobileAppMode, isDesignMode, guestUuidCookieName) {
  "use strict";
  function _interopDefaultLegacy(e2) {
    return e2 && typeof e2 === "object" && "default" in e2 ? e2 : {default: e2};
  }
  var authenticationCookieName__default = /* @__PURE__ */ _interopDefaultLegacy(authenticationCookieName);
  var basePath__default = /* @__PURE__ */ _interopDefaultLegacy(basePath);
  var basePath$1__default = /* @__PURE__ */ _interopDefaultLegacy(basePath$1);
  var routes__default = /* @__PURE__ */ _interopDefaultLegacy(routes);
  var viewToThemeLayoutMap__default = /* @__PURE__ */ _interopDefaultLegacy(viewToThemeLayoutMap);
  var extraRouteParams__default = /* @__PURE__ */ _interopDefaultLegacy(extraRouteParams);
  var apexApiBasePath__default = /* @__PURE__ */ _interopDefaultLegacy(apexApiBasePath);
  var isMobileAppMode__default = /* @__PURE__ */ _interopDefaultLegacy(isMobileAppMode);
  var isDesignMode__default = /* @__PURE__ */ _interopDefaultLegacy(isDesignMode);
  var guestUuidCookieName__default = /* @__PURE__ */ _interopDefaultLegacy(guestUuidCookieName);
  var _tmpl$a = void 0;
  const {
    performance: performance$3,
    console: console$1
  } = window;
  const detailMap = new WeakMap();
  let isDetailSupported = true;
  let isToJSONDetailSupported = false;
  try {
    const detail = {
      randomInfo: 123
    };
    const markEntry = performance$3.mark("A", {
      detail
    }) || performance$3.getEntriesByType("mark").pop();
    isDetailSupported = !!markEntry.detail && markEntry.detail.randomInfo === detail.randomInfo;
    isToJSONDetailSupported = JSON.stringify(markEntry).includes("randomInfo");
  } catch (ex) {
    isDetailSupported = false;
    console$1.warn("PerformanceMarkOptions#detail & PerformanceMeasureOptions#detail are not supported", ex);
  } finally {
    performance$3.clearMarks("A");
  }
  function override(object, method, fn) {
    const orig = object[method];
    object[method] = function() {
      return fn.apply(this, [orig.bind(this), ...arguments]);
    };
  }
  function setDetailOnEntries(entries) {
    entries.forEach((entry) => {
      if (entry instanceof PerformanceMark || entry instanceof PerformanceMeasure) {
        entry.detail = detailMap.get(entry) || null;
      }
    });
    return entries;
  }
  function entryToJSON() {
    return {
      name: this.name || null,
      entryType: this.entryType || null,
      startTime: this.startTime || null,
      duration: this.duration || null,
      detail: this.detail || null
    };
  }
  if (!isToJSONDetailSupported) {
    PerformanceMark.prototype.toJSON = entryToJSON;
    PerformanceMeasure.prototype.toJSON = entryToJSON;
  }
  if (!isDetailSupported) {
    override(performance$3, "mark", (orig, markName, markOptions) => {
      const mark2 = orig(markName) || performance$3.getEntriesByType("mark").pop();
      if (markOptions && markOptions.detail) {
        const serializedDetail = JSON.parse(JSON.stringify(markOptions.detail));
        mark2.detail = serializedDetail;
        detailMap.set(mark2, serializedDetail);
      }
      return mark2;
    });
    override(performance$3, "measure", (orig, ...args) => {
      if (typeof args[1] !== "string" && args[1] && args[1].detail) {
        const startName = args[1] && args[1].start || null;
        const measure = orig(args[0], startName) || performance$3.getEntriesByType("measure").sort((a2, b2) => a2.startTime + a2.duration - (b2.startTime + b2.duration)).pop();
        const serializedDetail = JSON.parse(JSON.stringify(args[1].detail));
        measure.detail = serializedDetail;
        detailMap.set(measure, serializedDetail);
        return measure;
      }
      return orig(...args);
    });
    override(performance$3, "getEntries", (orig) => {
      const entries = orig();
      return setDetailOnEntries(entries);
    });
    override(performance$3, "getEntriesByName", (orig, name, type) => {
      const entries = orig(name, type);
      return setDetailOnEntries(entries);
    });
    override(performance$3, "getEntriesByType", (orig, type) => {
      const entries = orig(type);
      return setDetailOnEntries(entries);
    });
  }
  const WEBRUNTIME_PREFIX = "webruntime";
  function getPrefixedURL(urlString) {
    return `/${WEBRUNTIME_PREFIX}${urlString}`;
  }
  const METRICS_PATH_PREFIX = getPrefixedURL(`/log/metrics`);
  const ERRORS_PATH_PREFIX = getPrefixedURL("/log/errors");
  const CLIENT_ERROR_TYPES = {
    APEX_ACTION_ERROR: "APEX_ACTION_ERROR",
    FAILED_TO_LOAD_RESOURCE: "FAILED_TO_LOAD_RESOURCE",
    TOO_MANY_REQUESTS: "TOO_MANY_REQUESTS",
    UNKNOWN_ERROR: "UNKNOWN_ERROR"
  };
  const MOBILE_APP_USER_AGENTS = {
    PUBLISHER: "CommunityHybridContainer/",
    PLAYGROUND: "playgroundcommunity"
  };
  const MAX_URL_LENGTH = 8e3;
  const VIEW_NAMESPACE = "@view";
  function getViewModuleSpecifier(name) {
    return `${VIEW_NAMESPACE}/${name}`;
  }
  const METADATA_PROPERTIES = ["hasVanityURL", "isDefault", "isPublic", "isRoot"];
  const TRANSFER_CONFIGS = [{
    type: "standard__search",
    params: [{
      name: "term",
      type: "state"
    }]
  }, {
    type: "standard__objectPage",
    params: [{
      name: "filterName",
      type: "state"
    }]
  }, {
    type: "standard__recordPage",
    params: [{
      name: "recordName",
      type: "state"
    }, {
      name: "categoryPath",
      type: "state"
    }],
    match: ({
      attributes
    }, {
      name
    }) => {
      if (attributes?.objectApiName === "ProductCategory") {
        return name === "categoryPath";
      }
      return name !== "categoryPath";
    }
  }];
  function transferRouteParameters(route, config2) {
    const {
      match,
      params
    } = config2;
    params.forEach((paramInfo) => {
      if (match && !match(route.page, paramInfo)) {
        return;
      }
      const {
        type,
        name
      } = paramInfo;
      const to = type;
      const from = to === "state" ? "attributes" : "state";
      if (!route.page?.[from]?.[name]) {
        return;
      }
      if (!route.page[to]) {
        route.page[to] = {};
      }
      route.page[to][name] = route.page[from][name];
      delete route.page[from][name];
    });
  }
  function transformMultiSegmentParams(path) {
    let newPath = path;
    ["categoryPath", "urlPath"].forEach((param) => {
      newPath = newPath.replace(new RegExp(`:${param}\\+?`), `:${param}+`);
    });
    return newPath;
  }
  const WITHIN_PARENTHESES_REGEXP = /\(.*\)/;
  function parseRoutes$1(routes2) {
    return routes2.map((route) => {
      if (!route.uri) {
        route.uri = route.path;
      }
      if (!route.metadata) {
        route.metadata = {};
      }
      METADATA_PROPERTIES.forEach((property) => {
        if (property in route) {
          route.metadata[property] = route[property];
          delete route[property];
        }
      });
      if (route.uri) {
        const segments = route.uri.split("/");
        for (let i = 0; i < segments.length; i++) {
          segments[i] = segments[i].replace(WITHIN_PARENTHESES_REGEXP, "");
          if (segments[i].startsWith(":")) {
            const key = segments[i].substring(1).replace(/[?+]/g, "");
            const value = `:${key}`;
            if (!route.page.attributes[key]) {
              route.page.attributes[key] = value;
            }
          }
        }
        route.uri = segments.join("/");
      }
      if (route.patternMap) {
        route.patterns = route.patternMap;
        delete route.patternMap;
      }
      const objectApiName = route.page?.attributes?.objectApiName;
      if (objectApiName && !objectApiName.startsWith(":")) {
        route.uri = route.uri.replace(":objectApiName", objectApiName);
        if (route.patterns?.objectApiName) {
          delete route.patterns.objectApiName;
        }
      }
      const transferConfig = TRANSFER_CONFIGS.find((config2) => route.page?.type === config2.type);
      if (transferConfig) {
        transferRouteParameters(route, transferConfig);
      }
      const type = route.page?.type;
      if (type === "standard__recordPage" && route.page.attributes?.objectApiName === "ProductCategory") {
        route.uri = transformMultiSegmentParams(route.uri);
      }
      const needsActionName = ["standard__recordPage", "standard__recordRelationshipPage"].includes(type) && !route.page?.attributes?.actionName;
      if (needsActionName) {
        route.page.attributes = route.page.attributes || {};
        route.page.attributes.actionName = "view";
      }
      return route;
    });
  }
  const PERFORMANCE_ENTRY_TYPE = {
    MARK: "mark",
    RESOURCE: "resource",
    MEASURE: "measure",
    PAINT: "paint",
    NAVIGATION: "navigation",
    LONGTASK: "longtask",
    FRAME: "frame"
  };
  const {
    window: window$3,
    document: document$3
  } = globalThis;
  const supports = {
    hostname: Boolean(window$3?.location && window$3?.location.hostname),
    pathname: Boolean(window$3?.location && window$3?.location.pathname !== void 0 && window$3?.location.pathname !== null),
    rtt: Boolean(window$3?.navigator && window$3?.navigator.connection && window$3?.navigator.connection.rtt),
    PerformanceObserver: Boolean(window$3?.PerformanceObserver),
    PerformancePaintTiming: Boolean(window$3?.PerformancePaintTiming),
    PerformanceResourceTiming: Boolean(window$3?.PerformanceResourceTiming),
    getEntriesByType: Boolean(window$3?.performance.getEntriesByType),
    getEntriesByName: Boolean(window$3?.performance.getEntriesByName)
  };
  function registerAppUnloadHandler(handler) {
    let unloaded = false;
    window$3?.addEventListener("pagehide", (e2) => {
      unloaded = !e2.persisted;
    });
    window$3?.addEventListener("visibilitychange", () => {
      if (document$3.visibilityState === "hidden" && unloaded) {
        handler();
      }
    });
  }
  function prepPayload(payload) {
    const stringifiedPayload = JSON.stringify(payload);
    return stringifiedPayload.replace(/(":)(\d+\.\d{2,})/g, (_match, p1, p2) => {
      return p1 + Number(p2).toFixed(2);
    });
  }
  function getBootstrapMetrics() {
    if (!supports.getEntriesByName) {
      return null;
    }
    const appBootstrap = window.performance.getEntriesByName(`${WEBRUNTIME_PREFIX}-app-bootstrap`);
    const frameworkBootstrap = window.performance.getEntriesByName(`${WEBRUNTIME_PREFIX}-framework-bootstrap`);
    return [...appBootstrap, ...frameworkBootstrap];
  }
  function getResourceMetrics() {
    return supports.PerformanceResourceTiming && supports.getEntriesByType ? window.performance.getEntriesByType(PERFORMANCE_ENTRY_TYPE.RESOURCE) : null;
  }
  function waitUntilIdle(callback) {
    let previousLength = getResourceMetrics().length;
    const intervalId = setInterval(() => {
      if (getResourceMetrics().length > previousLength) {
        previousLength = getResourceMetrics().length;
      } else {
        clearInterval(intervalId);
        callback();
      }
    }, 500);
  }
  function getPseudoEptMetrics(pageStartTime, renderTime, pageView) {
    const absoluteStart = window.performance.timing.navigationStart;
    const lastEntry = getResourceMetrics().sort((a2, b2) => {
      return a2.startTime + a2.duration > b2.startTime + b2.duration ? -1 : 1;
    })[0];
    let relativeEpt = renderTime - absoluteStart;
    if (lastEntry && lastEntry.startTime + lastEntry.duration > pageStartTime - absoluteStart) {
      relativeEpt = lastEntry.startTime + lastEntry.duration;
    }
    return {
      entryType: "webruntime-navigation",
      startTime: pageStartTime - absoluteStart,
      duration: absoluteStart + relativeEpt - pageStartTime,
      name: pageView && pageView.id
    };
  }
  function getLocationMetrics() {
    return {
      hostname: supports.hostname ? window.location.hostname : null,
      pathname: supports.pathname ? window.location.pathname : null
    };
  }
  function getNavigatorMetrics() {
    return supports.rtt ? {
      "connection.rtt": window.navigator.connection.rtt
    } : null;
  }
  function getPaintMetrics() {
    return supports.PerformancePaintTiming && supports.getEntriesByType ? window.performance.getEntriesByType(PERFORMANCE_ENTRY_TYPE.PAINT) : null;
  }
  var e, n, t, r, a = -1, o = function(e2) {
    addEventListener("pageshow", function(n2) {
      n2.persisted && (a = n2.timeStamp, e2(n2));
    }, true);
  }, c = function() {
    return window.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0];
  }, u = function() {
    var e2 = c();
    return e2 && e2.activationStart || 0;
  }, f = function(e2, n2) {
    var t2 = c(), r2 = "navigate";
    return a >= 0 ? r2 = "back-forward-cache" : t2 && (r2 = document.prerendering || u() > 0 ? "prerender" : document.wasDiscarded ? "restore" : t2.type.replace(/_/g, "-")), {
      name: e2,
      value: n2 === void 0 ? -1 : n2,
      rating: "good",
      delta: 0,
      entries: [],
      id: "v3-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12),
      navigationType: r2
    };
  }, s = function(e2, n2, t2) {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(e2)) {
        var r2 = new PerformanceObserver(function(e3) {
          Promise.resolve().then(function() {
            n2(e3.getEntries());
          });
        });
        return r2.observe(Object.assign({
          type: e2,
          buffered: true
        }, t2 || {})), r2;
      }
    } catch (e3) {
    }
  }, d = function(e2, n2, t2, r2) {
    var i, a2;
    return function(o2) {
      n2.value >= 0 && (o2 || r2) && ((a2 = n2.value - (i || 0)) || i === void 0) && (i = n2.value, n2.delta = a2, n2.rating = function(e3, n3) {
        return e3 > n3[1] ? "poor" : e3 > n3[0] ? "needs-improvement" : "good";
      }(n2.value, t2), e2(n2));
    };
  }, l = function(e2) {
    requestAnimationFrame(function() {
      return requestAnimationFrame(function() {
        return e2();
      });
    });
  }, p = function(e2) {
    var n2 = function(n3) {
      n3.type !== "pagehide" && document.visibilityState !== "hidden" || e2(n3);
    };
    addEventListener("visibilitychange", n2, true), addEventListener("pagehide", n2, true);
  }, v = function(e2) {
    var n2 = false;
    return function(t2) {
      n2 || (e2(t2), n2 = true);
    };
  }, m = -1, h = function() {
    return document.visibilityState !== "hidden" || document.prerendering ? 1 / 0 : 0;
  }, g = function(e2) {
    document.visibilityState === "hidden" && m > -1 && (m = e2.type === "visibilitychange" ? e2.timeStamp : 0, T());
  }, y = function() {
    addEventListener("visibilitychange", g, true), addEventListener("prerenderingchange", g, true);
  }, T = function() {
    removeEventListener("visibilitychange", g, true), removeEventListener("prerenderingchange", g, true);
  }, E = function() {
    return m < 0 && (m = h(), y(), o(function() {
      setTimeout(function() {
        m = h(), y();
      }, 0);
    })), {
      get firstHiddenTime() {
        return m;
      }
    };
  }, C = function(e2) {
    document.prerendering ? addEventListener("prerenderingchange", function() {
      return e2();
    }, true) : e2();
  }, L = [1800, 3e3], b = function(e2, n2) {
    n2 = n2 || {}, C(function() {
      var t2, r2 = E(), i = f("FCP"), a2 = s("paint", function(e3) {
        e3.forEach(function(e4) {
          e4.name === "first-contentful-paint" && (a2.disconnect(), e4.startTime < r2.firstHiddenTime && (i.value = Math.max(e4.startTime - u(), 0), i.entries.push(e4), t2(true)));
        });
      });
      a2 && (t2 = d(e2, i, L, n2.reportAllChanges), o(function(r3) {
        i = f("FCP"), t2 = d(e2, i, L, n2.reportAllChanges), l(function() {
          i.value = performance.now() - r3.timeStamp, t2(true);
        });
      }));
    });
  }, w = [0.1, 0.25], S = function(e2, n2) {
    n2 = n2 || {}, b(v(function() {
      var t2, r2 = f("CLS", 0), i = 0, a2 = [], c2 = function(e3) {
        e3.forEach(function(e4) {
          if (!e4.hadRecentInput) {
            var n3 = a2[0], t3 = a2[a2.length - 1];
            i && e4.startTime - t3.startTime < 1e3 && e4.startTime - n3.startTime < 5e3 ? (i += e4.value, a2.push(e4)) : (i = e4.value, a2 = [e4]);
          }
        }), i > r2.value && (r2.value = i, r2.entries = a2, t2());
      }, u2 = s("layout-shift", c2);
      u2 && (t2 = d(e2, r2, w, n2.reportAllChanges), p(function() {
        c2(u2.takeRecords()), t2(true);
      }), o(function() {
        i = 0, r2 = f("CLS", 0), t2 = d(e2, r2, w, n2.reportAllChanges), l(function() {
          return t2();
        });
      }), setTimeout(t2, 0));
    }));
  }, A = {
    passive: true,
    capture: true
  }, I = new Date(), P = function(r2, i) {
    e || (e = i, n = r2, t = new Date(), k(removeEventListener), F());
  }, F = function() {
    if (n >= 0 && n < t - I) {
      var i = {
        entryType: "first-input",
        name: e.type,
        target: e.target,
        cancelable: e.cancelable,
        startTime: e.timeStamp,
        processingStart: e.timeStamp + n
      };
      r.forEach(function(e2) {
        e2(i);
      }), r = [];
    }
  }, M = function(e2) {
    if (e2.cancelable) {
      var n2 = (e2.timeStamp > 1e12 ? new Date() : performance.now()) - e2.timeStamp;
      e2.type == "pointerdown" ? function(e3, n3) {
        var t2 = function() {
          P(e3, n3), i();
        }, r2 = function() {
          i();
        }, i = function() {
          removeEventListener("pointerup", t2, A), removeEventListener("pointercancel", r2, A);
        };
        addEventListener("pointerup", t2, A), addEventListener("pointercancel", r2, A);
      }(n2, e2) : P(n2, e2);
    }
  }, k = function(e2) {
    ["mousedown", "keydown", "touchstart", "pointerdown"].forEach(function(n2) {
      return e2(n2, M, A);
    });
  }, D = [100, 300], x = function(t2, i) {
    i = i || {}, C(function() {
      var a2, c2 = E(), u2 = f("FID"), l2 = function(e2) {
        e2.startTime < c2.firstHiddenTime && (u2.value = e2.processingStart - e2.startTime, u2.entries.push(e2), a2(true));
      }, m2 = function(e2) {
        e2.forEach(l2);
      }, h2 = s("first-input", m2);
      a2 = d(t2, u2, D, i.reportAllChanges), h2 && p(v(function() {
        m2(h2.takeRecords()), h2.disconnect();
      })), h2 && o(function() {
        var o2;
        u2 = f("FID"), a2 = d(t2, u2, D, i.reportAllChanges), r = [], n = -1, e = null, k(addEventListener), o2 = l2, r.push(o2), F();
      });
    });
  }, U = [2500, 4e3], V = {}, W = function(e2, n2) {
    n2 = n2 || {}, C(function() {
      var t2, r2 = E(), i = f("LCP"), a2 = function(e3) {
        var n3 = e3[e3.length - 1];
        n3 && n3.startTime < r2.firstHiddenTime && (i.value = Math.max(n3.startTime - u(), 0), i.entries = [n3], t2());
      }, c2 = s("largest-contentful-paint", a2);
      if (c2) {
        t2 = d(e2, i, U, n2.reportAllChanges);
        var m2 = v(function() {
          V[i.id] || (a2(c2.takeRecords()), c2.disconnect(), V[i.id] = true, t2(true));
        });
        ["keydown", "click"].forEach(function(e3) {
          addEventListener(e3, m2, true);
        }), p(m2), o(function(r3) {
          i = f("LCP"), t2 = d(e2, i, U, n2.reportAllChanges), l(function() {
            i.value = performance.now() - r3.timeStamp, V[i.id] = true, t2(true);
          });
        });
      }
    });
  }, X = [800, 1800], Y = function e2(n2) {
    document.prerendering ? C(function() {
      return e2(n2);
    }) : document.readyState !== "complete" ? addEventListener("load", function() {
      return e2(n2);
    }, true) : setTimeout(n2, 0);
  }, Z = function(e2, n2) {
    n2 = n2 || {};
    var t2 = f("TTFB"), r2 = d(e2, t2, X, n2.reportAllChanges);
    Y(function() {
      var i = c();
      if (i) {
        var a2 = i.responseStart;
        if (a2 <= 0 || a2 > performance.now())
          return;
        t2.value = Math.max(a2 - u(), 0), t2.entries = [i], r2(true), o(function() {
          t2 = f("TTFB", 0), (r2 = d(e2, t2, X, n2.reportAllChanges))(true);
        });
      }
    });
  };
  let isCLSSupported = false;
  try {
    isCLSSupported = PerformanceObserver.supportedEntryTypes.includes("layout-shift");
  } catch (ex) {
  }
  const webVitalsMetrics = {
    CLS: isCLSSupported ? {
      name: "CLS",
      value: 0,
      delta: 0
    } : null,
    LCP: null,
    FID: null,
    FCP: null,
    TTFB: null
  };
  function clearWebVitalsCLS() {
    if (webVitalsMetrics.CLS) {
      webVitalsMetrics.CLS.value = 0;
      webVitalsMetrics.CLS.delta = 0;
    }
  }
  function initWebVitalsObservers() {
    S(CLSHandler, true);
    W(webVitalHandler, true);
    x(webVitalHandler);
    b(webVitalHandler);
    Z(webVitalHandler);
  }
  function CLSHandler(metric) {
    if (webVitalsMetrics.CLS) {
      webVitalsMetrics.CLS.value += metric.delta;
      webVitalsMetrics.CLS.delta = webVitalsMetrics.CLS.value;
    }
  }
  function webVitalHandler(metric) {
    const {
      name,
      value,
      delta
    } = metric;
    webVitalsMetrics[metric.name] = {
      name,
      value,
      delta
    };
  }
  function getWebVitalsMetrics() {
    return webVitalsMetrics;
  }
  if (typeof document !== "undefined") {
    initWebVitalsObservers();
  }
  let isFirstSend = true;
  const {
    window: window$2
  } = globalThis;
  let currentPageStartTS;
  function getNavigationStart() {
    return window$2?.performance.timing && window$2?.performance.timing.navigationStart || 0;
  }
  function resetCurrentPageStartTime() {
    currentPageStartTS = isFirstSend ? getNavigationStart() : Date.now();
  }
  function setIsFirstSend(state) {
    isFirstSend = state;
  }
  function getIsFirstSend() {
    return isFirstSend;
  }
  function getCurrentPageStartTime() {
    if (currentPageStartTS === void 0) {
      resetCurrentPageStartTime();
    }
    return currentPageStartTS;
  }
  function ownKeys$e(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$e(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$e(Object(source), true).forEach(function(key) {
        _defineProperty$e(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$e(obj, key, value) {
    key = _toPropertyKey$e(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$e(arg) {
    var key = _toPrimitive$e(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$e(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const isSupported = typeof document !== "undefined";
  const initialLocation = _objectSpread$e({}, getLocationMetrics());
  function send(payload) {
    if (!isSupported) {
      return;
    }
    _1_66_319244_0$1.sendBeacon({
      path: METRICS_PATH_PREFIX,
      payload: prepPayload(payload),
      contentType: "text/plain;charset=UTF-8"
    });
  }
  function getBootstrapMetricsObject() {
    return {
      bootstrap: getBootstrapMetrics(),
      navigator: getNavigatorMetrics(),
      paint: getPaintMetrics()
    };
  }
  function sendMetricsAndPageView(pageView = {}) {
    if (!isSupported) {
      return;
    }
    const pageStartTime = getCurrentPageStartTime();
    const renderTime = Date.now();
    waitUntilIdle(() => {
      const basePayload = {
        pageView,
        location: getLocationMetrics(),
        navigation: getPseudoEptMetrics(pageStartTime, renderTime, pageView)
      };
      const {
        CLS
      } = getWebVitalsMetrics();
      const CLSPayload = {
        webVitals: {
          CLS
        }
      };
      let bootstrapPayload = {};
      if (getIsFirstSend()) {
        bootstrapPayload = getBootstrapMetricsObject();
        setIsFirstSend(false);
      }
      const payload = Object.assign({}, basePayload, bootstrapPayload, CLSPayload);
      send(payload);
      performance.clearResourceTimings();
      clearWebVitalsCLS();
    });
  }
  function init(location) {
    registerAppUnloadHandler(() => {
      const {
        FID,
        LCP,
        TTFB,
        FCP
      } = getWebVitalsMetrics();
      if (FID || LCP || TTFB || FCP) {
        send({
          webVitals: {
            FID,
            LCP,
            TTFB,
            FCP
          },
          location
        });
      }
    });
  }
  if (isSupported) {
    init(initialLocation);
  }
  function sendClientErrorToServer$1(payload) {
    const url = basePath__default["default"] + ERRORS_PATH_PREFIX;
    const body = JSON.stringify(payload);
    const sentBeacon = window.navigator && window.navigator.sendBeacon && window.navigator.sendBeacon(url, body);
    if (!sentBeacon) {
      const xhr = new XMLHttpRequest();
      xhr.open("POST", url, true);
      xhr.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
      xhr.send(body);
    }
  }
  function dispatchClientError$1(error2, type) {
    document.dispatchEvent(new CustomEvent("client-error", {
      detail: {
        error: error2,
        type
      }
    }));
  }
  function reportError$1({
    subject,
    error: error2 = {},
    extra,
    type = CLIENT_ERROR_TYPES.UNKNOWN_ERROR
  }) {
    let message, stack, wcstack;
    if (error2) {
      message = error2.message;
      stack = error2.stack;
      wcstack = error2.wcstack;
    } else if (extra) {
      message = extra.message;
    }
    const {
      pathname,
      hostname
    } = window.location;
    const location = {
      pathname,
      hostname
    };
    const payload = {
      subject,
      message,
      stack,
      wcstack,
      extra,
      location
    };
    dispatchClientError$1(payload, type);
    sendClientErrorToServer$1(payload);
  }
  window.addEventListener("error", (event = {}) => {
    const {
      message,
      filename,
      lineno,
      colno,
      error: error2
    } = event;
    reportError$1({
      subject: "window error",
      error: error2,
      extra: {
        message,
        filename,
        lineno,
        colno
      }
    });
  });
  window.addEventListener("unhandledrejection", (event = {}) => {
    const {
      reason = {}
    } = event;
    reportError$1({
      subject: "unhandledrejection",
      error: reason
    });
  });
  function log(...msg) {
    console.log(...msg);
  }
  function logError(...msg) {
    console.error(...msg);
  }
  var logger = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    log,
    logError
  });
  function getMarkName(ns, name) {
    return `${WEBRUNTIME_PREFIX}-${[ns, name].filter(Boolean).join(":")}`;
  }
  const {
    performance: performance$2
  } = globalThis;
  function unwrapProxy(input) {
    const stringified = JSON.stringify(input);
    return stringified && JSON.parse(stringified);
  }
  function performanceMarkHelper(ns, name, ctx) {
    const markName = getMarkName(ns, name);
    performance$2.mark(markName, {
      detail: {
        ctx: unwrapProxy(ctx)
      }
    });
  }
  function mark(ns, name, ctx) {
    performanceMarkHelper(ns, name, ctx);
  }
  function markStart(ns, name, ctx) {
    performanceMarkHelper(ns, name, ctx);
  }
  function markEnd(ns, name, ctx) {
    const markName = getMarkName(ns, name);
    try {
      performance$2.measure(markName, {
        detail: {
          ctx: unwrapProxy(ctx)
        },
        start: markName
      });
    } catch (ex) {
      logError(`[instrumentation] no startMark named ${markName} found`, ex.stack);
    }
  }
  function time() {
    return Date.now();
  }
  function perfStart(name, attributes, eventSource) {
    if (true) {
      log(`[instrumentation] perfStart()`, {
        name,
        attributes,
        eventSource
      });
    }
  }
  function perfEnd(name, attributes, eventSource) {
    if (true) {
      log(`[instrumentation] perfEnd()`, {
        name,
        attributes,
        eventSource
      });
    }
  }
  function interaction(target, scope, context, eventSource, eventType) {
    if (true) {
      log(`[instrumentation] interaction()`, {
        target,
        scope,
        context,
        eventSource,
        eventType
      });
    }
  }
  function registerPlugin(pluginConfig) {
    if (true) {
      log(`[instrumentation] registerPlugin()`, {
        pluginConfig
      });
    }
  }
  function registerPeriodicLogger(name, callback) {
    if (true) {
      log(`[instrumentation] registerPeriodicLogger()`, {
        name,
        callback
      });
    }
  }
  function registerCacheStats(name) {
    if (true) {
      log(`[instrumentation] registerCacheStats()`, {
        name
      });
    }
    return {
      logHits(count) {
        if (true) {
          log(`[instrumentation] registerCacheStats().logHits()`, {
            name,
            count
          });
        }
      },
      logMisses(count) {
        if (true) {
          log(`[instrumentation] registerCacheStats().logMisses()`, {
            name,
            count
          });
        }
      },
      unRegister() {
        if (true) {
          log(`[instrumentation] registerCacheStats().unRegister()`, {
            name
          });
        }
      }
    };
  }
  function error(attributes, eventSource, eventType) {
    if (true) {
      log(`[instrumentation] error()`, {
        attributes,
        eventSource,
        eventType
      });
    }
  }
  function removePeriodicLogger(id) {
    if (true) {
      log(`[instrumentation] removePeriodicLogger()`, {
        id
      });
    }
  }
  function enablePlugin(name) {
    if (true) {
      log(`[instrumentation] enablePlugin()`, {
        name
      });
    }
  }
  function disablePlugin(name) {
    if (true) {
      log(`[instrumentation] disablePlugin()`, {
        name
      });
    }
  }
  function trackScenario(nameIn, attributes, eventSourceIn) {
    if (true) {
      log(`[instrumentation] trackScenario()`, {
        nameIn,
        attributes,
        eventSourceIn
      });
    }
  }
  function counter(metricsKey) {
    return {
      increment(value) {
        if (true) {
          log(`[instrumentation] counter.increment()`, {
            metricsKey,
            value
          });
        }
      },
      decrement(value) {
        if (true) {
          log(`[instrumentation] counter.decrement()`, {
            metricsKey,
            value
          });
        }
      },
      getValue() {
        if (true) {
          log(`[instrumentation] counter.getValue()`, {
            metricsKey
          });
        }
        return 0;
      },
      reset() {
        if (true) {
          log(`[instrumentation] counter.reset()`, {
            metricsKey
          });
        }
      }
    };
  }
  function gauge(metricsKey) {
    return {
      setValue(value) {
        if (true) {
          log(`[instrumentation] setValue()`, {
            metricsKey,
            value
          });
        }
      },
      getValue() {
        if (true) {
          log(`[instrumentation] getValue()`, {
            metricsKey
          });
        }
        return 0;
      },
      reset() {
        if (true) {
          log(`[instrumentation] reset()`, {
            metricsKey
          });
        }
      }
    };
  }
  function percentileHistogram(metricsKey) {
    return {
      update(value) {
        if (true) {
          log(`[instrumentation] percentileHistogram.update()`, {
            metricsKey,
            value
          });
        }
      },
      getValue() {
        if (true) {
          log(`[instrumentation] percentileHistogram.getValue()`, {
            metricsKey
          });
        }
        return [];
      },
      reset() {
        if (true) {
          log(`[instrumentation] percentileHistogram.reset()`, {
            metricsKey
          });
        }
      }
    };
  }
  function timer(metricsKey) {
    return {
      addDuration() {
        if (true) {
          log(`[instrumentation] timer.addDuration()`, {
            metricsKey
          });
        }
      },
      time() {
        if (true) {
          log(`[instrumentation] timer.time()`, {
            metricsKey
          });
        }
      },
      getValue() {
        if (true) {
          log(`[instrumentation] timer.getValue()`, {
            metricsKey
          });
        }
        return [];
      },
      reset() {
        if (true) {
          log(`[instrumentation] timer.reset()`, {
            metricsKey
          });
        }
      },
      get() {
        if (true) {
          log(`[instrumentation] timer.get()`, {
            metricsKey
          });
        }
      }
    };
  }
  var auraInstrumentationService = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    counter,
    disablePlugin,
    enablePlugin,
    error,
    gauge,
    interaction,
    mark,
    markEnd,
    markStart,
    percentileHistogram,
    perfEnd,
    perfStart,
    registerCacheStats,
    registerPeriodicLogger,
    registerPlugin,
    removePeriodicLogger,
    time,
    timer,
    trackScenario
  });
  function assert$1(assertion, message) {
    if (!assertion) {
      throw new Error(message);
    }
  }
  function getCookie(cookieName) {
    return document.cookie.split(";").map((s2) => s2.trim().split("=")).filter(([name]) => name === cookieName).map(([, value]) => value)[0];
  }
  function uuidv4() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c2) => (c2 ^ window.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c2 / 4).toString(16));
  }
  function uuidValidate(uuid) {
    return typeof uuid === "string" && /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(uuid);
  }
  const absoluteUrlRegex = new RegExp("^([a-z]+://|//)", "i");
  function isAbsoluteURL(url) {
    if (url == null) {
      return false;
    }
    return absoluteUrlRegex.test(url);
  }
  class Notifications {
    constructor() {
      this._registry = {
        eptMarked: [],
        navToPage: [],
        navFromPage: [],
        windowUnload: []
      };
    }
    get knownEvents() {
      return Object.keys(this._registry);
    }
    _checkEventName(eventName) {
      if (!this._registry[eventName]) {
        throw new Error(`eventName ${eventName} isn't valid`);
      }
    }
    register(eventName, listenerName, callback) {
      assert$1(eventName && typeof eventName === "string", "eventName must be a valid string");
      this._checkEventName(eventName);
      assert$1(listenerName && typeof listenerName === "string", "listenerName must be a valid string");
      assert$1(typeof callback === "function", "callback must be provided");
      return this._registry[eventName].push({
        name: listenerName,
        func: callback
      });
    }
    unregister(eventName, registrationId) {
      this._checkEventName(eventName);
      const index2 = registrationId - 1;
      assert$1(this._registry[eventName][index2], `No listener found for ${eventName} with registration ID ${registrationId}`);
      delete this._registry[eventName][index2];
    }
    notify(eventName, eventPayload) {
      this._checkEventName(eventName);
      this._registry[eventName].forEach((subscriber) => subscriber.func(eventPayload));
    }
  }
  const notifications = new Notifications();
  var auraInstrumentationUtility = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    notifications
  });
  const ISO8601_STRICT_PATTERN$1 = /^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z){1})?)?)?$/i;
  const ISO8601_TIME_PATTERN$1 = /^\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;
  const STANDARD_TIME_FORMAT$1 = "HH:mm:ss.SSS";
  const STANDARD_DATE_FORMAT$1 = "YYYY-MM-DD";
  const TIME_SEPARATOR$1 = "T";
  const TIMEZONE_INDICATOR$1 = /(Z|([+-])(\d{2}):(\d{2}))$/;
  function isValidISODateTimeString$1(dateTimeString) {
    return isValidISO8601String$1(dateTimeString) && isValidDate$1(dateTimeString);
  }
  function isValidISOTimeString$1(timeString) {
    if (!isValidISO8601TimeString$1(timeString)) {
      return false;
    }
    const timeOnly = removeTimeZoneSuffix$1(timeString);
    return isValidDate$1(`2018-09-09T${timeOnly}Z`);
  }
  function removeTimeZoneSuffix$1(dateTimeString) {
    if (typeof dateTimeString === "string") {
      return dateTimeString.split(TIMEZONE_INDICATOR$1)[0];
    }
    return dateTimeString;
  }
  function isValidISO8601String$1(dateTimeString) {
    if (typeof dateTimeString !== "string") {
      return false;
    }
    return ISO8601_STRICT_PATTERN$1.test(dateTimeString);
  }
  function isValidISO8601TimeString$1(timeString) {
    if (typeof timeString !== "string") {
      return false;
    }
    return ISO8601_TIME_PATTERN$1.test(timeString);
  }
  function isValidDate$1(value) {
    const timeStamp = Date.parse(value);
    return isFinite(timeStamp);
  }
  const labelSecondsLater$1 = "in a few seconds";
  const labelSecondsAgo$1 = "a few seconds ago";
  const fallbackFutureLabel$1 = "in {0} {1}";
  const fallbackPastLabel$1 = "{0} {1} ago";
  const fallbackPluralSuffix$1 = "s";
  const units$1 = {
    SECONDS: {
      name: "second",
      threshold: 45
    },
    MINUTES: {
      name: "minute",
      threshold: 45
    },
    HOURS: {
      name: "hour",
      threshold: 22
    },
    DAYS: {
      name: "day",
      threshold: 26
    },
    MONTHS: {
      name: "month",
      threshold: 11
    },
    YEARS: {
      name: "year"
    }
  };
  const SECOND_TO_MILLISECONDS$1 = 1e3;
  const MINUTE_TO_MILLISECONDS$1 = 6e4;
  const HOUR_TO_MILLISECONDS$1 = 36e5;
  const DAY_TO_MILLISECONDS$1 = 864e5;
  let Duration$2 = class Duration {
    constructor(milliseconds) {
      this.milliseconds = 0;
      if (typeof milliseconds !== "number") {
        this.isValid = false;
        console.warn(`The value of milliseconds passed into Duration must be of type number, 
                but we are getting the ${typeof milliseconds} value "${milliseconds}" instead.
                `);
        return;
      }
      this.isValid = true;
      this.milliseconds = milliseconds;
    }
    humanize(locale) {
      if (!this.isValid) {
        return "";
      }
      const unit = findBestUnitMatch$1(this);
      if (unit === units$1.SECONDS) {
        const isLater = this.milliseconds > 0;
        return isLater ? labelSecondsLater$1 : labelSecondsAgo$1;
      }
      return format$1(locale, this.asIn(unit), unit.name);
    }
    asIn(unit) {
      switch (unit) {
        case units$1.SECONDS:
          return Math.round(this.milliseconds / SECOND_TO_MILLISECONDS$1);
        case units$1.MINUTES:
          return Math.round(this.milliseconds / MINUTE_TO_MILLISECONDS$1);
        case units$1.HOURS:
          return Math.round(this.milliseconds / HOUR_TO_MILLISECONDS$1);
        case units$1.DAYS:
          return Math.round(this.milliseconds / DAY_TO_MILLISECONDS$1);
        case units$1.MONTHS:
          return Math.round(daysToMonth$1(this.milliseconds / DAY_TO_MILLISECONDS$1));
        case units$1.YEARS:
        default:
          return Math.round(daysToMonth$1(this.milliseconds / DAY_TO_MILLISECONDS$1) / 12);
      }
    }
  };
  _2_41_4.registerDecorators(Duration$2, {
    fields: ["milliseconds"]
  });
  var Duration$3 = _2_41_4.registerComponent(Duration$2, {
    tmpl: _tmpl$a,
    sel: "lightningConfigProvider-localizationService"
  });
  function daysToMonth$1(days) {
    const daysToMonthRatio = 4800 / 146097;
    return days * daysToMonthRatio;
  }
  function findBestUnitMatch$1(duration2) {
    const match = Object.keys(units$1).find((key) => {
      const unit = units$1[key];
      return unit === units$1.YEARS || Math.abs(duration2.asIn(unit)) < unit.threshold;
    });
    return units$1[match];
  }
  function format$1(locale, value, unit) {
    if ("Intl" in window && Intl.RelativeTimeFormat) {
      const formatter = new Intl.RelativeTimeFormat(locale, {
        style: "long",
        numeric: "always"
      });
      return formatter.format(value, unit);
    }
    return fallbackFormatter$1(value, unit);
  }
  function fallbackFormatter$1(value, unit) {
    console.warn(`The current environment does not support formatters for relative time.`);
    const absoluteValue = Math.abs(value);
    const unitString = absoluteValue !== 1 ? unit + fallbackPluralSuffix$1 : unit;
    const label = value > 0 ? fallbackFutureLabel$1 : fallbackPastLabel$1;
    return formatString(label, absoluteValue, unitString);
  }
  function formatString(str, ...args) {
    return str.replace(/{(\d+)}/g, (match, i) => {
      return args[i];
    });
  }
  const MONTH_NAMES$1 = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  const DATE_FORMAT$1 = {
    short: "M/d/yyyy",
    medium: "MMM d, yyyy",
    long: "MMMM d, yyyy"
  };
  const TIME_FORMAT$1 = {
    short: "h:mm a",
    medium: "h:mm:ss a",
    long: "h:mm:ss a"
  };
  const TIME_FORMAT_SIMPLE$1 = {
    short: "h:m a",
    medium: "h:m:s a",
    long: "h:m:s a"
  };
  function formatDate$1(value, format2) {
    let isUTC = false;
    let dateString = value;
    if (typeof value === "string") {
      dateString = value.split(TIME_SEPARATOR$1)[0];
      isUTC = true;
    }
    return formatDateInternal$1(dateString, format2, isUTC);
  }
  function formatDateUTC$1(value, format2) {
    return formatDateInternal$1(value, format2, true);
  }
  function formatTime$1(date, format2) {
    if (!isDate$1(date)) {
      return new Date("");
    }
    const hours = (date.getHours() + 11) % 12 + 1;
    const suffix = date.getHours() >= 12 ? "PM" : "AM";
    switch (format2) {
      case STANDARD_TIME_FORMAT$1:
        return `${pad$1(date.getHours())}:${pad$1(date.getMinutes())}:${pad$1(date.getSeconds())}.${doublePad$1(date.getMilliseconds())}`;
      case TIME_FORMAT$1.short:
        return `${hours}:${pad$1(date.getMinutes())} ${suffix}`;
      case TIME_FORMAT$1.medium:
      case TIME_FORMAT$1.long:
      default:
        return `${hours}:${pad$1(date.getMinutes())}:${pad$1(date.getSeconds())} ${suffix}`;
    }
  }
  function formatDateTimeUTC$1(value) {
    if (!isDate$1(value)) {
      return new Date("");
    }
    const date = new Date(value.getTime());
    return `${formatDateUTC$1(date)}, ${formatTime$1(addTimezoneOffset$1(date))}`;
  }
  function parseDateTimeISO8601$1(value) {
    let isoString = null;
    let shouldAddOffset = true;
    if (isValidISOTimeString$1(value)) {
      isoString = `2014-03-20T${addTimezoneSuffix$1(value)}`;
    } else if (isValidISODateTimeString$1(value)) {
      if (value.indexOf(TIME_SEPARATOR$1) > 0) {
        isoString = addTimezoneSuffix$1(value);
        shouldAddOffset = false;
      } else {
        isoString = `${value}T00:00:00.000Z`;
      }
    }
    if (isoString) {
      const parsedDate = new Date(isoString);
      if (shouldAddOffset) {
        addTimezoneOffset$1(parsedDate);
      }
      return parsedDate;
    }
    return null;
  }
  function parseDateTime$1(value, format2) {
    if (format2 === STANDARD_DATE_FORMAT$1 && isValidISODateTimeString$1(value)) {
      return parseDateTimeISO8601$1(value);
    }
    if (Object.values(DATE_FORMAT$1).includes(format2)) {
      return parseFormattedDate$1(value, format2);
    }
    if (Object.values(TIME_FORMAT_SIMPLE$1).includes(format2)) {
      return parseFormattedTime$1(value);
    }
    return null;
  }
  function parseDateTimeUTC$1(value) {
    return parseDateTimeISO8601$1(addTimezoneSuffix$1(value));
  }
  function isBefore$1(date1, date2, unit) {
    const normalizedDate1 = getDate$1(date1);
    const normalizedDate2 = getDate$1(date2);
    if (!normalizedDate1 || !normalizedDate2) {
      return false;
    }
    return startOf$1(normalizedDate1, unit).getTime() < startOf$1(normalizedDate2, unit).getTime();
  }
  function isAfter$1(date1, date2, unit) {
    const normalizedDate1 = getDate$1(date1);
    const normalizedDate2 = getDate$1(date2);
    if (!normalizedDate1 || !normalizedDate2) {
      return false;
    }
    return startOf$1(normalizedDate1, unit).getTime() > startOf$1(normalizedDate2, unit).getTime();
  }
  function UTCToWallTime$1(date, timezone, callback) {
    const utcDate = new Date(date.getTime());
    callback(subtractTimezoneOffset$1(utcDate));
  }
  function WallTimeToUTC$1(date, timezone, callback) {
    const localDate = new Date(date.getTime());
    callback(addTimezoneOffset$1(localDate));
  }
  function translateToOtherCalendar$1(date) {
    return date;
  }
  function translateFromOtherCalendar$1(date) {
    return date;
  }
  function translateToLocalizedDigits$1(input) {
    return input;
  }
  function translateFromLocalizedDigits$1(input) {
    return input;
  }
  function getNumberFormat$1() {
    return {
      format: (value) => {
        console.warn(`The current environment does not support large numbers and the original value of ${value} will be returned.`);
        return value;
      }
    };
  }
  function duration$1(minutes) {
    return new Duration$3(minutes * 60 * 1e3);
  }
  function displayDuration$1(value) {
    return value.humanize("en");
  }
  function parseFormattedTime$1(value) {
    const values = value.trim().split(/[:.\s*]/);
    const length = values.length;
    if (!values || length < 2 || length > 5) {
      return null;
    }
    const ampm = values[length - 1];
    const isBeforeNoon = ampm.toLowerCase() === "am";
    const isAfternoon = ampm.toLowerCase() === "pm";
    values.splice(-1, 1);
    const allNumbers = values.every((item) => !isNaN(item));
    if (!isAfternoon && !isBeforeNoon || !allNumbers) {
      return null;
    }
    const hours = values[0];
    const hour24 = pad$1(isAfternoon ? hours % 12 + 12 : hours % 12);
    const minutes = length >= 3 && values[1] || "0";
    const seconds = length >= 4 && values[2] || "0";
    const milliseconds = length === 5 && values[3] || "0";
    const newDate = new Date("2014-03-20");
    newDate.setHours(hour24, minutes, seconds, milliseconds);
    return isDate$1(newDate) ? newDate : null;
  }
  function parseFormattedDate$1(value, format2) {
    let pattern = /^([a-zA-Z]{3})\s*(\d{1,2}),\s*(\d{4})$/;
    switch (format2) {
      case DATE_FORMAT$1.short:
        pattern = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/;
        break;
      case DATE_FORMAT$1.long:
        pattern = /^([a-zA-Z]+)\s*(\d{1,2}),\s*(\d{4})$/;
        break;
    }
    const match = pattern.exec(value.trim());
    if (!match) {
      return null;
    }
    let month = match[1];
    const day = match[2];
    const year = match[3];
    if (format2 !== DATE_FORMAT$1.short) {
      month = MONTH_NAMES$1.findIndex((item) => item.toLowerCase().includes(month.toLowerCase()));
      month += 1;
    }
    const isoValue = `${year}-${pad$1(month)}-${pad$1(day)}`;
    const newDate = new Date(`${isoValue}T00:00:00.000Z`);
    return isDate$1(newDate) ? addTimezoneOffset$1(newDate) : null;
  }
  function formatDateInternal$1(value, format2, isUTC) {
    const date = getDate$1(value);
    if (!date) {
      return new Date("");
    }
    if (isUTC && isDate$1(value)) {
      addTimezoneOffset$1(date);
    }
    switch (format2) {
      case STANDARD_DATE_FORMAT$1:
        return `${date.getFullYear()}-${pad$1(date.getMonth() + 1)}-${pad$1(date.getDate())}`;
      case DATE_FORMAT$1.short:
        return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
      case DATE_FORMAT$1.long:
        return `${MONTH_NAMES$1[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
      case DATE_FORMAT$1.medium:
      default: {
        const shortMonthName = MONTH_NAMES$1[date.getMonth()].substring(0, 3);
        return `${shortMonthName} ${date.getDate()}, ${date.getFullYear()}`;
      }
    }
  }
  function startOf$1(date, unit) {
    switch (unit) {
      case "day":
        date.setHours(0);
        date.setMinutes(0);
      case "minute":
        date.setSeconds(0);
        date.setMilliseconds(0);
        break;
    }
    return date;
  }
  function isDate$1(value) {
    return Object.prototype.toString.call(value) === "[object Date]" && !isNaN(value.getTime());
  }
  function addTimezoneSuffix$1(value) {
    return `${removeTimeZoneSuffix$1(value)}Z`;
  }
  function addTimezoneOffset$1(date) {
    date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    return date;
  }
  function subtractTimezoneOffset$1(date) {
    date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
    return date;
  }
  function getDate$1(value) {
    if (!value) {
      return null;
    }
    if (isDate$1(value)) {
      return new Date(value.getTime());
    }
    if (isFinite(value) && (typeof value === "number" || typeof value === "string")) {
      return new Date(parseInt(value, 10));
    }
    if (typeof value === "string") {
      return parseDateTimeISO8601$1(value);
    }
    return null;
  }
  function pad$1(n2) {
    return Number(n2) < 10 ? `0${n2}` : n2;
  }
  function doublePad$1(n2) {
    return Number(n2) < 10 ? `00${n2}` : Number(n2) < 100 ? `0${n2}` : n2;
  }
  var localizationService$1 = {
    formatDate: formatDate$1,
    formatDateUTC: formatDateUTC$1,
    formatTime: formatTime$1,
    formatDateTimeUTC: formatDateTimeUTC$1,
    parseDateTimeISO8601: parseDateTimeISO8601$1,
    parseDateTime: parseDateTime$1,
    parseDateTimeUTC: parseDateTimeUTC$1,
    isBefore: isBefore$1,
    isAfter: isAfter$1,
    UTCToWallTime: UTCToWallTime$1,
    WallTimeToUTC: WallTimeToUTC$1,
    translateToOtherCalendar: translateToOtherCalendar$1,
    translateFromOtherCalendar: translateFromOtherCalendar$1,
    translateToLocalizedDigits: translateToLocalizedDigits$1,
    translateFromLocalizedDigits: translateFromLocalizedDigits$1,
    getNumberFormat: getNumberFormat$1,
    duration: duration$1,
    displayDuration: displayDuration$1
  };
  function getLocalizationService() {
    return localizationService$1;
  }
  function getPathPrefix() {
    return basePath__default["default"];
  }
  function getToken() {
    return null;
  }
  function getIconSvgTemplates() {
    return null;
  }
  function getOneConfig() {
    return {
      densitySetting: ""
    };
  }
  var lightningConfigProvider = {
    getOneConfig,
    getIconSvgTemplates,
    getToken,
    getPathPrefix,
    getLocalizationService
  };
  var lightningConfigProvider$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    default: lightningConfigProvider,
    getIconSvgTemplates,
    getLocalizationService,
    getOneConfig,
    getPathPrefix,
    getToken
  });
  function validateProvider(obj) {
    if (obj === void 0 || obj === null) {
      throw new TypeError("Provider must be defined.");
    }
  }
  class ContextInfo {
    constructor(defaultValue) {
      this.infoMap = new WeakMap();
      this.defaultValue = defaultValue;
    }
    getInfo(targetProvider) {
      let info = this.infoMap.get(targetProvider);
      if (info === void 0) {
        info = {
          consumers: new Set()
        };
        this.infoMap.set(targetProvider, info);
      }
      return info;
    }
    setContext(targetProvider, contextValue) {
      validateProvider(targetProvider);
      const value = contextValue;
      const info = this.getInfo(targetProvider);
      info.contextValue = contextValue;
      info.consumers.forEach((consumer) => consumer.provide(value));
      if (info.consumers.size === 0 && value?.onComplete) {
        value.onComplete();
      }
    }
    getContext(targetProvider) {
      validateProvider(targetProvider);
      const {
        contextValue
      } = this.getInfo(targetProvider);
      return contextValue !== void 0 ? contextValue : this.defaultValue;
    }
    clearContext(targetProvider) {
      validateProvider(targetProvider);
      this.infoMap.delete(targetProvider);
    }
    subscribeContext(targetProvider, consumer) {
      validateProvider(targetProvider);
      const {
        consumers,
        contextValue
      } = this.getInfo(targetProvider);
      if (!consumers.has(consumer)) {
        consumers.add(consumer);
        consumer.provide(contextValue);
      }
    }
    unsubscribeContext(targetProvider, consumer) {
      validateProvider(targetProvider);
      this.getInfo(targetProvider).consumers.delete(consumer);
    }
  }
  _2_41_4.registerDecorators(ContextInfo, {
    fields: ["infoMap"]
  });
  function ownKeys$d(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$d(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$d(Object(source), true).forEach(function(key) {
        _defineProperty$d(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$d(obj, key, value) {
    key = _toPropertyKey$d(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$d(arg) {
    var key = _toPrimitive$d(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$d(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const ERROR_CODE_PREFIX = "LWR";
  const DiagnosticLevel = {
    Fatal: 0,
    Error: 1,
    Warning: 2,
    Log: 3
  };
  function replaceArgs(message, args) {
    return Array.isArray(args) ? message.replace(/\{([0-9]+)\}/g, (_, index2) => {
      return args[index2];
    }) : message;
  }
  function generateMessage(info, args) {
    return `${info.code}: ${replaceArgs(info.message, args)}`;
  }
  function generateMessageObject(info, args) {
    const messageObject = _objectSpread$d(_objectSpread$d({}, info), {}, {
      message: replaceArgs(info.message, args)
    });
    if (info.address) {
      messageObject.address = replaceArgs(info.address, args);
    }
    if (info.stack) {
      messageObject.stack = replaceArgs(info.stack, args);
    }
    return messageObject;
  }
  function invariant(condition, errorInfo, args) {
    if (!condition) {
      throw new Error(generateMessage(errorInfo, args));
    }
  }
  const messages = {
    INVALID_MIXIN_CMP: {
      code: `${ERROR_CODE_PREFIX}4001`,
      message: "{0} must be an Element type",
      level: DiagnosticLevel.Error
    },
    MISSING_CONTEXT: {
      code: `${ERROR_CODE_PREFIX}4002`,
      message: "Could not find context to perform navigation action.",
      level: DiagnosticLevel.Error
    },
    INVALID_CONTEXT: {
      code: `${ERROR_CODE_PREFIX}4003`,
      message: "Cannot register navigation context; it must have this shape: { navigate, generateUrl, subscribe }",
      level: DiagnosticLevel.Error
    },
    MULTIPLE_ROOTS: {
      code: `${ERROR_CODE_PREFIX}4004`,
      message: "Router connection failed. There can only be one root router.",
      level: DiagnosticLevel.Error
    },
    MULTIPLE_CHILDREN: {
      code: `${ERROR_CODE_PREFIX}4005`,
      message: "Could not add to the navigation hierarchy. There can only be one child per navigation node.",
      level: DiagnosticLevel.Error
    },
    MISSING_ROUTE: {
      code: `${ERROR_CODE_PREFIX}4006`,
      message: 'A route cannot be created to navigate to URL "{0}"',
      level: DiagnosticLevel.Error,
      address: "{0}"
    },
    MISSING_URL: {
      code: `${ERROR_CODE_PREFIX}4007`,
      message: 'A URL cannot be created to navigate to route "{0}"',
      level: DiagnosticLevel.Error,
      address: "{0}"
    },
    PRENAV_FAILED: {
      code: `${ERROR_CODE_PREFIX}4008`,
      message: 'A preNavigate hook listener blocked routing to "{0}"',
      level: DiagnosticLevel.Warning,
      address: "{0}"
    },
    MISSING_ROUTE_TEMPLATE: {
      code: `${ERROR_CODE_PREFIX}4009`,
      message: 'A route definition must contain a "uri" property.',
      level: DiagnosticLevel.Error
    },
    MISSING_ROUTE_CMP: {
      code: `${ERROR_CODE_PREFIX}4016`,
      message: "Expected a route view component with a default export.",
      level: DiagnosticLevel.Error
    },
    MISSING_DATA_CONTEXT: {
      code: `${ERROR_CODE_PREFIX}4018`,
      message: "Could not find context to retrieve navigation data.",
      level: DiagnosticLevel.Error
    },
    INVALID_ROUTE_QUERY: {
      code: `${ERROR_CODE_PREFIX}4019`,
      message: "Invalid query param in route definition.",
      level: DiagnosticLevel.Error
    },
    MISSING_PAGE_BINDING: {
      code: `${ERROR_CODE_PREFIX}4020`,
      message: "Route definition must provide page binding",
      level: DiagnosticLevel.Error
    },
    INVALID_PAGE_BINDING: {
      code: `${ERROR_CODE_PREFIX}4021`,
      message: "Invalid page binding in route definition",
      level: DiagnosticLevel.Error
    },
    INVALID_URI_SYNTAX: {
      code: `${ERROR_CODE_PREFIX}4022`,
      message: "Invalid uri syntax. URI cannot contain *, +, (, ), ",
      level: DiagnosticLevel.Error
    },
    VIEW_IMPORT_FAILED: {
      code: `${ERROR_CODE_PREFIX}4023`,
      message: 'Error importing view with name "{0}", failure was: {1}',
      level: DiagnosticLevel.Error,
      stack: "{2}"
    },
    VIEW_MISSING: {
      code: `${ERROR_CODE_PREFIX}4024`,
      message: 'Expected a view with name "{0}" in the viewset',
      level: DiagnosticLevel.Error
    },
    VIEW_IMPORT_FAILED_WITH_SPECIFIER: {
      code: `${ERROR_CODE_PREFIX}4025`,
      message: 'Error importing module "{0}" from view with name "{1}", failure was: {2}',
      level: DiagnosticLevel.Error,
      stack: "{3}"
    },
    NO_ROUTE_MATCH: {
      code: `${ERROR_CODE_PREFIX}4026`,
      message: "A routing match cannot be found for: {0}",
      level: DiagnosticLevel.Error
    },
    INVALID_ROUTE_HANDLER: {
      code: `${ERROR_CODE_PREFIX}4027`,
      message: 'Route definition "{0}" does not have a valid route handler module',
      level: DiagnosticLevel.Error
    },
    DESTINATION_NOT_FOUND: {
      code: `${ERROR_CODE_PREFIX}4028`,
      message: "Route handler returned 404: Not Found",
      level: DiagnosticLevel.Error
    },
    DESTINATION_ERROR: {
      code: `${ERROR_CODE_PREFIX}4029`,
      message: "Route handler returned error status {0}: {1}",
      level: DiagnosticLevel.Error,
      stack: "{2}"
    }
  };
  const CACHE = new WeakMap();
  function getNavigationHelm(id) {
    const metadata = CACHE.get(id);
    if (!metadata || !metadata.value) {
      throw new Error(generateMessage(messages.MISSING_CONTEXT));
    }
    return metadata.value;
  }
  function registerNavigationHelm(contextId, contextValue) {
    const metadata = {
      id: contextId,
      value: contextValue,
      update: (newValue) => {
        metadata.value = newValue;
      }
    };
    CACHE.set(metadata.id, metadata);
    return metadata;
  }
  function generateContextualWireAdapter(contextInstance) {
    var _class;
    const Adapter = (_class = class Adapter {
      constructor(callback) {
        this._callback = callback;
      }
      connect() {
      }
      disconnect() {
      }
      update(config2, context) {
        if (context) {
          this._callback(context);
        }
      }
      static setContext(targetProvider, contextValue) {
        contextInstance.setContext(targetProvider, contextValue);
      }
      static getContext(targetProvider) {
        return contextInstance.getContext(targetProvider);
      }
      static clearContext(targetProvider) {
        contextInstance.clearContext(targetProvider);
      }
      static subscribeContext(targetProvider, consumer) {
        contextInstance.subscribeContext(targetProvider, consumer);
      }
      static unsubscribeContext(targetProvider, consumer) {
        contextInstance.unsubscribeContext(targetProvider, consumer);
      }
    }, _class.contextSchema = {
      value: "required"
    }, _class);
    return Adapter;
  }
  const NAVIGATION_CONTEXT = new ContextInfo(void 0);
  const NavigationContext = generateContextualWireAdapter(NAVIGATION_CONTEXT);
  const CURRENT_PAGE_REFERENCE_CONTEXT = new ContextInfo(void 0);
  const CurrentPageReference = generateContextualWireAdapter(CURRENT_PAGE_REFERENCE_CONTEXT);
  const CURRENT_VIEW_CONTEXT = new ContextInfo(void 0);
  const CurrentView = class CurrentView extends generateContextualWireAdapter(CURRENT_VIEW_CONTEXT) {
    async update(config2, context) {
      if (context) {
        const viewName = config2 && config2.viewName ? config2.viewName : "default";
        const viewEntry = context.viewset[viewName];
        const viewInfo = viewEntry;
        const viewImporter = viewInfo && viewInfo.module || viewEntry;
        let importError;
        if (viewImporter) {
          try {
            const viewModule = await viewImporter();
            const newViewCtor = viewModule && viewModule.default;
            if (newViewCtor && newViewCtor.constructor !== void 0) {
              this._callback(newViewCtor);
            } else {
              throw new Error("error occurred with view import");
            }
          } catch (e2) {
            const error2 = e2;
            if (viewInfo.specifier) {
              importError = generateMessageObject(messages.VIEW_IMPORT_FAILED_WITH_SPECIFIER, [viewInfo.specifier, viewName, error2.message, error2.stack || ""]);
            } else {
              importError = generateMessageObject(messages.VIEW_IMPORT_FAILED, [viewName, error2.message, error2.stack || ""]);
            }
          }
        } else {
          importError = generateMessageObject(messages.VIEW_MISSING, [viewName]);
        }
        if (context.onComplete) {
          context.onComplete(importError);
        }
      }
    }
  };
  function navigate$1(context, pageReference, replace2) {
    const api = getNavigationHelm(context);
    api.navigate(pageReference, replace2);
  }
  function generateUrl$1(context, pageReference) {
    const api = getNavigationHelm(context);
    return api.generateUrl(pageReference);
  }
  function createFilterChain() {
    const filters = [];
    const empty = () => {
      return filters.length === 0;
    };
    const addSingle = (filter) => {
      if (typeof filter === "function") {
        filters.push(filter);
      }
    };
    const add = (f2 = []) => {
      if (Array.isArray(f2)) {
        f2.forEach((l2) => addSingle(l2));
      } else {
        addSingle(f2);
      }
    };
    const compile2 = (arg) => {
      return filters.length === 0 ? Promise.resolve(true) : filters.reduce((previous, current) => {
        return previous.then((val) => {
          return val === false ? Promise.reject() : Promise.resolve(current(arg));
        });
      }, Promise.resolve(true)).then((val) => {
        return val === false ? false : true;
      }).catch((error2) => {
        if (error2 instanceof Error) {
          throw error2;
        } else {
          return false;
        }
      });
    };
    return {
      add,
      compile: compile2,
      empty
    };
  }
  function encode(str = "") {
    str = str || "";
    return encodeURIComponent(str);
  }
  function decode(str = "") {
    str = str || "";
    return decodeURIComponent(str);
  }
  function getPathFromUrl(url) {
    url = url || "/";
    if (url.charAt(0) !== "/") {
      url = "/" + url;
    }
    const fullmatch = url.match(/^[^#?]+/);
    if (fullmatch !== null) {
      const path = fullmatch[0];
      return path === "/" ? "/" : path.replace(/\/$/, "");
    }
    return "/";
  }
  function getQueryFromUrl(url) {
    url = url || "";
    const fragmentStart = url.indexOf("#");
    if (fragmentStart >= 0) {
      url = url.substring(0, fragmentStart);
    }
    const queryIdx = url.indexOf("?");
    const queryStr = queryIdx >= 0 ? url.substr(queryIdx + 1) : null;
    const queryParams = {};
    if (queryStr) {
      queryStr.split("&").forEach((pair) => {
        if (pair.indexOf("=") >= 0) {
          const [key, value = ""] = pair.split("=");
          queryParams[decode(key)] = decode(value);
        } else {
          queryParams[decode(pair)] = null;
        }
      });
    }
    return queryParams;
  }
  function getQueryString(queryObj = {}) {
    const keys = Object.keys(queryObj);
    return keys.length ? `?${keys.map((key) => {
      const value = queryObj[key];
      if (value === null) {
        return key;
      }
      return `${key}=${encode(value)}`;
    }).join("&")}` : "";
  }
  function isParam$1(str) {
    return str && str.length > 1 ? str.startsWith(":") : false;
  }
  function getParamName(routeParamName) {
    return routeParamName ? isParam$1(routeParamName) ? routeParamName.substr(1) : false : false;
  }
  function getQueryNames(compiledQuery) {
    return Object.values(compiledQuery).reduce((paramNames, {
      routeParamName
    }) => {
      const paramName = getParamName(routeParamName);
      if (paramName) {
        paramNames.push(paramName);
      }
      return paramNames;
    }, []);
  }
  function ownKeys$c(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$c(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$c(Object(source), true).forEach(function(key) {
        _defineProperty$c(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$c(obj, key, value) {
    key = _toPropertyKey$c(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$c(arg) {
    var key = _toPrimitive$c(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$c(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function matchRouteDefinitionByPageReference(pageReference, routeDefs) {
    if (!pageReference) {
      return null;
    }
    const {
      type: refType,
      attributes: refAttrs = {},
      state: refState = {}
    } = pageReference;
    if (refType) {
      const [matched] = routeDefs.filter((compiledDef) => {
        const {
          original: {
            page: {
              type = null,
              attributes: pageAttrs = {},
              state: pageState = {}
            } = {}
          }
        } = compiledDef;
        const matchesType = type === refType;
        const refAttributesHasAllPageKeys = Object.keys(pageAttrs).every((key) => {
          return Object.keys(refAttrs).indexOf(key) >= 0;
        });
        const refAttributesHasSameNumberOfKeys = Object.keys(pageAttrs).length === Object.keys(refAttrs).length;
        const refStateHasAllPageKeys = Object.keys(pageState).every((key) => {
          return Object.keys(refState).indexOf(key) >= 0;
        });
        const pageAttributeLiteralsCompletelyMatch = Object.keys(pageAttrs).filter((key) => {
          const value = pageAttrs[key];
          return !value || !isParam$1(value);
        }).every((key) => pageAttrs[key] === refAttrs[key]);
        const pageStateLiteralsCompletelyMatch = Object.keys(pageState).filter((key) => {
          const value = pageState[key];
          return value === null || !isParam$1(value);
        }).every((key) => pageState[key] === refState[key]);
        return matchesType && refAttributesHasAllPageKeys && refAttributesHasSameNumberOfKeys && pageAttributeLiteralsCompletelyMatch && refStateHasAllPageKeys && pageStateLiteralsCompletelyMatch;
      });
      return matched || null;
    }
    return null;
  }
  function getPathParams(path, routeDef) {
    const {
      regex,
      params: definedParams
    } = routeDef;
    const execArray = regex.exec(path);
    if (execArray) {
      const [, ...pathParamValues] = execArray;
      const pathParams = {};
      definedParams.forEach((param, index2) => {
        const {
          name: paramName
        } = param;
        const paramValue = pathParamValues[index2];
        pathParams[paramName] = paramValue ? decode(paramValue) : paramValue;
      });
      return pathParams;
    }
    return null;
  }
  function getQueryParams(queryObj, routeDef) {
    if (queryObj && routeDef) {
      const {
        queryMatcher
      } = routeDef;
      const matchedQuery = queryMatcher(queryObj);
      if (matchedQuery) {
        const params = {};
        Object.keys(matchedQuery).forEach((queryKeyName) => {
          const paramValue = matchedQuery[queryKeyName];
          const {
            value,
            routeParamName
          } = paramValue;
          const paramName = routeParamName ? routeParamName.substr(1) : queryKeyName;
          params[paramName] = value ? decode(value) : value;
        });
        return params;
      }
    }
    return null;
  }
  function getUnboundQueries(queryObj, routeDef) {
    const {
      compiledQuery
    } = routeDef;
    const boundKeys = Object.keys(compiledQuery).filter((qKey) => {
      const {
        literalValue
      } = compiledQuery[qKey];
      return !literalValue;
    });
    const unbound = {};
    Object.keys(queryObj).forEach((queryKey) => {
      const queryValue = queryObj[queryKey];
      if (boundKeys.indexOf(queryKey) < 0) {
        unbound[queryKey] = queryValue;
      }
    });
    return unbound;
  }
  function getPageReferenceFromUriAndRouteDef(uri, routeDef) {
    if (routeDef) {
      const {
        original: {
          page: {
            type: pageType = "",
            attributes: pageAttributes = {},
            state: pageState = {}
          } = {}
        } = {}
      } = routeDef;
      const path = getPathFromUrl(uri);
      const query = getQueryFromUrl(uri);
      const pathParams = getPathParams(path, routeDef);
      const queryParams = getQueryParams(query, routeDef);
      if (pathParams && queryParams) {
        const allParams = _objectSpread$c(_objectSpread$c({}, pathParams), queryParams);
        const boundAttributeParams = {};
        Object.keys(pageAttributes).forEach((attributeKey) => {
          const attributeValue = pageAttributes[attributeKey];
          let value;
          if (attributeValue && isParam$1(attributeValue)) {
            const paramName = attributeValue.substr(1);
            value = allParams[paramName];
          } else {
            value = attributeValue;
          }
          boundAttributeParams[attributeKey] = value;
        });
        const boundStateParams = {};
        Object.keys(pageState).forEach((stateKey) => {
          const stateValue = pageState[stateKey];
          let value;
          if (stateValue && isParam$1(stateValue)) {
            const paramName = stateValue.substr(1);
            value = allParams[paramName];
          } else {
            value = stateValue;
          }
          boundStateParams[stateKey] = value;
        });
        const unboundState = getUnboundQueries(query, routeDef);
        return {
          type: pageType,
          attributes: _objectSpread$c({}, boundAttributeParams),
          state: _objectSpread$c(_objectSpread$c({}, unboundState), boundStateParams)
        };
      }
    }
    return null;
  }
  function ownKeys$b(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$b(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$b(Object(source), true).forEach(function(key) {
        _defineProperty$b(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$b(obj, key, value) {
    key = _toPropertyKey$b(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$b(arg) {
    var key = _toPrimitive$b(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$b(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function isRoutePatternsMatched(path, queryObj, routeDef) {
    const {
      original: {
        patterns = null
      } = {}
    } = routeDef || {};
    if (patterns) {
      const pathParams = getPathParams(path, routeDef);
      const queryParams = getQueryParams(queryObj, routeDef);
      const params = _objectSpread$b(_objectSpread$b({}, pathParams), queryParams);
      return Object.keys(patterns).every((paramKey) => {
        const pattern = patterns[paramKey];
        const regex = new RegExp(pattern);
        const paramValue = params[paramKey] || "";
        return regex.test(paramValue);
      });
    }
    return true;
  }
  function getRouteDefinitionForUri(uri, routeDefs) {
    const path = getPathFromUrl(uri);
    const queryObj = getQueryFromUrl(uri);
    const matchedPaths = routeDefs ? routeDefs.filter((def) => def.regex.test(path)) : [];
    const [matched] = matchedPaths.filter((def) => {
      const {
        queryMatcher
      } = def;
      return queryMatcher(queryObj) && isRoutePatternsMatched(path, queryObj, def);
    });
    return matched || null;
  }
  function matchRouteByUrl(url, routeDefs, basePath2 = "") {
    if (basePath2 && url.indexOf(basePath2) === 0) {
      url = url.replace(basePath2, "");
    }
    const routeDef = getRouteDefinitionForUri(url, routeDefs);
    let matchInfo;
    if (!routeDef) {
      return null;
    } else {
      const pageReference = getPageReferenceFromUriAndRouteDef(url, routeDef);
      if (pageReference) {
        const originalRouteDef = routeDef.original;
        matchInfo = {
          route: {
            id: originalRouteDef.id,
            attributes: _objectSpread$b({}, pageReference.attributes),
            state: _objectSpread$b({}, pageReference.state),
            pageReference: {
              type: pageReference.type,
              attributes: _objectSpread$b({}, pageReference.attributes),
              state: _objectSpread$b({}, pageReference.state)
            }
          },
          routeDefinition: routeDef
        };
        return matchInfo;
      }
    }
    return null;
  }
  function getUrlFromPageReference(pageReference, routeDefs, basePath2 = "") {
    const routeDef = matchRouteDefinitionByPageReference(pageReference, routeDefs);
    if (routeDef) {
      return getUrlFromPageReferenceAndRouteDef(pageReference, routeDef, basePath2);
    }
    return null;
  }
  function extractBindingValues(parameters, pageReference, pageBindings) {
    const {
      attributeBindings,
      stateBindings
    } = pageBindings;
    const {
      attributes: refAttributes,
      state: refState
    } = pageReference;
    const parameterValueMapping = {};
    parameters.forEach((paramName) => {
      const [attributeBindingKey] = Object.keys(attributeBindings).filter((attributeBindingKey2) => {
        return getParamName(attributeBindings[attributeBindingKey2]) === paramName;
      });
      if (attributeBindingKey) {
        parameterValueMapping[paramName] = refAttributes[attributeBindingKey];
      } else {
        const [stateBindingKey] = Object.keys(stateBindings).filter((stateBindingKey2) => {
          return getParamName(stateBindings[stateBindingKey2]) === paramName;
        });
        if (stateBindingKey) {
          parameterValueMapping[paramName] = refState[stateBindingKey];
        }
      }
    });
    return parameterValueMapping;
  }
  function getUrlFromPageReferenceAndRouteDef(pageReference, routeDef, basePath2 = "") {
    const {
      params,
      original: {
        page = {}
      } = {},
      toPath,
      compiledQuery
    } = routeDef;
    const {
      attributes: attributeBindings = {},
      state: stateBindings = {}
    } = page;
    const pathParamNames = params.filter(({
      name
    }) => {
      return typeof name === "string";
    }).map(({
      name
    }) => {
      return name;
    });
    const pathParameters = extractBindingValues(pathParamNames, pageReference, {
      attributeBindings,
      stateBindings
    });
    const toPathUrl = toPath(pathParameters);
    const queryParamNames = getQueryNames(compiledQuery);
    const queryParameters = extractBindingValues(queryParamNames, pageReference, {
      attributeBindings,
      stateBindings
    });
    const queryObject = getQueryObjectForParametersAndPageReference(pageReference, queryParameters, routeDef);
    const queryString = getQueryString(queryObject);
    return `${basePath2}${toPathUrl}${queryString}`;
  }
  function getQueryObjectForParametersAndPageReference(pageReference, queryParameters, routeDef) {
    const {
      compiledQuery,
      original: {
        page: {
          state: stateBindings = {}
        }
      }
    } = routeDef;
    const {
      state: refState = {}
    } = pageReference || {};
    const nonParamState = {};
    Object.keys(refState).filter((stateKey) => {
      const bindingValue = stateBindings[stateKey];
      return !isParam$1(bindingValue);
    }).forEach((key) => nonParamState[key] = refState[key]);
    const queryParamKeyValueMap = {};
    Object.keys(queryParameters).forEach((paramName) => {
      const paramValue = queryParameters[paramName];
      const [compiledQueryMatch] = Object.keys(compiledQuery).filter((key) => {
        const compiledValue = compiledQuery[key];
        const {
          routeParamName
        } = compiledValue;
        return getParamName(routeParamName) === paramName;
      });
      if (compiledQueryMatch) {
        const queryKey = compiledQueryMatch;
        queryParamKeyValueMap[queryKey] = paramValue;
      }
    });
    return _objectSpread$b(_objectSpread$b({}, nonParamState), queryParamKeyValueMap);
  }
  function getPageReferenceFromUrl(url, routeDefs, basePath2 = "") {
    const routingMatch = matchRouteByUrl(url, routeDefs, basePath2);
    if (routingMatch && routingMatch.route && routingMatch.route.pageReference) {
      return routingMatch.route.pageReference;
    }
    return null;
  }
  function isObject$1(o2) {
    return typeof o2 === "object" && o2 !== null && !Array.isArray(o2);
  }
  function objectHasKey(o2, key) {
    return key in o2;
  }
  function freeze$2(o2, depthLimit = 2) {
    if (isObject$1(o2)) {
      try {
        Object.freeze(o2);
        if (depthLimit > 0) {
          Object.keys(o2).forEach((key) => {
            if (objectHasKey(o2, key)) {
              const val = o2[key];
              if (val && typeof val === "object") {
                freeze$2(val, depthLimit - 1);
              }
            }
          });
        }
      } catch (e2) {
      }
    }
    return o2;
  }
  function guid$1() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  function lexer(str) {
    const tokens = [];
    let i = 0;
    while (i < str.length) {
      const char = str[i];
      if (char === "*" || char === "+" || char === "?") {
        tokens.push({
          type: "MODIFIER",
          index: i,
          value: str[i++]
        });
        continue;
      }
      if (char === "\\") {
        tokens.push({
          type: "ESCAPED_CHAR",
          index: i++,
          value: str[i++]
        });
        continue;
      }
      if (char === "{") {
        tokens.push({
          type: "OPEN",
          index: i,
          value: str[i++]
        });
        continue;
      }
      if (char === "}") {
        tokens.push({
          type: "CLOSE",
          index: i,
          value: str[i++]
        });
        continue;
      }
      if (char === ":") {
        let name = "";
        let j = i + 1;
        while (j < str.length) {
          const code = str.charCodeAt(j);
          if (code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code === 95) {
            name += str[j++];
            continue;
          }
          break;
        }
        if (!name)
          throw new TypeError(`Missing parameter name at ${i}`);
        tokens.push({
          type: "NAME",
          index: i,
          value: name
        });
        i = j;
        continue;
      }
      if (char === "(") {
        let count = 1;
        let pattern = "";
        let j = i + 1;
        if (str[j] === "?") {
          throw new TypeError(`Pattern cannot start with "?" at ${j}`);
        }
        while (j < str.length) {
          if (str[j] === "\\") {
            pattern += str[j++] + str[j++];
            continue;
          }
          if (str[j] === ")") {
            count--;
            if (count === 0) {
              j++;
              break;
            }
          } else if (str[j] === "(") {
            count++;
            if (str[j + 1] !== "?") {
              throw new TypeError(`Capturing groups are not allowed at ${j}`);
            }
          }
          pattern += str[j++];
        }
        if (count)
          throw new TypeError(`Unbalanced pattern at ${i}`);
        if (!pattern)
          throw new TypeError(`Missing pattern at ${i}`);
        tokens.push({
          type: "PATTERN",
          index: i,
          value: pattern
        });
        i = j;
        continue;
      }
      tokens.push({
        type: "CHAR",
        index: i,
        value: str[i++]
      });
    }
    tokens.push({
      type: "END",
      index: i,
      value: ""
    });
    return tokens;
  }
  function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
  }
  function flags(options) {
    return options && options.sensitive ? "" : "i";
  }
  function parse(str, options = {}) {
    const tokens = lexer(str);
    const {
      prefixes = "./"
    } = options;
    const defaultPattern = `[^${escapeString(options.delimiter || "/#?")}]+?`;
    const result = [];
    let key = 0;
    let i = 0;
    let path = "";
    const tryConsume = (type) => {
      if (i < tokens.length && tokens[i].type === type)
        return tokens[i++].value;
    };
    const mustConsume = (type) => {
      const value = tryConsume(type);
      if (value !== void 0)
        return value;
      const {
        type: nextType,
        index: index2
      } = tokens[i];
      throw new TypeError(`Unexpected ${nextType} at ${index2}, expected ${type}`);
    };
    const consumeText = () => {
      let result2 = "";
      let value;
      while (value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
        result2 += value;
      }
      return result2;
    };
    while (i < tokens.length) {
      const char = tryConsume("CHAR");
      const name = tryConsume("NAME");
      const pattern = tryConsume("PATTERN");
      if (name || pattern) {
        let prefix2 = char || "";
        if (prefixes.indexOf(prefix2) === -1) {
          path += prefix2;
          prefix2 = "";
        }
        if (path) {
          result.push(path);
          path = "";
        }
        result.push({
          name: name || key++,
          prefix: prefix2,
          suffix: "",
          pattern: pattern || defaultPattern,
          modifier: tryConsume("MODIFIER") || ""
        });
        continue;
      }
      const value = char || tryConsume("ESCAPED_CHAR");
      if (value) {
        path += value;
        continue;
      }
      if (path) {
        result.push(path);
        path = "";
      }
      const open = tryConsume("OPEN");
      if (open) {
        const prefix2 = consumeText();
        const name2 = tryConsume("NAME") || "";
        const pattern2 = tryConsume("PATTERN") || "";
        const suffix = consumeText();
        mustConsume("CLOSE");
        result.push({
          name: name2 || (pattern2 ? key++ : ""),
          pattern: name2 && !pattern2 ? defaultPattern : pattern2,
          prefix: prefix2,
          suffix,
          modifier: tryConsume("MODIFIER") || ""
        });
        continue;
      }
      mustConsume("END");
    }
    return result;
  }
  function tokensToFunction(tokens, options = {}) {
    const reFlags = flags(options);
    const {
      encode: encode2 = (x2) => x2,
      validate = true
    } = options;
    const matches = tokens.map((token) => {
      if (typeof token === "object") {
        return new RegExp(`^(?:${token.pattern})$`, reFlags);
      }
    });
    return (data) => {
      let path = "";
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        if (typeof token === "string") {
          path += token;
          continue;
        }
        const value = data ? data[token.name] : void 0;
        const optional = token.modifier === "?" || token.modifier === "*";
        const repeat = token.modifier === "*" || token.modifier === "+";
        if (Array.isArray(value)) {
          if (!repeat) {
            throw new TypeError(`Expected "${token.name}" to not repeat, but got an array`);
          }
          if (value.length === 0) {
            if (optional)
              continue;
            throw new TypeError(`Expected "${token.name}" to not be empty`);
          }
          for (let j = 0; j < value.length; j++) {
            const segment = encode2(value[j], token);
            if (validate && !matches[i].test(segment)) {
              throw new TypeError(`Expected all "${token.name}" to match "${token.pattern}", but got "${segment}"`);
            }
            path += token.prefix + segment + token.suffix;
          }
          continue;
        }
        if (typeof value === "string" || typeof value === "number") {
          const segment = encode2(String(value), token);
          if (validate && !matches[i].test(segment)) {
            throw new TypeError(`Expected "${token.name}" to match "${token.pattern}", but got "${segment}"`);
          }
          path += token.prefix + segment + token.suffix;
          continue;
        }
        if (optional)
          continue;
        const typeOfMessage = repeat ? "an array" : "a string";
        throw new TypeError(`Expected "${token.name}" to be ${typeOfMessage}`);
      }
      return path;
    };
  }
  function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
  }
  function regexpToRegexp(path, keys) {
    if (!keys)
      return path;
    const groups = path.source.match(/\((?!\?)/g);
    if (groups) {
      for (let i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: "",
          suffix: "",
          modifier: "",
          pattern: ""
        });
      }
    }
    return path;
  }
  function tokensToRegexp(tokens, keys, options = {}) {
    const {
      strict = false,
      start = true,
      end = true,
      encode: encode2 = (x2) => x2
    } = options;
    const endsWith = `[${escapeString(options.endsWith || "")}]|$`;
    const delimiter = `[${escapeString(options.delimiter || "/#?")}]`;
    let route = start ? "^" : "";
    for (const token of tokens) {
      if (typeof token === "string") {
        route += escapeString(encode2(token));
      } else {
        const prefix2 = escapeString(encode2(token.prefix));
        const suffix = escapeString(encode2(token.suffix));
        if (token.pattern) {
          if (keys)
            keys.push(token);
          if (prefix2 || suffix) {
            if (token.modifier === "+" || token.modifier === "*") {
              const mod = token.modifier === "*" ? "?" : "";
              route += `(?:${prefix2}((?:${token.pattern})(?:${suffix}${prefix2}(?:${token.pattern}))*)${suffix})${mod}`;
            } else {
              route += `(?:${prefix2}(${token.pattern})${suffix})${token.modifier}`;
            }
          } else {
            route += `(${token.pattern})${token.modifier}`;
          }
        } else {
          route += `(?:${prefix2}${suffix})${token.modifier}`;
        }
      }
    }
    if (end) {
      if (!strict)
        route += `${delimiter}?`;
      route += !options.endsWith ? "$" : `(?=${endsWith})`;
    } else {
      const endToken = tokens[tokens.length - 1];
      const isEndDelimited = typeof endToken === "string" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
      if (!strict) {
        route += `(?:${delimiter}(?=${endsWith}))?`;
      }
      if (!isEndDelimited) {
        route += `(?=${delimiter}|${endsWith})`;
      }
    }
    return new RegExp(route, flags(options));
  }
  function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
  }
  function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
      return regexpToRegexp(path, keys);
    if (Array.isArray(path))
      return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
  }
  function arrayToRegexp(paths, keys, options) {
    const parts = paths.map((path) => pathToRegexp(path, keys, options).source);
    return new RegExp(`(?:${parts.join("|")})`, flags(options));
  }
  function ownKeys$a(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$a(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$a(Object(source), true).forEach(function(key) {
        _defineProperty$a(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$a(obj, key, value) {
    key = _toPropertyKey$a(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$a(arg) {
    var key = _toPrimitive$a(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$a(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const {
    INVALID_ROUTE_QUERY,
    MISSING_ROUTE_TEMPLATE,
    MISSING_PAGE_BINDING,
    INVALID_PAGE_BINDING,
    INVALID_URI_SYNTAX
  } = messages;
  function parseRoutes(config2) {
    const {
      routes: routes2,
      caseSensitive
    } = config2;
    return routes2.map((def) => {
      return parseUriRoute(def, caseSensitive);
    });
  }
  function parseUriRoute(def, caseSensitive = false) {
    const params = [];
    const {
      uri,
      page
    } = def;
    invariant(!!uri, MISSING_ROUTE_TEMPLATE);
    invariant(isValidUri(uri), INVALID_URI_SYNTAX);
    invariant(!!page, MISSING_PAGE_BINDING);
    const path = getPathFromUrl(uri);
    const query = getQueryFromUrl(uri);
    const regex = pathToRegexp(path, params, {
      sensitive: caseSensitive,
      end: def.exact === false ? false : true
    });
    const toPath = compile(path, {
      encode: encodeURIComponent
    });
    const compiledQuery = compileQueryObject(query);
    const queryMatcher = getQueryMatcher(compiledQuery, caseSensitive);
    const compiledRoute = {
      original: def,
      regex,
      params,
      toPath,
      compiledQuery,
      queryMatcher
    };
    invariant(isValidPageBinding(compiledRoute), INVALID_PAGE_BINDING);
    return compiledRoute;
  }
  function isValidUri(uri = "") {
    const invalid = ["*", "(", ")", ";"];
    const containsInvalidCharacter = invalid.some((invalidChar) => uri.indexOf(invalidChar) >= 0);
    return !containsInvalidCharacter;
  }
  function isValidPageBinding(compiledDef) {
    const {
      original: {
        page
      } = {},
      params,
      compiledQuery
    } = compiledDef;
    const pageType = page ? page.type : page;
    const pageAttributes = (page ? page.attributes : page) || {};
    const pageState = (page ? page.state : page) || {};
    if (typeof pageType !== "string" || typeof pageAttributes !== "object" || typeof pageState !== "object") {
      return false;
    }
    const pathParams = Object.values(params).map(({
      name
    }) => name);
    const queryParams = getQueryNames(compiledQuery);
    const allParams = [...pathParams, ...queryParams];
    const attributeBindings = Object.values(pageAttributes).filter(isParam$1).map(getParamName);
    const stateBindings = Object.values(pageState).filter(isParam$1).map(getParamName);
    const hasAllParams = allParams.every((paramName) => {
      if (typeof paramName !== "string") {
        return false;
      }
      return attributeBindings.indexOf(paramName) >= 0 || stateBindings.indexOf(paramName) >= 0;
    });
    const paramsUsedOnlyOnce = allParams.length === attributeBindings.length + stateBindings.length;
    return !!(page && pageType && pageAttributes && pageState && hasAllParams && paramsUsedOnlyOnce);
  }
  function compileQueryObject(queryObject) {
    const compiled = {};
    Object.keys(queryObject).forEach((qKey) => {
      const qValue = queryObject[qKey];
      invariant(isParam$1(qKey) ? qValue === null : true, INVALID_ROUTE_QUERY);
      if (isParam$1(qKey)) {
        compiled[qKey.substr(1)] = {
          routeParamName: qKey
        };
      } else if (qValue && isParam$1(qValue)) {
        compiled[qKey] = {
          routeParamName: qValue
        };
      } else {
        compiled[qKey] = {
          literalValue: qValue === null ? null : qValue
        };
      }
    });
    return compiled;
  }
  function getQueryMatcher(compiledQuery, caseSensitive = false) {
    const queryMatcher = (queryObject) => {
      const inputKeys = Object.keys(queryObject);
      const defKeys = Object.keys(compiledQuery);
      const hasAllDefKeys = defKeys.every((defKey) => inputKeys.indexOf(defKey) >= 0);
      if (hasAllDefKeys) {
        return defKeys.reduce((matched, defKey) => {
          if (matched === null)
            return null;
          const {
            literalValue,
            routeParamName
          } = compiledQuery[defKey];
          const inputValue = queryObject[defKey];
          let literalValueMatches = true;
          if (typeof literalValue === "string") {
            literalValueMatches = caseSensitive ? literalValue === inputValue : literalValue.toUpperCase() === (inputValue == null ? inputValue : inputValue.toUpperCase());
          } else if (literalValue === null) {
            literalValueMatches = inputValue === literalValue;
          }
          if (literalValueMatches) {
            matched = _objectSpread$a(_objectSpread$a({}, matched), {}, {
              [defKey]: {
                value: inputValue,
                routeParamName
              }
            });
          } else {
            matched = null;
          }
          return matched;
        }, {});
      }
      return null;
    };
    return queryMatcher;
  }
  const hasDocument = typeof document !== "undefined";
  const CONTEXT_ID_BACKDOOR = `universalcontainergetnavigationcontext${guid$1()}`;
  const Navigate = Symbol("Navigate");
  const GenerateUrl = Symbol("GenerateUrl");
  const NavContext = Symbol("NavContext");
  const GetContext = Symbol("NavContext");
  function NavigationMixin(Base) {
    invariant(typeof Base.prototype.dispatchEvent === "function", messages.INVALID_MIXIN_CMP, [Base.toString()]);
    class Mixin extends Base {
      [GetContext]() {
        if (!this[NavContext]) {
          this.dispatchEvent(new CustomEvent(CONTEXT_ID_BACKDOOR, {
            bubbles: true,
            composed: true,
            detail: {
              callback: (contextId) => {
                this[NavContext] = contextId;
              }
            }
          }));
          if (!this[NavContext]) {
            throw new Error(generateMessage(messages.MISSING_CONTEXT));
          }
        }
      }
      [Navigate](pageRef, replace2) {
        this[GetContext]();
        navigate$1(this[NavContext], pageRef, replace2);
      }
      async [GenerateUrl](pageRef) {
        this[GetContext]();
        return generateUrl$1(this[NavContext], pageRef);
      }
    }
    return Mixin;
  }
  NavigationMixin.Navigate = Navigate;
  NavigationMixin.GenerateUrl = GenerateUrl;
  NavigationMixin.NavContext = NavContext;
  var navigation = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ContextInfo,
    CurrentPageReference,
    CurrentView,
    NavigationContext,
    NavigationMixin,
    generateContextualWireAdapter,
    generateUrl: generateUrl$1,
    getNavigationHelm,
    navigate: navigate$1,
    registerNavigationHelm
  });
  const ARIA_LIVE_ID = "sf-aria-live";
  const TAB_INDEX_ATTR_NAME = "tabindex";
  const {
    document: document$2
  } = globalThis;
  function ariaLiveNavigate(routingResult) {
    if (document$2 && routingResult?.routeDefinition) {
      let ariaLiveRegion = document$2.body.querySelector(`#${ARIA_LIVE_ID}`);
      if (!ariaLiveRegion) {
        ariaLiveRegion = document$2.createElement("span");
        ariaLiveRegion.id = ARIA_LIVE_ID;
        ariaLiveRegion.setAttribute("aria-live", "polite");
        ariaLiveRegion.setAttribute("aria-atomic", "true");
        ariaLiveRegion.setAttribute("style", "position: absolute; margin: -1px; border: 0; padding: 0; width: 1px; height: 1px; overflow: hidden; clip: rect(0 0 0 0); text-transform: none; white-space: nowrap;");
        document$2.body.appendChild(ariaLiveRegion);
      }
      ariaLiveRegion.innerText = routingResult.routeDefinition.label;
    }
  }
  function updateTitle(routingResult) {
    if (document$2 && routingResult?.routeDefinition) {
      document$2.title = routingResult.routeDefinition.label;
    }
  }
  function updateFocus(resetFocus) {
    if (!document$2) {
      return;
    }
    const treeWalker = document$2.createTreeWalker(document$2.body, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (e2) => {
        if (e2.matches("webruntime-router-container")) {
          return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_SKIP;
      }
    });
    const element = resetFocus ? document$2.body : treeWalker.nextNode();
    if (element) {
      element.setAttribute(TAB_INDEX_ATTR_NAME, "-1");
      element.focus({
        preventScroll: true
      });
      element.removeAttribute(TAB_INDEX_ATTR_NAME);
    }
  }
  function createObservable() {
    let currentValue = void 0;
    let currentError = void 0;
    let observers = [];
    const addObserver = (obs) => {
      observers.push(obs);
    };
    const removeObserver = (obsIndex) => {
      observers = [...observers.slice(0, obsIndex), ...observers.slice(obsIndex + 1)];
    };
    const next = (value) => {
      observers.filter((obs) => obs !== null).forEach((obs) => obs.next && obs.next(value));
      currentValue = value;
      currentError = void 0;
    };
    const error2 = (err) => {
      observers.filter((obs) => obs !== null).forEach((obs) => obs.error && obs.error(err));
      currentValue = void 0;
      currentError = err;
    };
    const complete = () => {
      observers.filter((obs) => obs !== null).forEach((obs) => obs.complete && obs.complete());
      observers = [];
      currentValue = void 0;
      currentError = void 0;
    };
    const subscribe2 = (obs, replay = true) => {
      addObserver(obs);
      if (currentValue && replay) {
        obs.next(currentValue);
      }
      if (currentError) {
        error2(currentError);
      }
      const obsIndex = observers.length - 1;
      return {
        unsubscribe: () => removeObserver(obsIndex)
      };
    };
    return {
      next,
      error: error2,
      complete,
      subscribe: subscribe2
    };
  }
  function ownKeys$9(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$9(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$9(Object(source), true).forEach(function(key) {
        _defineProperty$9(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$9(obj, key, value) {
    key = _toPropertyKey$9(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$9(arg) {
    var key = _toPrimitive$9(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$9(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  class RouterImpl {
    constructor(config2) {
      this.deprecatedConfig = {};
      this.routeHandlerId = 0;
      this.compiledRoutes = [];
      this.routeObservable = createObservable();
      this.config = {
        basePath: config2.basePath || "",
        caseSensitive: Boolean(config2.caseSensitive),
        routes: config2.routes || [],
        generateUrl: (address) => getUrlFromPageReference(address, this.compiledRoutes, this.config.basePath),
        parseUrl: (url) => getPageReferenceFromUrl(url, this.compiledRoutes, this.config.basePath)
      };
      const {
        DEPRECATED_getRouteFromUrl,
        DEPRECATED_getUrlFromRoute
      } = config2;
      if (DEPRECATED_getRouteFromUrl) {
        this.deprecatedConfig.DEPRECATED_getRouteFromUrl = DEPRECATED_getRouteFromUrl;
      }
      if (DEPRECATED_getUrlFromRoute) {
        this.deprecatedConfig.DEPRECATED_getUrlFromRoute = DEPRECATED_getUrlFromRoute;
      }
      this.compiledRoutes = parseRoutes(this.config);
    }
    generateUrl(address) {
      const {
        DEPRECATED_getUrlFromRoute: getUrlFromRoute2
      } = this.deprecatedConfig;
      if (getUrlFromRoute2) {
        return getUrlFromRoute2(address, this.config.generateUrl);
      } else {
        return this.config.generateUrl(address);
      }
    }
    parseUrl(url) {
      const {
        DEPRECATED_getRouteFromUrl: getRouteFromUrl2
      } = this.deprecatedConfig;
      if (getRouteFromUrl2) {
        return getRouteFromUrl2(url, this.config.parseUrl);
      } else {
        return this.config.parseUrl(url);
      }
    }
    matchRoute(address) {
      const url = typeof address === "string" ? address : this.generateUrl(address);
      if (url === null) {
        return null;
      }
      const match = matchRouteByUrl(url, this.compiledRoutes, this.config.basePath);
      const pathMatch = match && getUrlFromPageReferenceAndRouteDef(match.route.pageReference, match.routeDefinition, this.config.basePath);
      if (!match || !pathMatch) {
        return null;
      }
      return {
        pathMatch,
        route: match.route,
        routeDefinition: match.routeDefinition.original
      };
    }
    async resolveView(address) {
      return new Promise((resolve, reject) => {
        const routingMatch = this.matchRoute(address);
        if (!routingMatch) {
          return reject(generateMessage(messages.NO_ROUTE_MATCH, [JSON.stringify(address)]));
        }
        return routingMatch.routeDefinition.handler().then((handlerModule) => {
          const routeHandlerClass = handlerModule.default;
          if (!routeHandlerClass) {
            return reject(generateMessage(messages.INVALID_ROUTE_HANDLER, [routingMatch.routeDefinition.id]));
          }
          const routeHandler = new routeHandlerClass(resolve);
          if (routeHandler) {
            routeHandler.update(routingMatch.route);
          }
        });
      });
    }
    navigate(address) {
      const routingMatch = this.matchRoute(address);
      if (!routingMatch) {
        throw new Error(generateMessage(messages.MISSING_ROUTE, [JSON.stringify(address)]));
      }
      this.pendingRoute = _objectSpread$9({}, routingMatch);
      this._mapView(this.pendingRoute);
    }
    subscribe(callback, replay) {
      return this.routeObservable.subscribe({
        next: callback,
        error: () => {
        },
        complete: () => {
        }
      }, Boolean(replay));
    }
    async _mapView(routingMatch) {
      const routeHandlerId = Math.random();
      this.routeHandlerId = routeHandlerId;
      const handlerModule = await routingMatch.routeDefinition.handler();
      const routeHandlerClass = handlerModule.default;
      if (!routeHandlerClass) {
        throw new Error(generateMessage(messages.INVALID_ROUTE_HANDLER, [routingMatch.routeDefinition.id]));
      }
      this.routeHandler = new routeHandlerClass((routeDestination) => {
        this._updateView(routeHandlerId, routeDestination);
      });
      if (this.routeHandler) {
        this.routeHandler.update(routingMatch.route);
      }
      return true;
    }
    _updateView(viewHandlerId, routeDestination) {
      if (!routeDestination || viewHandlerId !== this.routeHandlerId) {
        return;
      }
      if (!this.pendingRoute) {
        throw new Error("Trying to commit route state without a route");
      }
      const viewset = freeze$2(routeDestination.viewset);
      this.routeObservable.next(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, this.pendingRoute), routeDestination), {}, {
        viewset
      }));
    }
  }
  _2_41_4.registerDecorators(RouterImpl, {
    fields: ["deprecatedConfig", "routeHandlerId"]
  });
  function createRouter(config2 = {}) {
    return new RouterImpl(config2);
  }
  class Overrides {
    constructor() {
      this.overrides = [];
    }
    add(f2) {
      this.overrides.push(f2);
    }
    run(...args) {
      return this.overrides.length === 0 ? Promise.resolve(true) : this.overrides.reduce((previous, current) => {
        return previous.then((val) => {
          return val === false ? Promise.resolve(false) : Promise.resolve(current(...args));
        });
      }, Promise.resolve(true)).then((val) => {
        return Promise.resolve(val);
      });
    }
    runSync(...args) {
      return this.overrides.length === 0 ? true : this.overrides.reduce((previous, current) => {
        return previous === true ? current(...args) : false;
      }, true);
    }
  }
  _2_41_4.registerDecorators(Overrides, {
    fields: ["overrides"]
  });
  const PreNavigateOverrides = new Overrides(), NavigationOverrides = new Overrides(), SessionTimeoutOverrides = new Overrides(), PageNavigationFailureOverrides = new Overrides();
  var overrides = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    NavigationOverrides,
    Overrides,
    PageNavigationFailureOverrides,
    PreNavigateOverrides,
    SessionTimeoutOverrides
  });
  function ownKeys$8(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$8(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty$8(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$8(obj, key, value) {
    key = _toPropertyKey$8(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$8(arg) {
    var key = _toPrimitive$8(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$8(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function splitOptionalParameters(inputRoutes) {
    const routesWithoutOptionalParameters = [];
    const routesWithOptionalParameters = [];
    inputRoutes.forEach((route) => {
      if (route.uri.includes("?")) {
        routesWithOptionalParameters.push(route);
      } else {
        routesWithoutOptionalParameters.push(route);
      }
    });
    const splitRoutes = [];
    routesWithOptionalParameters.forEach((route) => {
      const segments = [];
      const parts = route.uri.split("/");
      let optionalSegment;
      let paramName;
      let paramType = "";
      parts.forEach((part) => {
        if (part.endsWith("?")) {
          optionalSegment = part.substring(0, part.length - 1);
          segments.push({
            value: optionalSegment,
            isOptional: true
          });
          paramName = optionalSegment.substring(1);
          paramType = route.page.attributes?.[paramName] ? "attributes" : "state";
        } else {
          segments.push({
            value: part,
            isOptional: false
          });
        }
      });
      const optionalRoute = _objectSpread$8(_objectSpread$8({}, route), {}, {
        uri: segments.map((s2) => s2.value).join("/")
      });
      splitRoutes.push(optionalRoute);
      const filteredSet = {};
      Object.keys(route.page[paramType]).forEach((key) => {
        if (key !== paramName) {
          filteredSet[key] = route.page[paramType][key];
        }
      });
      const requiredRoute = _objectSpread$8(_objectSpread$8({}, route), {}, {
        uri: segments.filter((s2) => !s2.isOptional).map((s2) => s2.value).join("/"),
        page: _objectSpread$8(_objectSpread$8({}, route.page), {}, {
          [paramType]: filteredSet
        })
      });
      if (requiredRoute.patterns) {
        requiredRoute.patterns = Object.fromEntries(Object.entries(requiredRoute.patterns).filter(([key]) => key !== paramName));
      }
      splitRoutes.push(requiredRoute);
    });
    return [...routesWithoutOptionalParameters, ...splitRoutes];
  }
  function splitObjectPageRoutes(inputRoutes) {
    const objectPageRoutes = [];
    const nonObjectPageRoutes = [];
    inputRoutes.forEach((route) => {
      const {
        type,
        attributes = {},
        state = {}
      } = route.page || {};
      if (type === "standard__objectPage") {
        if (isParam(attributes.actionName)) {
          objectPageRoutes.push(route);
        } else {
          let otherRoute;
          if (attributes.actionName === "list") {
            otherRoute = _objectSpread$8(_objectSpread$8({}, route), {}, {
              page: _objectSpread$8(_objectSpread$8({}, route.page), {}, {
                attributes: _objectSpread$8({}, attributes),
                state: _objectSpread$8({}, state)
              })
            });
            otherRoute.page.attributes.actionName = "home";
          } else if (attributes.actionName === "home") {
            otherRoute = _objectSpread$8(_objectSpread$8({}, route), {}, {
              page: _objectSpread$8(_objectSpread$8({}, route.page), {}, {
                attributes: _objectSpread$8({}, attributes),
                state: _objectSpread$8({}, state)
              })
            });
            otherRoute.page.attributes.actionName = "list";
          } else if (!attributes.actionName) {
            route.page.attributes.actionName = "home";
            otherRoute = _objectSpread$8(_objectSpread$8({}, route), {}, {
              page: _objectSpread$8(_objectSpread$8({}, route.page), {}, {
                attributes: _objectSpread$8({}, attributes),
                state: _objectSpread$8({}, state)
              })
            });
            otherRoute.page.attributes.actionName = "list";
          }
          objectPageRoutes.push(route, otherRoute);
        }
      } else {
        nonObjectPageRoutes.push(route);
      }
    });
    return [...objectPageRoutes, ...nonObjectPageRoutes];
  }
  function isParam(str) {
    return str && str.length > 1 ? str.startsWith(":") : false;
  }
  const canonicalURLCache = {};
  function parseURL(url) {
    const {
      pathname,
      search,
      hash
    } = new URL(url, window.location.origin);
    return {
      pathname,
      search,
      hash
    };
  }
  async function getCanonicalURL(url) {
    const {
      pathname,
      search,
      hash
    } = parseURL(url);
    if (canonicalURLCache[pathname]) {
      return canonicalURLCache[pathname] + search + hash;
    }
    if (Object.values(canonicalURLCache).includes(pathname)) {
      return url;
    }
    try {
      const {
        redirected,
        url: canonicalUrl
      } = await _1_66_319244_0$1.fetch(url, {
        basePath: "",
        method: "HEAD",
        isNonApiRequest: true
      });
      if (redirected) {
        const canonicalPath = parseURL(canonicalUrl).pathname;
        canonicalURLCache[pathname] = canonicalPath;
        return canonicalPath + search + hash;
      }
    } catch (error2) {
      logError(`Unable to fetch canonical URL for ${url}`, "error:\n", error2);
    }
    return null;
  }
  async function canonicalRedirectionHandler(router2, routingResult) {
    const {
      route,
      routeDefinition
    } = routingResult;
    if (routeDefinition?.metadata?.hasVanityURL) {
      const url = router2.generateUrl(route.pageReference);
      const canonicalUrl = await getCanonicalURL(url);
      if (canonicalUrl && canonicalUrl !== url) {
        const canonicalUrlPageRef = {
          type: "standard__webPage",
          attributes: {
            url: canonicalUrl
          }
        };
        navigate$1(router2.contextId, canonicalUrlPageRef, true);
        return true;
      }
    }
    return false;
  }
  class GenericRouteHandler {
    constructor(callback) {
      this.callback = void 0;
      this.callback = callback;
    }
    dispose() {
    }
    update(routeInfo) {
      const view = routes__default["default"].find((r2) => r2.id === routeInfo.id)?.view;
      this.callback({
        viewset: {
          default: () => _0_9_0.load(getViewModuleSpecifier(view), "webruntime/app/v/1")
        }
      });
    }
  }
  _2_41_4.registerDecorators(GenericRouteHandler, {
    fields: ["callback"]
  });
  var genericRouteHandler = _2_41_4.registerComponent(GenericRouteHandler, {
    tmpl: _tmpl$a,
    sel: "webruntime-routingService"
  });
  function ownKeys$7(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$7(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty$7(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$7(obj, key, value) {
    key = _toPropertyKey$7(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$7(arg) {
    var key = _toPrimitive$7(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$7(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  let useImportedExtraRouteParams = true;
  const extraRouteParamsStore = {};
  function getStoreKeyfromPageReference(pageReference) {
    return pageReference?.attributes?.urlName || pageReference?.attributes?.urlPath;
  }
  function storeAndDeleteExtraRouteParamsFromPageReference(pageReference) {
    if (pageReference.extraRouteParams) {
      storeExtraRouteParams(pageReference, pageReference.extraRouteParams);
      delete pageReference.extraRouteParams;
    }
  }
  function storeExtraRouteParams(pageReference, extraRouteParamsToStore) {
    const storeKey = getStoreKeyfromPageReference(pageReference);
    if (!extraRouteParamsToStore || !storeKey)
      return;
    extraRouteParamsStore[storeKey] = extraRouteParamsToStore;
  }
  function needsExtraRouteParams(pageReference) {
    const storeKey = getStoreKeyfromPageReference(pageReference);
    if (storeKey && storeKey in extraRouteParamsStore) {
      const storedExtraRouteParams = extraRouteParamsStore[storeKey];
      return !(storedExtraRouteParams && Object.keys(storedExtraRouteParams).length > 0);
    }
    return !!storeKey;
  }
  function extraRouteParamsPreNavigation(routeChange = {}) {
    const {
      current,
      next: {
        url,
        route: {
          pageReference
        } = {}
      }
    } = routeChange;
    if (current && needsExtraRouteParams(pageReference)) {
      window.location.assign(url);
      return true;
    }
    return false;
  }
  function handleExtraRouteParams(route) {
    if (useImportedExtraRouteParams) {
      addExtraRouteParamsToRoute$1(route, extraRouteParams__default["default"]);
      storeExtraRouteParams(route.pageReference, extraRouteParams__default["default"]);
      useImportedExtraRouteParams = false;
    } else {
      const storeKey = getStoreKeyfromPageReference(route?.pageReference);
      const storedExtraRouteParams = extraRouteParamsStore[storeKey];
      addExtraRouteParamsToRoute$1(route, storedExtraRouteParams);
    }
  }
  function addExtraRouteParamsToRoute$1(route, extraRouteParamsToAdd) {
    if (isObject(extraRouteParamsToAdd)) {
      if (isObject(route?.attributes)) {
        route.attributes = _objectSpread$7(_objectSpread$7({}, route.attributes), extraRouteParamsToAdd);
      }
      if (isObject(route?.pageReference?.attributes)) {
        route.pageReference.attributes = _objectSpread$7(_objectSpread$7({}, route.pageReference.attributes), extraRouteParamsToAdd);
      }
    }
  }
  function isObject(obj) {
    return obj && typeof obj === "object";
  }
  const REDIRECT_PAGE_CONTEXT_KEY = "redirectPageContext";
  function getRedirectPageContext(route) {
    return route?.state?.[REDIRECT_PAGE_CONTEXT_KEY] || null;
  }
  function redirectPageContextIfNeeded(routerContextId, defaultRouteDef2, routeChange = {}) {
    const {
      current,
      next: {
        route
      } = {}
    } = routeChange;
    if (getRedirectPageContext(route)) {
      if (current) {
        window.location.assign(generateRedirectPageContextURL(route));
      } else {
        navigate$1(routerContextId, defaultRouteDef2.page, true);
      }
      return true;
    }
    return false;
  }
  function generateRedirectPageContextURL(pageReference) {
    if (!pageReference)
      return null;
    const encodedPageReference = getRedirectPageContext(pageReference) || window.btoa(window.encodeURIComponent(JSON.stringify(pageReference)));
    return `${basePath__default["default"]}/?${REDIRECT_PAGE_CONTEXT_KEY}=${encodedPageReference}`;
  }
  const ARTICLE_APINAME_ALIAS = "KnowledgeArticleVersion";
  const defaultValueConfigs = [{
    type: "standard__objectPage",
    params: [{
      name: "filterName",
      type: "state",
      value: "Default"
    }]
  }, {
    type: "standard__search",
    params: [{
      name: "term",
      type: "state",
      value: " "
    }]
  }, {
    type: "standard__recordPage",
    params: [{
      name: "recordName",
      type: "state",
      value: "detail"
    }, {
      name: "categoryPath",
      type: "state",
      value: "detail"
    }],
    match: (route, {
      name
    }) => {
      const {
        attributes = {}
      } = route;
      if (attributes.urlName || attributes.urlPath) {
        return false;
      }
      if (attributes.objectApiName === "ProductCategory") {
        return name === "categoryPath";
      }
      if (attributes.objectApiName === "OrderSummary") {
        return false;
      }
      return name === "recordName";
    }
  }];
  function getDefaultValueRouteParamConfig(route) {
    return defaultValueConfigs.find((config2) => route.type === config2.type);
  }
  function transferParamsForManagedContentRoute(route) {
    if (route.attributes && route.attributes.contentKey) {
      route.attributes.urlAlias = route.attributes.contentKey;
      delete route.attributes.contentKey;
    }
    return route;
  }
  let articleObjectApiName;
  function convertArticleApiNameAlias(route, routes2) {
    if (route.attributes?.objectApiName === ARTICLE_APINAME_ALIAS) {
      if (articleObjectApiName === void 0) {
        const articleRoute = routes2.find((r2) => r2.page.attributes?.objectApiName?.endsWith("__kav"));
        articleObjectApiName = articleRoute?.page?.attributes?.objectApiName || null;
      }
      if (articleObjectApiName) {
        route.attributes.objectApiName = articleObjectApiName;
      }
    }
  }
  function transformRouteWithURLName(route) {
    if (!route.attributes?.urlName && !route.attributes?.urlPath)
      return route;
    if (route.type === "standard__recordPage") {
      addExtraRouteParamsToRoute(route);
      delete route.attributes.recordId;
      delete route.state?.recordName;
      delete route.state?.categoryPath;
    }
    if (route.type === "standard__recordRelationshipPage") {
      addExtraRouteParamsToRoute(route);
      delete route.attributes.recordId;
    }
    return route;
  }
  function addExtraRouteParamsToRoute(route) {
    if (route.attributes.recordId) {
      route.extraRouteParams = {
        recordId: route.attributes.recordId
      };
    }
  }
  function transformArticleRoute(route, routes2) {
    if (route.type === "standard__knowledgeArticlePage") {
      route.type = "standard__recordPage";
      route.attributes.actionName = "view";
      route.attributes.objectApiName = ARTICLE_APINAME_ALIAS;
      delete route.attributes.articleType;
    }
    convertArticleApiNameAlias(route, routes2);
    return route;
  }
  function setDefaultParameterValue(route, config2) {
    const {
      params,
      match
    } = config2;
    params.forEach((param) => {
      const {
        type,
        name,
        value
      } = param;
      if (match && !match(route, param)) {
        return;
      }
      if (!route?.[type]?.[name]) {
        if (!route[type]) {
          route[type] = {};
        }
        route[type][name] = value;
      }
    });
  }
  function setDefaultValueForParameters(route = {}) {
    const config2 = getDefaultValueRouteParamConfig(route);
    if (config2) {
      setDefaultParameterValue(route, config2);
    }
  }
  function replaceSlashEntityCharacters(route, url) {
    if (route.state?.categoryPath?.includes("/") || route.attributes?.urlPath?.includes("/")) {
      let [pathname, search] = url.split("?");
      pathname = pathname.replace(/%2F/g, "/");
      search = search ? `?${search}` : "";
      return pathname + search;
    }
    return url;
  }
  const {
    window: window$1,
    performance: performance$1
  } = globalThis;
  const routerMark = `${WEBRUNTIME_PREFIX}-framework-router`;
  performance$1?.mark(routerMark);
  const processedRoutes = splitObjectPageRoutes(splitOptionalParameters(parseRoutes$1(routes__default["default"])));
  processedRoutes.forEach((route) => {
    route.handler = () => new Promise((resolve) => {
      resolve({
        default: genericRouteHandler
      });
    });
  });
  const defaultRouteDef = processedRoutes.find((route) => route.metadata.isDefault);
  const isAllRoutesPublic = routes__default["default"].every((route) => route.metadata.isPublic !== false);
  const config = {
    basePath: basePath$1__default["default"],
    caseSensitive: true,
    routes: processedRoutes,
    DEPRECATED_getRouteFromUrl: getRouteFromUrl,
    DEPRECATED_getUrlFromRoute: getUrlFromRoute
  };
  const router = createRouter(config);
  performance$1?.measure(routerMark, routerMark);
  let o11yRouterSupport;
  function getRouteFromUrl(url, defaultImpl) {
    const route = defaultImpl(url);
    if (!route) {
      if (defaultRouteDef?.page) {
        return defaultRouteDef.page;
      }
      return null;
    }
    setDefaultValueForParameters(route);
    return route;
  }
  function getUrlFromRoute(route = {
    type: "",
    attributes: {},
    state: {}
  }, defaultImpl) {
    const {
      type,
      attributes
    } = route;
    let url;
    if (type === "standard__webPage") {
      url = attributes.url;
      return url == null ? "" : addBasePath(url);
    }
    if (type === "standard__managedContentPage") {
      route = transferParamsForManagedContentRoute(route);
    }
    transformArticleRoute(route, processedRoutes);
    transformRouteWithURLName(route);
    setDefaultValueForParameters(route);
    url = defaultImpl(route);
    if (type === "standard__recordPage") {
      url = replaceSlashEntityCharacters(route, url);
    }
    if (!url && isAllRoutesPublic) {
      url = generateRedirectPageContextURL(route);
    }
    return url;
  }
  async function isAuthorized(routeChange, event) {
    const {
      route,
      routeDefinition
    } = routeChange.next;
    if (routeDefinition?.metadata?.isPublic !== false) {
      return true;
    }
    const {
      default: user
    } = await _0_9_0.load("@app/user/v/1");
    if (user.isGuest) {
      const url = generateUrl(route.pageReference);
      if (url && window$1) {
        event.preventDefault();
        window$1.location.href = url;
      }
      return false;
    }
    return true;
  }
  function handleRedirectPageContext(routeChange) {
    return redirectPageContextIfNeeded(router.contextId, defaultRouteDef, routeChange);
  }
  async function handleError(event) {
    try {
      const {
        detail: {
          address,
          message,
          code
        }
      } = event;
      logError(`Routing error: ${message}`);
      if (code === messages.PRENAV_FAILED.code) {
        return;
      }
      if (code === messages.MISSING_ROUTE.code && !defaultRouteDef && address?.includes("redirectPageContext=")) {
        window$1?.location.assign(address);
        return;
      }
      if (defaultRouteDef?.metadata?.isPublic === false) {
        const {
          default: user
        } = await _0_9_0.load("@app/user/v/1");
        if (user.isGuest) {
          return;
        }
      }
      navigate(defaultRouteDef.page);
    } finally {
      o11yRouterSupport?.errorNavigate(event.detail);
    }
  }
  function handleNavigation(event) {
    const pageReference = event.detail.address;
    if (!NavigationOverrides.runSync(pageReference)) {
      event.preventDefault();
      return;
    }
    const {
      type,
      attributes: {
        url
      } = {
        url: null
      }
    } = pageReference;
    if (type === "standard__webPage" && url != null) {
      if (isAbsoluteURL(url)) {
        window$1?.open(url);
        event.preventDefault();
        return;
      }
      const matchedRouteDef = router.parseUrl(url);
      if (isAllRoutesPublic && (!matchedRouteDef || matchedRouteDef === defaultRouteDef?.page)) {
        window$1?.location.assign(addBasePath(url));
        event.preventDefault();
      }
    }
    storeAndDeleteExtraRouteParamsFromPageReference(pageReference);
  }
  function addBasePath(url) {
    if (isAbsoluteURL(url)) {
      return url;
    }
    const baseMissing = basePath$1__default["default"] && url !== basePath$1__default["default"] && url.indexOf(`${basePath$1__default["default"]}/`) !== 0;
    return baseMissing ? `${basePath$1__default["default"]}${url}` : url;
  }
  function navigate(pageRef) {
    navigate$1(router.contextId, pageRef);
  }
  function generateUrl(pageRef) {
    return router.generateUrl(pageRef);
  }
  function subscribe(callback, replay = true) {
    return router.subscribe(callback, replay);
  }
  let previousThemeLayout;
  async function handlePrenavigate(event) {
    const routeChange = event.detail;
    const currentView = routeChange.current?.routeDefinition.view;
    if (currentView) {
      previousThemeLayout = viewToThemeLayoutMap__default["default"][currentView];
    } else {
      previousThemeLayout = null;
    }
    o11yRouterSupport?.preNavigate(routeChange);
    PreNavigateOverrides.run(routeChange);
    isAuthorized(routeChange, event);
    resetCurrentPageStartTime();
    if (handleRedirectPageContext(routeChange)) {
      event.preventDefault();
      return;
    }
    if (extraRouteParamsPreNavigation(routeChange)) {
      event.preventDefault();
    }
  }
  async function handlePostnavigate(event) {
    const routingResult = event.detail;
    const view = routingResult.routeDefinition?.view;
    const resetFocusToThemeRegion = previousThemeLayout !== viewToThemeLayoutMap__default["default"][view];
    try {
      ariaLiveNavigate(routingResult);
      updateTitle(routingResult);
      updateFocus(resetFocusToThemeRegion);
      await canonicalRedirectionHandler(router, routingResult);
    } finally {
      o11yRouterSupport?.postNavigate(routingResult);
    }
  }
  function initializeRouterContainer(routerContainer) {
    o11yRouterSupport = _1_66_319244_0._o11y.routingSupport;
    routerContainer.addEventListener("prenavigate", handlePrenavigate);
    routerContainer.addEventListener("handlenavigation", handleNavigation);
    routerContainer.addEventListener("postnavigate", handlePostnavigate);
    routerContainer.addEventListener("errornavigate", handleError);
  }
  var routingService = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    generateUrl,
    handleExtraRouteParams,
    initializeRouterContainer,
    navigate,
    router,
    subscribe
  });
  function isMedium() {
    return typeof window !== "undefined" && window.matchMedia("only screen and (min-width: 48em) and (max-width: 64em)").matches;
  }
  function isSmall() {
    return typeof window !== "undefined" && window.matchMedia("only screen and (max-width: 47.9375em)").matches;
  }
  function getFormFactor() {
    if (isMedium())
      return "Medium";
    if (isSmall())
      return "Small";
    return "Large";
  }
  var formFactor = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getFormFactor
  });
  const prefix = "/services/data/v58.0";
  const auraMethodToResourceReferenceMapping = {
    "CommerceCatalogController.getProductCategoryPath": {
      urlPath: prefix + "/commerce/webstores/${webstoreId}/product-category-path/product-categories/${productCategoryId}",
      urlPathParamNames: ["productCategoryId", "webstoreId"],
      method: "GET"
    },
    "CommerceCatalogController.getProducts": {
      urlPath: prefix + "/commerce/webstores/${webstoreId}/products",
      urlPathParamNames: ["webstoreId"],
      method: "GET"
    },
    "CommerceCatalogController.getProduct": {
      urlPath: prefix + "/commerce/webstores/${webstoreId}/products/${productId}",
      urlPathParamNames: ["productId", "webstoreId"],
      method: "GET"
    },
    "HSRCommerceCatalogController.getProductCategoryPathHSR": {
      urlPath: prefix + "/commerce/webstores/${webstoreId}/versions/${versionId}/product-categories/${productCategoryId}/product-category-path",
      urlPathParamNames: ["productCategoryId", "versionId", "webstoreId"],
      method: "GET"
    },
    "HSRCommerceCatalogController.getProductHSR": {
      urlPath: prefix + "/commerce/webstores/${webstoreId}/versions/${versionId}/products/${productId}",
      urlPathParamNames: ["productId", "versionId", "webstoreId"],
      method: "GET"
    },
    "CommerceStorePricingController.getProductPrices": {
      urlPath: prefix + "/commerce/webstores/${webstoreId}/pricing/products",
      urlPathParamNames: ["webstoreId"],
      method: "GET"
    },
    "CommerceStorePricingController.getProductPrice": {
      urlPath: prefix + "/commerce/webstores/${webstoreId}/pricing/products/${productId}",
      urlPathParamNames: ["productId", "webstoreId"],
      method: "GET"
    },
    "CommunitiesController.getCommunity": {
      urlPath: prefix + "/connect/communities/${communityId}",
      urlPathParamNames: ["communityId"],
      method: "GET"
    },
    "CommunitiesController.ingestRecord": {
      urlPath: prefix + "/connect/communities/${communityId}/microbatching",
      urlPathParamNames: ["communityId"],
      inputRepresentation: "requestIngestionInput",
      method: "POST"
    },
    "MissionsController.purgeUserMissionsActivities": {
      urlPath: prefix + "/connect/communities/${communityId}/missions/activities/purge-job",
      urlPathParamNames: ["communityId"],
      method: "POST"
    },
    "CommerceCartController.upsertInventoryReservation": {
      urlPath: prefix + "/commerce/webstores/${webstoreId}/carts/${activeCartOrId}/inventory-reservations",
      urlPathParamNames: ["activeCartOrId", "webstoreId"],
      inputRepresentation: "cartInventoryReservationInput",
      method: "PUT"
    },
    "CommerceSearchController.searchProducts": {
      urlPath: prefix + "/commerce/webstores/${webstoreId}/search/product-search",
      urlPathParamNames: ["webstoreId"],
      inputRepresentation: "productSearchInput",
      method: "POST"
    },
    "NavigationMenuController.getCommunityNavigationMenu": {
      urlPath: prefix + "/connect/communities/${communityId}/navigation-menu/navigation-menu-items",
      urlPathParamNames: ["communityId"],
      method: "GET"
    },
    "MarketingIntegrationController.getForm": {
      urlPath: prefix + "/sites/${siteId}/marketing-integration/forms/${formId}",
      urlPathParamNames: ["formId", "siteId"],
      method: "GET"
    },
    "MarketingIntegrationController.saveForm": {
      urlPath: prefix + "/sites/${siteId}/marketing-integration/forms",
      urlPathParamNames: ["siteId"],
      inputRepresentation: "formInput",
      method: "POST"
    },
    "MarketingIntegrationController.submitForm": {
      urlPath: prefix + "/sites/${siteId}/marketing-integration/forms/${formId}/data",
      urlPathParamNames: ["formId", "siteId"],
      inputRepresentation: "formSubmissionInput",
      method: "POST"
    },
    "SeoPropertiesController.getRecordSeoProperties": {
      urlPath: prefix + "/connect/communities/${communityId}/seo/properties/${recordId}",
      urlPathParamNames: ["communityId", "recordId"],
      method: "GET"
    },
    "FlowBuilderController.getRules": {
      urlPath: prefix + "/connect/interaction/builder/rules",
      urlPathParamNames: [],
      method: "GET"
    },
    "OrchestrationController.getOrchestrationInstanceCollection": {
      urlPath: prefix + "/connect/interaction/orchestration/instances",
      urlPathParamNames: [],
      method: "GET"
    },
    "FlowRuntimeConnectController.navigateFlow": {
      urlPath: prefix + "/connect/interaction/runtime/navigateFlow",
      urlPathParamNames: [],
      inputRepresentation: "request",
      method: "POST"
    },
    "FlowRuntimeConnectController.resumeFlow": {
      urlPath: prefix + "/connect/interaction/runtime/resumeFlow",
      urlPathParamNames: [],
      method: "POST"
    },
    "FlowRuntimeConnectController.startFlow": {
      urlPath: prefix + "/connect/interaction/runtime/startFlow",
      urlPathParamNames: [],
      method: "POST"
    },
    "ExperienceModelTypeSystemController.getBlockTypes": {
      urlPath: prefix + "/connect/experience-model/block-types",
      urlPathParamNames: [],
      method: "GET"
    },
    "ExperienceModelTypeSystemController.getBlockType": {
      urlPath: prefix + "/connect/experience-model/block-types/${fullyQualifiedName}",
      urlPathParamNames: ["fullyQualifiedName"],
      method: "GET"
    },
    "ExperienceModelTypeSystemController.getContentTypes": {
      urlPath: prefix + "/connect/experience-model/content-types",
      urlPathParamNames: [],
      method: "GET"
    },
    "ExperienceModelTypeSystemController.getContentTypesByContextRecordId": {
      urlPath: prefix + "/connect/experience-model/content-types",
      urlPathParamNames: [],
      method: "GET"
    },
    "ExperienceModelTypeSystemController.getContentType": {
      urlPath: prefix + "/connect/experience-model/content-types/${fullyQualifiedName}",
      urlPathParamNames: ["fullyQualifiedName"],
      method: "GET"
    },
    "ExperienceModelTypeSystemController.getPropertyTypes": {
      urlPath: prefix + "/connect/experience-model/property-types",
      urlPathParamNames: [],
      method: "GET"
    },
    "ExperienceModelTypeSystemController.getPropertyType": {
      urlPath: prefix + "/connect/experience-model/property-types/${fullyQualifiedName}",
      urlPathParamNames: ["fullyQualifiedName"],
      method: "GET"
    },
    "ManagedContentController.getAllManagedContentChannels": {
      urlPath: prefix + "/connect/cms/management/channels",
      urlPathParamNames: [],
      method: "GET"
    },
    "ManagedContentController.postManagedContentChannel": {
      urlPath: prefix + "/connect/cms/management/channels",
      urlPathParamNames: [],
      inputRepresentation: "ManagedContentChannelInput",
      method: "POST"
    },
    "ManagedContentController.getManagedContentChannelRecordByChannelId": {
      urlPath: prefix + "/connect/cms/management/channels/${channelId}",
      urlPathParamNames: ["channelId"],
      method: "GET"
    },
    "ManagedContentController.patchManagedContentChannelRecord": {
      urlPath: prefix + "/connect/cms/management/channels/${channelId}",
      urlPathParamNames: ["channelId"],
      inputRepresentation: "ManagedContentChannelInput",
      method: "PATCH"
    },
    "ManagedContentController.getCollectionItems": {
      urlPath: prefix + "/connect/cms/collections/${collectionKeyOrId}",
      urlPathParamNames: ["collectionKeyOrId"],
      method: "GET"
    },
    "ManagedContentController.getManagedContentByTopicsAndContentKeys": {
      urlPath: prefix + "/connect/communities/${communityId}/managed-content/delivery",
      urlPathParamNames: ["communityId"],
      method: "GET"
    },
    "ManagedContentController.getPublishedManagedContentListByContentKey": {
      urlPath: prefix + "/connect/communities/${communityId}/managed-content/delivery/contents",
      urlPathParamNames: ["communityId"],
      method: "GET"
    },
    "ManagedContentController.createDeployment": {
      urlPath: prefix + "/cms/deployments",
      urlPathParamNames: [],
      inputRepresentation: "DeploymentInput",
      method: "POST"
    },
    "ManagedContentController.createManagedContent": {
      urlPath: prefix + "/connect/cms/contents",
      urlPathParamNames: [],
      inputRepresentation: "ManagedContentInputParam",
      method: "POST"
    },
    "ManagedContentController.createManagedContentWithMedia": {
      urlPath: prefix + "/connect/cms/contents",
      urlPathParamNames: [],
      inputRepresentation: "ManagedContentInputParam",
      method: "POST"
    },
    "ManagedContentController.getManagedContent": {
      urlPath: prefix + "/connect/cms/contents/${contentKeyOrId}",
      urlPathParamNames: ["contentKeyOrId"],
      method: "GET"
    },
    "ManagedContentController.createManagedContentExportV2Job": {
      urlPath: prefix + "/connect/cms/spaces/${contentSpaceId}/contents/export",
      urlPathParamNames: ["contentSpaceId"],
      inputRepresentation: "managedContentV2JobRequest",
      method: "POST"
    },
    "ManagedContentController.createManagedContentImportV2Job": {
      urlPath: prefix + "/connect/cms/spaces/${contentSpaceId}/contents/import",
      urlPathParamNames: ["contentSpaceId"],
      inputRepresentation: "managedContentV2JobRequest",
      method: "POST"
    },
    "ManagedContentController.getManagedContentOrchestrationDefinitions": {
      urlPath: prefix + "/connect/cms/contents/orchestration-definitions",
      urlPathParamNames: [],
      method: "GET"
    },
    "ManagedContentController.getManagedContentOrchestrationInstances": {
      urlPath: prefix + "/connect/cms/contents/orchestration-instances",
      urlPathParamNames: [],
      method: "GET"
    },
    "ManagedContentController.createManagedContentOrchestrationInstance": {
      urlPath: prefix + "/connect/cms/contents/orchestration-instances",
      urlPathParamNames: [],
      inputRepresentation: "mContentOrchInstanceInput",
      method: "POST"
    },
    "ManagedContentController.getManagedContentPreviews": {
      urlPath: prefix + "/cms/spaces/${contentSpaceId}/preview-endpoints",
      urlPathParamNames: ["contentSpaceId"],
      method: "GET"
    },
    "ManagedContentController.publish": {
      urlPath: prefix + "/connect/cms/contents/publish",
      urlPathParamNames: [],
      inputRepresentation: "publishInput",
      method: "POST"
    },
    "ManagedContentController.getManagedContentReferencedBy": {
      urlPath: prefix + "/connect/cms/contents/${contentKeyOrId}/referenced-by",
      urlPathParamNames: ["contentKeyOrId"],
      method: "GET"
    },
    "ManagedContentController.getManagedContentVariantRendition": {
      urlPath: prefix + "/connect/cms/contents/${contentKeyOrId}/renditions/${renditionType}",
      urlPathParamNames: ["contentKeyOrId", "renditionType"],
      method: "GET"
    },
    "ManagedContentController.getManagedContentRunningOrchestrationHistoryEvents": {
      urlPath: prefix + "/connect/cms/contents/orchestration-history-events",
      urlPathParamNames: [],
      method: "GET"
    },
    "ManagedContentController.searchManagedContentForItems": {
      urlPath: prefix + "/connect/cms/items/search",
      urlPathParamNames: [],
      method: "GET"
    },
    "ManagedContentController.getManagedContentSpaces": {
      urlPath: prefix + "/connect/cms/spaces",
      urlPathParamNames: [],
      method: "GET"
    },
    "ManagedContentController.getManagedContentSpaceFolderItems": {
      urlPath: prefix + "/connect/cms/folders/${folderId}/items",
      urlPathParamNames: ["folderId"],
      method: "GET"
    },
    "ManagedContentController.getManagedContentSpace": {
      urlPath: prefix + "/connect/cms/spaces/${contentSpaceId}",
      urlPathParamNames: ["contentSpaceId"],
      method: "GET"
    },
    "ManagedContentController.patchManagedContentSpace": {
      urlPath: prefix + "/connect/cms/spaces/${contentSpaceId}",
      urlPathParamNames: ["contentSpaceId"],
      inputRepresentation: "ManagedContentSpaceInput",
      method: "PATCH"
    },
    "ManagedContentController.createTranslationJob": {
      urlPath: prefix + "/connect/managed-content/translation",
      urlPathParamNames: [],
      inputRepresentation: "translationRequest",
      method: "POST"
    },
    "ManagedContentController.createTranslationV2Job": {
      urlPath: prefix + "/connect/cms/content/spaces/${contentSpaceId}/translation",
      urlPathParamNames: ["contentSpaceId"],
      inputRepresentation: "translationV2Request",
      method: "POST"
    },
    "ManagedContentController.unpublish": {
      urlPath: prefix + "/connect/cms/contents/unpublish",
      urlPathParamNames: [],
      inputRepresentation: "unpublishInput",
      method: "POST"
    },
    "ManagedContentController.createManagedContentVariant": {
      urlPath: prefix + "/connect/cms/contents/variants",
      urlPathParamNames: [],
      inputRepresentation: "ManagedContentVariantInputParam",
      method: "POST"
    },
    "ManagedContentController.getVariantReferences": {
      urlPath: prefix + "/connect/cms/contents/${contentKeyOrId}/variants/references",
      urlPathParamNames: ["contentKeyOrId"],
      method: "GET"
    },
    "ManagedContentController.deleteManagedContentVariant": {
      urlPath: prefix + "/connect/cms/contents/variants/${variantId}",
      urlPathParamNames: ["variantId"],
      method: "DELETE"
    },
    "ManagedContentController.getManagedContentVariant": {
      urlPath: prefix + "/connect/cms/contents/variants/${variantId}",
      urlPathParamNames: ["variantId"],
      method: "GET"
    },
    "ManagedContentController.replaceManagedContentVariant": {
      urlPath: prefix + "/connect/cms/contents/variants/${variantId}",
      urlPathParamNames: ["variantId"],
      inputRepresentation: "ManagedContentVariantInputParam",
      method: "PUT"
    },
    "ManagedContentController.replaceManagedContentVariantWithMedia": {
      urlPath: prefix + "/connect/cms/contents/variants/${variantId}",
      urlPathParamNames: ["variantId"],
      inputRepresentation: "ManagedContentVariantInputParam",
      method: "PUT"
    },
    "ManagedContentController.getManagedContentVariantVersions": {
      urlPath: prefix + "/connect/cms/contents/variants/${variantId}/versions",
      urlPathParamNames: ["variantId"],
      method: "GET"
    },
    "ManagedContentDeliveryController.getCollectionItemsForChannel": {
      urlPath: prefix + "/connect/cms/delivery/channels/${channelId}/collections/${collectionKeyOrId}",
      urlPathParamNames: ["channelId", "collectionKeyOrId"],
      method: "GET"
    },
    "ManagedContentDeliveryController.getCollectionItemsForSite": {
      urlPath: prefix + "/connect/sites/${siteId}/cms/delivery/collections/${collectionKeyOrId}",
      urlPathParamNames: ["collectionKeyOrId", "siteId"],
      method: "GET"
    },
    "ManagedContentDeliveryController.getCollectionMetadata": {
      urlPath: prefix + "/connect/cms/collections/${collectionKeyOrId}/metadata",
      urlPathParamNames: ["collectionKeyOrId"],
      method: "GET"
    },
    "ManagedContentDeliveryController.getCollectionMetadataForChannel": {
      urlPath: prefix + "/connect/cms/delivery/channels/${channelId}/collections/${collectionKeyOrId}/metadata",
      urlPathParamNames: ["channelId", "collectionKeyOrId"],
      method: "GET"
    },
    "ManagedContentDeliveryController.getCollectionMetadataForSite": {
      urlPath: prefix + "/connect/sites/${siteId}/cms/delivery/collections/${collectionKeyOrId}/metadata",
      urlPathParamNames: ["collectionKeyOrId", "siteId"],
      method: "GET"
    },
    "ManagedContentTypeController.getContentTypeSchema": {
      urlPath: prefix + "/connect/cms/content-types/${contentTypeFQN}",
      urlPathParamNames: ["contentTypeFQN"],
      method: "GET"
    },
    "SitesController.searchSite": {
      urlPath: prefix + "/connect/sites/${siteId}/search",
      urlPathParamNames: ["siteId"],
      method: "GET"
    },
    "ActionsController.getGlobalActions": {
      urlPath: prefix + "/ui-api/actions/global",
      urlPathParamNames: [],
      method: "GET"
    },
    "ActionsController.getActionLayout": {
      urlPath: prefix + "/ui-api/actions/layout/${actionApiName}",
      urlPathParamNames: ["actionApiName"],
      method: "GET"
    },
    "ActionsController.getListViewActions": {
      urlPath: prefix + "/ui-api/actions/list-view/${listViewIds}",
      urlPathParamNames: ["listViewIds"],
      method: "GET"
    },
    "ActionsController.getLookupActions": {
      urlPath: prefix + "/ui-api/actions/lookup/${objectApiNames}",
      urlPathParamNames: ["objectApiNames"],
      method: "GET"
    },
    "ActionsController.getMRUListActions": {
      urlPath: prefix + "/ui-api/actions/mru-list/${objectApiNames}",
      urlPathParamNames: ["objectApiNames"],
      method: "GET"
    },
    "ActionsController.getObjectCreateActions": {
      urlPath: prefix + "/ui-api/actions/object/${objectApiName}/record-create",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "ActionsController.getActionOverrides": {
      urlPath: prefix + "/ui-api/actions/overrides/${objectApiName}",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "ActionsController.performUpdateRecordQuickAction": {
      urlPath: prefix + "/ui-api/actions/perform-quick-action/${actionApiName}",
      urlPathParamNames: ["actionApiName"],
      inputRepresentation: "performQuickActionInput",
      method: "PATCH"
    },
    "ActionsController.performQuickAction": {
      urlPath: prefix + "/ui-api/actions/perform-quick-action/${actionApiName}",
      urlPathParamNames: ["actionApiName"],
      inputRepresentation: "performQuickActionInput",
      method: "POST"
    },
    "ActionsController.getQuickActionDefaults": {
      urlPath: prefix + "/ui-api/actions/record-defaults/${actionApiName}",
      urlPathParamNames: ["actionApiName"],
      method: "GET"
    },
    "ActionsController.getRecordEditActions": {
      urlPath: prefix + "/ui-api/actions/record/${recordIds}/record-edit",
      urlPathParamNames: ["recordIds"],
      method: "GET"
    },
    "ActionsController.getRecordActions": {
      urlPath: prefix + "/ui-api/actions/record/${recordIds}",
      urlPathParamNames: ["recordIds"],
      method: "GET"
    },
    "ActionsController.getRelatedListsActions": {
      urlPath: prefix + "/ui-api/actions/record/${recordIds}/related-list/batch/${relatedListIds}",
      urlPathParamNames: ["recordIds", "relatedListIds"],
      method: "GET"
    },
    "ActionsController.postRelatedListsActions": {
      urlPath: prefix + "/ui-api/actions/record/${recordIds}/related-list/batch",
      urlPathParamNames: ["recordIds"],
      inputRepresentation: "listRecordActionsQuery",
      method: "POST"
    },
    "ActionsController.getRelatedListRecordActions": {
      urlPath: prefix + "/ui-api/actions/record/${recordIds}/related-list-record/${relatedListRecordIds}",
      urlPathParamNames: ["recordIds", "relatedListRecordIds"],
      method: "GET"
    },
    "ActionsController.getRelatedListActions": {
      urlPath: prefix + "/ui-api/actions/record/${recordIds}/related-list/${relatedListId}",
      urlPathParamNames: ["recordIds", "relatedListId"],
      method: "GET"
    },
    "ActionsController.postRelatedListActions": {
      urlPath: prefix + "/ui-api/actions/record/${recordIds}/related-list/${relatedListId}",
      urlPathParamNames: ["recordIds", "relatedListId"],
      inputRepresentation: "listRecordActionsQuery",
      method: "POST"
    },
    "AppsController.getAppByID": {
      urlPath: prefix + "/ui-api/apps/${appId}",
      urlPathParamNames: ["appId"],
      method: "GET"
    },
    "AppsController.getAccessibleApps": {
      urlPath: prefix + "/ui-api/apps",
      urlPathParamNames: [],
      method: "GET"
    },
    "AppsController.getNavItems": {
      urlPath: prefix + "/ui-api/nav-items",
      urlPathParamNames: [],
      method: "GET"
    },
    "ListUiController.getListsByObjectName": {
      urlPath: prefix + "/ui-api/list-ui/${objectApiName}",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "ListUiController.getListInfosById": {
      urlPath: prefix + "/ui-api/list-info/batch",
      urlPathParamNames: [],
      method: "GET"
    },
    "ListUiController.getListInfosByName": {
      urlPath: prefix + "/ui-api/list-info/batch",
      urlPathParamNames: [],
      method: "GET"
    },
    "ListUiController.getListInfoById": {
      urlPath: prefix + "/ui-api/list-info/${listViewId}",
      urlPathParamNames: ["listViewId"],
      method: "GET"
    },
    "ListUiController.getListInfoByName": {
      urlPath: prefix + "/ui-api/list-info/${objectApiName}/${listViewApiName}",
      urlPathParamNames: ["listViewApiName", "objectApiName"],
      method: "GET"
    },
    "ListUiController.getListRecordsById": {
      urlPath: prefix + "/ui-api/list-records/${listViewId}",
      urlPathParamNames: ["listViewId"],
      method: "GET"
    },
    "ListUiController.getListRecordsByName": {
      urlPath: prefix + "/ui-api/list-records/${objectApiName}/${listViewApiName}",
      urlPathParamNames: ["listViewApiName", "objectApiName"],
      method: "GET"
    },
    "ListUiController.getListUiById": {
      urlPath: prefix + "/ui-api/list-ui/${listViewId}",
      urlPathParamNames: ["listViewId"],
      method: "GET"
    },
    "ListUiController.getListUiByName": {
      urlPath: prefix + "/ui-api/list-ui/${objectApiName}/${listViewApiName}",
      urlPathParamNames: ["listViewApiName", "objectApiName"],
      method: "GET"
    },
    "MruListUiController.getMruListInfo": {
      urlPath: prefix + "/ui-api/mru-list-info/${objectApiName}",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "MruListUiController.getMruListRecords": {
      urlPath: prefix + "/ui-api/mru-list-records/${objectApiName}",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "MruListUiController.getMruListUi": {
      urlPath: prefix + "/ui-api/mru-list-ui/${objectApiName}",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "RecordUiController.getAggregateUi": {
      urlPath: prefix + "/ui-api/aggregate-ui",
      urlPathParamNames: [],
      method: "GET"
    },
    "RecordUiController.executeAggregateUi": {
      urlPath: prefix + "/ui-api/aggregate-ui",
      urlPathParamNames: [],
      inputRepresentation: "input",
      method: "POST"
    },
    "RecordUiController.getRecordsWithFields": {
      urlPath: prefix + "/ui-api/records/batch/${recordIds}",
      urlPathParamNames: ["recordIds"],
      method: "GET"
    },
    "RecordUiController.getRecordsWithLayouts": {
      urlPath: prefix + "/ui-api/records/batch/${recordIds}",
      urlPathParamNames: ["recordIds"],
      method: "GET"
    },
    "RecordUiController.getDedupeConfig": {
      urlPath: prefix + "/ui-api/duplicates/${objectApiName}",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "RecordUiController.getDuplicateConfig": {
      urlPath: prefix + "/ui-api/duplicates/${objectApiName}",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "RecordUiController.getFormByName": {
      urlPath: prefix + "/ui-api/forms/${apiName}",
      urlPathParamNames: ["apiName"],
      method: "GET"
    },
    "RecordUiController.executeBatchGraphQL": {
      urlPath: prefix + "/graphql/batch",
      urlPathParamNames: [],
      inputRepresentation: "QUERY_INPUT_PARAMETER",
      method: "POST"
    },
    "RecordUiController.executeGraphQL": {
      urlPath: prefix + "/graphql",
      urlPathParamNames: [],
      inputRepresentation: "queryInput",
      method: "POST"
    },
    "RecordUiController.getLayout": {
      urlPath: prefix + "/ui-api/layout/${objectApiName}",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "RecordUiController.getLayoutUserState": {
      urlPath: prefix + "/ui-api/layout/${objectApiName}/user-state",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "RecordUiController.updateLayoutUserState": {
      urlPath: prefix + "/ui-api/layout/${objectApiName}/user-state",
      urlPathParamNames: ["objectApiName"],
      inputRepresentation: "userState",
      method: "PATCH"
    },
    "RecordUiController.getObjectInfos": {
      urlPath: prefix + "/ui-api/object-info/batch/${objectApiNames}",
      urlPathParamNames: ["objectApiNames"],
      method: "GET"
    },
    "RecordUiController.getObjectInfo": {
      urlPath: prefix + "/ui-api/object-info/${objectApiName}",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "RecordUiController.getPicklistValuesByRecordType": {
      urlPath: prefix + "/ui-api/object-info/${objectApiName}/picklist-values/${recordTypeId}",
      urlPathParamNames: ["objectApiName", "recordTypeId"],
      method: "GET"
    },
    "RecordUiController.getPicklistValues": {
      urlPath: prefix + "/ui-api/object-info/${objectApiName}/picklist-values/${recordTypeId}/${fieldApiName}",
      urlPathParamNames: ["fieldApiName", "objectApiName", "recordTypeId"],
      method: "GET"
    },
    "RecordUiController.findDuplicates": {
      urlPath: prefix + "/ui-api/predupe",
      urlPathParamNames: [],
      inputRepresentation: "recordInput",
      method: "POST"
    },
    "RecordUiController.postRecordAvatarAssociation": {
      urlPath: prefix + "/ui-api/record-avatars/${recordId}/association",
      urlPathParamNames: ["recordId"],
      inputRepresentation: "input",
      method: "POST"
    },
    "RecordUiController.getRecordAvatars": {
      urlPath: prefix + "/ui-api/record-avatars/batch/${recordIds}",
      urlPathParamNames: ["recordIds"],
      method: "GET"
    },
    "RecordUiController.getRecordCloneDefaults": {
      urlPath: prefix + "/ui-api/record-defaults/clone/${recordId}",
      urlPathParamNames: ["recordId"],
      method: "GET"
    },
    "RecordUiController.getRecordCreateDefaults": {
      urlPath: prefix + "/ui-api/record-defaults/create/${objectApiName}",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "RecordUiController.createRecord": {
      urlPath: prefix + "/ui-api/records",
      urlPathParamNames: [],
      inputRepresentation: "recordInput",
      method: "POST"
    },
    "RecordUiController.deleteRecord": {
      urlPath: prefix + "/ui-api/records/${recordId}",
      urlPathParamNames: ["recordId"],
      method: "DELETE"
    },
    "RecordUiController.getRecordWithFields": {
      urlPath: prefix + "/ui-api/records/${recordId}",
      urlPathParamNames: ["recordId"],
      method: "GET"
    },
    "RecordUiController.getRecordWithLayouts": {
      urlPath: prefix + "/ui-api/records/${recordId}",
      urlPathParamNames: ["recordId"],
      method: "GET"
    },
    "RecordUiController.updateRecord": {
      urlPath: prefix + "/ui-api/records/${recordId}",
      urlPathParamNames: ["recordId"],
      inputRepresentation: "recordInput",
      method: "PATCH"
    },
    "RecordUiController.getRecordDefaultsTemplateClone": {
      urlPath: prefix + "/ui-api/record-defaults/template/clone/${recordId}",
      urlPathParamNames: ["recordId"],
      method: "GET"
    },
    "RecordUiController.getRecordDefaultsTemplateForCreate": {
      urlPath: prefix + "/ui-api/record-defaults/template/create/${objectApiName}",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "RecordUiController.getRecordUis": {
      urlPath: prefix + "/ui-api/record-ui/${recordIds}",
      urlPathParamNames: ["recordIds"],
      method: "GET"
    },
    "RecordUiController.getValidationRulesInfo": {
      urlPath: prefix + "/ui-api/object-info/${objectApiName}/validation-rules-info",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "RelatedListUiController.getRelatedListInfoBatch": {
      urlPath: prefix + "/ui-api/related-list-info/batch/${parentObjectApiName}/${relatedListNames}",
      urlPathParamNames: ["parentObjectApiName", "relatedListNames"],
      method: "GET"
    },
    "RelatedListUiController.getRelatedListInfoCollection": {
      urlPath: prefix + "/ui-api/related-list-info/${parentObjectApiName}",
      urlPathParamNames: ["parentObjectApiName"],
      method: "GET"
    },
    "RelatedListUiController.getRelatedListInfo": {
      urlPath: prefix + "/ui-api/related-list-info/${parentRecordId}/${relatedListId}",
      urlPathParamNames: ["parentRecordId", "relatedListId"],
      method: "GET"
    },
    "RelatedListUiController.getRelatedListInfoByApiName": {
      urlPath: prefix + "/ui-api/related-list-info/${parentObjectApiName}/${relatedListId}",
      urlPathParamNames: ["parentObjectApiName", "relatedListId"],
      method: "GET"
    },
    "RelatedListUiController.updateRelatedListInfoByApiName": {
      urlPath: prefix + "/ui-api/related-list-info/${parentObjectApiName}/${relatedListId}",
      urlPathParamNames: ["parentObjectApiName", "relatedListId"],
      inputRepresentation: "relatedListInfoInput",
      method: "PATCH"
    },
    "RelatedListUiController.getRelatedListPreferencesBatch": {
      urlPath: prefix + "/ui-api/related-list-preferences/batch/${preferencesIds}",
      urlPathParamNames: ["preferencesIds"],
      method: "GET"
    },
    "RelatedListUiController.getRelatedListPreferences": {
      urlPath: prefix + "/ui-api/related-list-preferences/${preferencesId}",
      urlPathParamNames: ["preferencesId"],
      method: "GET"
    },
    "RelatedListUiController.updateRelatedListPreferences": {
      urlPath: prefix + "/ui-api/related-list-preferences/${preferencesId}",
      urlPathParamNames: ["preferencesId"],
      inputRepresentation: "relatedListUserPreferencesInput",
      method: "PATCH"
    },
    "RelatedListUiController.getRelatedListsRecordCount": {
      urlPath: prefix + "/ui-api/related-list-count/batch/${parentRecordId}/${relatedListNames}",
      urlPathParamNames: ["parentRecordId", "relatedListNames"],
      method: "GET"
    },
    "RelatedListUiController.getRelatedListRecordCount": {
      urlPath: prefix + "/ui-api/related-list-count/${parentRecordId}/${relatedListId}",
      urlPathParamNames: ["parentRecordId", "relatedListId"],
      method: "GET"
    },
    "RelatedListUiController.getRelatedListRecordsBatch": {
      urlPath: prefix + "/ui-api/related-list-records/batch/${parentRecordId}/${relatedListIds}",
      urlPathParamNames: ["parentRecordId", "relatedListIds"],
      method: "GET"
    },
    "RelatedListUiController.postRelatedListRecordsBatch": {
      urlPath: prefix + "/ui-api/related-list-records/batch/${parentRecordId}",
      urlPathParamNames: ["parentRecordId"],
      inputRepresentation: "listRecordsQuery",
      method: "POST"
    },
    "RelatedListUiController.getRelatedListRecords": {
      urlPath: prefix + "/ui-api/related-list-records/${parentRecordId}/${relatedListId}",
      urlPathParamNames: ["parentRecordId", "relatedListId"],
      method: "GET"
    },
    "RelatedListUiController.postRelatedListRecords": {
      urlPath: prefix + "/ui-api/related-list-records/${parentRecordId}/${relatedListId}",
      urlPathParamNames: ["parentRecordId", "relatedListId"],
      inputRepresentation: "listRecordsQuery",
      method: "POST"
    },
    "SearchUiController.searchResultsKeyword": {
      urlPath: prefix + "/ui-api/search/results/keyword",
      urlPathParamNames: [],
      inputRepresentation: "options",
      method: "POST"
    },
    "SearchUiController.getSearchFilterMetadata": {
      urlPath: prefix + "/ui-api/search-info/${objectApiName}/filters",
      urlPathParamNames: ["objectApiName"],
      method: "GET"
    },
    "SearchUiController.getFilterOptions": {
      urlPath: prefix + "/ui-api/search-info/${objectApiName}/filters/${filterApiName}/options",
      urlPathParamNames: ["filterApiName", "objectApiName"],
      method: "GET"
    },
    "SearchUiController.searchResults": {
      urlPath: prefix + "/ui-api/search/results",
      urlPathParamNames: [],
      inputRepresentation: "options",
      method: "POST"
    },
    "LookupController.getLookupMetadata": {
      urlPath: prefix + "/ui-api/search-info/${objectApiName}/lookup/${fieldApiName}",
      urlPathParamNames: ["fieldApiName", "objectApiName"],
      method: "GET"
    },
    "LookupController.getLookupRecords": {
      urlPath: prefix + "/ui-api/lookups/${objectApiName}/${fieldApiName}",
      urlPathParamNames: ["fieldApiName", "objectApiName"],
      method: "GET"
    }
  };
  function getResourceReferenceFromAuraMethod(auraMethod) {
    return auraMethodToResourceReferenceMapping[auraMethod];
  }
  function sendClientErrorToServer(payload) {
    _1_66_319244_0$1.sendBeacon({
      path: ERRORS_PATH_PREFIX,
      payload: JSON.stringify(payload),
      contentType: "text/plain;charset=UTF-8"
    });
  }
  function dispatchClientError(error2, type) {
    document.dispatchEvent(new CustomEvent("client-error", {
      detail: {
        error: error2,
        type
      }
    }));
  }
  function reportError({
    subject,
    error: error2,
    wcstack,
    type = CLIENT_ERROR_TYPES.UNKNOWN_ERROR
  }) {
    wcstack = wcstack || error2.wcstack;
    const {
      message,
      stack
    } = error2;
    const {
      hostname,
      pathname
    } = globalThis.location || {};
    const location = {
      hostname,
      pathname
    };
    const payload = {
      subject,
      message,
      stack,
      wcstack,
      location
    };
    logError(stack || payload);
    if (typeof document !== "undefined") {
      dispatchClientError(payload, type);
      sendClientErrorToServer(payload);
    }
  }
  function ownKeys$6(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$6(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty$6(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$6(obj, key, value) {
    key = _toPropertyKey$6(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$6(arg) {
    var key = _toPrimitive$6(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$6(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  async function apiCallRawResponse(endpoint, params) {
    const [controller, action] = endpoint.split(".");
    if (controller === "ApexActionController") {
      return handleApexAction(action, params);
    }
    const uiApiReference = getResourceReferenceFromAuraMethod(endpoint);
    if (uiApiReference) {
      return handleUiApiCall(uiApiReference, params);
    }
    throw new Error(`Unsupported controller action: ${controller}.${action}`);
  }
  async function handleUiApiCall({
    urlPath,
    urlPathParamNames,
    method,
    inputRepresentation
  }, params) {
    const remainingParams = params && _objectSpread$6({}, params) || {};
    let path = urlPathParamNames.reduce((currentPath, paramName) => {
      const value = remainingParams[paramName];
      delete remainingParams[paramName];
      return currentPath.replace(`\${${paramName}}`, encodeURIComponent(value));
    }, urlPath);
    let body;
    if ((method === "POST" || method === "PATCH") && remainingParams[inputRepresentation]) {
      body = JSON.stringify(remainingParams[inputRepresentation]);
      delete remainingParams[inputRepresentation];
    }
    if (Object.keys(remainingParams).length) {
      path += `?${Object.entries(remainingParams).filter(([, val]) => {
        return val !== void 0 && val !== null && (!Array.isArray(val) || val.length);
      }).map(([key, val]) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join("&")}`;
    }
    const response = await _1_66_319244_0$1.fetch(path, {
      method,
      body
    });
    let data;
    if (response.status === 401) {
      handleTimeoutNavigation();
    }
    if (response.status !== 204) {
      data = await response.json();
    }
    if (data instanceof Array) {
      data = data[0];
    }
    if (!response.ok) {
      const error2 = {
        status: response.status,
        data: _objectSpread$6(_objectSpread$6({}, data), {}, {
          statusCode: response.status
        })
      };
      throw convertResponseToAuraActionErrorObject([error2]);
    }
    return convertResponseToAuraActionObject(data);
  }
  async function handleApexAction(action, params) {
    if (action === "execute") {
      const {
        url,
        httpRequestOptions
      } = formatApexRequest(action, params);
      return _1_66_319244_0$1.fetch(url, httpRequestOptions).then((response) => {
        if (response.status === 401) {
          handleTimeoutNavigation();
        }
        return response.status !== 204 ? response.json() : void 0;
      }).then((response) => {
        if (response && response.error && response.error.length > 0) {
          throw convertResponseToAuraActionErrorObject(response.error);
        }
        return convertResponseToAuraActionObject(response);
      });
    }
    throw new Error(`Unsupported Apex action: ${action}`);
  }
  function formatApexRequest(action, params) {
    if (!params || typeof params !== "object" || Object.keys(params).length === 0) {
      reportError({
        subject: "Apex API action error - invalid params",
        type: CLIENT_ERROR_TYPES.APEX_ACTION_ERROR,
        error: new Error(`Apex ${action} action called with invalid params: '${JSON.stringify(params)}'.`)
      });
    }
    if (params && params.cacheable === true) {
      const url = `/apex/${action}?${getApexQueryParams(params)}`;
      if (url.length <= MAX_URL_LENGTH) {
        return {
          url,
          httpRequestOptions: {
            method: "GET",
            basePath: apexApiBasePath__default["default"]
          }
        };
      }
    }
    return {
      url: `/apex/${action}`,
      httpRequestOptions: {
        method: "POST",
        body: JSON.stringify(params),
        basePath: apexApiBasePath__default["default"]
      }
    };
  }
  function getApexQueryParams(apexActionParams) {
    const cloneApexActionParams = _objectSpread$6({}, apexActionParams);
    const methodArguments = cloneApexActionParams.params;
    if (methodArguments && typeof methodArguments === "object") {
      const orderedParams = Object.keys(methodArguments).sort().reduce((obj, key) => {
        obj[key] = methodArguments[key];
        return obj;
      }, {});
      cloneApexActionParams.params = JSON.stringify(orderedParams);
    }
    return Object.keys(cloneApexActionParams).filter((key) => cloneApexActionParams[key] !== void 0 && cloneApexActionParams[key] != null).sort().map((key) => `${key}=${encodeURIComponent(cloneApexActionParams[key])}`).join("&");
  }
  function handleTimeoutNavigation() {
    SessionTimeoutOverrides.runSync();
  }
  function convertResponseToAuraActionObject(data) {
    return {
      getReturnValue: () => {
        return data;
      }
    };
  }
  function convertResponseToAuraActionErrorObject(errors) {
    return {
      getError: () => {
        return errors;
      }
    };
  }
  const createComponent = null;
  const renderComponent = null;
  const getDefinition = null;
  var webruntimeAura = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    createComponent,
    executeGlobalControllerRawResponse: apiCallRawResponse,
    getDefinition,
    logger,
    renderComponent
  });
  function isUndefined(obj) {
    return obj === void 0;
  }
  const ValueChangedEventType = "ValueChangedEvent";
  class ValueChangedEvent {
    constructor(value) {
      this.type = ValueChangedEventType;
      this.value = value;
    }
  }
  const {
    freeze: freeze$1,
    defineProperty,
    isExtensible
  } = Object;
  const DeprecatedWiredElementHost = "$$DeprecatedWiredElementHostKey$$";
  const DeprecatedWiredParamsMeta = "$$DeprecatedWiredParamsMetaKey$$";
  function register(adapterId, adapterEventTargetCallback) {
    if (adapterId == null || !isExtensible(adapterId)) {
      throw new TypeError("adapter id must be extensible");
    }
    if (typeof adapterEventTargetCallback !== "function") {
      throw new TypeError("adapter factory must be a callable");
    }
    if ("adapter" in adapterId) {
      throw new TypeError("adapter id is already associated to an adapter factory");
    }
    const AdapterClass = class extends LegacyWireAdapterBridge {
      constructor(dataCallback) {
        super(dataCallback);
        adapterEventTargetCallback(this.eventTarget);
      }
    };
    freeze$1(AdapterClass);
    freeze$1(AdapterClass.prototype);
    defineProperty(adapterId, "adapter", {
      writable: false,
      configurable: false,
      value: AdapterClass
    });
  }
  function registerWireService() {
  }
  const {
    forEach,
    splice: ArraySplice,
    indexOf: ArrayIndexOf
  } = Array.prototype;
  const CONNECT = "connect";
  const DISCONNECT = "disconnect";
  const CONFIG = "config";
  function removeListener(listeners, toRemove) {
    const idx = ArrayIndexOf.call(listeners, toRemove);
    if (idx > -1) {
      ArraySplice.call(listeners, idx, 1);
    }
  }
  function isEmptyConfig(config2) {
    return Object.keys(config2).length === 0;
  }
  function isValidConfig(config2, params) {
    return params.length === 0 || params.some((param) => !isUndefined(config2[param]));
  }
  function isDifferentConfig(newConfig, oldConfig, params) {
    return params.some((param) => newConfig[param] !== oldConfig[param]);
  }
  class LegacyWireAdapterBridge {
    constructor(callback) {
      this.connecting = [];
      this.disconnecting = [];
      this.configuring = [];
      this.isFirstUpdate = true;
      this.callback = callback;
      this.wiredElementHost = callback[DeprecatedWiredElementHost];
      this.dynamicParamsNames = callback[DeprecatedWiredParamsMeta];
      this.eventTarget = {
        addEventListener: (type, listener) => {
          switch (type) {
            case CONNECT: {
              this.connecting.push(listener);
              break;
            }
            case DISCONNECT: {
              this.disconnecting.push(listener);
              break;
            }
            case CONFIG: {
              this.configuring.push(listener);
              if (this.currentConfig !== void 0) {
                listener.call(void 0, this.currentConfig);
              }
              break;
            }
            default:
              throw new Error(`Invalid event type ${type}.`);
          }
        },
        removeEventListener: (type, listener) => {
          switch (type) {
            case CONNECT: {
              removeListener(this.connecting, listener);
              break;
            }
            case DISCONNECT: {
              removeListener(this.disconnecting, listener);
              break;
            }
            case CONFIG: {
              removeListener(this.configuring, listener);
              break;
            }
            default:
              throw new Error(`Invalid event type ${type}.`);
          }
        },
        dispatchEvent: (evt) => {
          if (evt instanceof ValueChangedEvent) {
            const value = evt.value;
            this.callback(value);
          } else if (evt.type === "wirecontextevent") {
            return this.wiredElementHost.dispatchEvent(evt);
          } else {
            throw new Error(`Invalid event type ${evt.type}.`);
          }
          return false;
        }
      };
    }
    update(config2) {
      if (this.isFirstUpdate) {
        this.isFirstUpdate = false;
        if (!isEmptyConfig(config2) && !isValidConfig(config2, this.dynamicParamsNames)) {
          return;
        }
      }
      if (isUndefined(this.currentConfig) || isDifferentConfig(config2, this.currentConfig, this.dynamicParamsNames)) {
        this.currentConfig = config2;
        forEach.call(this.configuring, (listener) => {
          listener.call(void 0, config2);
        });
      }
    }
    connect() {
      forEach.call(this.connecting, (listener) => listener.call(void 0));
    }
    disconnect() {
      forEach.call(this.disconnecting, (listener) => listener.call(void 0));
    }
  }
  var wireService = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ValueChangedEvent,
    register,
    registerWireService
  });
  const stc0$8 = {
    hidden: ""
  };
  const stc1$4 = {
    lwc: {
      dom: "manual"
    }
  };
  function tmpl$9($api, $cmp, $slotset, $ctx) {
    const {shc: api_sanitize_html_content, h: api_element} = $api;
    return [api_element("div", {
      attrs: stc0$8,
      props: {
        innerHTML: $ctx._rawHtml$0 !== ($ctx._rawHtml$0 = $cmp.scriptElement) ? $ctx._sanitizedHtml$0 = api_sanitize_html_content($cmp.scriptElement) : $ctx._sanitizedHtml$0
      },
      context: stc1$4,
      key: 0
    })];
  }
  var _tmpl$9 = _2_41_4.registerTemplate(tmpl$9);
  tmpl$9.stylesheets = [];
  tmpl$9.renderMode = "light";
  tmpl$9.stylesheetToken = "experience-dataLayerObject_dataLayerObject";
  _2_41_4.freezeTemplate(tmpl$9);
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze, seal = Object.seal, create = Object.create;
  var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
  if (!apply) {
    apply = function apply2(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }
  if (!freeze) {
    freeze = function freeze2(x2) {
      return x2;
    };
  }
  if (!seal) {
    seal = function seal2(x2) {
      return x2;
    };
  }
  if (!construct) {
    construct = function construct2(Func, args) {
      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
    };
  }
  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);
  var regExpTest = unapply(RegExp.prototype.test);
  var typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return apply(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return construct(func, args);
    };
  }
  function addToSet(set2, array) {
    if (setPrototypeOf) {
      setPrototypeOf(set2, null);
    }
    var l2 = array.length;
    while (l2--) {
      var element = array[l2];
      if (typeof element === "string") {
        var lcElement = stringToLowerCase(element);
        if (lcElement !== element) {
          if (!isFrozen(array)) {
            array[l2] = lcElement;
          }
          element = lcElement;
        }
      }
      set2[element] = true;
    }
    return set2;
  }
  function clone(object) {
    var newObject = create(null);
    var property = void 0;
    for (property in object) {
      if (apply(hasOwnProperty, object, [property])) {
        newObject[property] = object[property];
      }
    }
    return newObject;
  }
  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object = getPrototypeOf(object);
    }
    return null;
  }
  var html = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  var svg = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  var mathMl = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
  var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  var text = freeze(["#text"]);
  var html$1 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns"]);
  var svg$1 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  var mathMl$1 = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);
  var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  function _toConsumableArray$1(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  var getGlobal = function getGlobal2() {
    return typeof window === "undefined" ? null : window;
  };
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
    if ((typeof trustedTypes === "undefined" ? "undefined" : _typeof(trustedTypes)) !== "object" || typeof trustedTypes.createPolicy !== "function") {
      return null;
    }
    var suffix = null;
    var ATTR_NAME = "data-tt-policy-suffix";
    if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document2.currentScript.getAttribute(ATTR_NAME);
    }
    var policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html$$1) {
          return html$$1;
        }
      });
    } catch (_) {
      console.warn("TrustedTypes policy " + policyName + " could not be created.");
      return null;
    }
  };
  function createDOMPurify() {
    var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    var DOMPurify = function DOMPurify2(root) {
      return createDOMPurify(root);
    };
    DOMPurify.version = "2.2.6";
    DOMPurify.removed = [];
    if (!window2 || !window2.document || window2.document.nodeType !== 9) {
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    var originalDocument = window2.document;
    var document2 = window2.document;
    var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node2 = window2.Node, Element2 = window2.Element, NodeFilter2 = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, Text = window2.Text, Comment = window2.Comment, DOMParser = window2.DOMParser, trustedTypes = window2.trustedTypes;
    var ElementPrototype = Element2.prototype;
    var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    var getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement === "function") {
      var template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML("") : "";
    var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, getElementsByTagName = _document.getElementsByTagName, createDocumentFragment = _document.createDocumentFragment;
    var importNode = originalDocument.importNode;
    var documentMode = {};
    try {
      documentMode = clone(document2).documentMode ? document2.documentMode : {};
    } catch (_) {
    }
    var hooks = {};
    DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
    var ALLOWED_TAGS2 = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));
    var ALLOWED_ATTR2 = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));
    var FORBID_TAGS = null;
    var FORBID_ATTR = null;
    var ALLOW_ARIA_ATTR = true;
    var ALLOW_DATA_ATTR = true;
    var ALLOW_UNKNOWN_PROTOCOLS = false;
    var SAFE_FOR_TEMPLATES = false;
    var WHOLE_DOCUMENT = false;
    var SET_CONFIG = false;
    var FORCE_BODY = false;
    var RETURN_DOM = false;
    var RETURN_DOM_FRAGMENT = false;
    var RETURN_DOM_IMPORT = true;
    var RETURN_TRUSTED_TYPE = false;
    var SANITIZE_DOM = true;
    var KEEP_CONTENT = true;
    var IN_PLACE = false;
    var USE_PROFILES = {};
    var FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "summary", "title", "value", "style", "xmlns"]);
    var CONFIG2 = null;
    var formElement = document2.createElement("form");
    var _parseConfig = function _parseConfig2(cfg) {
      if (CONFIG2 && CONFIG2 === cfg) {
        return;
      }
      if (!cfg || (typeof cfg === "undefined" ? "undefined" : _typeof(cfg)) !== "object") {
        cfg = {};
      }
      cfg = clone(cfg);
      ALLOWED_TAGS2 = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR2 = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
      FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
      FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
      USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS2 = addToSet({}, [].concat(_toConsumableArray$1(text)));
        ALLOWED_ATTR2 = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS2, html);
          addToSet(ALLOWED_ATTR2, html$1);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS2, svg);
          addToSet(ALLOWED_ATTR2, svg$1);
          addToSet(ALLOWED_ATTR2, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS2, svgFilters);
          addToSet(ALLOWED_ATTR2, svg$1);
          addToSet(ALLOWED_ATTR2, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS2, mathMl);
          addToSet(ALLOWED_ATTR2, mathMl$1);
          addToSet(ALLOWED_ATTR2, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS2 === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS2 = clone(ALLOWED_TAGS2);
        }
        addToSet(ALLOWED_TAGS2, cfg.ADD_TAGS);
      }
      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR2 === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR2 = clone(ALLOWED_ATTR2);
        }
        addToSet(ALLOWED_ATTR2, cfg.ADD_ATTR);
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS2["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS2, ["html", "head", "body"]);
      }
      if (ALLOWED_TAGS2.table) {
        addToSet(ALLOWED_TAGS2, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG2 = cfg;
    };
    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
    var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
    var ALL_SVG_TAGS = addToSet({}, svg);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);
    var ALL_MATHML_TAGS = addToSet({}, mathMl);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
    var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    var _checkValidNamespace = function _checkValidNamespace2(element) {
      var parent = getParentNode(element);
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: HTML_NAMESPACE,
          tagName: "template"
        };
      }
      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);
      if (element.namespaceURI === SVG_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        var commonSvgAndHTMLElements = addToSet({}, ["title", "style", "font", "a", "script"]);
        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      return false;
    };
    var _forceRemove = function _forceRemove2(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });
      try {
        node.parentNode.removeChild(node);
      } catch (_) {
        try {
          node.outerHTML = emptyHTML;
        } catch (_2) {
          node.remove();
        }
      }
    };
    var _removeAttribute = function _removeAttribute2(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }
      node.removeAttribute(name);
    };
    var _initDocument = function _initDocument2(dirty) {
      var doc = void 0;
      var leadingWhitespace = void 0;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, "text/html");
      } catch (_) {
      }
      if (!doc || !doc.documentElement) {
        doc = implementation.createHTMLDocument("");
        var _doc = doc, body = _doc.body;
        body.parentNode.removeChild(body.parentNode.firstElementChild);
        body.outerHTML = dirtyPayload;
      }
      if (dirty && leadingWhitespace) {
        doc.body.insertBefore(document2.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);
      }
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    };
    var _createIterator = function _createIterator2(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter2.SHOW_ELEMENT | NodeFilter2.SHOW_COMMENT | NodeFilter2.SHOW_TEXT, function() {
        return NodeFilter2.FILTER_ACCEPT;
      }, false);
    };
    var _isClobbered = function _isClobbered2(elm) {
      if (elm instanceof Text || elm instanceof Comment) {
        return false;
      }
      if (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function") {
        return true;
      }
      return false;
    };
    var _isNode = function _isNode2(object) {
      return (typeof Node2 === "undefined" ? "undefined" : _typeof(Node2)) === "object" ? object instanceof Node2 : object && (typeof object === "undefined" ? "undefined" : _typeof(object)) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
    };
    var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }
      arrayForEach(hooks[entryPoint], function(hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG2);
      });
    };
    var _sanitizeElements = function _sanitizeElements2(currentNode) {
      var content = void 0;
      _executeHook("beforeSanitizeElements", currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
        _forceRemove(currentNode);
        return true;
      }
      var tagName = stringToLowerCase(currentNode.nodeName);
      _executeHook("uponSanitizeElement", currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS2
      });
      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!ALLOWED_TAGS2[tagName] || FORBID_TAGS[tagName]) {
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode);
          var childNodes = getChildNodes(currentNode);
          var childCount = childNodes.length;
          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$$1, " ");
        content = stringReplace(content, ERB_EXPR$$1, " ");
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      _executeHook("afterSanitizeElements", currentNode, null);
      return false;
    };
    var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName))
        ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName))
        ;
      else if (!ALLOWED_ATTR2[lcName] || FORBID_ATTR[lcName]) {
        return false;
      } else if (URI_SAFE_ATTRIBUTES[lcName])
        ;
      else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
        ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
        ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
        ;
      else if (!value)
        ;
      else {
        return false;
      }
      return true;
    };
    var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
      var attr = void 0;
      var value = void 0;
      var lcName = void 0;
      var l2 = void 0;
      _executeHook("beforeSanitizeAttributes", currentNode, null);
      var attributes = currentNode.attributes;
      if (!attributes) {
        return;
      }
      var hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR2
      };
      l2 = attributes.length;
      while (l2--) {
        attr = attributes[l2];
        var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
        value = stringTrim(attr.value);
        lcName = stringToLowerCase(name);
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
        value = hookEvent.attrValue;
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        _removeAttribute(name, currentNode);
        if (!hookEvent.keepAttr) {
          continue;
        }
        if (regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$$1, " ");
          value = stringReplace(value, ERB_EXPR$$1, " ");
        }
        var lcTag = currentNode.nodeName.toLowerCase();
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            currentNode.setAttribute(name, value);
          }
          arrayPop(DOMPurify.removed);
        } catch (_) {
        }
      }
      _executeHook("afterSanitizeAttributes", currentNode, null);
    };
    var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      var shadowNode = void 0;
      var shadowIterator = _createIterator(fragment);
      _executeHook("beforeSanitizeShadowDOM", fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHook("uponSanitizeShadowNode", shadowNode, null);
        if (_sanitizeElements(shadowNode)) {
          continue;
        }
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
        _sanitizeAttributes(shadowNode);
      }
      _executeHook("afterSanitizeShadowDOM", fragment, null);
    };
    DOMPurify.sanitize = function(dirty, cfg) {
      var body = void 0;
      var importedNode = void 0;
      var currentNode = void 0;
      var oldNode = void 0;
      var returnNode = void 0;
      if (!dirty) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString !== "function") {
          throw typeErrorCreate("toString is not a function");
        } else {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        }
      }
      if (!DOMPurify.isSupported) {
        if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
          if (typeof dirty === "string") {
            return window2.toStaticHTML(dirty);
          }
          if (_isNode(dirty)) {
            return window2.toStaticHTML(dirty.outerHTML);
          }
        }
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE)
        ;
      else if (dirty instanceof Node2) {
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          body.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body = _initDocument(dirty);
        if (!body) {
          return RETURN_DOM ? null : emptyHTML;
        }
      }
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
      while (currentNode = nodeIterator.nextNode()) {
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }
        if (_sanitizeElements(currentNode)) {
          continue;
        }
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
        _sanitizeAttributes(currentNode);
        oldNode = currentNode;
      }
      oldNode = null;
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (RETURN_DOM_IMPORT) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, " ");
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, " ");
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function(cfg) {
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
      CONFIG2 = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag, attr, value) {
      if (!CONFIG2) {
        _parseConfig({});
      }
      var lcTag = stringToLowerCase(tag);
      var lcName = stringToLowerCase(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint) {
      if (hooks[entryPoint]) {
        arrayPop(hooks[entryPoint]);
      }
    };
    DOMPurify.removeHooks = function(entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };
    DOMPurify.removeAllHooks = function() {
      hooks = {};
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();
  var purify$1 = _2_41_4.registerComponent(purify, {
    tmpl: _tmpl$a,
    sel: "lightning-purifyLib"
  });
  function sanitizeHTML(dirty, config2) {
    return purify$1.sanitize(dirty, config2);
  }
  const ALLOWED_TAGS = [];
  const ALLOWED_ATTR = [];
  const richTextConfig = Object.freeze({
    ALLOWED_TAGS,
    ALLOWED_ATTR
  });
  function sanitizeDataLayerObject(html2) {
    const cleanedHTML = sanitizeHTML(html2, richTextConfig);
    return cleanedHTML;
  }
  class DataLayerObject extends _2_41_4.LightningElement {
    constructor(...args) {
      super(...args);
      this._scriptDataAttributes = {};
      this._catalogObjectId = void 0;
      this._catalogObjectType = void 0;
      this._catalogObjectAttributes = void 0;
      this._relatedCatalogObjects = void 0;
      this._customObject = void 0;
    }
    set scriptDataAttributes(scriptDataAttributes) {
      this._scriptDataAttributes = scriptDataAttributes;
    }
    get scriptDataAttributes() {
      return this._scriptDataAttributes;
    }
    set catalogObjectId(catalogObjectId) {
      this._catalogObjectId = catalogObjectId;
    }
    get catalogObjectId() {
      return this._catalogObjectId;
    }
    set catalogObjectType(catalogObjectType) {
      this._catalogObjectType = catalogObjectType;
    }
    get catalogObjectType() {
      return this._catalogObjectType;
    }
    set catalogObjectAttributes(catalogObjectAttributes) {
      this._catalogObjectAttributes = catalogObjectAttributes;
    }
    get catalogObjectAttributes() {
      return this._catalogObjectAttributes;
    }
    set relatedCatalogObjects(relatedCatalogObjects) {
      this._relatedCatalogObjects = relatedCatalogObjects;
    }
    get relatedCatalogObjects() {
      return this._relatedCatalogObjects;
    }
    set customObject(customObject) {
      this._customObject = customObject;
    }
    get customObject() {
      return this._customObject;
    }
    get scriptElement() {
      if (this.scriptDataAttributes?.providerType && (this.isCustomObject() || this.isCatalogObject())) {
        const dataProviderType = this.scriptDataAttributes?.providerType;
        return `<script type="application/json" data-provider-type=${dataProviderType}>${sanitizeDataLayerObject(this.scriptElementContent())}</script>`;
      }
      return ``;
    }
    scriptElementContent() {
      const renderedContent = this.isCustomObject() ? this.customObject : this.buildCatalogObject();
      return JSON.stringify(renderedContent);
    }
    isCustomObject() {
      return this.customObject ? true : false;
    }
    isCatalogObject() {
      return this.catalogObjectId && this.catalogObjectType ? true : false;
    }
    buildCatalogObject() {
      return {
        id: this.catalogObjectId,
        type: this.catalogObjectType,
        attributes: this.catalogObjectAttributes,
        relatedCatalogObjects: this.relatedCatalogObjects
      };
    }
  }
  DataLayerObject.renderMode = "light";
  _2_41_4.registerDecorators(DataLayerObject, {
    publicProps: {
      scriptDataAttributes: {
        config: 3
      },
      catalogObjectId: {
        config: 3
      },
      catalogObjectType: {
        config: 3
      },
      catalogObjectAttributes: {
        config: 3
      },
      relatedCatalogObjects: {
        config: 3
      },
      customObject: {
        config: 3
      },
      scriptElement: {
        config: 1
      }
    },
    fields: ["_scriptDataAttributes", "_catalogObjectId", "_catalogObjectType", "_catalogObjectAttributes", "_relatedCatalogObjects", "_customObject"]
  });
  var _experienceDataLayerObject = _2_41_4.registerComponent(DataLayerObject, {
    tmpl: _tmpl$9,
    sel: "experience-dataLayerObject"
  });
  const stc0$7 = [];
  function tmpl$8($api, $cmp, $slotset, $ctx) {
    return stc0$7;
  }
  var _tmpl$8 = _2_41_4.registerTemplate(tmpl$8);
  tmpl$8.stylesheets = [];
  tmpl$8.renderMode = "light";
  tmpl$8.stylesheetToken = "webruntime-innerApp_innerApp";
  _2_41_4.freezeTemplate(tmpl$8);
  function getViewModule(viewName) {
    return _0_9_0.load(viewName, "webruntime/app/v/1");
  }
  function isMobileApp() {
    const userAgent = globalThis.navigator?.userAgent;
    return userAgent && (isMobileAppMode__default["default"] && userAgent.includes(MOBILE_APP_USER_AGENTS.PUBLISHER) || userAgent.includes(MOBILE_APP_USER_AGENTS.PLAYGROUND));
  }
  function mobileEventsBridge() {
    registerEvents();
    subscribe(routeComplete);
  }
  function registerEvents() {
    document.addEventListener("notify-client-module", notifyClientModule);
  }
  function routeComplete(routeResult) {
    notifyMobileModule("navigationcompleted", {
      routeResult
    });
  }
  function notifyClientModule({
    detail
  }) {
    const {
      action,
      data
    } = detail;
    switch (action) {
      case "navigate":
        navigate(data.routeObj, data.replaceState);
        break;
      default:
        log(`No such action "${action}" exists.`);
        break;
    }
  }
  function notifyMobileModule(action, data) {
    document.dispatchEvent(new CustomEvent("notify-mobile-module", {
      bubbles: true,
      composed: true,
      detail: {
        action,
        data
      }
    }));
  }
  async function mobileModuleInit() {
    if (!isMobileApp()) {
      return;
    }
    const {
      hybridAppManager
    } = await _0_9_0.load("mobileruntime/hybridAppManager/v/1");
    hybridAppManager();
    mobileEventsBridge();
  }
  async function designmodeInit() {
    if (!isDesignMode__default["default"]) {
      return;
    }
    const {
      start
    } = await _0_9_0.load("webruntimedesign/designmode/v/1");
    if (/interactive|complete/.test(document.readyState)) {
      start();
    } else {
      document.addEventListener("DOMContentLoaded", start, false);
    }
  }
  function assert(condition, message) {
    if (true) {
      if (!condition) {
        throw new Error(message);
      }
    }
  }
  const ARIA_PROP_LIST = ["activeDescendant", "atomic", "autoComplete", "busy", "checked", "colCount", "colIndex", "colSpan", "controls", "current", "describedAt", "describedBy", "description", "details", "disabled", "dropEffect", "errorMessage", "expanded", "flowTo", "grabbed", "hasPopup", "hidden", "invalid", "keyShortcuts", "label", "labelledBy", "level", "live", "modal", "multiLine", "multiSelectable", "orientation", "owns", "placeholder", "posInSet", "pressed", "readOnly", "relevant", "required", "roleDescription", "rowCount", "rowIndex", "rowSpan", "selected", "setSize", "sort", "valueMax", "valueMin", "valueNow", "valueText"];
  const getAriaLookup = (list, type = "default") => {
    if (!list || list.length === 0) {
      throw new Error("List of aria properties is required");
    }
    const lookupObj = {};
    if (type === "default") {
      list.forEach((name) => {
        const nameUpperCase = name.toUpperCase();
        if (!lookupObj[nameUpperCase]) {
          lookupObj[nameUpperCase] = `aria-${name.toLowerCase()}`;
        }
      });
      return lookupObj;
    }
    list.forEach((name) => {
      const ariaPropertyLowerCase = `aria-${name.toLowerCase()}`;
      const ariaPropertyCamelCase = `aria${name.charAt(0).toUpperCase()}${name.slice(1)}`;
      if (!lookupObj[ariaPropertyLowerCase]) {
        lookupObj[ariaPropertyLowerCase] = ariaPropertyCamelCase;
      }
    });
    return lookupObj;
  };
  getAriaLookup(ARIA_PROP_LIST);
  getAriaLookup(ARIA_PROP_LIST, "cc");
  const isCSR = typeof window !== "undefined";
  function guid() {
    function s4() {
      return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
    }
    return s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
  }
  isCSR && isIE11Test(navigator);
  isCSR && isChromeTest(navigator);
  isCSR && isSafariTest(navigator);
  function isIE11Test(navigator2) {
    return /Trident.*rv[ :]*11\./.test(navigator2.userAgent);
  }
  function isChromeTest(navigator2) {
    return /Chrome/.test(navigator2.userAgent) && /Google Inc/.test(navigator2.vendor);
  }
  function isSafariTest(navigator2) {
    return /^((?!chrome|android).)*safari/i.test(navigator2.userAgent);
  }
  function normalizeString(value, config2 = {}) {
    const {
      fallbackValue = "",
      validValues,
      toLowerCase = true
    } = config2;
    let normalized = typeof value === "string" && value.trim() || "";
    normalized = toLowerCase ? normalized.toLowerCase() : normalized;
    if (validValues && validValues.indexOf(normalized) === -1) {
      normalized = fallbackValue;
    }
    return normalized;
  }
  function smartSetAttribute(element, attribute, value) {
    if (element.tagName.match(/^LIGHTNING/i)) {
      attribute = attribute.replace(/-\w/g, (m2) => m2[1].toUpperCase());
      element[attribute] = value ? value : null;
    } else if (value) {
      element.setAttribute(attribute, value);
    } else {
      element.removeAttribute(attribute);
    }
  }
  function synchronizeAttrs(element, values) {
    if (!element) {
      return;
    }
    const attributes = Object.keys(values);
    attributes.forEach((attribute) => {
      smartSetAttribute(element, attribute, values[attribute]);
    });
  }
  const DEFAULT_MODAL_ZINDEX = 9e3;
  const DEFAULT_ZINDEX_OFFSET = 100;
  const DEFAULT_ZINDEX_BASELINE = DEFAULT_MODAL_ZINDEX + DEFAULT_ZINDEX_OFFSET;
  function getZIndexBaseline() {
    const isCSR2 = typeof window !== "undefined";
    const modalZindexValueLwc = isCSR2 ? (window.getComputedStyle(document.documentElement) || document.documentElement.style).getPropertyValue("--lwc-zIndexModal") : DEFAULT_MODAL_ZINDEX;
    const baseZindexModalLwc = parseInt(modalZindexValueLwc, 10);
    return isNaN(baseZindexModalLwc) ? DEFAULT_ZINDEX_BASELINE : baseZindexModalLwc + DEFAULT_ZINDEX_OFFSET;
  }
  function isNativeComponent(cmp) {
    if (cmp && cmp.template && cmp.template.constructor) {
      return !!String(cmp.template.constructor).match(/\[native code\]/);
    }
    return false;
  }
  function debounce(func, delay, options) {
    const _options = options || {};
    let invokeLeading = _options.leading;
    let timer2;
    return function debounced() {
      const args = Array.prototype.slice.apply(arguments);
      if (invokeLeading) {
        func.apply(this, args);
        invokeLeading = false;
      }
      clearTimeout(timer2);
      timer2 = setTimeout(function() {
        func.apply(this, args);
        invokeLeading = _options.leading;
      }, delay);
    };
  }
  var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var AddressTokenTypes = Object.freeze({
    DATA: Symbol("data"),
    STRING: Symbol("string"),
    NEWLINE: Symbol("newline"),
    GROUP: Symbol("group")
  });
  (function() {
    function AddressToken(type, string, pattern) {
      classCallCheck(this, AddressToken);
      this.type = type;
      this.string = string;
      this.pattern = pattern;
    }
    createClass(AddressToken, null, [{
      key: "string",
      value: function string(_string) {
        return new AddressToken(AddressTokenTypes.STRING, _string);
      }
    }, {
      key: "data",
      value: function data(pattern) {
        return new AddressToken(AddressTokenTypes.DATA, void 0, pattern);
      }
    }, {
      key: "newLine",
      value: function newLine() {
        return new AddressToken(AddressTokenTypes.NEWLINE);
      }
    }]);
    return AddressToken;
  })();
  var fieldConstants = {
    SALUTATION: Symbol("Salutation"),
    FIRST: Symbol("First Name"),
    MIDDLE: Symbol("Middle Name"),
    LAST: Symbol("Last Name"),
    SUFFIX: Symbol("Suffix"),
    INFORMAL: Symbol("Informal Name")
  };
  var _createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Format = function Format2(parts) {
    _classCallCheck(this, Format2);
    this.parts = Object.freeze(parts);
    Object.freeze(this);
  };
  var FieldFormatPart = function FieldFormatPart2(field) {
    _classCallCheck(this, FieldFormatPart2);
    this.field = field;
    this.type = "field";
    Object.freeze(this);
  };
  var TextFormatPart = function TextFormatPart2(text2) {
    _classCallCheck(this, TextFormatPart2);
    this.type = "text";
    this.text = text2;
    Object.freeze(this);
  };
  var fieldFormatParts = Object.freeze({
    SALUTATION: new FieldFormatPart(fieldConstants.SALUTATION),
    FIRST: new FieldFormatPart(fieldConstants.FIRST),
    MIDDLE: new FieldFormatPart(fieldConstants.MIDDLE),
    LAST: new FieldFormatPart(fieldConstants.LAST),
    SUFFIX: new FieldFormatPart(fieldConstants.SUFFIX),
    INFORMAL: new FieldFormatPart(fieldConstants.INFORMAL)
  });
  var FormatParser = function() {
    function FormatParser2() {
      _classCallCheck(this, FormatParser2);
    }
    _createClass(FormatParser2, [{
      key: "parse",
      value: function parse2(fmt) {
        var nodes = [];
        var textBuffer = "";
        for (var i = 0; i < fmt.length; i = i + 1) {
          if (fmt[i] === "%") {
            i = i + 1;
            if (textBuffer.length > 0) {
              nodes.push(Object.freeze(new TextFormatPart(textBuffer)));
              textBuffer = "";
            }
            if (i >= fmt.length) {
              throw new Error("Unexpected end of format. Symbol at " + (i - 1) + " should be followed by a valid field code");
            }
            var code = fmt[i];
            switch (code) {
              case "S":
                nodes.push(fieldFormatParts.SALUTATION);
                break;
              case "F":
                nodes.push(fieldFormatParts.FIRST);
                break;
              case "M":
                nodes.push(fieldFormatParts.MIDDLE);
                break;
              case "L":
                nodes.push(fieldFormatParts.LAST);
                break;
              case "X":
                nodes.push(fieldFormatParts.SUFFIX);
                break;
              case "I":
                nodes.push(fieldFormatParts.INFORMAL);
                break;
            }
          } else {
            textBuffer += fmt[i];
          }
        }
        if (textBuffer.length > 0) {
          nodes.push(new TextFormatPart(textBuffer));
        }
        return new Format(nodes);
      }
    }]);
    return FormatParser2;
  }();
  new FormatParser();
  _2_41_4.registerComponent(JSON.parse('{"adlm":"\u{1E950}\u{1E951}\u{1E952}\u{1E953}\u{1E954}\u{1E955}\u{1E956}\u{1E957}\u{1E958}\u{1E959}","ahom":"\u{11730}\u{11731}\u{11732}\u{11733}\u{11734}\u{11735}\u{11736}\u{11737}\u{11738}\u{11739}","arab":"\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669","arabext":"\u06F0\u06F1\u06F2\u06F3\u06F4\u06F5\u06F6\u06F7\u06F8\u06F9","bali":"\u1B50\u1B51\u1B52\u1B53\u1B54\u1B55\u1B56\u1B57\u1B58\u1B59","beng":"\u09E6\u09E7\u09E8\u09E9\u09EA\u09EB\u09EC\u09ED\u09EE\u09EF","bhks":"\u{11C50}\u{11C51}\u{11C52}\u{11C53}\u{11C54}\u{11C55}\u{11C56}\u{11C57}\u{11C58}\u{11C59}","brah":"\u{11066}\u{11067}\u{11068}\u{11069}\u{1106A}\u{1106B}\u{1106C}\u{1106D}\u{1106E}\u{1106F}","cakm":"\u{11136}\u{11137}\u{11138}\u{11139}\u{1113A}\u{1113B}\u{1113C}\u{1113D}\u{1113E}\u{1113F}","cham":"\uAA50\uAA51\uAA52\uAA53\uAA54\uAA55\uAA56\uAA57\uAA58\uAA59","deva":"\u0966\u0967\u0968\u0969\u096A\u096B\u096C\u096D\u096E\u096F","fullwide":"\uFF10\uFF11\uFF12\uFF13\uFF14\uFF15\uFF16\uFF17\uFF18\uFF19","gong":"\u{11DA0}\u{11DA1}\u{11DA2}\u{11DA3}\u{11DA4}\u{11DA5}\u{11DA6}\u{11DA7}\u{11DA8}\u{11DA9}","gonm":"\u{11D50}\u{11D51}\u{11D52}\u{11D53}\u{11D54}\u{11D55}\u{11D56}\u{11D57}\u{11D58}\u{11D59}","gujr":"\u0AE6\u0AE7\u0AE8\u0AE9\u0AEA\u0AEB\u0AEC\u0AED\u0AEE\u0AEF","guru":"\u0A66\u0A67\u0A68\u0A69\u0A6A\u0A6B\u0A6C\u0A6D\u0A6E\u0A6F","hanidec":"\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D","hmng":"\u{16B50}\u{16B51}\u{16B52}\u{16B53}\u{16B54}\u{16B55}\u{16B56}\u{16B57}\u{16B58}\u{16B59}","hmnp":"\u{1E140}\u{1E141}\u{1E142}\u{1E143}\u{1E144}\u{1E145}\u{1E146}\u{1E147}\u{1E148}\u{1E149}","java":"\uA9D0\uA9D1\uA9D2\uA9D3\uA9D4\uA9D5\uA9D6\uA9D7\uA9D8\uA9D9","kali":"\uA900\uA901\uA902\uA903\uA904\uA905\uA906\uA907\uA908\uA909","khmr":"\u17E0\u17E1\u17E2\u17E3\u17E4\u17E5\u17E6\u17E7\u17E8\u17E9","knda":"\u0CE6\u0CE7\u0CE8\u0CE9\u0CEA\u0CEB\u0CEC\u0CED\u0CEE\u0CEF","lana":"\u1A80\u1A81\u1A82\u1A83\u1A84\u1A85\u1A86\u1A87\u1A88\u1A89","lanatham":"\u1A90\u1A91\u1A92\u1A93\u1A94\u1A95\u1A96\u1A97\u1A98\u1A99","laoo":"\u0ED0\u0ED1\u0ED2\u0ED3\u0ED4\u0ED5\u0ED6\u0ED7\u0ED8\u0ED9","latn":"0123456789","lepc":"\u1C40\u1C41\u1C42\u1C43\u1C44\u1C45\u1C46\u1C47\u1C48\u1C49","limb":"\u1946\u1947\u1948\u1949\u194A\u194B\u194C\u194D\u194E\u194F","mathbold":"\u{1D7CE}\u{1D7CF}\u{1D7D0}\u{1D7D1}\u{1D7D2}\u{1D7D3}\u{1D7D4}\u{1D7D5}\u{1D7D6}\u{1D7D7}","mathdbl":"\u{1D7D8}\u{1D7D9}\u{1D7DA}\u{1D7DB}\u{1D7DC}\u{1D7DD}\u{1D7DE}\u{1D7DF}\u{1D7E0}\u{1D7E1}","mathmono":"\u{1D7F6}\u{1D7F7}\u{1D7F8}\u{1D7F9}\u{1D7FA}\u{1D7FB}\u{1D7FC}\u{1D7FD}\u{1D7FE}\u{1D7FF}","mathsanb":"\u{1D7EC}\u{1D7ED}\u{1D7EE}\u{1D7EF}\u{1D7F0}\u{1D7F1}\u{1D7F2}\u{1D7F3}\u{1D7F4}\u{1D7F5}","mathsans":"\u{1D7E2}\u{1D7E3}\u{1D7E4}\u{1D7E5}\u{1D7E6}\u{1D7E7}\u{1D7E8}\u{1D7E9}\u{1D7EA}\u{1D7EB}","mlym":"\u0D66\u0D67\u0D68\u0D69\u0D6A\u0D6B\u0D6C\u0D6D\u0D6E\u0D6F","modi":"\u{11650}\u{11651}\u{11652}\u{11653}\u{11654}\u{11655}\u{11656}\u{11657}\u{11658}\u{11659}","mong":"\u1810\u1811\u1812\u1813\u1814\u1815\u1816\u1817\u1818\u1819","mroo":"\u{16A60}\u{16A61}\u{16A62}\u{16A63}\u{16A64}\u{16A65}\u{16A66}\u{16A67}\u{16A68}\u{16A69}","mtei":"\uABF0\uABF1\uABF2\uABF3\uABF4\uABF5\uABF6\uABF7\uABF8\uABF9","mymr":"\u1040\u1041\u1042\u1043\u1044\u1045\u1046\u1047\u1048\u1049","mymrshan":"\u1090\u1091\u1092\u1093\u1094\u1095\u1096\u1097\u1098\u1099","mymrtlng":"\uA9F0\uA9F1\uA9F2\uA9F3\uA9F4\uA9F5\uA9F6\uA9F7\uA9F8\uA9F9","newa":"\u{11450}\u{11451}\u{11452}\u{11453}\u{11454}\u{11455}\u{11456}\u{11457}\u{11458}\u{11459}","nkoo":"\u07C0\u07C1\u07C2\u07C3\u07C4\u07C5\u07C6\u07C7\u07C8\u07C9","olck":"\u1C50\u1C51\u1C52\u1C53\u1C54\u1C55\u1C56\u1C57\u1C58\u1C59","orya":"\u0B66\u0B67\u0B68\u0B69\u0B6A\u0B6B\u0B6C\u0B6D\u0B6E\u0B6F","osma":"\u{104A0}\u{104A1}\u{104A2}\u{104A3}\u{104A4}\u{104A5}\u{104A6}\u{104A7}\u{104A8}\u{104A9}","rohg":"\u{10D30}\u{10D31}\u{10D32}\u{10D33}\u{10D34}\u{10D35}\u{10D36}\u{10D37}\u{10D38}\u{10D39}","saur":"\uA8D0\uA8D1\uA8D2\uA8D3\uA8D4\uA8D5\uA8D6\uA8D7\uA8D8\uA8D9","shrd":"\u{111D0}\u{111D1}\u{111D2}\u{111D3}\u{111D4}\u{111D5}\u{111D6}\u{111D7}\u{111D8}\u{111D9}","sind":"\u{112F0}\u{112F1}\u{112F2}\u{112F3}\u{112F4}\u{112F5}\u{112F6}\u{112F7}\u{112F8}\u{112F9}","sinh":"\u0DE6\u0DE7\u0DE8\u0DE9\u0DEA\u0DEB\u0DEC\u0DED\u0DEE\u0DEF","sora":"\u{110F0}\u{110F1}\u{110F2}\u{110F3}\u{110F4}\u{110F5}\u{110F6}\u{110F7}\u{110F8}\u{110F9}","sund":"\u1BB0\u1BB1\u1BB2\u1BB3\u1BB4\u1BB5\u1BB6\u1BB7\u1BB8\u1BB9","takr":"\u{116C0}\u{116C1}\u{116C2}\u{116C3}\u{116C4}\u{116C5}\u{116C6}\u{116C7}\u{116C8}\u{116C9}","talu":"\u19D0\u19D1\u19D2\u19D3\u19D4\u19D5\u19D6\u19D7\u19D8\u19D9","tamldec":"\u0BE6\u0BE7\u0BE8\u0BE9\u0BEA\u0BEB\u0BEC\u0BED\u0BEE\u0BEF","telu":"\u0C66\u0C67\u0C68\u0C69\u0C6A\u0C6B\u0C6C\u0C6D\u0C6E\u0C6F","thai":"\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59","tibt":"\u0F20\u0F21\u0F22\u0F23\u0F24\u0F25\u0F26\u0F27\u0F28\u0F29","tirh":"\u{114D0}\u{114D1}\u{114D2}\u{114D3}\u{114D4}\u{114D5}\u{114D6}\u{114D7}\u{114D8}\u{114D9}","vaii":"\uA620\uA621\uA622\uA623\uA624\uA625\uA626\uA627\uA628\uA629","wara":"\u{118E0}\u{118E1}\u{118E2}\u{118E3}\u{118E4}\u{118E5}\u{118E6}\u{118E7}\u{118E8}\u{118E9}","wcho":"\u{1E2F0}\u{1E2F1}\u{1E2F2}\u{1E2F3}\u{1E2F4}\u{1E2F5}\u{1E2F6}\u{1E2F7}\u{1E2F8}\u{1E2F9}"}'), {
    tmpl: _tmpl$a,
    sel: "lwc-components-lightning-scopedImports"
  });
  _2_41_4.registerComponent(JSON.parse('{"buddhist":{"calendarSystem":"solar","eras":{"0":{"_start":"-542-01-01"}}},"ethiopic-amete-alem":{"eras":{"0":{"_end":"-5492-08-29"}}},"generic":{},"gregorian":{"calendarSystem":"solar","eras":{"0":{"_end":"0-12-31"},"1":{"_start":"1-01-01"}}},"indian":{"eras":{"0":{"_start":"79-01-01"}}},"japanese":{"calendarSystem":"solar","eras":{"0":{"_start":"645-6-19"},"1":{"_start":"650-2-15"},"2":{"_start":"672-1-1"},"3":{"_start":"686-7-20"},"4":{"_start":"701-3-21"},"5":{"_start":"704-5-10"},"6":{"_start":"708-1-11"},"7":{"_start":"715-9-2"},"8":{"_start":"717-11-17"},"9":{"_start":"724-2-4"},"10":{"_start":"729-8-5"},"11":{"_start":"749-4-14"},"12":{"_start":"749-7-2"},"13":{"_start":"757-8-18"},"14":{"_start":"765-1-7"},"15":{"_start":"767-8-16"},"16":{"_start":"770-10-1"},"17":{"_start":"781-1-1"},"18":{"_start":"782-8-19"},"19":{"_start":"806-5-18"},"20":{"_start":"810-9-19"},"21":{"_start":"824-1-5"},"22":{"_start":"834-1-3"},"23":{"_start":"848-6-13"},"24":{"_start":"851-4-28"},"25":{"_start":"854-11-30"},"26":{"_start":"857-2-21"},"27":{"_start":"859-4-15"},"28":{"_start":"877-4-16"},"29":{"_start":"885-2-21"},"30":{"_start":"889-4-27"},"31":{"_start":"898-4-26"},"32":{"_start":"901-7-15"},"33":{"_start":"923-4-11"},"34":{"_start":"931-4-26"},"35":{"_start":"938-5-22"},"36":{"_start":"947-4-22"},"37":{"_start":"957-10-27"},"38":{"_start":"961-2-16"},"39":{"_start":"964-7-10"},"40":{"_start":"968-8-13"},"41":{"_start":"970-3-25"},"42":{"_start":"973-12-20"},"43":{"_start":"976-7-13"},"44":{"_start":"978-11-29"},"45":{"_start":"983-4-15"},"46":{"_start":"985-4-27"},"47":{"_start":"987-4-5"},"48":{"_start":"989-8-8"},"49":{"_start":"990-11-7"},"50":{"_start":"995-2-22"},"51":{"_start":"999-1-13"},"52":{"_start":"1004-7-20"},"53":{"_start":"1012-12-25"},"54":{"_start":"1017-4-23"},"55":{"_start":"1021-2-2"},"56":{"_start":"1024-7-13"},"57":{"_start":"1028-7-25"},"58":{"_start":"1037-4-21"},"59":{"_start":"1040-11-10"},"60":{"_start":"1044-11-24"},"61":{"_start":"1046-4-14"},"62":{"_start":"1053-1-11"},"63":{"_start":"1058-8-29"},"64":{"_start":"1065-8-2"},"65":{"_start":"1069-4-13"},"66":{"_start":"1074-8-23"},"67":{"_start":"1077-11-17"},"68":{"_start":"1081-2-10"},"69":{"_start":"1084-2-7"},"70":{"_start":"1087-4-7"},"71":{"_start":"1094-12-15"},"72":{"_start":"1096-12-17"},"73":{"_start":"1097-11-21"},"74":{"_start":"1099-8-28"},"75":{"_start":"1104-2-10"},"76":{"_start":"1106-4-9"},"77":{"_start":"1108-8-3"},"78":{"_start":"1110-7-13"},"79":{"_start":"1113-7-13"},"80":{"_start":"1118-4-3"},"81":{"_start":"1120-4-10"},"82":{"_start":"1124-4-3"},"83":{"_start":"1126-1-22"},"84":{"_start":"1131-1-29"},"85":{"_start":"1132-8-11"},"86":{"_start":"1135-4-27"},"87":{"_start":"1141-7-10"},"88":{"_start":"1142-4-28"},"89":{"_start":"1144-2-23"},"90":{"_start":"1145-7-22"},"91":{"_start":"1151-1-26"},"92":{"_start":"1154-10-28"},"93":{"_start":"1156-4-27"},"94":{"_start":"1159-4-20"},"95":{"_start":"1160-1-10"},"96":{"_start":"1161-9-4"},"97":{"_start":"1163-3-29"},"98":{"_start":"1165-6-5"},"99":{"_start":"1166-8-27"},"100":{"_start":"1169-4-8"},"101":{"_start":"1171-4-21"},"102":{"_start":"1175-7-28"},"103":{"_start":"1177-8-4"},"104":{"_start":"1181-7-14"},"105":{"_start":"1182-5-27"},"106":{"_start":"1184-4-16"},"107":{"_start":"1185-8-14"},"108":{"_start":"1190-4-11"},"109":{"_start":"1199-4-27"},"110":{"_start":"1201-2-13"},"111":{"_start":"1204-2-20"},"112":{"_start":"1206-4-27"},"113":{"_start":"1207-10-25"},"114":{"_start":"1211-3-9"},"115":{"_start":"1213-12-6"},"116":{"_start":"1219-4-12"},"117":{"_start":"1222-4-13"},"118":{"_start":"1224-11-20"},"119":{"_start":"1225-4-20"},"120":{"_start":"1227-12-10"},"121":{"_start":"1229-3-5"},"122":{"_start":"1232-4-2"},"123":{"_start":"1233-4-15"},"124":{"_start":"1234-11-5"},"125":{"_start":"1235-9-19"},"126":{"_start":"1238-11-23"},"127":{"_start":"1239-2-7"},"128":{"_start":"1240-7-16"},"129":{"_start":"1243-2-26"},"130":{"_start":"1247-2-28"},"131":{"_start":"1249-3-18"},"132":{"_start":"1256-10-5"},"133":{"_start":"1257-3-14"},"134":{"_start":"1259-3-26"},"135":{"_start":"1260-4-13"},"136":{"_start":"1261-2-20"},"137":{"_start":"1264-2-28"},"138":{"_start":"1275-4-25"},"139":{"_start":"1278-2-29"},"140":{"_start":"1288-4-28"},"141":{"_start":"1293-8-5"},"142":{"_start":"1299-4-25"},"143":{"_start":"1302-11-21"},"144":{"_start":"1303-8-5"},"145":{"_start":"1306-12-14"},"146":{"_start":"1308-10-9"},"147":{"_start":"1311-4-28"},"148":{"_start":"1312-3-20"},"149":{"_start":"1317-2-3"},"150":{"_start":"1319-4-28"},"151":{"_start":"1321-2-23"},"152":{"_start":"1324-12-9"},"153":{"_start":"1326-4-26"},"154":{"_start":"1329-8-29"},"155":{"_start":"1331-8-9"},"156":{"_start":"1334-1-29"},"157":{"_start":"1336-2-29"},"158":{"_start":"1340-4-28"},"159":{"_start":"1346-12-8"},"160":{"_start":"1370-7-24"},"161":{"_start":"1372-4-1"},"162":{"_start":"1375-5-27"},"163":{"_start":"1379-3-22"},"164":{"_start":"1381-2-10"},"165":{"_start":"1384-4-28"},"166":{"_start":"1387-8-22"},"167":{"_start":"1387-8-23"},"168":{"_start":"1389-2-9"},"169":{"_start":"1390-3-26"},"170":{"_start":"1394-7-5"},"171":{"_start":"1428-4-27"},"172":{"_start":"1429-9-5"},"173":{"_start":"1441-2-17"},"174":{"_start":"1444-2-5"},"175":{"_start":"1449-7-28"},"176":{"_start":"1452-7-25"},"177":{"_start":"1455-7-25"},"178":{"_start":"1457-9-28"},"179":{"_start":"1460-12-21"},"180":{"_start":"1466-2-28"},"181":{"_start":"1467-3-3"},"182":{"_start":"1469-4-28"},"183":{"_start":"1487-7-29"},"184":{"_start":"1489-8-21"},"185":{"_start":"1492-7-19"},"186":{"_start":"1501-2-29"},"187":{"_start":"1504-2-30"},"188":{"_start":"1521-8-23"},"189":{"_start":"1528-8-20"},"190":{"_start":"1532-7-29"},"191":{"_start":"1555-10-23"},"192":{"_start":"1558-2-28"},"193":{"_start":"1570-4-23"},"194":{"_start":"1573-7-28"},"195":{"_start":"1592-12-8"},"196":{"_start":"1596-10-27"},"197":{"_start":"1615-7-13"},"198":{"_start":"1624-2-30"},"199":{"_start":"1644-12-16"},"200":{"_start":"1648-2-15"},"201":{"_start":"1652-9-18"},"202":{"_start":"1655-4-13"},"203":{"_start":"1658-7-23"},"204":{"_start":"1661-4-25"},"205":{"_start":"1673-9-21"},"206":{"_start":"1681-9-29"},"207":{"_start":"1684-2-21"},"208":{"_start":"1688-9-30"},"209":{"_start":"1704-3-13"},"210":{"_start":"1711-4-25"},"211":{"_start":"1716-6-22"},"212":{"_start":"1736-4-28"},"213":{"_start":"1741-2-27"},"214":{"_start":"1744-2-21"},"215":{"_start":"1748-7-12"},"216":{"_start":"1751-10-27"},"217":{"_start":"1764-6-2"},"218":{"_start":"1772-11-16"},"219":{"_start":"1781-4-2"},"220":{"_start":"1789-1-25"},"221":{"_start":"1801-2-5"},"222":{"_start":"1804-2-11"},"223":{"_start":"1818-4-22"},"224":{"_start":"1830-12-10"},"225":{"_start":"1844-12-2"},"226":{"_start":"1848-2-28"},"227":{"_start":"1854-11-27"},"228":{"_start":"1860-3-18"},"229":{"_start":"1861-2-19"},"230":{"_start":"1864-2-20"},"231":{"_start":"1865-4-7"},"232":{"_start":"1868-9-8"},"233":{"_start":"1912-7-30"},"234":{"_start":"1926-12-25"},"235":{"_start":"1989-1-8"},"236":{"_start":"2019-5-1"}}},"persian":{"calendarSystem":"solar","eras":{"0":{"_start":"622-01-01"}}},"roc":{"eras":{"0":{"_end":"1911-12-31"},"1":{"_start":"1912-01-01"}}}}'), {
    tmpl: _tmpl$a,
    sel: "lwc-components-lightning-scopedImports"
  });
  _2_41_4.registerComponent(JSON.parse('{"buddhist":{"dayPeriods":{"format":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"narrow":{"midnight":"mi","am":"a","am-alt-variant":"am","noon":"n","pm":"p","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"}},"stand-alone":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"narrow":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"}}},"days":{"format":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}},"stand-alone":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}}},"eras":{"eraNames":{"0":"BE"},"eraAbbr":{"0":"BE"},"eraNarrow":{"0":"BE"}},"months":{"format":{"abbreviated":{"1":"Jan","2":"Feb","3":"Mar","4":"Apr","5":"May","6":"Jun","7":"Jul","8":"Aug","9":"Sep","10":"Oct","11":"Nov","12":"Dec"},"narrow":{"1":"J","2":"F","3":"M","4":"A","5":"M","6":"J","7":"J","8":"A","9":"S","10":"O","11":"N","12":"D"},"wide":{"1":"January","2":"February","3":"March","4":"April","5":"May","6":"June","7":"July","8":"August","9":"September","10":"October","11":"November","12":"December"}},"stand-alone":{"abbreviated":{"1":"Jan","2":"Feb","3":"Mar","4":"Apr","5":"May","6":"Jun","7":"Jul","8":"Aug","9":"Sep","10":"Oct","11":"Nov","12":"Dec"},"narrow":{"1":"J","2":"F","3":"M","4":"A","5":"M","6":"J","7":"J","8":"A","9":"S","10":"O","11":"N","12":"D"},"wide":{"1":"January","2":"February","3":"March","4":"April","5":"May","6":"June","7":"July","8":"August","9":"September","10":"October","11":"November","12":"December"}}},"quarters":{"format":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}},"stand-alone":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}}}},"ethiopic-amete-alem":{"dayPeriods":{"format":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"narrow":{"midnight":"mi","am":"a","am-alt-variant":"am","noon":"n","pm":"p","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"}},"stand-alone":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"narrow":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"}}},"days":{"format":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}},"stand-alone":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}}},"eras":{"eraNames":{"0":"ERA0"},"eraAbbr":{"0":"ERA0"},"eraNarrow":{"0":"ERA0"}},"months":{"format":{"abbreviated":{"1":"Meskerem","2":"Tekemt","3":"Hedar","4":"Tahsas","5":"Ter","6":"Yekatit","7":"Megabit","8":"Miazia","9":"Genbot","10":"Sene","11":"Hamle","12":"Nehasse","13":"Pagumen"},"narrow":{"1":"1","2":"2","3":"3","4":"4","5":"5","6":"6","7":"7","8":"8","9":"9","10":"10","11":"11","12":"12","13":"13"},"wide":{"1":"Meskerem","2":"Tekemt","3":"Hedar","4":"Tahsas","5":"Ter","6":"Yekatit","7":"Megabit","8":"Miazia","9":"Genbot","10":"Sene","11":"Hamle","12":"Nehasse","13":"Pagumen"}},"stand-alone":{"abbreviated":{"1":"Meskerem","2":"Tekemt","3":"Hedar","4":"Tahsas","5":"Ter","6":"Yekatit","7":"Megabit","8":"Miazia","9":"Genbot","10":"Sene","11":"Hamle","12":"Nehasse","13":"Pagumen"},"narrow":{"1":"1","2":"2","3":"3","4":"4","5":"5","6":"6","7":"7","8":"8","9":"9","10":"10","11":"11","12":"12","13":"13"},"wide":{"1":"Meskerem","2":"Tekemt","3":"Hedar","4":"Tahsas","5":"Ter","6":"Yekatit","7":"Megabit","8":"Miazia","9":"Genbot","10":"Sene","11":"Hamle","12":"Nehasse","13":"Pagumen"}}},"quarters":{"format":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}},"stand-alone":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}}}},"generic":{"dayPeriods":{"format":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"narrow":{"midnight":"mi","am":"a","am-alt-variant":"am","noon":"n","pm":"p","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"}},"stand-alone":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"narrow":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"}}},"days":{"format":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}},"stand-alone":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}}},"eras":{"eraNames":{"0":"ERA0","1":"ERA1"},"eraAbbr":{"0":"ERA0","1":"ERA1"},"eraNarrow":{"0":"ERA0","1":"ERA1"}},"months":{"format":{"abbreviated":{"1":"M01","2":"M02","3":"M03","4":"M04","5":"M05","6":"M06","7":"M07","8":"M08","9":"M09","10":"M10","11":"M11","12":"M12"},"narrow":{"1":"1","2":"2","3":"3","4":"4","5":"5","6":"6","7":"7","8":"8","9":"9","10":"10","11":"11","12":"12"},"wide":{"1":"M01","2":"M02","3":"M03","4":"M04","5":"M05","6":"M06","7":"M07","8":"M08","9":"M09","10":"M10","11":"M11","12":"M12"}},"stand-alone":{"abbreviated":{"1":"M01","2":"M02","3":"M03","4":"M04","5":"M05","6":"M06","7":"M07","8":"M08","9":"M09","10":"M10","11":"M11","12":"M12"},"narrow":{"1":"1","2":"2","3":"3","4":"4","5":"5","6":"6","7":"7","8":"8","9":"9","10":"10","11":"11","12":"12"},"wide":{"1":"M01","2":"M02","3":"M03","4":"M04","5":"M05","6":"M06","7":"M07","8":"M08","9":"M09","10":"M10","11":"M11","12":"M12"}}},"quarters":{"format":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}},"stand-alone":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}}}},"gregorian":{"dayPeriods":{"format":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"narrow":{"midnight":"mi","am":"a","am-alt-variant":"am","noon":"n","pm":"p","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"}},"stand-alone":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"narrow":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"}}},"days":{"format":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}},"stand-alone":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}}},"eras":{"eraNames":{"0":"Before Christ","1":"Anno Domini","0-alt-variant":"Before Common Era","1-alt-variant":"Common Era"},"eraAbbr":{"0":"BC","1":"AD","0-alt-variant":"BCE","1-alt-variant":"CE"},"eraNarrow":{"0":"B","1":"A","0-alt-variant":"BCE","1-alt-variant":"CE"}},"months":{"format":{"abbreviated":{"1":"Jan","2":"Feb","3":"Mar","4":"Apr","5":"May","6":"Jun","7":"Jul","8":"Aug","9":"Sep","10":"Oct","11":"Nov","12":"Dec"},"narrow":{"1":"J","2":"F","3":"M","4":"A","5":"M","6":"J","7":"J","8":"A","9":"S","10":"O","11":"N","12":"D"},"wide":{"1":"January","2":"February","3":"March","4":"April","5":"May","6":"June","7":"July","8":"August","9":"September","10":"October","11":"November","12":"December"}},"stand-alone":{"abbreviated":{"1":"Jan","2":"Feb","3":"Mar","4":"Apr","5":"May","6":"Jun","7":"Jul","8":"Aug","9":"Sep","10":"Oct","11":"Nov","12":"Dec"},"narrow":{"1":"J","2":"F","3":"M","4":"A","5":"M","6":"J","7":"J","8":"A","9":"S","10":"O","11":"N","12":"D"},"wide":{"1":"January","2":"February","3":"March","4":"April","5":"May","6":"June","7":"July","8":"August","9":"September","10":"October","11":"November","12":"December"}}},"quarters":{"format":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}},"stand-alone":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}}}},"indian":{"dayPeriods":{"format":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"narrow":{"midnight":"mi","am":"a","am-alt-variant":"am","noon":"n","pm":"p","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"}},"stand-alone":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"narrow":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"}}},"days":{"format":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}},"stand-alone":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}}},"eras":{"eraNames":{"0":"Saka"},"eraAbbr":{"0":"Saka"},"eraNarrow":{"0":"Saka"}},"months":{"format":{"abbreviated":{"1":"Chaitra","2":"Vaisakha","3":"Jyaistha","4":"Asadha","5":"Sravana","6":"Bhadra","7":"Asvina","8":"Kartika","9":"Agrahayana","10":"Pausa","11":"Magha","12":"Phalguna"},"narrow":{"1":"1","2":"2","3":"3","4":"4","5":"5","6":"6","7":"7","8":"8","9":"9","10":"10","11":"11","12":"12"},"wide":{"1":"Chaitra","2":"Vaisakha","3":"Jyaistha","4":"Asadha","5":"Sravana","6":"Bhadra","7":"Asvina","8":"Kartika","9":"Agrahayana","10":"Pausa","11":"Magha","12":"Phalguna"}},"stand-alone":{"abbreviated":{"1":"Chaitra","2":"Vaisakha","3":"Jyaistha","4":"Asadha","5":"Sravana","6":"Bhadra","7":"Asvina","8":"Kartika","9":"Agrahayana","10":"Pausa","11":"Magha","12":"Phalguna"},"narrow":{"1":"1","2":"2","3":"3","4":"4","5":"5","6":"6","7":"7","8":"8","9":"9","10":"10","11":"11","12":"12"},"wide":{"1":"Chaitra","2":"Vaisakha","3":"Jyaistha","4":"Asadha","5":"Sravana","6":"Bhadra","7":"Asvina","8":"Kartika","9":"Agrahayana","10":"Pausa","11":"Magha","12":"Phalguna"}}},"quarters":{"format":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}},"stand-alone":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}}}},"japanese":{"dayPeriods":{"format":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"narrow":{"midnight":"mi","am":"a","am-alt-variant":"am","noon":"n","pm":"p","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"}},"stand-alone":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"narrow":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"}}},"days":{"format":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}},"stand-alone":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}}},"eras":{"eraNames":{"0":"Taika (645\u2013650)","1":"Hakuchi (650\u2013671)","2":"Hakuh\u014D (672\u2013686)","3":"Shuch\u014D (686\u2013701)","4":"Taih\u014D (701\u2013704)","5":"Keiun (704\u2013708)","6":"Wad\u014D (708\u2013715)","7":"Reiki (715\u2013717)","8":"Y\u014Dr\u014D (717\u2013724)","9":"Jinki (724\u2013729)","10":"Tenpy\u014D (729\u2013749)","11":"Tenpy\u014D-kamp\u014D (749\u2013749)","12":"Tenpy\u014D-sh\u014Dh\u014D (749\u2013757)","13":"Tenpy\u014D-h\u014Dji (757\u2013765)","14":"Tenpy\u014D-jingo (765\u2013767)","15":"Jingo-keiun (767\u2013770)","16":"H\u014Dki (770\u2013780)","17":"Ten-\u014D (781\u2013782)","18":"Enryaku (782\u2013806)","19":"Daid\u014D (806\u2013810)","20":"K\u014Dnin (810\u2013824)","21":"Tench\u014D (824\u2013834)","22":"J\u014Dwa (834\u2013848)","23":"Kaj\u014D (848\u2013851)","24":"Ninju (851\u2013854)","25":"Saik\u014D (854\u2013857)","26":"Ten-an (857\u2013859)","27":"J\u014Dgan (859\u2013877)","28":"Gangy\u014D (877\u2013885)","29":"Ninna (885\u2013889)","30":"Kanpy\u014D (889\u2013898)","31":"Sh\u014Dtai (898\u2013901)","32":"Engi (901\u2013923)","33":"Ench\u014D (923\u2013931)","34":"J\u014Dhei (931\u2013938)","35":"Tengy\u014D (938\u2013947)","36":"Tenryaku (947\u2013957)","37":"Tentoku (957\u2013961)","38":"\u014Cwa (961\u2013964)","39":"K\u014Dh\u014D (964\u2013968)","40":"Anna (968\u2013970)","41":"Tenroku (970\u2013973)","42":"Ten\u2019en (973\u2013976)","43":"J\u014Dgen (976\u2013978)","44":"Tengen (978\u2013983)","45":"Eikan (983\u2013985)","46":"Kanna (985\u2013987)","47":"Eien (987\u2013989)","48":"Eiso (989\u2013990)","49":"Sh\u014Dryaku (990\u2013995)","50":"Ch\u014Dtoku (995\u2013999)","51":"Ch\u014Dh\u014D (999\u20131004)","52":"Kank\u014D (1004\u20131012)","53":"Ch\u014Dwa (1012\u20131017)","54":"Kannin (1017\u20131021)","55":"Jian (1021\u20131024)","56":"Manju (1024\u20131028)","57":"Ch\u014Dgen (1028\u20131037)","58":"Ch\u014Dryaku (1037\u20131040)","59":"Ch\u014Dky\u016B (1040\u20131044)","60":"Kantoku (1044\u20131046)","61":"Eish\u014D (1046\u20131053)","62":"Tengi (1053\u20131058)","63":"K\u014Dhei (1058\u20131065)","64":"Jiryaku (1065\u20131069)","65":"Enky\u016B (1069\u20131074)","66":"Sh\u014Dho (1074\u20131077)","67":"Sh\u014Dryaku (1077\u20131081)","68":"Eih\u014D (1081\u20131084)","69":"\u014Ctoku (1084\u20131087)","70":"Kanji (1087\u20131094)","71":"Kah\u014D (1094\u20131096)","72":"Eich\u014D (1096\u20131097)","73":"J\u014Dtoku (1097\u20131099)","74":"K\u014Dwa (1099\u20131104)","75":"Ch\u014Dji (1104\u20131106)","76":"Kash\u014D (1106\u20131108)","77":"Tennin (1108\u20131110)","78":"Ten-ei (1110\u20131113)","79":"Eiky\u016B (1113\u20131118)","80":"Gen\u2019ei (1118\u20131120)","81":"H\u014Dan (1120\u20131124)","82":"Tenji (1124\u20131126)","83":"Daiji (1126\u20131131)","84":"Tensh\u014D (1131\u20131132)","85":"Ch\u014Dsh\u014D (1132\u20131135)","86":"H\u014Den (1135\u20131141)","87":"Eiji (1141\u20131142)","88":"K\u014Dji (1142\u20131144)","89":"Ten\u2019y\u014D (1144\u20131145)","90":"Ky\u016Ban (1145\u20131151)","91":"Ninpei (1151\u20131154)","92":"Ky\u016Bju (1154\u20131156)","93":"H\u014Dgen (1156\u20131159)","94":"Heiji (1159\u20131160)","95":"Eiryaku (1160\u20131161)","96":"\u014Cho (1161\u20131163)","97":"Ch\u014Dkan (1163\u20131165)","98":"Eiman (1165\u20131166)","99":"Nin\u2019an (1166\u20131169)","100":"Ka\u014D (1169\u20131171)","101":"Sh\u014Dan (1171\u20131175)","102":"Angen (1175\u20131177)","103":"Jish\u014D (1177\u20131181)","104":"Y\u014Dwa (1181\u20131182)","105":"Juei (1182\u20131184)","106":"Genryaku (1184\u20131185)","107":"Bunji (1185\u20131190)","108":"Kenky\u016B (1190\u20131199)","109":"Sh\u014Dji (1199\u20131201)","110":"Kennin (1201\u20131204)","111":"Genky\u016B (1204\u20131206)","112":"Ken\u2019ei (1206\u20131207)","113":"J\u014Dgen (1207\u20131211)","114":"Kenryaku (1211\u20131213)","115":"Kenp\u014D (1213\u20131219)","116":"J\u014Dky\u016B (1219\u20131222)","117":"J\u014D\u014D (1222\u20131224)","118":"Gennin (1224\u20131225)","119":"Karoku (1225\u20131227)","120":"Antei (1227\u20131229)","121":"Kanki (1229\u20131232)","122":"J\u014Dei (1232\u20131233)","123":"Tenpuku (1233\u20131234)","124":"Bunryaku (1234\u20131235)","125":"Katei (1235\u20131238)","126":"Ryakunin (1238\u20131239)","127":"En\u2019\u014D (1239\u20131240)","128":"Ninji (1240\u20131243)","129":"Kangen (1243\u20131247)","130":"H\u014Dji (1247\u20131249)","131":"Kench\u014D (1249\u20131256)","132":"K\u014Dgen (1256\u20131257)","133":"Sh\u014Dka (1257\u20131259)","134":"Sh\u014Dgen (1259\u20131260)","135":"Bun\u2019\u014D (1260\u20131261)","136":"K\u014Dch\u014D (1261\u20131264)","137":"Bun\u2019ei (1264\u20131275)","138":"Kenji (1275\u20131278)","139":"K\u014Dan (1278\u20131288)","140":"Sh\u014D\u014D (1288\u20131293)","141":"Einin (1293\u20131299)","142":"Sh\u014Dan (1299\u20131302)","143":"Kengen (1302\u20131303)","144":"Kagen (1303\u20131306)","145":"Tokuji (1306\u20131308)","146":"Enky\u014D (1308\u20131311)","147":"\u014Cch\u014D (1311\u20131312)","148":"Sh\u014Dwa (1312\u20131317)","149":"Bunp\u014D (1317\u20131319)","150":"Gen\u014D (1319\u20131321)","151":"Genk\u014D (1321\u20131324)","152":"Sh\u014Dch\u016B (1324\u20131326)","153":"Karyaku (1326\u20131329)","154":"Gentoku (1329\u20131331)","155":"Genk\u014D (1331\u20131334)","156":"Kenmu (1334\u20131336)","157":"Engen (1336\u20131340)","158":"K\u014Dkoku (1340\u20131346)","159":"Sh\u014Dhei (1346\u20131370)","160":"Kentoku (1370\u20131372)","161":"Bunch\u016B (1372\u20131375)","162":"Tenju (1375\u20131379)","163":"K\u014Dryaku (1379\u20131381)","164":"K\u014Dwa (1381\u20131384)","165":"Gench\u016B (1384\u20131392)","166":"Meitoku (1384\u20131387)","167":"Kakei (1387\u20131389)","168":"K\u014D\u014D (1389\u20131390)","169":"Meitoku (1390\u20131394)","170":"\u014Cei (1394\u20131428)","171":"Sh\u014Dch\u014D (1428\u20131429)","172":"Eiky\u014D (1429\u20131441)","173":"Kakitsu (1441\u20131444)","174":"Bun\u2019an (1444\u20131449)","175":"H\u014Dtoku (1449\u20131452)","176":"Ky\u014Dtoku (1452\u20131455)","177":"K\u014Dsh\u014D (1455\u20131457)","178":"Ch\u014Droku (1457\u20131460)","179":"Kansh\u014D (1460\u20131466)","180":"Bunsh\u014D (1466\u20131467)","181":"\u014Cnin (1467\u20131469)","182":"Bunmei (1469\u20131487)","183":"Ch\u014Dky\u014D (1487\u20131489)","184":"Entoku (1489\u20131492)","185":"Mei\u014D (1492\u20131501)","186":"Bunki (1501\u20131504)","187":"Eish\u014D (1504\u20131521)","188":"Taiei (1521\u20131528)","189":"Ky\u014Droku (1528\u20131532)","190":"Tenbun (1532\u20131555)","191":"K\u014Dji (1555\u20131558)","192":"Eiroku (1558\u20131570)","193":"Genki (1570\u20131573)","194":"Tensh\u014D (1573\u20131592)","195":"Bunroku (1592\u20131596)","196":"Keich\u014D (1596\u20131615)","197":"Genna (1615\u20131624)","198":"Kan\u2019ei (1624\u20131644)","199":"Sh\u014Dho (1644\u20131648)","200":"Keian (1648\u20131652)","201":"J\u014D\u014D (1652\u20131655)","202":"Meireki (1655\u20131658)","203":"Manji (1658\u20131661)","204":"Kanbun (1661\u20131673)","205":"Enp\u014D (1673\u20131681)","206":"Tenna (1681\u20131684)","207":"J\u014Dky\u014D (1684\u20131688)","208":"Genroku (1688\u20131704)","209":"H\u014Dei (1704\u20131711)","210":"Sh\u014Dtoku (1711\u20131716)","211":"Ky\u014Dh\u014D (1716\u20131736)","212":"Genbun (1736\u20131741)","213":"Kanp\u014D (1741\u20131744)","214":"Enky\u014D (1744\u20131748)","215":"Kan\u2019en (1748\u20131751)","216":"H\u014Dreki (1751\u20131764)","217":"Meiwa (1764\u20131772)","218":"An\u2019ei (1772\u20131781)","219":"Tenmei (1781\u20131789)","220":"Kansei (1789\u20131801)","221":"Ky\u014Dwa (1801\u20131804)","222":"Bunka (1804\u20131818)","223":"Bunsei (1818\u20131830)","224":"Tenp\u014D (1830\u20131844)","225":"K\u014Dka (1844\u20131848)","226":"Kaei (1848\u20131854)","227":"Ansei (1854\u20131860)","228":"Man\u2019en (1860\u20131861)","229":"Bunky\u016B (1861\u20131864)","230":"Genji (1864\u20131865)","231":"Kei\u014D (1865\u20131868)","232":"Meiji","233":"Taish\u014D","234":"Sh\u014Dwa","235":"Heisei","236":"Reiwa"},"eraAbbr":{"0":"Taika (645\u2013650)","1":"Hakuchi (650\u2013671)","2":"Hakuh\u014D (672\u2013686)","3":"Shuch\u014D (686\u2013701)","4":"Taih\u014D (701\u2013704)","5":"Keiun (704\u2013708)","6":"Wad\u014D (708\u2013715)","7":"Reiki (715\u2013717)","8":"Y\u014Dr\u014D (717\u2013724)","9":"Jinki (724\u2013729)","10":"Tenpy\u014D (729\u2013749)","11":"Tenpy\u014D-kamp\u014D (749\u2013749)","12":"Tenpy\u014D-sh\u014Dh\u014D (749\u2013757)","13":"Tenpy\u014D-h\u014Dji (757\u2013765)","14":"Tenpy\u014D-jingo (765\u2013767)","15":"Jingo-keiun (767\u2013770)","16":"H\u014Dki (770\u2013780)","17":"Ten-\u014D (781\u2013782)","18":"Enryaku (782\u2013806)","19":"Daid\u014D (806\u2013810)","20":"K\u014Dnin (810\u2013824)","21":"Tench\u014D (824\u2013834)","22":"J\u014Dwa (834\u2013848)","23":"Kaj\u014D (848\u2013851)","24":"Ninju (851\u2013854)","25":"Saik\u014D (854\u2013857)","26":"Ten-an (857\u2013859)","27":"J\u014Dgan (859\u2013877)","28":"Gangy\u014D (877\u2013885)","29":"Ninna (885\u2013889)","30":"Kanpy\u014D (889\u2013898)","31":"Sh\u014Dtai (898\u2013901)","32":"Engi (901\u2013923)","33":"Ench\u014D (923\u2013931)","34":"J\u014Dhei (931\u2013938)","35":"Tengy\u014D (938\u2013947)","36":"Tenryaku (947\u2013957)","37":"Tentoku (957\u2013961)","38":"\u014Cwa (961\u2013964)","39":"K\u014Dh\u014D (964\u2013968)","40":"Anna (968\u2013970)","41":"Tenroku (970\u2013973)","42":"Ten\u2019en (973\u2013976)","43":"J\u014Dgen (976\u2013978)","44":"Tengen (978\u2013983)","45":"Eikan (983\u2013985)","46":"Kanna (985\u2013987)","47":"Eien (987\u2013989)","48":"Eiso (989\u2013990)","49":"Sh\u014Dryaku (990\u2013995)","50":"Ch\u014Dtoku (995\u2013999)","51":"Ch\u014Dh\u014D (999\u20131004)","52":"Kank\u014D (1004\u20131012)","53":"Ch\u014Dwa (1012\u20131017)","54":"Kannin (1017\u20131021)","55":"Jian (1021\u20131024)","56":"Manju (1024\u20131028)","57":"Ch\u014Dgen (1028\u20131037)","58":"Ch\u014Dryaku (1037\u20131040)","59":"Ch\u014Dky\u016B (1040\u20131044)","60":"Kantoku (1044\u20131046)","61":"Eish\u014D (1046\u20131053)","62":"Tengi (1053\u20131058)","63":"K\u014Dhei (1058\u20131065)","64":"Jiryaku (1065\u20131069)","65":"Enky\u016B (1069\u20131074)","66":"Sh\u014Dho (1074\u20131077)","67":"Sh\u014Dryaku (1077\u20131081)","68":"Eih\u014D (1081\u20131084)","69":"\u014Ctoku (1084\u20131087)","70":"Kanji (1087\u20131094)","71":"Kah\u014D (1094\u20131096)","72":"Eich\u014D (1096\u20131097)","73":"J\u014Dtoku (1097\u20131099)","74":"K\u014Dwa (1099\u20131104)","75":"Ch\u014Dji (1104\u20131106)","76":"Kash\u014D (1106\u20131108)","77":"Tennin (1108\u20131110)","78":"Ten-ei (1110\u20131113)","79":"Eiky\u016B (1113\u20131118)","80":"Gen\u2019ei (1118\u20131120)","81":"H\u014Dan (1120\u20131124)","82":"Tenji (1124\u20131126)","83":"Daiji (1126\u20131131)","84":"Tensh\u014D (1131\u20131132)","85":"Ch\u014Dsh\u014D (1132\u20131135)","86":"H\u014Den (1135\u20131141)","87":"Eiji (1141\u20131142)","88":"K\u014Dji (1142\u20131144)","89":"Ten\u2019y\u014D (1144\u20131145)","90":"Ky\u016Ban (1145\u20131151)","91":"Ninpei (1151\u20131154)","92":"Ky\u016Bju (1154\u20131156)","93":"H\u014Dgen (1156\u20131159)","94":"Heiji (1159\u20131160)","95":"Eiryaku (1160\u20131161)","96":"\u014Cho (1161\u20131163)","97":"Ch\u014Dkan (1163\u20131165)","98":"Eiman (1165\u20131166)","99":"Nin\u2019an (1166\u20131169)","100":"Ka\u014D (1169\u20131171)","101":"Sh\u014Dan (1171\u20131175)","102":"Angen (1175\u20131177)","103":"Jish\u014D (1177\u20131181)","104":"Y\u014Dwa (1181\u20131182)","105":"Juei (1182\u20131184)","106":"Genryaku (1184\u20131185)","107":"Bunji (1185\u20131190)","108":"Kenky\u016B (1190\u20131199)","109":"Sh\u014Dji (1199\u20131201)","110":"Kennin (1201\u20131204)","111":"Genky\u016B (1204\u20131206)","112":"Ken\u2019ei (1206\u20131207)","113":"J\u014Dgen (1207\u20131211)","114":"Kenryaku (1211\u20131213)","115":"Kenp\u014D (1213\u20131219)","116":"J\u014Dky\u016B (1219\u20131222)","117":"J\u014D\u014D (1222\u20131224)","118":"Gennin (1224\u20131225)","119":"Karoku (1225\u20131227)","120":"Antei (1227\u20131229)","121":"Kanki (1229\u20131232)","122":"J\u014Dei (1232\u20131233)","123":"Tenpuku (1233\u20131234)","124":"Bunryaku (1234\u20131235)","125":"Katei (1235\u20131238)","126":"Ryakunin (1238\u20131239)","127":"En\u2019\u014D (1239\u20131240)","128":"Ninji (1240\u20131243)","129":"Kangen (1243\u20131247)","130":"H\u014Dji (1247\u20131249)","131":"Kench\u014D (1249\u20131256)","132":"K\u014Dgen (1256\u20131257)","133":"Sh\u014Dka (1257\u20131259)","134":"Sh\u014Dgen (1259\u20131260)","135":"Bun\u2019\u014D (1260\u20131261)","136":"K\u014Dch\u014D (1261\u20131264)","137":"Bun\u2019ei (1264\u20131275)","138":"Kenji (1275\u20131278)","139":"K\u014Dan (1278\u20131288)","140":"Sh\u014D\u014D (1288\u20131293)","141":"Einin (1293\u20131299)","142":"Sh\u014Dan (1299\u20131302)","143":"Kengen (1302\u20131303)","144":"Kagen (1303\u20131306)","145":"Tokuji (1306\u20131308)","146":"Enky\u014D (1308\u20131311)","147":"\u014Cch\u014D (1311\u20131312)","148":"Sh\u014Dwa (1312\u20131317)","149":"Bunp\u014D (1317\u20131319)","150":"Gen\u014D (1319\u20131321)","151":"Genk\u014D (1321\u20131324)","152":"Sh\u014Dch\u016B (1324\u20131326)","153":"Karyaku (1326\u20131329)","154":"Gentoku (1329\u20131331)","155":"Genk\u014D (1331\u20131334)","156":"Kenmu (1334\u20131336)","157":"Engen (1336\u20131340)","158":"K\u014Dkoku (1340\u20131346)","159":"Sh\u014Dhei (1346\u20131370)","160":"Kentoku (1370\u20131372)","161":"Bunch\u016B (1372\u20131375)","162":"Tenju (1375\u20131379)","163":"K\u014Dryaku (1379\u20131381)","164":"K\u014Dwa (1381\u20131384)","165":"Gench\u016B (1384\u20131392)","166":"Meitoku (1384\u20131387)","167":"Kakei (1387\u20131389)","168":"K\u014D\u014D (1389\u20131390)","169":"Meitoku (1390\u20131394)","170":"\u014Cei (1394\u20131428)","171":"Sh\u014Dch\u014D (1428\u20131429)","172":"Eiky\u014D (1429\u20131441)","173":"Kakitsu (1441\u20131444)","174":"Bun\u2019an (1444\u20131449)","175":"H\u014Dtoku (1449\u20131452)","176":"Ky\u014Dtoku (1452\u20131455)","177":"K\u014Dsh\u014D (1455\u20131457)","178":"Ch\u014Droku (1457\u20131460)","179":"Kansh\u014D (1460\u20131466)","180":"Bunsh\u014D (1466\u20131467)","181":"\u014Cnin (1467\u20131469)","182":"Bunmei (1469\u20131487)","183":"Ch\u014Dky\u014D (1487\u20131489)","184":"Entoku (1489\u20131492)","185":"Mei\u014D (1492\u20131501)","186":"Bunki (1501\u20131504)","187":"Eish\u014D (1504\u20131521)","188":"Taiei (1521\u20131528)","189":"Ky\u014Droku (1528\u20131532)","190":"Tenbun (1532\u20131555)","191":"K\u014Dji (1555\u20131558)","192":"Eiroku (1558\u20131570)","193":"Genki (1570\u20131573)","194":"Tensh\u014D (1573\u20131592)","195":"Bunroku (1592\u20131596)","196":"Keich\u014D (1596\u20131615)","197":"Genna (1615\u20131624)","198":"Kan\u2019ei (1624\u20131644)","199":"Sh\u014Dho (1644\u20131648)","200":"Keian (1648\u20131652)","201":"J\u014D\u014D (1652\u20131655)","202":"Meireki (1655\u20131658)","203":"Manji (1658\u20131661)","204":"Kanbun (1661\u20131673)","205":"Enp\u014D (1673\u20131681)","206":"Tenna (1681\u20131684)","207":"J\u014Dky\u014D (1684\u20131688)","208":"Genroku (1688\u20131704)","209":"H\u014Dei (1704\u20131711)","210":"Sh\u014Dtoku (1711\u20131716)","211":"Ky\u014Dh\u014D (1716\u20131736)","212":"Genbun (1736\u20131741)","213":"Kanp\u014D (1741\u20131744)","214":"Enky\u014D (1744\u20131748)","215":"Kan\u2019en (1748\u20131751)","216":"H\u014Dreki (1751\u20131764)","217":"Meiwa (1764\u20131772)","218":"An\u2019ei (1772\u20131781)","219":"Tenmei (1781\u20131789)","220":"Kansei (1789\u20131801)","221":"Ky\u014Dwa (1801\u20131804)","222":"Bunka (1804\u20131818)","223":"Bunsei (1818\u20131830)","224":"Tenp\u014D (1830\u20131844)","225":"K\u014Dka (1844\u20131848)","226":"Kaei (1848\u20131854)","227":"Ansei (1854\u20131860)","228":"Man\u2019en (1860\u20131861)","229":"Bunky\u016B (1861\u20131864)","230":"Genji (1864\u20131865)","231":"Kei\u014D (1865\u20131868)","232":"Meiji","233":"Taish\u014D","234":"Sh\u014Dwa","235":"Heisei","236":"Reiwa"},"eraNarrow":{"0":"Taika (645\u2013650)","1":"Hakuchi (650\u2013671)","2":"Hakuh\u014D (672\u2013686)","3":"Shuch\u014D (686\u2013701)","4":"Taih\u014D (701\u2013704)","5":"Keiun (704\u2013708)","6":"Wad\u014D (708\u2013715)","7":"Reiki (715\u2013717)","8":"Y\u014Dr\u014D (717\u2013724)","9":"Jinki (724\u2013729)","10":"Tenpy\u014D (729\u2013749)","11":"Tenpy\u014D-kamp\u014D (749\u2013749)","12":"Tenpy\u014D-sh\u014Dh\u014D (749\u2013757)","13":"Tenpy\u014D-h\u014Dji (757\u2013765)","14":"Tenpy\u014D-jingo (765\u2013767)","15":"Jingo-keiun (767\u2013770)","16":"H\u014Dki (770\u2013780)","17":"Ten-\u014D (781\u2013782)","18":"Enryaku (782\u2013806)","19":"Daid\u014D (806\u2013810)","20":"K\u014Dnin (810\u2013824)","21":"Tench\u014D (824\u2013834)","22":"J\u014Dwa (834\u2013848)","23":"Kaj\u014D (848\u2013851)","24":"Ninju (851\u2013854)","25":"Saik\u014D (854\u2013857)","26":"Ten-an (857\u2013859)","27":"J\u014Dgan (859\u2013877)","28":"Gangy\u014D (877\u2013885)","29":"Ninna (885\u2013889)","30":"Kanpy\u014D (889\u2013898)","31":"Sh\u014Dtai (898\u2013901)","32":"Engi (901\u2013923)","33":"Ench\u014D (923\u2013931)","34":"J\u014Dhei (931\u2013938)","35":"Tengy\u014D (938\u2013947)","36":"Tenryaku (947\u2013957)","37":"Tentoku (957\u2013961)","38":"\u014Cwa (961\u2013964)","39":"K\u014Dh\u014D (964\u2013968)","40":"Anna (968\u2013970)","41":"Tenroku (970\u2013973)","42":"Ten\u2019en (973\u2013976)","43":"J\u014Dgen (976\u2013978)","44":"Tengen (978\u2013983)","45":"Eikan (983\u2013985)","46":"Kanna (985\u2013987)","47":"Eien (987\u2013989)","48":"Eiso (989\u2013990)","49":"Sh\u014Dryaku (990\u2013995)","50":"Ch\u014Dtoku (995\u2013999)","51":"Ch\u014Dh\u014D (999\u20131004)","52":"Kank\u014D (1004\u20131012)","53":"Ch\u014Dwa (1012\u20131017)","54":"Kannin (1017\u20131021)","55":"Jian (1021\u20131024)","56":"Manju (1024\u20131028)","57":"Ch\u014Dgen (1028\u20131037)","58":"Ch\u014Dryaku (1037\u20131040)","59":"Ch\u014Dky\u016B (1040\u20131044)","60":"Kantoku (1044\u20131046)","61":"Eish\u014D (1046\u20131053)","62":"Tengi (1053\u20131058)","63":"K\u014Dhei (1058\u20131065)","64":"Jiryaku (1065\u20131069)","65":"Enky\u016B (1069\u20131074)","66":"Sh\u014Dho (1074\u20131077)","67":"Sh\u014Dryaku (1077\u20131081)","68":"Eih\u014D (1081\u20131084)","69":"\u014Ctoku (1084\u20131087)","70":"Kanji (1087\u20131094)","71":"Kah\u014D (1094\u20131096)","72":"Eich\u014D (1096\u20131097)","73":"J\u014Dtoku (1097\u20131099)","74":"K\u014Dwa (1099\u20131104)","75":"Ch\u014Dji (1104\u20131106)","76":"Kash\u014D (1106\u20131108)","77":"Tennin (1108\u20131110)","78":"Ten-ei (1110\u20131113)","79":"Eiky\u016B (1113\u20131118)","80":"Gen\u2019ei (1118\u20131120)","81":"H\u014Dan (1120\u20131124)","82":"Tenji (1124\u20131126)","83":"Daiji (1126\u20131131)","84":"Tensh\u014D (1131\u20131132)","85":"Ch\u014Dsh\u014D (1132\u20131135)","86":"H\u014Den (1135\u20131141)","87":"Eiji (1141\u20131142)","88":"K\u014Dji (1142\u20131144)","89":"Ten\u2019y\u014D (1144\u20131145)","90":"Ky\u016Ban (1145\u20131151)","91":"Ninpei (1151\u20131154)","92":"Ky\u016Bju (1154\u20131156)","93":"H\u014Dgen (1156\u20131159)","94":"Heiji (1159\u20131160)","95":"Eiryaku (1160\u20131161)","96":"\u014Cho (1161\u20131163)","97":"Ch\u014Dkan (1163\u20131165)","98":"Eiman (1165\u20131166)","99":"Nin\u2019an (1166\u20131169)","100":"Ka\u014D (1169\u20131171)","101":"Sh\u014Dan (1171\u20131175)","102":"Angen (1175\u20131177)","103":"Jish\u014D (1177\u20131181)","104":"Y\u014Dwa (1181\u20131182)","105":"Juei (1182\u20131184)","106":"Genryaku (1184\u20131185)","107":"Bunji (1185\u20131190)","108":"Kenky\u016B (1190\u20131199)","109":"Sh\u014Dji (1199\u20131201)","110":"Kennin (1201\u20131204)","111":"Genky\u016B (1204\u20131206)","112":"Ken\u2019ei (1206\u20131207)","113":"J\u014Dgen (1207\u20131211)","114":"Kenryaku (1211\u20131213)","115":"Kenp\u014D (1213\u20131219)","116":"J\u014Dky\u016B (1219\u20131222)","117":"J\u014D\u014D (1222\u20131224)","118":"Gennin (1224\u20131225)","119":"Karoku (1225\u20131227)","120":"Antei (1227\u20131229)","121":"Kanki (1229\u20131232)","122":"J\u014Dei (1232\u20131233)","123":"Tenpuku (1233\u20131234)","124":"Bunryaku (1234\u20131235)","125":"Katei (1235\u20131238)","126":"Ryakunin (1238\u20131239)","127":"En\u2019\u014D (1239\u20131240)","128":"Ninji (1240\u20131243)","129":"Kangen (1243\u20131247)","130":"H\u014Dji (1247\u20131249)","131":"Kench\u014D (1249\u20131256)","132":"K\u014Dgen (1256\u20131257)","133":"Sh\u014Dka (1257\u20131259)","134":"Sh\u014Dgen (1259\u20131260)","135":"Bun\u2019\u014D (1260\u20131261)","136":"K\u014Dch\u014D (1261\u20131264)","137":"Bun\u2019ei (1264\u20131275)","138":"Kenji (1275\u20131278)","139":"K\u014Dan (1278\u20131288)","140":"Sh\u014D\u014D (1288\u20131293)","141":"Einin (1293\u20131299)","142":"Sh\u014Dan (1299\u20131302)","143":"Kengen (1302\u20131303)","144":"Kagen (1303\u20131306)","145":"Tokuji (1306\u20131308)","146":"Enky\u014D (1308\u20131311)","147":"\u014Cch\u014D (1311\u20131312)","148":"Sh\u014Dwa (1312\u20131317)","149":"Bunp\u014D (1317\u20131319)","150":"Gen\u014D (1319\u20131321)","151":"Genk\u014D (1321\u20131324)","152":"Sh\u014Dch\u016B (1324\u20131326)","153":"Karyaku (1326\u20131329)","154":"Gentoku (1329\u20131331)","155":"Genk\u014D (1331\u20131334)","156":"Kenmu (1334\u20131336)","157":"Engen (1336\u20131340)","158":"K\u014Dkoku (1340\u20131346)","159":"Sh\u014Dhei (1346\u20131370)","160":"Kentoku (1370\u20131372)","161":"Bunch\u016B (1372\u20131375)","162":"Tenju (1375\u20131379)","163":"K\u014Dryaku (1379\u20131381)","164":"K\u014Dwa (1381\u20131384)","165":"Gench\u016B (1384\u20131392)","166":"Meitoku (1384\u20131387)","167":"Kakei (1387\u20131389)","168":"K\u014D\u014D (1389\u20131390)","169":"Meitoku (1390\u20131394)","170":"\u014Cei (1394\u20131428)","171":"Sh\u014Dch\u014D (1428\u20131429)","172":"Eiky\u014D (1429\u20131441)","173":"Kakitsu (1441\u20131444)","174":"Bun\u2019an (1444\u20131449)","175":"H\u014Dtoku (1449\u20131452)","176":"Ky\u014Dtoku (1452\u20131455)","177":"K\u014Dsh\u014D (1455\u20131457)","178":"Ch\u014Droku (1457\u20131460)","179":"Kansh\u014D (1460\u20131466)","180":"Bunsh\u014D (1466\u20131467)","181":"\u014Cnin (1467\u20131469)","182":"Bunmei (1469\u20131487)","183":"Ch\u014Dky\u014D (1487\u20131489)","184":"Entoku (1489\u20131492)","185":"Mei\u014D (1492\u20131501)","186":"Bunki (1501\u20131504)","187":"Eish\u014D (1504\u20131521)","188":"Taiei (1521\u20131528)","189":"Ky\u014Droku (1528\u20131532)","190":"Tenbun (1532\u20131555)","191":"K\u014Dji (1555\u20131558)","192":"Eiroku (1558\u20131570)","193":"Genki (1570\u20131573)","194":"Tensh\u014D (1573\u20131592)","195":"Bunroku (1592\u20131596)","196":"Keich\u014D (1596\u20131615)","197":"Genna (1615\u20131624)","198":"Kan\u2019ei (1624\u20131644)","199":"Sh\u014Dho (1644\u20131648)","200":"Keian (1648\u20131652)","201":"J\u014D\u014D (1652\u20131655)","202":"Meireki (1655\u20131658)","203":"Manji (1658\u20131661)","204":"Kanbun (1661\u20131673)","205":"Enp\u014D (1673\u20131681)","206":"Tenna (1681\u20131684)","207":"J\u014Dky\u014D (1684\u20131688)","208":"Genroku (1688\u20131704)","209":"H\u014Dei (1704\u20131711)","210":"Sh\u014Dtoku (1711\u20131716)","211":"Ky\u014Dh\u014D (1716\u20131736)","212":"Genbun (1736\u20131741)","213":"Kanp\u014D (1741\u20131744)","214":"Enky\u014D (1744\u20131748)","215":"Kan\u2019en (1748\u20131751)","216":"H\u014Dreki (1751\u20131764)","217":"Meiwa (1764\u20131772)","218":"An\u2019ei (1772\u20131781)","219":"Tenmei (1781\u20131789)","220":"Kansei (1789\u20131801)","221":"Ky\u014Dwa (1801\u20131804)","222":"Bunka (1804\u20131818)","223":"Bunsei (1818\u20131830)","224":"Tenp\u014D (1830\u20131844)","225":"K\u014Dka (1844\u20131848)","226":"Kaei (1848\u20131854)","227":"Ansei (1854\u20131860)","228":"Man\u2019en (1860\u20131861)","229":"Bunky\u016B (1861\u20131864)","230":"Genji (1864\u20131865)","231":"Kei\u014D (1865\u20131868)","232":"M","233":"T","234":"S","235":"H","236":"R"}},"months":{"format":{"abbreviated":{"1":"Jan","2":"Feb","3":"Mar","4":"Apr","5":"May","6":"Jun","7":"Jul","8":"Aug","9":"Sep","10":"Oct","11":"Nov","12":"Dec"},"narrow":{"1":"J","2":"F","3":"M","4":"A","5":"M","6":"J","7":"J","8":"A","9":"S","10":"O","11":"N","12":"D"},"wide":{"1":"January","2":"February","3":"March","4":"April","5":"May","6":"June","7":"July","8":"August","9":"September","10":"October","11":"November","12":"December"}},"stand-alone":{"abbreviated":{"1":"Jan","2":"Feb","3":"Mar","4":"Apr","5":"May","6":"Jun","7":"Jul","8":"Aug","9":"Sep","10":"Oct","11":"Nov","12":"Dec"},"narrow":{"1":"J","2":"F","3":"M","4":"A","5":"M","6":"J","7":"J","8":"A","9":"S","10":"O","11":"N","12":"D"},"wide":{"1":"January","2":"February","3":"March","4":"April","5":"May","6":"June","7":"July","8":"August","9":"September","10":"October","11":"November","12":"December"}}},"quarters":{"format":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}},"stand-alone":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}}}},"persian":{"dayPeriods":{"format":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"narrow":{"midnight":"mi","am":"a","am-alt-variant":"am","noon":"n","pm":"p","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"}},"stand-alone":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"narrow":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"}}},"days":{"format":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}},"stand-alone":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}}},"eras":{"eraNames":{"0":"AP"},"eraAbbr":{"0":"AP"},"eraNarrow":{"0":"AP"}},"months":{"format":{"abbreviated":{"1":"Farvardin","2":"Ordibehesht","3":"Khordad","4":"Tir","5":"Mordad","6":"Shahrivar","7":"Mehr","8":"Aban","9":"Azar","10":"Dey","11":"Bahman","12":"Esfand"},"narrow":{"1":"1","2":"2","3":"3","4":"4","5":"5","6":"6","7":"7","8":"8","9":"9","10":"10","11":"11","12":"12"},"wide":{"1":"Farvardin","2":"Ordibehesht","3":"Khordad","4":"Tir","5":"Mordad","6":"Shahrivar","7":"Mehr","8":"Aban","9":"Azar","10":"Dey","11":"Bahman","12":"Esfand"}},"stand-alone":{"abbreviated":{"1":"Farvardin","2":"Ordibehesht","3":"Khordad","4":"Tir","5":"Mordad","6":"Shahrivar","7":"Mehr","8":"Aban","9":"Azar","10":"Dey","11":"Bahman","12":"Esfand"},"narrow":{"1":"1","2":"2","3":"3","4":"4","5":"5","6":"6","7":"7","8":"8","9":"9","10":"10","11":"11","12":"12"},"wide":{"1":"Farvardin","2":"Ordibehesht","3":"Khordad","4":"Tir","5":"Mordad","6":"Shahrivar","7":"Mehr","8":"Aban","9":"Azar","10":"Dey","11":"Bahman","12":"Esfand"}}},"quarters":{"format":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}},"stand-alone":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}}}},"roc":{"dayPeriods":{"format":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"narrow":{"midnight":"mi","am":"a","am-alt-variant":"am","noon":"n","pm":"p","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"in the morning","afternoon1":"in the afternoon","evening1":"in the evening","night1":"at night"}},"stand-alone":{"abbreviated":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"narrow":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"},"wide":{"midnight":"midnight","am":"AM","am-alt-variant":"am","noon":"noon","pm":"PM","pm-alt-variant":"pm","morning1":"morning","afternoon1":"afternoon","evening1":"evening","night1":"night"}}},"days":{"format":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}},"stand-alone":{"abbreviated":{"sun":"Sun","mon":"Mon","tue":"Tue","wed":"Wed","thu":"Thu","fri":"Fri","sat":"Sat"},"narrow":{"sun":"S","mon":"M","tue":"T","wed":"W","thu":"T","fri":"F","sat":"S"},"short":{"sun":"Su","mon":"Mo","tue":"Tu","wed":"We","thu":"Th","fri":"Fr","sat":"Sa"},"wide":{"sun":"Sunday","mon":"Monday","tue":"Tuesday","wed":"Wednesday","thu":"Thursday","fri":"Friday","sat":"Saturday"}}},"eras":{"eraNames":{"0":"Before R.O.C.","1":"Minguo"},"eraAbbr":{"0":"Before R.O.C.","1":"Minguo"},"eraNarrow":{"0":"Before R.O.C.","1":"Minguo"}},"months":{"format":{"abbreviated":{"1":"Jan","2":"Feb","3":"Mar","4":"Apr","5":"May","6":"Jun","7":"Jul","8":"Aug","9":"Sep","10":"Oct","11":"Nov","12":"Dec"},"narrow":{"1":"J","2":"F","3":"M","4":"A","5":"M","6":"J","7":"J","8":"A","9":"S","10":"O","11":"N","12":"D"},"wide":{"1":"January","2":"February","3":"March","4":"April","5":"May","6":"June","7":"July","8":"August","9":"September","10":"October","11":"November","12":"December"}},"stand-alone":{"abbreviated":{"1":"Jan","2":"Feb","3":"Mar","4":"Apr","5":"May","6":"Jun","7":"Jul","8":"Aug","9":"Sep","10":"Oct","11":"Nov","12":"Dec"},"narrow":{"1":"J","2":"F","3":"M","4":"A","5":"M","6":"J","7":"J","8":"A","9":"S","10":"O","11":"N","12":"D"},"wide":{"1":"January","2":"February","3":"March","4":"April","5":"May","6":"June","7":"July","8":"August","9":"September","10":"October","11":"November","12":"December"}}},"quarters":{"format":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}},"stand-alone":{"abbreviated":{"1":"Q1","2":"Q2","3":"Q3","4":"Q4"},"narrow":{"1":"1","2":"2","3":"3","4":"4"},"wide":{"1":"1st quarter","2":"2nd quarter","3":"3rd quarter","4":"4th quarter"}}}}}'), {
    tmpl: _tmpl$a,
    sel: "lwc-components-lightning-scopedImports"
  });
  const ISO8601_STRICT_PATTERN = /^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d[:]?\d\d)|Z)?)?)?)?$/i;
  const ISO8601_TIME_PATTERN = /^\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d[:]?\d\d)|Z)?$/i;
  const STANDARD_TIME_FORMAT = "HH:mm:ss.SSS";
  const STANDARD_DATE_FORMAT = "YYYY-MM-DD";
  const TIME_SEPARATOR = "T";
  const TIMEZONE_INDICATOR = /(Z|([+-])(\d{2})[:]?(\d{2}))$/i;
  function isValidISODateTimeString(dateTimeString) {
    return isValidISO8601String(dateTimeString) && isValidDate(dateTimeString);
  }
  function isValidISOTimeString(timeString) {
    if (!isValidISO8601TimeString(timeString)) {
      return false;
    }
    const timeOnly = removeTimeZoneSuffix(timeString);
    return isValidDate(`2018-09-09T${timeOnly}Z`);
  }
  function removeTimeZoneSuffix(dateTimeString) {
    if (typeof dateTimeString === "string") {
      return dateTimeString.split(TIMEZONE_INDICATOR)[0];
    }
    return dateTimeString;
  }
  function isValidISO8601String(dateTimeString) {
    if (typeof dateTimeString !== "string") {
      return false;
    }
    return ISO8601_STRICT_PATTERN.test(dateTimeString);
  }
  function isValidISO8601TimeString(timeString) {
    if (typeof timeString !== "string") {
      return false;
    }
    return ISO8601_TIME_PATTERN.test(timeString);
  }
  function isValidDate(value) {
    const timeStamp = Date.parse(value);
    return isFinite(timeStamp);
  }
  var labelSecondsLater = "in a few seconds";
  var labelSecondsAgo = "a few seconds ago";
  const classNamesHash = (classes) => {
    return typeof classes === "string" ? classes.trim().split(/\s+/).reduce((acc, cn) => {
      acc[cn] = true;
      return acc;
    }, {}) : classes;
  };
  const proto = {
    add(className) {
      Object.assign(this, classNamesHash(className));
      return this;
    },
    invert() {
      Object.keys(this).forEach((key) => {
        this[key] = !this[key];
      });
      return this;
    },
    toString() {
      return Object.keys(this).filter((key) => this[key]).join(" ");
    }
  };
  function classSet(config2) {
    return Object.assign(Object.create(proto), classNamesHash(config2));
  }
  function formatLabel(str) {
    const args = Array.prototype.slice.call(arguments, 1);
    let replacements = args;
    if (Array.isArray(args[0])) {
      [replacements] = args;
    }
    return str.replace(/{(\d+)}/g, (match, i) => {
      const replacement = replacements[i];
      return replacement !== null && replacement !== void 0 ? replacement : "";
    });
  }
  const fallbackFutureLabel = "in {0} {1}";
  const fallbackPastLabel = "{0} {1} ago";
  const fallbackPluralSuffix = "s";
  const units = {
    SECONDS: {
      name: "second",
      threshold: 45
    },
    MINUTES: {
      name: "minute",
      threshold: 45
    },
    HOURS: {
      name: "hour",
      threshold: 22
    },
    DAYS: {
      name: "day",
      threshold: 26
    },
    MONTHS: {
      name: "month",
      threshold: 11
    },
    YEARS: {
      name: "year"
    }
  };
  const SECOND_TO_MILLISECONDS = 1e3;
  const MINUTE_TO_MILLISECONDS = 6e4;
  const HOUR_TO_MILLISECONDS = 36e5;
  const DAY_TO_MILLISECONDS = 864e5;
  class Duration {
    constructor(milliseconds) {
      this.milliseconds = 0;
      if (typeof milliseconds !== "number") {
        this.isValid = false;
        console.warn(`The value of milliseconds passed into Duration must be of type number,
                but we are getting the ${typeof milliseconds} value "${milliseconds}" instead.
                `);
        return;
      }
      this.isValid = true;
      this.milliseconds = milliseconds;
    }
    humanize(locale) {
      if (!this.isValid) {
        return "";
      }
      const unit = findBestUnitMatch(this);
      if (unit === units.SECONDS) {
        const isLater = this.milliseconds > 0;
        return isLater ? labelSecondsLater : labelSecondsAgo;
      }
      return format(locale, this.asIn(unit), unit.name);
    }
    asIn(unit) {
      switch (unit) {
        case units.SECONDS:
          return Math.round(this.milliseconds / SECOND_TO_MILLISECONDS);
        case units.MINUTES:
          return Math.round(this.milliseconds / MINUTE_TO_MILLISECONDS);
        case units.HOURS:
          return Math.round(this.milliseconds / HOUR_TO_MILLISECONDS);
        case units.DAYS:
          return Math.round(this.milliseconds / DAY_TO_MILLISECONDS);
        case units.MONTHS:
          return Math.round(daysToMonth(this.milliseconds / DAY_TO_MILLISECONDS));
        case units.YEARS:
        default:
          return Math.round(daysToMonth(this.milliseconds / DAY_TO_MILLISECONDS) / 12);
      }
    }
  }
  _2_41_4.registerDecorators(Duration, {
    fields: ["milliseconds"]
  });
  var Duration$1 = _2_41_4.registerComponent(Duration, {
    tmpl: _tmpl$a,
    sel: "lightning-configProvider"
  });
  function daysToMonth(days) {
    const daysToMonthRatio = 4800 / 146097;
    return days * daysToMonthRatio;
  }
  function findBestUnitMatch(duration2) {
    const match = Object.keys(units).find((key) => {
      const unit = units[key];
      return unit === units.YEARS || Math.abs(duration2.asIn(unit)) < unit.threshold;
    });
    return units[match];
  }
  function format(locale, value, unit) {
    if ("Intl" in window && Intl.RelativeTimeFormat) {
      const formatter = new Intl.RelativeTimeFormat(locale, {
        style: "long",
        numeric: "always"
      });
      return formatter.format(value, unit);
    }
    return fallbackFormatter(value, unit);
  }
  function fallbackFormatter(value, unit) {
    console.warn(`The current environment does not support formatters for relative time.`);
    const absoluteValue = Math.abs(value);
    const unitString = absoluteValue !== 1 ? unit + fallbackPluralSuffix : unit;
    const label = value > 0 ? fallbackFutureLabel : fallbackPastLabel;
    return formatLabel(label, absoluteValue, unitString);
  }
  const MONTH_NAMES = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  const DATE_FORMAT = {
    short: "M/d/yyyy",
    medium: "MMM d, yyyy",
    long: "MMMM d, yyyy"
  };
  const TIME_FORMAT = {
    short: "h:mm a",
    medium: "h:mm:ss a",
    long: "h:mm:ss a"
  };
  const TIME_FORMAT_SIMPLE = {
    short: "h:m a",
    medium: "h:m:s a",
    long: "h:m:s a"
  };
  function formatDate(value, format2) {
    let isUTC = false;
    let dateString = value;
    if (typeof value === "string") {
      dateString = value.split(TIME_SEPARATOR)[0];
      isUTC = true;
    }
    return formatDateInternal(dateString, format2, isUTC);
  }
  function formatDateUTC(value, format2) {
    return formatDateInternal(value, format2, true);
  }
  function formatTime(date, format2) {
    if (!isDate(date)) {
      return new Date("");
    }
    const hours = (date.getHours() + 11) % 12 + 1;
    const suffix = date.getHours() >= 12 ? "PM" : "AM";
    switch (format2) {
      case STANDARD_TIME_FORMAT:
        return `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${doublePad(date.getMilliseconds())}`;
      case TIME_FORMAT.short:
        return `${hours}:${pad(date.getMinutes())} ${suffix}`;
      case TIME_FORMAT.medium:
      case TIME_FORMAT.long:
      default:
        return `${hours}:${pad(date.getMinutes())}:${pad(date.getSeconds())} ${suffix}`;
    }
  }
  function formatDateTimeUTC(value) {
    if (!isDate(value)) {
      return new Date("");
    }
    const date = new Date(value.getTime());
    return `${formatDateUTC(date)}, ${formatTime(addTimezoneOffset(date))}`;
  }
  function parseDateTimeISO8601(value) {
    let isoString = null;
    let shouldAddOffset = true;
    if (isValidISOTimeString(value)) {
      isoString = `${getTodayInISO()}T${addTimezoneSuffix(value)}`;
    } else if (isValidISODateTimeString(value)) {
      if (value.indexOf(TIME_SEPARATOR) > 0) {
        isoString = addTimezoneSuffix(value);
        shouldAddOffset = false;
      } else {
        isoString = `${value}T00:00:00.000Z`;
      }
    }
    if (isoString) {
      const parsedDate = new Date(isoString);
      if (shouldAddOffset) {
        addTimezoneOffset(parsedDate);
      }
      return parsedDate;
    }
    return null;
  }
  function parseDateTime(value, format2) {
    if (format2 === STANDARD_DATE_FORMAT && isValidISODateTimeString(value)) {
      return parseDateTimeISO8601(value);
    }
    if (Object.values(DATE_FORMAT).includes(format2)) {
      return parseFormattedDate(value, format2);
    }
    if (Object.values(TIME_FORMAT_SIMPLE).includes(format2)) {
      return parseFormattedTime(value);
    }
    return null;
  }
  function parseDateTimeUTC(value) {
    return parseDateTimeISO8601(addTimezoneSuffix(value));
  }
  function isBefore(date1, date2, unit) {
    const normalizedDate1 = getDate(date1);
    const normalizedDate2 = getDate(date2);
    if (!normalizedDate1 || !normalizedDate2) {
      return false;
    }
    return startOf(normalizedDate1, unit).getTime() < startOf(normalizedDate2, unit).getTime();
  }
  function isAfter(date1, date2, unit) {
    const normalizedDate1 = getDate(date1);
    const normalizedDate2 = getDate(date2);
    if (!normalizedDate1 || !normalizedDate2) {
      return false;
    }
    return startOf(normalizedDate1, unit).getTime() > startOf(normalizedDate2, unit).getTime();
  }
  function UTCToWallTime(date, timezone, callback) {
    const utcDate = new Date(date.getTime());
    callback(subtractTimezoneOffset(utcDate));
  }
  function WallTimeToUTC(date, timezone, callback) {
    const localDate = new Date(date.getTime());
    callback(addTimezoneOffset(localDate));
  }
  function translateToOtherCalendar(date) {
    return date;
  }
  function translateFromOtherCalendar(date) {
    return date;
  }
  function translateToLocalizedDigits(input) {
    return input;
  }
  function translateFromLocalizedDigits(input) {
    return input;
  }
  function getNumberFormat() {
    return {
      format: (value) => {
        console.warn(`The current environment does not support large numbers and the original value of ${value} will be returned.`);
        return value;
      }
    };
  }
  function duration(minutes) {
    return new Duration$1(minutes * 60 * 1e3);
  }
  function displayDuration(value) {
    return value.humanize("en");
  }
  function parseFormattedTime(value) {
    const values = value.trim().split(/[:.\s*]/);
    const length = values.length;
    if (!values || length < 2 || length > 5) {
      return null;
    }
    const ampm = values[length - 1];
    const isBeforeNoon = ampm.toLowerCase() === "am";
    const isAfternoon = ampm.toLowerCase() === "pm";
    values.splice(-1, 1);
    const allNumbers = values.every((item) => !isNaN(item));
    if (!isAfternoon && !isBeforeNoon || !allNumbers) {
      return null;
    }
    const hours = values[0];
    const hour24 = pad(isAfternoon ? hours % 12 + 12 : hours % 12);
    const minutes = length >= 3 && values[1] || "0";
    const seconds = length >= 4 && values[2] || "0";
    const milliseconds = length === 5 && values[3] || "0";
    const newDate = new Date(getTodayInISO());
    newDate.setHours(hour24, minutes, seconds, milliseconds);
    return isDate(newDate) ? newDate : null;
  }
  function parseFormattedDate(value, format2) {
    let pattern = /^([a-zA-Z]{3})\s*(\d{1,2}),\s*(\d{4})$/;
    switch (format2) {
      case DATE_FORMAT.short:
        pattern = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/;
        break;
      case DATE_FORMAT.long:
        pattern = /^([a-zA-Z]+)\s*(\d{1,2}),\s*(\d{4})$/;
        break;
    }
    const match = pattern.exec(value.trim());
    if (!match) {
      return null;
    }
    let month = match[1];
    const day = match[2];
    const year = match[3];
    if (format2 !== DATE_FORMAT.short) {
      month = MONTH_NAMES.findIndex((item) => item.toLowerCase().includes(month.toLowerCase()));
      month += 1;
    }
    const isoValue = `${year}-${pad(month)}-${pad(day)}`;
    const newDate = new Date(`${isoValue}T00:00:00.000Z`);
    return isDate(newDate) ? addTimezoneOffset(newDate) : null;
  }
  function formatDateInternal(value, format2, isUTC) {
    const date = getDate(value);
    if (!date) {
      return new Date("");
    }
    if (isUTC && isDate(value)) {
      addTimezoneOffset(date);
    }
    switch (format2) {
      case STANDARD_DATE_FORMAT:
        return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
      case DATE_FORMAT.short:
        return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
      case DATE_FORMAT.long:
        return `${MONTH_NAMES[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
      case DATE_FORMAT.medium:
      default: {
        const shortMonthName = MONTH_NAMES[date.getMonth()].substring(0, 3);
        return `${shortMonthName} ${date.getDate()}, ${date.getFullYear()}`;
      }
    }
  }
  function startOf(date, unit) {
    switch (unit) {
      case "day":
        date.setHours(0);
        date.setMinutes(0);
      case "minute":
        date.setSeconds(0);
        date.setMilliseconds(0);
        break;
    }
    return date;
  }
  function isDate(value) {
    return Object.prototype.toString.call(value) === "[object Date]" && !isNaN(value.getTime());
  }
  function addTimezoneSuffix(value) {
    return removeTimeZoneSuffix(value) + "Z";
  }
  function addTimezoneOffset(date) {
    date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    return date;
  }
  function subtractTimezoneOffset(date) {
    date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
    return date;
  }
  function getDate(value) {
    if (!value) {
      return null;
    }
    if (isDate(value)) {
      return new Date(value.getTime());
    }
    if (isFinite(value) && (typeof value === "number" || typeof value === "string")) {
      return new Date(parseInt(value, 10));
    }
    if (typeof value === "string") {
      return parseDateTimeISO8601(value);
    }
    return null;
  }
  function getTodayInISO() {
    return new Date().toISOString().split("T")[0];
  }
  function pad(n2) {
    return Number(n2) < 10 ? "0" + n2 : n2;
  }
  function doublePad(n2) {
    return Number(n2) < 10 ? "00" + n2 : Number(n2) < 100 ? "0" + n2 : n2;
  }
  var localizationService = {
    formatDate,
    formatDateUTC,
    formatTime,
    formatDateTimeUTC,
    parseDateTimeISO8601,
    parseDateTime,
    parseDateTimeUTC,
    isBefore,
    isAfter,
    UTCToWallTime,
    WallTimeToUTC,
    translateToOtherCalendar,
    translateFromOtherCalendar,
    translateToLocalizedDigits,
    translateFromLocalizedDigits,
    getNumberFormat,
    duration,
    displayDuration
  };
  function getConfigFromAura($A) {
    return {
      getLocalizationService() {
        return $A.localizationService;
      },
      getPathPrefix() {
        return $A.getContext().getPathPrefix();
      },
      getToken(name) {
        return $A.getToken(name);
      }
    };
  }
  function createStandAloneConfig() {
    return {
      getLocalizationService() {
        return localizationService;
      },
      getPathPrefix() {
        return "";
      },
      getToken() {
        return void 0;
      },
      getOneConfig() {
        return {
          densitySetting: ""
        };
      }
    };
  }
  function getDefaultConfig() {
    return isCSR && window.$A !== void 0 && window.$A.localizationService ? getConfigFromAura(window.$A) : createStandAloneConfig();
  }
  getDefaultConfig();
  isCSR && window.$A && window.$A.localizationService;
  (function() {
    try {
      Intl.DateTimeFormat("en-US", {
        timeZone: "America/Los_Angeles"
      });
    } catch (err) {
      return false;
    }
    return true;
  })();
  const POSITION_ATTR_NAME = "data-position-id";
  class BrowserWindow {
    get window() {
      if (!this._window) {
        this._window = window;
        if (!this.window.getComputedStyle) {
          this.window.getComputedStyle = (node) => {
            return node.style;
          };
        }
      }
      return this._window;
    }
    mockWindow(value) {
      this._window = value;
    }
    get documentElement() {
      assert(this.window.document, "Missing window.document");
      return this.window.document.documentElement;
    }
    get MutationObserver() {
      return this.window.MutationObserver;
    }
    isWindow(element) {
      return element && element.toString() === "[object Window]";
    }
  }
  const WindowManager = new BrowserWindow();
  function isShadowRoot(node) {
    return node && node.nodeType === 11;
  }
  function enumerateParent(elem, stopEl, checker) {
    if (!elem || elem === stopEl || elem === document.body) {
      return null;
    }
    try {
      const computedStyle = WindowManager.window.getComputedStyle(elem);
      if (!computedStyle) {
        return null;
      }
      if (checker(computedStyle)) {
        return elem;
      }
      return enumerateParent(isShadowRoot(elem.parentNode) ? elem.parentNode.host : elem.parentNode, stopEl, checker);
    } catch (e2) {
      return null;
    }
  }
  function getScrollableParent(elem, stopEl) {
    return enumerateParent(elem, stopEl, (computedStyle) => {
      const overflow = computedStyle["overflow-y"];
      return overflow === "auto" || overflow === "scroll";
    });
  }
  function getScrollableParentFromEventPath(eventPath) {
    var computedStyle;
    var overflow;
    for (let i = 0; i < eventPath.length; i++) {
      let element = eventPath[i];
      if (element instanceof HTMLElement) {
        computedStyle = WindowManager.window.getComputedStyle(element);
        overflow = computedStyle["overflow-y"];
        if (overflow === "auto" || overflow === "scroll") {
          return element;
        }
      }
    }
    return null;
  }
  function queryOverflowHiddenParent(elem, stopEl) {
    return enumerateParent(elem, stopEl, (computedStyle) => {
      return computedStyle["overflow-x"] === "hidden" || computedStyle["overflow-y"] === "hidden";
    });
  }
  function isInDom(el) {
    if (el === WindowManager.window) {
      return true;
    }
    if (!isShadowRoot(el.parentNode) && el.parentNode && el.parentNode.tagName && el.parentNode.tagName.toUpperCase() === "BODY") {
      return true;
    }
    if (isShadowRoot(el.parentNode) && el.parentNode.host) {
      return isInDom(el.parentNode.host);
    }
    if (el.parentNode) {
      return isInDom(el.parentNode);
    }
    return false;
  }
  function isDomNode(obj) {
    return obj.nodeType && (obj.nodeType === 1 || obj.nodeType === 11);
  }
  function timeout(time2) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, time2);
    });
  }
  function getPositionTarget(element) {
    return element.tagName === "TEXTAREA" ? isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode : element;
  }
  let lastId = 1e6;
  function generateUniqueSelector() {
    return `lgcp-${lastId++}`;
  }
  function normalizeElement(element) {
    const selector = generateUniqueSelector();
    element.setAttribute(POSITION_ATTR_NAME, selector);
    element = document.querySelector(`[${POSITION_ATTR_NAME}="${selector}"]`) || element;
    return element;
  }
  function normalizePosition(element, overlay, nextIndex2, target, alignWidth) {
    const isFixed = overlay.isInside || !alignWidth && queryOverflowHiddenParent(target, WindowManager.window);
    element.style.position = isFixed ? "fixed" : "absolute";
    element.style.zIndex = nextIndex2 || 0;
    element.style.left = "-9999px";
    element.style.right = "auto";
    element.style.top = "0px";
    return {
      element,
      overlay
    };
  }
  function requestAnimationFrameAsPromise() {
    return new Promise((resolve) => {
      requestAnimationFrame(() => resolve());
    });
  }
  function isPx(value) {
    return value.slice(-2) === "px";
  }
  function pxToInt(value) {
    return value && isPx(value) ? parseInt(value, 10) : 0;
  }
  const Direction = {
    Center: "center",
    Middle: "middle",
    Right: "right",
    Left: "left",
    Bottom: "bottom",
    Top: "top",
    Default: "default"
  };
  const VerticalMap = {
    top: Direction.Top,
    bottom: Direction.Bottom,
    center: Direction.Middle
  };
  const HorizontalMap = {
    left: Direction.Left,
    right: Direction.Right,
    center: Direction.Center
  };
  const FlipMap = {
    left: Direction.Right,
    right: Direction.Left,
    top: Direction.Bottom,
    bottom: Direction.Top,
    center: Direction.Center,
    default: Direction.Right
  };
  function getContainerSize(parent) {
    if (parent) {
      return parent.getBoundingClientRect();
    }
    const rect = {
      width: WindowManager.window.innerWidth || document.body.clientWidth || 0,
      height: WindowManager.window.innerHeight || document.body.clientHeight || 0,
      top: 0,
      left: 0
    };
    rect.bottom = rect.height;
    rect.right = rect.width;
    return rect;
  }
  function normalizeDirection(direction, defaultValue) {
    return normalizeString(direction, {
      fallbackValue: defaultValue || Direction.Default,
      validValues: [Direction.Center, Direction.Right, Direction.Left, Direction.Bottom, Direction.Top, Direction.Middle, Direction.Default]
    });
  }
  function mapToHorizontal(value) {
    value = normalizeDirection(value, Direction.Left);
    return HorizontalMap[value];
  }
  function mapToVertical(value) {
    value = normalizeDirection(value, Direction.Left);
    return VerticalMap[value];
  }
  function flipDirection(value) {
    value = normalizeDirection(value, Direction.Left);
    return FlipMap[value];
  }
  function checkFlipPossibility(parent, element, target, leftAsBoundary) {
    const viewPort = getContainerSize(parent);
    const windowViewPort = getContainerSize();
    const elemRect = element.getBoundingClientRect();
    const referenceElemRect = target.getBoundingClientRect();
    const height = typeof elemRect.height !== "undefined" ? elemRect.height : elemRect.bottom - elemRect.top;
    const width = typeof elemRect.width !== "undefined" ? elemRect.width : elemRect.right - elemRect.left;
    let rightAsBoundary = false;
    if (document.dir === "rtl") {
      rightAsBoundary = leftAsBoundary;
      leftAsBoundary = false;
    }
    let aboveSpace = referenceElemRect.top - viewPort.top - height;
    let belowSpace = viewPort.height - referenceElemRect.bottom - height;
    let hasSpaceAbove = aboveSpace >= 0 || parent == null && belowSpace < 0 && aboveSpace > belowSpace;
    let hasSpaceBelow = belowSpace >= 0 || aboveSpace < 0 && belowSpace > aboveSpace;
    let shouldAlignToRight = false;
    if (parent) {
      shouldAlignToRight = referenceElemRect.right - viewPort.left >= width && referenceElemRect.left + width > (rightAsBoundary ? referenceElemRect.right : viewPort.width);
    } else {
      shouldAlignToRight = referenceElemRect.right >= width && referenceElemRect.left + width > (rightAsBoundary ? referenceElemRect.right : viewPort.width);
    }
    let shouldAlignToLeft = false;
    if (parent) {
      shouldAlignToLeft = referenceElemRect.left + width <= viewPort.right && referenceElemRect.right - viewPort.left - width < (leftAsBoundary ? referenceElemRect.left : 0);
    } else {
      shouldAlignToLeft = referenceElemRect.left + width <= viewPort.width && referenceElemRect.right - width < (leftAsBoundary ? referenceElemRect.left : 0);
    }
    if (!shouldAlignToLeft && !shouldAlignToRight && parent) {
      shouldAlignToRight = (referenceElemRect.right - viewPort.left >= width || referenceElemRect.right >= width) && referenceElemRect.left + width > (rightAsBoundary ? referenceElemRect.right : viewPort.width);
      shouldAlignToLeft = (referenceElemRect.left + width <= viewPort.right || referenceElemRect.left + width <= windowViewPort.width) && referenceElemRect.right - width < (leftAsBoundary ? referenceElemRect.left : 0);
    }
    if (!hasSpaceAbove && !hasSpaceBelow && parent && element.style && element.style.position === "fixed") {
      hasSpaceAbove = referenceElemRect.top - windowViewPort.top - height > 0;
      hasSpaceBelow = windowViewPort.height - referenceElemRect.bottom - height > 0;
    }
    const centerOverflow = {
      left: referenceElemRect.left - width * 0.5 < 0,
      right: referenceElemRect.right + width * 0.5 > viewPort.width,
      top: referenceElemRect.top - height * 0.5 < 0,
      bottom: referenceElemRect.bottom + height * 0.5 > viewPort.height
    };
    return {
      shouldAlignToLeft,
      shouldAlignToRight,
      hasSpaceAbove,
      hasSpaceBelow,
      centerOverflow
    };
  }
  class Transformer {
    constructor(pad2, boxDirections, transformX, transformY) {
      this.pad = pad2 || 0;
      this.boxDirections = boxDirections || {
        left: true,
        right: true
      };
      this.transformX = transformX || function() {
      };
      this.transformY = transformY || function() {
      };
    }
    transform() {
    }
  }
  class TopTransformer extends Transformer {
    transform(targetBox, elementBox) {
      return {
        top: Math.floor(this.transformY(targetBox.top, targetBox, elementBox) + this.pad)
      };
    }
  }
  class BottomTransFormer extends Transformer {
    transform(targetBox, elementBox) {
      return {
        top: Math.floor(this.transformY(targetBox.top, targetBox, elementBox) - elementBox.height - this.pad)
      };
    }
  }
  class CenterTransformer extends Transformer {
    transform(targetBox, elementBox) {
      return {
        left: Math.floor(this.transformX(targetBox.left, targetBox, elementBox) - 0.5 * elementBox.width)
      };
    }
  }
  class MiddleTransformer extends Transformer {
    transform(targetBox, elementBox) {
      return {
        top: Math.floor(0.5 * (2 * targetBox.top + targetBox.height - elementBox.height))
      };
    }
  }
  class LeftTransformer extends Transformer {
    transform(targetBox, elementBox) {
      return {
        left: Math.floor(this.transformX(targetBox.left, targetBox, elementBox) + this.pad)
      };
    }
  }
  class RightTransformer extends Transformer {
    transform(targetBox, elementBox) {
      return {
        left: Math.floor(this.transformX(targetBox.left, targetBox, elementBox) - elementBox.width - this.pad)
      };
    }
  }
  class BelowTransformer extends Transformer {
    transform(targetBox, elementBox) {
      const top = targetBox.top + targetBox.height + this.pad;
      return elementBox.top < top ? {
        top
      } : {};
    }
  }
  const MIN_HEIGHT = 36;
  const MIN_WIDTH = 36;
  class ShrinkingBoxTransformer extends Transformer {
    transform(targetBox, elementBox) {
      const retBox = {};
      if (this.boxDirections.top && elementBox.top < targetBox.top + this.pad) {
        retBox.top = targetBox.top + this.pad;
        retBox.height = Math.max(elementBox.height - (retBox.top - elementBox.top), MIN_HEIGHT);
      }
      if (this.boxDirections.left && elementBox.left < targetBox.left + this.pad) {
        retBox.left = targetBox.left + this.pad;
        retBox.width = Math.max(elementBox.width - (retBox.left - elementBox.left), MIN_WIDTH);
      }
      if (this.boxDirections.right && elementBox.left + elementBox.width > targetBox.left + targetBox.width - this.pad) {
        retBox.right = targetBox.left + targetBox.width - this.pad;
        retBox.width = Math.max(retBox.right - (retBox.left || elementBox.left), MIN_WIDTH);
      }
      if (this.boxDirections.bottom && elementBox.top + elementBox.height > targetBox.top + targetBox.height - this.pad) {
        retBox.bottom = targetBox.top + targetBox.height - this.pad;
        retBox.height = Math.max(retBox.bottom - (retBox.top || elementBox.top), MIN_HEIGHT);
      }
      return retBox;
    }
  }
  class BoundingBoxTransformer extends Transformer {
    transform(targetBox, elementBox) {
      const retBox = {};
      if (this.boxDirections.top && elementBox.top < targetBox.top + this.pad) {
        retBox.top = targetBox.top + this.pad;
      }
      if (this.boxDirections.left && elementBox.left < targetBox.left + this.pad) {
        retBox.left = targetBox.left + this.pad;
      }
      if (this.boxDirections.right && elementBox.left + elementBox.width > targetBox.left + targetBox.width - this.pad) {
        retBox.left = targetBox.left + targetBox.width - elementBox.width - this.pad;
      }
      if (this.boxDirections.bottom && elementBox.top + elementBox.height > targetBox.top + targetBox.height - this.pad) {
        retBox.top = targetBox.top + targetBox.height - elementBox.height - this.pad;
      }
      return retBox;
    }
  }
  class InverseBoundingBoxTransformer extends Transformer {
    transform(targetBox, elementBox) {
      const retBox = {};
      if (this.boxDirections.left && targetBox.left - this.pad < elementBox.left) {
        retBox.left = targetBox.left - this.pad;
      }
      if (this.boxDirections.right && elementBox.left + elementBox.width < targetBox.left + targetBox.width + this.pad) {
        retBox.left = targetBox.width + this.pad - elementBox.width + targetBox.left;
      }
      if (this.boxDirections.top && targetBox.top < elementBox.top + this.pad) {
        retBox.top = targetBox.top - this.pad;
      }
      if (this.boxDirections.bottom && elementBox.top + elementBox.height < targetBox.top + targetBox.height + this.pad) {
        retBox.top = targetBox.height + this.pad - elementBox.height + targetBox.top;
      }
      return retBox;
    }
  }
  const TransformFunctions = {
    center(input, targetBox) {
      return Math.floor(input + 0.5 * targetBox.width);
    },
    right(input, targetBox) {
      return input + targetBox.width;
    },
    left(input) {
      return input;
    },
    bottom(input, targetBox) {
      return input + targetBox.height;
    }
  };
  const Transformers = {
    top: TopTransformer,
    bottom: BottomTransFormer,
    center: CenterTransformer,
    middle: MiddleTransformer,
    left: LeftTransformer,
    right: RightTransformer,
    below: BelowTransformer,
    "bounding box": BoundingBoxTransformer,
    "shrinking box": ShrinkingBoxTransformer,
    "inverse bounding box": InverseBoundingBoxTransformer,
    default: Transformer
  };
  function toTransformFunctions(value) {
    return TransformFunctions[value] || TransformFunctions.left;
  }
  class TransformBuilder {
    type(value) {
      this._type = value;
      return this;
    }
    align(horizontal, vertical) {
      this._transformX = toTransformFunctions(horizontal);
      this._transformY = toTransformFunctions(vertical);
      return this;
    }
    pad(value) {
      this._pad = parseInt(value, 10);
      return this;
    }
    boxDirections(value) {
      this._boxDirections = value;
      return this;
    }
    build() {
      const AConstructor = Transformers[this._type] ? Transformers[this._type] : Transformers[Direction.Default];
      return new AConstructor(this._pad || 0, this._boxDirections || {}, this._transformX || toTransformFunctions(Direction.left), this._transformY || toTransformFunctions(Direction.left));
    }
  }
  class Constraint {
    constructor(type, config2) {
      const {
        target,
        element,
        pad: pad2,
        boxDirections
      } = config2;
      const {
        horizontal,
        vertical
      } = config2.targetAlign;
      this._element = element;
      this._targetElement = target;
      this.destroyed = false;
      this._transformer = new TransformBuilder().type(type).align(horizontal, vertical).pad(pad2).boxDirections(boxDirections).build();
    }
    detach() {
      this._disabled = true;
    }
    attach() {
      this._disabled = false;
    }
    computeDisplacement() {
      if (!this._disabled) {
        this._targetElement.refresh();
        this._element.refresh();
        this._pendingBox = this._transformer.transform(this._targetElement, this._element);
      }
      return this;
    }
    computePosition() {
      const el = this._element;
      if (!this._disabled) {
        Object.keys(this._pendingBox).forEach((key) => {
          el.setDirection(key, this._pendingBox[key]);
        });
      }
      return this;
    }
    destroy() {
      this._element.release();
      this._targetElement.release();
      this._disabled = true;
      this.destroyed = true;
    }
  }
  class ElementProxy {
    constructor(el, id) {
      this.id = id;
      this.width = 0;
      this.height = 0;
      this.left = 0;
      this.top = 0;
      this.right = 0;
      this.bottom = 0;
      this._dirty = false;
      this._node = null;
      this._releaseCb = null;
      if (!el) {
        throw new Error("Element missing");
      }
      if (WindowManager.isWindow(el)) {
        el = WindowManager.window;
      }
      this._node = el;
      this.setupObserver();
      this.refresh();
    }
    setupObserver() {
      if (WindowManager.MutationObserver && !this._node.isObserved) {
        this._observer = new WindowManager.MutationObserver(this.refresh.bind(this));
        if (!WindowManager.isWindow(this._node)) {
          this._observer.observe(this._node, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          });
          this._node.isObserved = true;
        }
      }
    }
    setReleaseCallback(cb, scope) {
      const scopeObj = scope || this;
      this._releaseCb = cb.bind(scopeObj);
    }
    checkNodeIsInDom() {
      if (!isInDom(this._node)) {
        return false;
      }
      return true;
    }
    refresh() {
      const w2 = WindowManager.window;
      if (!this.isDirty()) {
        if (!this.checkNodeIsInDom()) {
          return this.release();
        }
        let box, x2, scrollTop, scrollLeft;
        if (typeof w2.pageYOffset !== "undefined") {
          scrollTop = w2.pageYOffset;
          scrollLeft = w2.pageXOffset;
        } else {
          scrollTop = w2.scrollY;
          scrollLeft = w2.scrollX;
        }
        if (!WindowManager.isWindow(this._node)) {
          this._node.offsetHeight;
          box = this._node.getBoundingClientRect();
          for (x2 in box) {
            this[x2] = Math.floor(box[x2]);
          }
          this.top = Math.floor(this.top + scrollTop);
          this.bottom = Math.floor(this.top + box.height);
          this.left = Math.floor(this.left + scrollLeft);
          this.right = Math.floor(this.left + box.width);
        } else {
          box = {};
          this.width = WindowManager.documentElement.clientWidth;
          this.height = WindowManager.documentElement.clientHeight;
          this.left = scrollLeft;
          this.top = scrollTop;
          this.right = WindowManager.documentElement.clientWidth + scrollLeft;
          this.bottom = WindowManager.documentElement.clientHeight;
        }
        this._dirty = false;
      }
      return this._dirty;
    }
    getNode() {
      return this._node;
    }
    isDirty() {
      return this._dirty;
    }
    bake() {
      const w2 = WindowManager.window;
      const absPos = this._node.getBoundingClientRect();
      const style = w2.getComputedStyle(this._node) || this._node.style;
      const hasPageOffset = typeof w2.pageYOffset !== "undefined";
      const scrollTop = hasPageOffset ? w2.pageYOffset : w2.scrollY;
      const scrollLeft = hasPageOffset ? w2.pageXOffset : w2.scrollX;
      const originalLeft = style.left.match(/auto|fixed/) ? "0" : parseInt(style.left.replace("px", ""), 10);
      const originalTop = style.top.match(/auto|fixed/) ? "0" : parseInt(style.top.replace("px", ""), 10);
      const marginOffset = this.top < absPos.top ? pxToInt(style.marginBottom) : pxToInt(style.marginTop) * -1;
      let leftDif = Math.round(this.left - (absPos.left + scrollLeft));
      const topDif = this.top - (absPos.top + marginOffset + scrollTop);
      const viewPortWidth = w2.innerWidth || document.body.clientWidth;
      let rightPos = parseInt(style.right, 10);
      if (originalLeft + leftDif + parseInt(style.width, 10) > viewPortWidth && rightPos <= 0) {
        rightPos = rightPos < 0 ? -rightPos : leftDif;
        this._node.style.right = -rightPos + "px";
        leftDif = 0;
      }
      this._node.style.left = `${originalLeft + leftDif}px`;
      this._node.style.top = `${originalTop + topDif}px`;
      if (this._restoreSize) {
        if (this.originalHeight === void 0) {
          this.originalHeight = this._node.style.height;
        }
        if (this.originalWidth === void 0) {
          this.originalWidth = this._node.style.width;
        }
        this._node.style.width = `${this.width}px`;
        this._node.style.height = `${this.height}px`;
      }
      this._dirty = false;
    }
    setDirection(direction, val) {
      this[direction] = val;
      this._dirty = true;
      if (direction === "height" || direction === "width") {
        this._restoreSize = true;
      }
    }
    release() {
      if (this._restoreSize) {
        this._node.style.width = this.originalWidth;
        this._node.style.height = this.originalHeight;
        if (this._removeMinHeight) {
          this._node.style.minHeight = "";
        }
      }
      if (this._releaseCb) {
        this._releaseCb(this);
      }
      if (this._observer) {
        this._observer.disconnect();
        this._observer = null;
      }
    }
    querySelectorAll(selector) {
      return this._node.querySelectorAll(selector);
    }
  }
  class ProxyCache {
    constructor() {
      this.proxyCache = {};
    }
    get count() {
      return Object.keys(this.proxyCache).length;
    }
    releaseOrphanProxies() {
      for (const proxy in this.proxyCache) {
        if (!this.proxyCache[proxy].el.checkNodeIsInDom()) {
          this.proxyCache[proxy].el.release();
        }
      }
    }
    bakeOff() {
      for (const proxy in this.proxyCache) {
        if (this.proxyCache[proxy].el.isDirty()) {
          this.proxyCache[proxy].el.bake();
        }
      }
    }
    getReferenceCount(proxy) {
      const id = proxy.id;
      if (!id || !this.proxyCache[id]) {
        return 0;
      }
      return this.proxyCache[id].refCount;
    }
    release(proxy) {
      const proxyInstance = this.proxyCache[proxy.id];
      if (proxyInstance) {
        --proxyInstance.refCount;
      }
      if (proxyInstance && proxyInstance.refCount <= 0) {
        delete this.proxyCache[proxy.id];
      }
    }
    reset() {
      this.proxyCache = {};
    }
    create(element) {
      let key = "window";
      if (!WindowManager.isWindow(element)) {
        key = element ? element.getAttribute(POSITION_ATTR_NAME) : null;
        assert(key && element.nodeType && (element.nodeType !== 1 || element.nodeType !== 11), `Element Proxy requires an element and has property ${POSITION_ATTR_NAME}`);
      }
      if (this.proxyCache[key]) {
        this.proxyCache[key].refCount++;
        return this.proxyCache[key].el;
      }
      const newProxy = new ElementProxy(element, key);
      newProxy.setReleaseCallback(release, newProxy);
      this.proxyCache[key] = {
        el: newProxy,
        refCount: 1
      };
      timeout(0).then(() => {
        this.releaseOrphanProxies();
      });
      return this.proxyCache[key].el;
    }
  }
  _2_41_4.registerDecorators(ProxyCache, {
    fields: ["proxyCache"]
  });
  const elementProxyCache = new ProxyCache();
  function bakeOff() {
    elementProxyCache.bakeOff();
  }
  function release(proxy) {
    return elementProxyCache.release(proxy);
  }
  function createProxy(element) {
    return elementProxyCache.create(element);
  }
  class RepositionQueue {
    constructor() {
      this.callbacks = [];
      this.repositionScheduled = false;
      this._constraints = [];
      this.timeoutId = 0;
      this.lastIndex = getZIndexBaseline();
      this.eventsBound = false;
    }
    get nextIndex() {
      return this.lastIndex++;
    }
    get constraints() {
      return this._constraints;
    }
    set constraints(value) {
      this._constraints = this._constraints.concat(value);
    }
    dispatchRepositionCallbacks() {
      while (this.callbacks.length > 0) {
        this.callbacks.shift()();
      }
    }
    add(callback) {
      if (typeof callback === "function") {
        this.callbacks.push(callback);
        return true;
      }
      return false;
    }
    scheduleReposition(callback) {
      if (this.timeoutId === 0) {
        this.timeoutId = setTimeout(() => {
          this.reposition(callback);
        }, 10);
      }
    }
    reposition(callback) {
      if (typeof callback === "function") {
        this.callbacks.push(callback);
      }
      clearTimeout(this.timeoutId);
      this.timeoutId = 0;
      if (!this.repositionScheduled) {
        requestAnimationFrame(() => {
          this.repositionScheduled = false;
          this._constraints = this._constraints.filter((constraint) => {
            if (!constraint.destroyed) {
              constraint.computeDisplacement().computePosition();
              return true;
            }
            return false;
          });
          bakeOff();
          this.dispatchRepositionCallbacks();
        });
        this.repositionScheduled = true;
      }
    }
    get repositioning() {
      if (!this._reposition) {
        this._reposition = this.scheduleReposition.bind(this);
      }
      return this._reposition;
    }
    bindEvents() {
      if (!this.eventsBound) {
        window.addEventListener("resize", this.repositioning);
        window.addEventListener("scroll", this.repositioning);
        this.eventsBound = true;
      }
    }
    detachEvents() {
      window.removeEventListener("resize", this.repositioning);
      window.removeEventListener("scroll", this.repositioning);
      this.eventsBound = false;
    }
    rebase(index2) {
      if (this.lastIndex <= index2) {
        this.lastIndex = index2 + 1;
      }
    }
  }
  _2_41_4.registerDecorators(RepositionQueue, {
    fields: ["callbacks", "repositionScheduled", "_constraints", "timeoutId", "lastIndex", "eventsBound"]
  });
  const positionQueue = new RepositionQueue();
  function scheduleReposition(callback) {
    positionQueue.scheduleReposition(callback);
  }
  function bindEvents() {
    positionQueue.bindEvents();
  }
  function addConstraints(list) {
    positionQueue.constraints = list;
  }
  function reposition(callback) {
    positionQueue.reposition(callback);
  }
  function nextIndex() {
    return positionQueue.nextIndex;
  }
  function rebaseIndex(index2) {
    return positionQueue.rebase(index2);
  }
  class Relationship {
    constructor(config2, constraintList, scrollableParent, observer) {
      this.config = config2;
      this.constraintList = constraintList;
      this.scrollableParent = scrollableParent;
      this.observer = observer;
    }
    disable() {
      this.constraintList.forEach((constraintToDisable) => {
        constraintToDisable.detach();
      });
    }
    enable() {
      this.constraintList.forEach((constraintToEnable) => {
        constraintToEnable.attach();
      });
    }
    destroy() {
      if (this.config.removeListeners) {
        this.config.removeListeners();
        this.config.removeListeners = void 0;
      }
      while (this.constraintList.length > 0) {
        this.constraintList.pop().destroy();
      }
      if (this.config.appendToBody && this.config.element) {
        const nodeToRemove = document.querySelector(`[${POSITION_ATTR_NAME}="${this.config.element.getAttribute(POSITION_ATTR_NAME)}"]`);
        if (nodeToRemove) {
          nodeToRemove.parentNode.removeChild(nodeToRemove);
        }
      }
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }
    }
    reposition() {
      return new Promise((resolve) => {
        reposition(() => {
          resolve();
        });
      });
    }
  }
  const OVERLAY_TYPE = {
    NONE: "none",
    MODAL: "uiModal",
    DIALOG: "lightning-dialog",
    POPOVER: "lightning-popover",
    PANEL: "uiPanel",
    SLDSMODAL: "slds-modal"
  };
  function isOverlay(element) {
    const isDialog = element.localName === OVERLAY_TYPE.DIALOG;
    if (isDialog) {
      return OVERLAY_TYPE.DIALOG;
    }
    const isPopover = element.localName === OVERLAY_TYPE.POPOVER;
    if (isPopover) {
      return OVERLAY_TYPE.POPOVER;
    }
    const isModal = element.classList && element.classList.contains(OVERLAY_TYPE.MODAL);
    if (isModal) {
      return OVERLAY_TYPE.MODAL;
    }
    const isPanel = element.classList && element.classList.contains(OVERLAY_TYPE.PANEL);
    if (isPanel) {
      return OVERLAY_TYPE.PANEL;
    }
    const isSldsModal = element.classList && element.classList.contains(OVERLAY_TYPE.SLDSMODAL);
    if (isSldsModal) {
      return OVERLAY_TYPE.SLDSMODAL;
    }
    return OVERLAY_TYPE.NONE;
  }
  function isInsideOverlay(element) {
    if (!element) {
      return {
        isInside: false,
        type: null,
        overlay: null
      };
    }
    const type = isOverlay(element);
    if (type !== OVERLAY_TYPE.NONE) {
      return {
        isInside: true,
        type,
        overlay: element
      };
    }
    if (!element.parentNode) {
      return {
        isInside: false,
        type: null,
        overlay: null
      };
    }
    return isInsideOverlay(isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode);
  }
  class OverlayDetector {
    constructor(element) {
      this._element = element;
      this._detection = isInsideOverlay(this._element) || {
        isInside: false,
        overlay: null
      };
    }
    get isInsideModal() {
      return this.isInside && (this._detection.type === OVERLAY_TYPE.MODAL || this._detection.type === OVERLAY_TYPE.DIALOG || this._detection.type === OVERLAY_TYPE.SLDSMODAL);
    }
    get isInside() {
      return this._detection.isInside;
    }
    get overlay() {
      return this._detection.overlay;
    }
  }
  const DEFAULT_MIN_HEIGHT = "1.875rem";
  function setupObserver(config2, scrollableParent) {
    const observedElement = config2.element;
    let observer = null;
    if (WindowManager.MutationObserver && !observedElement.isObserved) {
      observer = new WindowManager.MutationObserver(() => {
      });
      observer.observe(observedElement, {
        attributes: true,
        subtree: true,
        childList: true
      });
      observedElement.isObserved = true;
    }
    if (scrollableParent) {
      scrollableParent.addEventListener("scroll", scheduleReposition);
      config2.removeListeners = () => {
        scrollableParent.removeEventListener("scroll", scheduleReposition);
      };
    }
    return observer;
  }
  function validateConfig(config2) {
    assert(config2.element && isDomNode(config2.element), "Element is undefined or missing, or not a Dom Node");
    assert(config2.target && (WindowManager.isWindow(config2.target) || isDomNode(config2.target)), "Target is undefined or missing");
  }
  function createRelationship(originalConfig, disableReposition, eventComposedPath) {
    bindEvents();
    let scrollableParent = getScrollableParent(getPositionTarget(originalConfig.target), WindowManager.window);
    if (!scrollableParent && eventComposedPath) {
      scrollableParent = getScrollableParentFromEventPath(eventComposedPath);
    }
    const config2 = normalizeConfig(scrollableParent, originalConfig);
    if (config2.alignWidth && config2.element.style.position === "fixed") {
      config2.element.style.width = config2.target.getBoundingClientRect().width + "px";
    }
    const constraintList = [];
    const observer = setupObserver(config2, scrollableParent);
    if (config2.appendToBody) {
      document.body.appendChild(config2.element);
    }
    config2.element = createProxy(config2.element);
    config2.target = createProxy(config2.target);
    const horizontalConfig = Object.assign({}, config2);
    if (horizontalConfig.padLeft !== void 0) {
      horizontalConfig.pad = horizontalConfig.padLeft;
    }
    const verticalConfig = Object.assign({}, config2);
    if (verticalConfig.padTop !== void 0) {
      verticalConfig.pad = verticalConfig.padTop;
    }
    constraintList.push(new Constraint(mapToHorizontal(config2.align.horizontal), horizontalConfig));
    constraintList.push(new Constraint(mapToVertical(config2.align.vertical), verticalConfig));
    const autoShrink = config2.autoShrink.height || config2.autoShrink.width;
    if (config2.scrollableParentBound && scrollableParent) {
      const parent = normalizeElement(scrollableParent);
      const boxConfig = {
        element: config2.element,
        enabled: config2.enabled,
        target: createProxy(parent),
        align: {},
        targetAlign: {},
        pad: 3,
        boxDirections: {
          top: true,
          bottom: true,
          left: true,
          right: true
        }
      };
      if (autoShrink) {
        const style = boxConfig.element.getNode().style;
        if (!style.minHeight) {
          style.minHeight = config2.minHeight;
          boxConfig.element._removeMinHeight = true;
        }
        boxConfig.boxDirections = {
          top: !!config2.autoShrink.height,
          bottom: !!config2.autoShrink.height,
          left: !!config2.autoShrink.width,
          right: !!config2.autoShrink.width
        };
        constraintList.push(new Constraint("shrinking box", boxConfig));
      } else {
        constraintList.push(new Constraint("bounding box", boxConfig));
      }
    }
    if (config2.keepInViewport) {
      constraintList.push(new Constraint("bounding box", {
        element: config2.element,
        enabled: config2.enabled,
        target: createProxy(window),
        align: {},
        targetAlign: {},
        pad: 3,
        boxDirections: {
          top: true,
          bottom: true,
          left: true,
          right: true
        }
      }));
    }
    addConstraints(constraintList);
    if (!disableReposition) {
      reposition();
    }
    return new Relationship(config2, constraintList, scrollableParent, observer);
  }
  function isAutoFlipHorizontal(config2) {
    return config2.autoFlip || config2.autoFlipHorizontal;
  }
  function isAutoFlipVertical(config2) {
    return config2.autoFlip || config2.autoFlipVertical;
  }
  function normalizeAlignments(config2, flipConfig) {
    const align = {
      horizontal: config2.align.horizontal,
      vertical: config2.align.vertical
    };
    const targetAlign = {
      horizontal: config2.targetAlign.horizontal,
      vertical: config2.targetAlign.vertical
    };
    if (document.dir === "rtl") {
      align.horizontal = flipDirection(align.horizontal);
      targetAlign.horizontal = flipDirection(targetAlign.horizontal);
    }
    let vFlip = false;
    if (isAutoFlipVertical(config2)) {
      if (align.vertical === Direction.Bottom) {
        vFlip = !flipConfig.hasSpaceAbove && flipConfig.hasSpaceBelow;
      } else if (align.vertical === Direction.Top) {
        vFlip = flipConfig.hasSpaceAbove && !flipConfig.hasSpaceBelow;
      } else if (align.vertical === Direction.Center) {
        if (flipConfig.centerOverflow.top && !flipConfig.centerOverflow.bottom) {
          align.vertical = targetAlign.vertical = Direction.Top;
        } else if (flipConfig.centerOverflow.bottom && !flipConfig.centerOverflow.top) {
          align.vertical = targetAlign.vertical = Direction.Bottom;
        }
      }
    }
    let hFlip = false;
    if (isAutoFlipHorizontal(config2)) {
      if (align.horizontal === Direction.Left) {
        hFlip = flipConfig.shouldAlignToRight && !flipConfig.shouldAlignToLeft;
      } else if (align.horizontal === Direction.Right) {
        hFlip = flipConfig.shouldAlignToLeft && !flipConfig.shouldAlignToRight;
      } else if (align.horizontal === Direction.Center) {
        if (flipConfig.centerOverflow.left && !flipConfig.centerOverflow.right) {
          align.horizontal = targetAlign.horizontal = Direction.Left;
        } else if (flipConfig.centerOverflow.right && !flipConfig.centerOverflow.left) {
          align.horizontal = targetAlign.horizontal = Direction.Right;
        }
      }
    }
    return {
      align: {
        horizontal: hFlip ? flipDirection(align.horizontal) : normalizeDirection(align.horizontal, Direction.Left),
        vertical: vFlip ? flipDirection(align.vertical) : normalizeDirection(align.vertical, Direction.Top)
      },
      targetAlign: {
        horizontal: hFlip ? flipDirection(targetAlign.horizontal) : normalizeDirection(targetAlign.horizontal, Direction.Left),
        vertical: vFlip ? flipDirection(targetAlign.vertical) : normalizeDirection(targetAlign.vertical, Direction.Bottom)
      }
    };
  }
  function normalizeConfig(parent, config2) {
    config2.align = config2.align || {};
    config2.targetAlign = config2.targetAlign || {};
    const flipConfig = checkFlipPossibility(config2.overlay.isInside ? null : parent, config2.element, config2.target, config2.leftAsBoundary);
    const {
      align,
      targetAlign
    } = normalizeAlignments(config2, flipConfig);
    if (config2.isInsideModal && !flipConfig.hasSpaceAbove && !flipConfig.hasSpaceBelow) {
      config2.scrollableParentBound = true;
    }
    return {
      target: config2.target,
      element: config2.element,
      align,
      targetAlign,
      alignWidth: config2.alignWidth,
      scrollableParentBound: config2.scrollableParentBound,
      keepInViewport: config2.keepInViewport,
      pad: config2.pad,
      padTop: config2.padTop,
      padLeft: config2.padLeft,
      autoShrink: {
        height: config2.autoShrink || config2.autoShrinkHeight,
        width: config2.autoShrink || config2.autoShrinkWidth
      },
      minHeight: config2.minHeight || DEFAULT_MIN_HEIGHT
    };
  }
  function toElement(root, target) {
    if (target && typeof target === "string") {
      return root.querySelector(target);
    } else if (target && typeof target === "function") {
      return target();
    }
    return target;
  }
  function startPositioning(root, config2, disableReposition) {
    assert(root, "Root is undefined or missing");
    assert(config2, "Config is undefined or missing");
    const node = normalizeElement(root);
    const target = toElement(node, config2.target);
    const element = toElement(node, config2.element);
    if (!target || !element) {
      return null;
    }
    config2.target = normalizeElement(target);
    config2.element = normalizeElement(element);
    const result = new OverlayDetector(config2.element);
    config2.isInsideModal = result.isInsideModal;
    if (config2.isInsideModal && result.overlay) {
      const index2 = parseInt(result.overlay.style.zIndex, 10);
      rebaseIndex(index2);
    }
    const targetResult = new OverlayDetector(config2.target);
    if (targetResult.isInsideModal && targetResult.overlay) {
      const index2 = parseInt(targetResult.overlay.style.zIndex, 10);
      rebaseIndex(index2);
    }
    const overlayCheck = normalizePosition(config2.element, result, nextIndex(), config2.target, config2.alignWidth);
    config2.element = overlayCheck.element;
    config2.overlay = overlayCheck.overlay;
    validateConfig(config2);
    const relationship = createRelationship(config2, disableReposition);
    root.dispatchEvent(new CustomEvent("privatescrollablecontainer", {
      composed: true,
      bubbles: true,
      detail: {
        callback: (eventComposedPath) => {
          var updatedReltnWrtoScrollParent = createRelationship(config2, disableReposition, eventComposedPath);
          relationship.config.align.horizontal = updatedReltnWrtoScrollParent.config.align.horizontal;
          relationship.config.align.vertical = updatedReltnWrtoScrollParent.config.align.vertical;
        }
      }
    }));
    return relationship;
  }
  function stopPositioning(relationship) {
    if (relationship) {
      relationship.destroy();
    }
  }
  class AutoPosition {
    constructor(root) {
      this._autoPositionUpdater = null;
      this._root = root;
    }
    start(config2) {
      return requestAnimationFrameAsPromise().then(() => {
        let promise = Promise.resolve();
        if (!this._autoPositionUpdater) {
          this._autoPositionUpdater = startPositioning(this._root, config2);
        } else {
          promise = promise.then(() => {
            return this._autoPositionUpdater.reposition();
          });
        }
        return promise.then(() => {
          return this._autoPositionUpdater;
        });
      });
    }
    stop() {
      if (this._autoPositionUpdater) {
        stopPositioning(this._autoPositionUpdater);
        this._autoPositionUpdater = null;
      }
      return Promise.resolve();
    }
  }
  _2_41_4.registerDecorators(AutoPosition, {
    fields: ["_autoPositionUpdater"]
  });
  function stylesheet$5(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? "[" + token + "]" : "";
    return ["*", shadowSelector, ",", shadowSelector, "::before,", shadowSelector, "::after {box-sizing: border-box;}h1", shadowSelector, ",h2", shadowSelector, ",h3", shadowSelector, ",h4", shadowSelector, ",h5", shadowSelector, ",h6", shadowSelector, " {font-weight: var(--sds-s-heading-font-weight, inherit);margin-block-start: var(--sds-s-heading-spacing-block-start, var(--sds-s-heading-spacing-block));margin-block-end: var(--sds-s-heading-spacing-block-end, var(--sds-s-heading-spacing-block));font-size: 1em;}a", shadowSelector, " {color: var(--slds-g-link-color, var(--slds-g-color-brand-base-50, #0176d3));text-decoration: var(--_slds-g-font-decoration, none);transition: color 0.1s linear;background-color: transparent;}a:active", shadowSelector, ",a:hover", shadowSelector, " {outline: 0;}a:hover", shadowSelector, ",a:focus", shadowSelector, " {text-decoration: var(--_slds-g-font-decoration-hover, underline);color: var(--slds-g-link-color-hover, var(--slds-g-color-brand-base-30, #014486));}a:active", shadowSelector, " {color: var(--slds-g-link-color-active, var(--slds-g-color-brand-base-30, #014486));}a:focus-visible", shadowSelector, " {outline-color: var(--_slds-g-color-outline, var(--slds-g-color-brand-base-50, #0176d3));}a:focus", shadowSelector, " {box-shadow: var(--_slds-g-shadow);border-color: var(--_slds-g-color-border);border-width: var(--_slds-g-sizing-border);border-style: var(--_slds-g-style-border);outline: var(--_slds-g-font-decoration-hover);}a", shadowSelector, ",button", shadowSelector, " {cursor: pointer;}p", shadowSelector, " {margin-block-start: var(--sds-s-content-spacing-block-start,\n var(--sds-s-content-spacing-block, 0));margin-block-end: var(--sds-s-content-spacing-block-end,\n var(--sds-s-content-spacing-block, 0));margin-inline-start: 0;margin-inline-end: 0;padding-block-start: 0;padding-block-end: 0;padding-inline-start: 0;padding-inline-end: 0;}ol", shadowSelector, ",ul", shadowSelector, " {list-style: none;padding: 0;margin-block-start: var(--sds-s-content-spacing-block-start,\n var(--sds-s-content-spacing-block));margin-block-end: var(--sds-s-content-spacing-block-end,\n var(--sds-s-content-spacing-block));}button", shadowSelector, ",[type='button']", shadowSelector, ",[type='reset']", shadowSelector, ",[type='submit']", shadowSelector, " {-webkit-appearance: button;appearance: button;cursor: pointer;}[type='search']", shadowSelector, " {-webkit-appearance: textfield;outline-offset: -2px;}[type=search]", shadowSelector, "::-webkit-search-decoration,[type=search]", shadowSelector, "::-webkit-search-cancel-button,[type=search]", shadowSelector, "::-webkit-search-results-button,[type=search]", shadowSelector, "::-webkit-search-results-decoration {display: none;}select", shadowSelector, " {color: inherit;font: inherit;margin: 0;}input:focus", shadowSelector, ",button:focus", shadowSelector, ",select:focus", shadowSelector, ",textarea:focus", shadowSelector, " {outline-offset: 0;}", shadowSelector, "::-moz-focus-inner {border-style: none;padding: 0;}", shadowSelector, "::-webkit-search-decoration {-webkit-appearance: none;}", shadowSelector, "::-webkit-file-upload-button {-webkit-appearance: button;font: inherit;}:-moz-focusring", shadowSelector, " {outline: 1px dotted ButtonText;}:-moz-ui-invalid", shadowSelector, " {box-shadow: none;}code", shadowSelector, ",kbd", shadowSelector, ",samp", shadowSelector, ",pre", shadowSelector, " {font-family: var(--sds-g-font-family-monospace, monospace);font-size: var(--sds-g-font-size-base, 1rem);}img", shadowSelector, ",[type='image']", shadowSelector, " {max-width: 100%;height: auto;border: 0;vertical-align: middle;}iframe", shadowSelector, " {border-style: none;}svg:not([fill])", shadowSelector, " {fill: currentColor;}abbr[title]", shadowSelector, " {text-decoration: none;cursor: help;}table", shadowSelector, " {border-collapse: collapse;border-spacing: 0;border: 0;width: 100%;}hr", shadowSelector, " {display: block;margin: var(--sds-g-spacing-6, 2rem) 0;border-top: var(--sds-g-sizing-border-1, 1px) solid var(--slds-g-color-border-base-1, #c9c9c9);height: var(--sds-g-sizing-border-1, 1px);clear: both;box-sizing: content-box;border: 0;padding: 0;}abbr[title]", shadowSelector, " {border-bottom: var(--sds-g-sizing-border-1, 1px) dotted;text-decoration: none;border: 0;cursor: help;}caption", shadowSelector, ",th", shadowSelector, ",td", shadowSelector, " {text-align: left;}td", shadowSelector, ",th", shadowSelector, " {padding: 0;}dl", shadowSelector, " {margin: 0;padding: 0;}dd", shadowSelector, " {margin: 0;}pre", shadowSelector, " {overflow: auto;}mark", shadowSelector, " {background-color: #ff0;color: #000;}small", shadowSelector, " {font-size: 80%;}sub", shadowSelector, ",sup", shadowSelector, " {font-size: 75%;line-height: 0;position: relative;vertical-align: baseline;}sup", shadowSelector, " {top: -0.5em;}sub", shadowSelector, " {bottom: -0.25em;}b", shadowSelector, ",strong", shadowSelector, ",dfn", shadowSelector, " {font-weight: var(--sds-g-font-weight-7, 700);}b", shadowSelector, ",strong", shadowSelector, " {font-weight: var(--sds-g-font-weight-bold, bold);}"].join("");
  }
  var stylesheet0 = [stylesheet$5];
  function stylesheet$4(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? "[" + token + "]" : "";
    var hostSelector = token ? "[" + token + "-host]" : "";
    return [useActualHostSelector ? `:host([data-render-mode="shadow"]) [part~='overlay']` : hostSelector + `[data-render-mode="shadow"] [part~='overlay']`, shadowSelector, " {background-color: var(\n --sds-c-overlay-color-background,\n var(--sds-s-popup-color-background, var(--sds-g-color-neutral-base-1))\n );color: var(\n --sds-c-overlay-text-color,\n var(--sds-s-popup-text-color, var(--sds-g-color-neutral-base-contrast-4))\n );border-radius: var(\n --sds-c-overlay-radius-border,\n var(--sds-s-popup-radius-border, var(--sds-g-radius-border-2, 0.25rem))\n );border-width: var(\n --sds-c-overlay-sizing-border,\n var(--sds-s-popup-sizing-border, var(--sds-g-sizing-border-1, 1px))\n );border-color: var(\n --sds-c-overlay-color-border,\n var(--sds-s-popup-color-border, var(--sds-g-color-border-base-1, #c9c9c9))\n );box-shadow: var(--sds-c-overlay-shadow, var(--sds-s-popup-shadow, var(--sds-g-shadow-1, 0 0 2px 0 #18181814, 0 2px 4px 1px #18181828)));padding-left: var(\n --sds-c-overlay-spacing-inline-start,\n var(--sds-c-overlay-spacing-inline, var(--sds-s-popup-spacing-inline, var(--sds-g-spacing-3, 0.75rem)))\n );padding-right: var(\n --sds-c-overlay-spacing-inline-end,\n var(--sds-c-overlay-spacing-inline, var(--sds-s-popup-spacing-inline, var(--sds-g-spacing-3, 0.75rem)))\n );padding-top: var(\n --sds-c-overlay-spacing-block-start,\n var(--sds-c-overlay-spacing-block, var(--sds-s-popup-spacing-block, var(--sds-g-spacing-3, 0.75rem)))\n );padding-bottom: var(\n --sds-c-overlay-spacing-block-end,\n var(--sds-c-overlay-spacing-block, var(--sds-s-popup-spacing-block, var(--sds-g-spacing-3, 0.75rem)))\n );}@supports (--styling-hooks: '') {", useActualHostSelector ? `:host([data-render-mode="shadow"]) [part~='overlay']` : hostSelector + `[data-render-mode="shadow"] [part~='overlay']`, shadowSelector, " {--sds-c-overlay-color-background: var(--slds-c-tooltip-color-background, #032d60);--sds-c-overlay-text-color: var(--slds-c-tooltip-text-color, #fff);--sds-c-overlay-radius-border: var(--slds-c-tooltip-radius-border, 0.25rem);--sds-c-overlay-sizing-border: var(--slds-c-tooltip-sizing-border, 0);--sds-c-overlay-color-border: var(--slds-c-tooltip-color-border);--sds-c-overlay-shadow: var(--slds-c-tooltip-shadow, 0 2px 3px 0 rgb(0 0 0 / 16%));--sds-c-overlay-spacing-inline-start: var(\n --slds-c-tooltip-spacing-inline-start,\n var(--sds-c-tooltip-spacing-inline, 0.75rem)\n );--sds-c-overlay-spacing-inline-end: var(\n --slds-c-tooltip-spacing-inline-end,\n var(--sds-c-tooltip-spacing-inline, 0.75rem)\n );--sds-c-overlay-spacing-block-start: var(\n --slds-c-tooltip-spacing-block-start,\n var(--sds-c-tooltip-spacing-block, 0.5rem)\n );--sds-c-overlay-spacing-block-end: var(\n --slds-c-tooltip-spacing-block-end,\n var(--sds-c-tooltip-spacing-block, 0.5rem)\n );font-size: var(--slds-c-tooltip-font-size, 0.75rem);max-width: var(--slds-c-tooltip-sizing-width-max, 20rem);position: relative;}}", useActualHostSelector ? `:host([data-render-mode="shadow"]) [part~='overlay']` : hostSelector + `[data-render-mode="shadow"] [part~='overlay']`, shadowSelector, "::after {box-shadow: -1px -1px 0 0 rgba(0, 0, 0, 0.16);z-index: -1;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_top' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top', shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: -0.5rem;margin-left: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_top' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top', shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: -0.5rem;margin-left: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_top-left' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_top-left-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-left' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-left-corner', shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: -0.5rem;margin-left: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_top-left' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_top-left-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-left' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-left-corner', shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: -0.5rem;margin-left: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_top-left' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_top-left' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_top-left-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_top-left-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-left' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-left' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-left-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-left-corner', shadowSelector, "::after {left: 1.5rem;top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_top-right' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_top-right-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-right' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-right-corner', shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: -0.5rem;margin-left: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_top-right' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_top-right-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-right' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-right-corner', shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;top: -0.5rem;margin-left: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_top-right' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_top-right' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_top-right-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_top-right-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-right' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-right' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-right-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-right-corner', shadowSelector, "::after {left: auto;right: 1.5rem;top: -0.5rem;margin-right: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom', shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: -0.5rem;margin-left: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom', shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: -0.5rem;margin-left: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom', shadowSelector, "::after {-webkit-box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.16);box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.16);z-index: -1;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom-left' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-left-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left-corner', shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: -0.5rem;margin-left: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom-left' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-left-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left-corner', shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: -0.5rem;margin-left: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom-left' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-left-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left-corner', shadowSelector, "::after {-webkit-box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.16);box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.16);z-index: -1;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom-left' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-left' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-left-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-left-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left-corner', shadowSelector, "::after {left: 1.5rem;top: 100%;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom-right' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-right-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right-corner', shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: -0.5rem;margin-left: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom-right' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-right-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right-corner', shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;left: 50%;bottom: -0.5rem;margin-left: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom-right' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-right-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right-corner', shadowSelector, "::after {-webkit-box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.16);box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.16);z-index: -1;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom-right' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-right' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-right-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-right-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right-corner', shadowSelector, "::after {left: auto;right: 1.5rem;top: 100%;margin-top: -0.5rem;margin-right: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left', shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: -0.5rem;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left', shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: -0.5rem;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left', shadowSelector, "::after {-webkit-box-shadow: -1px 1px 2px 0 rgba(0, 0, 0, 0.16);box-shadow: -1px 1px 2px 0 rgba(0, 0, 0, 0.16);z-index: -1;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-top' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_left-top-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top-corner', shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: -0.5rem;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-top' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_left-top-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top-corner', shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: -0.5rem;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-top' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_left-top-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top-corner', shadowSelector, "::after {-webkit-box-shadow: -1px 1px 2px 0 rgba(0, 0, 0, 0.16);box-shadow: -1px 1px 2px 0 rgba(0, 0, 0, 0.16);z-index: -1;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-top' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_left-top' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_left-top-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_left-top-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top-corner', shadowSelector, "::after {top: 1.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-bottom' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_left-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom-corner', shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: -0.5rem;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-bottom' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_left-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom-corner', shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;left: -0.5rem;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-bottom' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_left-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom-corner', shadowSelector, "::before {margin-bottom: -1px;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-bottom' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_left-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom-corner', shadowSelector, "::after {-webkit-box-shadow: -1px 2px 3px 0 rgba(0, 0, 0, 0.16);box-shadow: -1px 2px 3px 0 rgba(0, 0, 0, 0.16);z-index: -1;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-bottom' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_left-bottom' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_left-bottom-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_left-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom-corner', shadowSelector, "::after {top: auto;bottom: 1rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right', shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: -0.5rem;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right', shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: -0.5rem;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right', shadowSelector, "::after {-webkit-box-shadow: 1px -1px 2px 0 rgba(0, 0, 0, 0.16);box-shadow: 1px -1px 2px 0 rgba(0, 0, 0, 0.16);z-index: -1;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-top' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_right-top-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top-corner', shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: -0.5rem;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-top' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_right-top-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top-corner', shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: -0.5rem;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-top' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_right-top-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top-corner', shadowSelector, "::after {-webkit-box-shadow: 1px -1px 2px 0 rgba(0, 0, 0, 0.16);box-shadow: 1px -1px 2px 0 rgba(0, 0, 0, 0.16);z-index: -1;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-top' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_right-top' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_right-top-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_right-top-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top-corner', shadowSelector, "::after {top: 1.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-bottom' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_right-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom-corner', shadowSelector, "::before {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: -0.5rem;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-bottom' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_right-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom-corner', shadowSelector, "::after {width: 1rem;height: 1rem;position: absolute;transform: rotate(45deg);content: '';background-color: inherit;top: 50%;right: -0.5rem;margin-top: -0.5rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-bottom' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_right-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom-corner', shadowSelector, "::before {margin-bottom: -1px;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-bottom' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_right-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom-corner', shadowSelector, "::after {-webkit-box-shadow: 2px -1px 3px 0 rgba(0, 0, 0, 0.16);box-shadow: 2px -1px 3px 0 rgba(0, 0, 0, 0.16);z-index: -1;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-bottom' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_right-bottom' + shadowSelector + '::after,:host([data-render-mode="shadow"]) .slds-nubbin_right-bottom-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_right-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom' + shadowSelector + "::after," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom-corner', shadowSelector, "::after {top: auto;bottom: 1rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_top-left-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-left-corner', shadowSelector, " {border-radius: 0.125rem 0.25rem 0.25rem 0.25rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_top-left-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_top-left-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-left-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-left-corner', shadowSelector, "::after {left: 0.75rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom-left-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left-corner', shadowSelector, " {border-radius: 0.25rem 0.25rem 0.25rem 0.125rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom-left-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-left-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-left-corner', shadowSelector, "::after {left: 0.75rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_top-right-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-right-corner', shadowSelector, " {border-radius: 0.25rem 0.125rem 0.25rem 0.25rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_top-right-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_top-right-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-right-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_top-right-corner', shadowSelector, "::after {right: 0.75rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom-right-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right-corner', shadowSelector, " {border-radius: 0.25rem 0.25rem 0.125rem 0.25rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_bottom-right-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_bottom-right-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_bottom-right-corner', shadowSelector, "::after {right: 0.75rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-top-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top-corner', shadowSelector, " {border-radius: 0.125rem 0.25rem 0.25rem 0.25rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-top-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_left-top-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-top-corner', shadowSelector, "::after {top: 0.75rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-top-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top-corner', shadowSelector, " {border-radius: 0.25rem 0.125rem 0.25rem 0.25rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-top-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_right-top-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-top-corner', shadowSelector, "::after {top: 0.75rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom-corner', shadowSelector, " {border-radius: 0.25rem 0.25rem 0.25rem 0.125rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_left-bottom-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_left-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_left-bottom-corner', shadowSelector, "::after {bottom: 0.25rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom-corner', shadowSelector, " {border-radius: 0.25rem 0.25rem 0.125rem 0.25rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-nubbin_right-bottom-corner' + shadowSelector + '::before,:host([data-render-mode="shadow"]) .slds-nubbin_right-bottom-corner' : hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom-corner' + shadowSelector + "::before," + hostSelector + '[data-render-mode="shadow"] .slds-nubbin_right-bottom-corner', shadowSelector, "::after {bottom: 0.25rem;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-rise-from-ground' : hostSelector + '[data-render-mode="shadow"] .slds-rise-from-ground', shadowSelector, " {visibility: visible;opacity: 1;transform: translate(0%, 0%);transition: opacity 0.1s linear, visibility 0.1s linear, transform 0.1s linear;will-change: transform;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-fall-into-ground' : hostSelector + '[data-render-mode="shadow"] .slds-fall-into-ground', shadowSelector, " {visibility: hidden;opacity: 0;transform: translate(0%, 0%);transition: opacity 0.1s linear, visibility 0.1s linear, transform 0.1s linear;will-change: transform;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-slide-from-bottom-to-top' : hostSelector + '[data-render-mode="shadow"] .slds-slide-from-bottom-to-top', shadowSelector, " {transform: translateY(10%);will-change: transform;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-slide-from-top-to-bottom' : hostSelector + '[data-render-mode="shadow"] .slds-slide-from-top-to-bottom', shadowSelector, " {transform: translateY(-10%);will-change: transform;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-slide-from-right-to-left' : hostSelector + '[data-render-mode="shadow"] .slds-slide-from-right-to-left', shadowSelector, " {transform: translateX(5%);will-change: transform;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-slide-from-left-to-right' : hostSelector + '[data-render-mode="shadow"] .slds-slide-from-left-to-right', shadowSelector, " {transform: translateX(-5%);will-change: transform;}", useActualHostSelector ? ':host([data-render-mode="shadow"]) .slds-hide' : hostSelector + '[data-render-mode="shadow"] .slds-hide', shadowSelector, " {display: none;}"].join("");
  }
  var stylesheet1 = [stylesheet$4];
  function stylesheet$3(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? "[" + token + "]" : "";
    return ".fix-popover_tooltip_alignment" + shadowSelector + " {min-width: inherit;}";
  }
  var _implicitStylesheets$1 = [stylesheet0, stylesheet1, stylesheet$3];
  const stc0$6 = {
    part: "overlay"
  };
  const stc1$3 = {
    "slds-popover__body": true
  };
  const stc2 = {
    lwc: {
      dom: "manual"
    }
  };
  function tmpl$7($api, $cmp, $slotset, $ctx) {
    const {b: api_bind, h: api_element} = $api;
    const {_m0, _m1} = $ctx;
    return [api_element("div", {
      className: $cmp.computedPopoverClass,
      attrs: stc0$6,
      key: 0,
      on: {
        transitionend: _m0 || ($ctx._m0 = api_bind($cmp.handleTransitionEnd))
      }
    }, [api_element("div", {
      classMap: stc1$3,
      context: stc2,
      key: 1,
      on: {
        mouseleave: _m1 || ($ctx._m1 = api_bind($cmp.handleMouseLeave))
      }
    })])];
  }
  var _tmpl$7 = _2_41_4.registerTemplate(tmpl$7);
  tmpl$7.stylesheets = [];
  if (_implicitStylesheets$1) {
    tmpl$7.stylesheets.push.apply(tmpl$7.stylesheets, _implicitStylesheets$1);
  }
  tmpl$7.stylesheetToken = "lightning-primitiveBubble_primitiveBubble";
  _2_41_4.freezeTemplate(tmpl$7);
  const stc0$5 = [];
  function tmpl$6($api, $cmp, $slotset, $ctx) {
    return stc0$5;
  }
  var _tmpl$6 = _2_41_4.registerTemplate(tmpl$6);
  tmpl$6.stylesheets = [];
  tmpl$6.stylesheetToken = "lightning-shadowBaseClassPrivate_shadowBaseClassPrivate";
  _2_41_4.freezeTemplate(tmpl$6);
  class LightningShadowBaseClass extends _2_41_4.LightningElement {
    connectedCallback() {
      if (!this.template.synthetic) {
        this.setAttribute("data-render-mode", "shadow");
      }
    }
  }
  LightningShadowBaseClass.shadowSupportMode = "any";
  var LightningShadowBaseClass$1 = _2_41_4.registerComponent(LightningShadowBaseClass, {
    tmpl: _tmpl$6,
    sel: "lightning-shadowBaseClassPrivate"
  });
  const DEFAULT_ALIGN = {
    horizontal: "left",
    vertical: "bottom"
  };
  class LightningPrimitiveBubble extends LightningShadowBaseClass$1 {
    constructor(...args) {
      super(...args);
      this.state = {
        visible: false,
        hidden: true,
        contentId: ""
      };
      this.disableVisibilityChangeOnLeave = void 0;
    }
    get contentId() {
      return this.state.contentId;
    }
    set contentId(value) {
      this.state.contentId = value;
      if (this.state.inDOM) {
        this.divEl.setAttribute("id", this.state.contentId);
      }
    }
    connectedCallback() {
      super.connectedCallback();
      this.setAttribute("role", "tooltip");
      this.state.inDOM = true;
    }
    disconnectedCallback() {
      this.state.inDOM = false;
    }
    renderedCallback() {
      this.setContentManually();
      this.setIdManually();
    }
    set content(value) {
      this.state.content = value;
      if (this.state.inDOM) {
        this.setContentManually();
      }
    }
    get content() {
      return this.state.content || "";
    }
    get align() {
      return this.state.align || DEFAULT_ALIGN;
    }
    set align(value) {
      this.state.align = value;
    }
    get visible() {
      return this.state.visible;
    }
    set visible(value) {
      this.state.visible = value;
      if (this.state.visible) {
        this.state.hidden = false;
      }
    }
    handleTransitionEnd() {
      if (!this.state.visible) {
        this.state.hidden = true;
      }
    }
    setIdManually() {
      this.setAttribute("id", this.state.contentId);
    }
    setContentManually() {
      this.template.querySelector(".slds-popover__body").textContent = this.state.content;
    }
    get computedPopoverClass() {
      const classes = classSet("slds-popover").add("slds-popover_tooltip").add("fix-popover_tooltip_alignment");
      classes.add({
        "slds-rise-from-ground": this.visible,
        "slds-fall-into-ground": !this.visible,
        "slds-hide": this.state.hidden
      });
      const {
        horizontal,
        vertical
      } = this.align;
      classes.add({
        "slds-nubbin_top-left": horizontal === "left" && vertical === "top",
        "slds-nubbin_top-right": horizontal === "right" && vertical === "top",
        "slds-nubbin_bottom-left": horizontal === "left" && vertical === "bottom",
        "slds-nubbin_bottom-right": horizontal === "right" && vertical === "bottom",
        "slds-nubbin_bottom": horizontal === "center" && vertical === "bottom",
        "slds-nubbin_top": horizontal === "center" && vertical === "top",
        "slds-nubbin_left": horizontal === "left" && vertical === "center",
        "slds-nubbin_right": horizontal === "right" && vertical === "center"
      });
      return classes.toString();
    }
    handleMouseLeave() {
      if (!this.disableVisibilityChangeOnLeave) {
        this.visible = false;
      }
    }
  }
  _2_41_4.registerDecorators(LightningPrimitiveBubble, {
    publicProps: {
      disableVisibilityChangeOnLeave: {
        config: 0
      },
      contentId: {
        config: 3
      },
      content: {
        config: 3
      },
      align: {
        config: 3
      },
      visible: {
        config: 3
      }
    },
    track: {
      state: 1
    }
  });
  var LightningPrimitiveBubble$1 = _2_41_4.registerComponent(LightningPrimitiveBubble, {
    tmpl: _tmpl$7,
    sel: "lightning-primitiveBubble"
  });
  const screenReaderOnlyStyles = `
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
`;
  let microtaskQueued = false;
  const queue = [];
  function flushQueue() {
    const sortedQueue = [...queue].sort((a2, b2) => a2.priority - b2.priority);
    queue.length = 0;
    microtaskQueued = false;
    sortedQueue.forEach(({
      callback
    }) => callback());
  }
  function queueMicrotaskWithPriority(priority, callback) {
    queue.push({
      callback,
      priority
    });
    if (microtaskQueued) {
      return;
    }
    microtaskQueued = true;
    Promise.resolve().then(flushQueue);
  }
  function getChildNodesIgnoringShadowRoot(node) {
    if (node.shadowRoot) {
      return node.shadowRoot.childNodes;
    } else if (typeof node.assignedNodes === "function") {
      const assigned = node.assignedNodes();
      return assigned.length ? assigned : node.childNodes;
    }
    return node.childNodes;
  }
  function getParentIgnoringShadowRoot(element) {
    if (typeof element.assignedNodes !== "function" && element.assignedSlot && element.assignedSlot.parentElement) {
      return element.assignedSlot.parentElement;
    }
    if (element.parentElement) {
      return element.parentElement;
    }
    const rootNode = element.getRootNode();
    if (rootNode !== document) {
      return rootNode.host;
    }
    return null;
  }
  function isAncestor(node, possibleAncestor) {
    let ancestor = node;
    while (ancestor !== null && ancestor !== void 0) {
      ancestor = getParentIgnoringShadowRoot(ancestor);
      if (ancestor === possibleAncestor) {
        return true;
      }
    }
    return false;
  }
  class DeepMutationObserver {
    constructor(rootNode) {
      this._observers = [];
      this._callbacks = [];
      const observedNodes = [];
      const alreadyObserved = (node) => {
        return observedNodes.some((otherNode) => otherNode.contains(node));
      };
      const observe = (node) => {
        if (!alreadyObserved(node)) {
          observedNodes.push(node);
          const observer = new MutationObserver(() => this._mutationCallback());
          observer.observe(node, {
            subtree: true,
            attributes: true,
            childList: true,
            characterData: true
          });
          this._observers.push(observer);
        }
        getChildNodesIgnoringShadowRoot(node).forEach((child) => observe(child));
      };
      observe(rootNode);
    }
    onMutation(callback) {
      this._callbacks.push(callback);
    }
    _mutationCallback() {
      queueMicrotaskWithPriority(0, () => this._callbacks.forEach((callback) => callback()));
    }
    disconnect() {
      this._observers.forEach((observer) => observer.disconnect());
      this._observers = void 0;
      this._callbacks = void 0;
    }
  }
  function collateTasks(tasks) {
    const mapOfFromRootsToTasks = new Map();
    tasks.forEach((task) => {
      const {
        fromNode
      } = task;
      const fromRoot = fromNode.getRootNode();
      let collatedTask = mapOfFromRootsToTasks.get(fromRoot);
      if (!collatedTask) {
        collatedTask = {
          relationships: [],
          redundantChildNodes: new Set()
        };
        mapOfFromRootsToTasks.set(fromRoot, collatedTask);
      }
      collatedTask.relationships.push(task);
    });
    mapOfFromRootsToTasks.forEach((value) => {
      const {
        relationships,
        redundantChildNodes
      } = value;
      const allToNodes = relationships.map((relationship) => relationship.toNodes).flat();
      for (let i = 0; i < allToNodes.length; i++) {
        for (let j = i + 1; j < allToNodes.length; j++) {
          const toNodeA = allToNodes[i];
          const toNodeB = allToNodes[j];
          if (toNodeA && toNodeB && i !== j) {
            if (isAncestor(toNodeA, toNodeB)) {
              redundantChildNodes.add(toNodeA);
            } else if (isAncestor(toNodeB, toNodeA)) {
              redundantChildNodes.add(toNodeB);
            }
          }
        }
      }
    });
    return mapOfFromRootsToTasks;
  }
  function getAttributes(node) {
    const res = {};
    const {
      attributes
    } = node;
    for (let i = 0; i < attributes.length; i++) {
      const attribute = attributes[i];
      res[attribute.name] = attribute.value;
    }
    return res;
  }
  const stableIds = new WeakMap();
  function generateId() {
    return "shadow-aria-" + Math.floor(Math.random() * 1e9).toString(16);
  }
  function getStableId(referenceNode) {
    let id = stableIds.get(referenceNode);
    if (!id) {
      id = generateId();
      stableIds.set(referenceNode, id);
    }
    return id;
  }
  const TABBABLE_TAG_NAMES = new Set(["a", "audio", "button", "details", "input", "select", "summary", "textarea", "video"]);
  function redirectEvents(fromNode, toNode) {
    if (fromNode && toNode) {
      redirectFocusEvent(fromNode, toNode);
    }
  }
  function redirectFocusEvent(fromNode, toNode) {
    fromNode.addEventListener("focus", (event) => {
      event.preventDefault();
      event.stopImmediatePropagation();
      toNode.dispatchEvent(new event.constructor(event.type, event));
      toNode.focus();
    });
  }
  const STYLE_PROPS_TO_MIRROR = ["display", "visibility"];
  function mirrorNode(node, existingNode) {
    if (node.nodeType === Node.TEXT_NODE) {
      if (existingNode && existingNode.nodeType === Node.TEXT_NODE) {
        if (existingNode.textContent !== node.textContent) {
          existingNode.textContent = node.textContent;
        }
        return existingNode;
      }
      return node.cloneNode();
    }
    if (node.nodeType !== Node.ELEMENT_NODE) {
      return document.createComment("shadow-aria-deleted");
    }
    let {
      tagName
    } = node;
    if (["style", "link", "script"].includes(tagName.toLowerCase())) {
      return document.createComment("shadow-aria-deleted");
    }
    if (tagName.includes("-") || tagName.toLowerCase() === "slot") {
      tagName = "div";
    }
    let oldAttributes;
    let mirroredNode;
    if (existingNode && existingNode.nodeType === Node.ELEMENT_NODE && existingNode.tagName.toLowerCase() === tagName.toLowerCase()) {
      mirroredNode = existingNode;
      oldAttributes = getAttributes(mirroredNode);
    } else {
      mirroredNode = document.createElement(tagName);
    }
    const newAttributes = Object.fromEntries([...Object.entries(getAttributes(node))].filter(([name]) => name.toLowerCase().startsWith("aria-") || name.toLowerCase() === "role"));
    const computedStyle = getComputedStyle(node);
    let newStyle = "";
    STYLE_PROPS_TO_MIRROR.forEach((prop) => newStyle += `${prop}:${computedStyle[prop]};`);
    if (computedStyle?.display !== "contents") {
      newAttributes.id = getStableId(node);
    }
    newAttributes.style = newStyle;
    if (TABBABLE_TAG_NAMES.has(tagName.toLowerCase())) {
      newAttributes.tabindex = "-1";
    }
    Object.entries(newAttributes).forEach(([name, value]) => {
      if (!oldAttributes || oldAttributes[name] !== value) {
        mirroredNode.setAttribute(name, value);
      }
    });
    if (oldAttributes) {
      Object.keys(oldAttributes).forEach((name) => {
        if (!(name in newAttributes)) {
          mirroredNode.removeAttribute(name);
        }
      });
    }
    redirectEvents(mirroredNode, node);
    return mirroredNode;
  }
  function patchMirrorDomTree(root, existingRoot, trackedNodes) {
    const trackedNodesToMirroredNodes = new Map();
    const mirrorNodeRecursive = (node, existingNode) => {
      const mirroredNode = mirrorNode(node, existingNode);
      if (mirroredNode.nodeType === Node.COMMENT_NODE) {
        return mirroredNode;
      }
      if (trackedNodes.has(node)) {
        trackedNodesToMirroredNodes.set(node, mirroredNode);
      }
      const childNodes = getChildNodesIgnoringShadowRoot(node);
      if (existingNode && existingNode.childNodes.length === childNodes.length) {
        for (let i = 0; i < childNodes.length; i++) {
          const existingChild = existingNode.childNodes[i];
          const child = childNodes[i];
          const newChild = mirrorNodeRecursive(child, existingChild);
          if (newChild !== existingChild) {
            existingNode.replaceChild(newChild, existingChild);
          }
        }
      } else {
        if (existingNode) {
          while (existingNode.childNodes.length) {
            existingNode.childNodes[existingNode.childNodes.length - 1].remove();
          }
        }
        childNodes.forEach((childNode) => {
          const mirrorChild = mirrorNodeRecursive(childNode, null);
          mirroredNode.appendChild(mirrorChild);
        });
      }
      return mirroredNode;
    };
    const mirroredDomTree = mirrorNodeRecursive(root, existingRoot);
    return {
      mirroredNode: mirroredDomTree,
      trackedNodesToMirroredNodes
    };
  }
  function updateAttribute(fromNode, toNodes, relationship) {
    const newIds = toNodes.map((toNode) => toNode.getAttribute("id"));
    const existingIds = splitIds$1(fromNode.getAttribute(relationship));
    const linkedNodeIds = newIds.filter((newId) => !existingIds.includes(newId));
    const unlinkedNodeIds = existingIds.filter((existingId) => !newIds.includes(existingId));
    fromNode.setAttribute(relationship, newIds.join(" "));
    return {
      linkedNodeIds,
      unlinkedNodeIds
    };
  }
  function splitIds$1(ids) {
    if (!ids) {
      return [];
    }
    return ids.trim().split(/\s+/);
  }
  const SINGLE_TARGET_ARIA_RELATIONSHIPS = ["aria-activedescendant", "aria-errormessage"];
  const mirroredEnvironments = new WeakMap();
  const taskQueue = [];
  function processTask(fromRoot, task) {
    const mirroredEnvironment = getMirroredEnvironment(fromRoot);
    mirrorNodes(mirroredEnvironment, task);
    linkAndObserveNodes(mirroredEnvironment, task);
  }
  function getMirroredEnvironment(fromRoot) {
    let mirroredEnvironment = mirroredEnvironments.get(fromRoot);
    if (!mirroredEnvironment) {
      const mirrorRoot = document.createElement("div");
      mirrorRoot.setAttribute("class", "aria-element-reflection-mirror");
      mirrorRoot.setAttribute("style", screenReaderOnlyStyles);
      const fromAnchorRoot = fromRoot.body || fromRoot;
      fromAnchorRoot.appendChild(mirrorRoot);
      mirroredEnvironment = {
        redundantChildNodes: new Set(),
        nodesToMirroredNodes: new Map(),
        mirrorRoot
      };
      mirroredEnvironments.set(fromRoot, mirroredEnvironment);
    }
    return mirroredEnvironment;
  }
  function mirrorNodes(mirroredEnvironment, task) {
    const {
      redundantChildNodes,
      nodesToMirroredNodes,
      mirrorRoot
    } = mirroredEnvironment;
    task.redundantChildNodes.forEach((node) => redundantChildNodes.add(node));
    const rootToNodes = new Set(task.relationships.map(({
      toNodes
    }) => toNodes).flat().filter(Boolean).filter((_) => !redundantChildNodes.has(_)));
    rootToNodes.forEach((toNode) => {
      const trackedNodes = new Set([...redundantChildNodes, toNode]);
      const {
        node: existingMirroredNode = null,
        usage = 0
      } = nodesToMirroredNodes.get(toNode) || {};
      const {
        mirroredNode,
        trackedNodesToMirroredNodes
      } = patchMirrorDomTree(toNode, existingMirroredNode, trackedNodes);
      if (mirroredNode !== existingMirroredNode) {
        if (existingMirroredNode) {
          mirrorRoot.removeChild(existingMirroredNode);
        }
        mirrorRoot.appendChild(mirroredNode);
      }
      trackedNodesToMirroredNodes.forEach((trackedMirroredNode, trackedNode) => nodesToMirroredNodes.set(trackedNode, {
        node: trackedMirroredNode,
        usage
      }));
    });
  }
  function linkAndObserveNodes(mirroredEnvironment, task) {
    const {
      nodesToMirroredNodes
    } = mirroredEnvironment;
    task.relationships.forEach((collatedRelationship) => {
      const {
        fromNode,
        toNodes,
        relationship,
        track,
        signal,
        mirrorOnly
      } = collatedRelationship;
      if (toNodes?.length) {
        if (!mirrorOnly) {
          const mirroredNodes = toNodes.map((toNode) => nodesToMirroredNodes.get(toNode).node);
          const {
            linkedNodeIds,
            unlinkedNodeIds
          } = updateAttribute(fromNode, mirroredNodes, relationship);
          updateNodeUsage(mirroredEnvironment, unlinkedNodeIds, linkedNodeIds);
          if (track) {
            observeNode(fromNode, toNodes, signal);
          }
        }
      } else {
        const {
          unlinkedNodeIds
        } = updateAttribute(fromNode, [], relationship);
        updateNodeUsage(mirroredEnvironment, unlinkedNodeIds);
        fromNode.removeAttribute(relationship);
      }
    });
  }
  function updateNodeUsage(mirroredEnvironment, unlinkedNodes, linkedNodes = []) {
    const {
      nodesToMirroredNodes,
      mirrorRoot
    } = mirroredEnvironment;
    nodesToMirroredNodes.forEach((mirroredNode, node) => {
      if (linkedNodes.includes(mirroredNode.node.id)) {
        mirroredNode.usage++;
      } else if (unlinkedNodes.includes(mirroredNode.node.id) && --mirroredNode.usage <= 0) {
        nodesToMirroredNodes.delete(node);
        if (mirroredNode.node.parentElement === mirrorRoot) {
          mirrorRoot.removeChild(mirroredNode.node);
        }
      }
    });
  }
  function observeNode(fromNode, toNodes, signal) {
    toNodes.forEach((toNode) => {
      const mutationObserver = new DeepMutationObserver(toNode);
      mutationObserver.onMutation(() => {
        updateAriaRelationship(fromNode, [toNode]);
      });
      if (signal) {
        signal.addEventListener("abort", () => {
          mutationObserver.disconnect();
        });
      }
    });
  }
  function processQueue() {
    const mapOfFromRootsToTasks = collateTasks(taskQueue);
    taskQueue.length = 0;
    mapOfFromRootsToTasks.forEach((task, fromRoot) => processTask(fromRoot, task));
  }
  function updateAriaRelationship(fromNode, toNodes) {
    queueTask({
      fromNode,
      toNodes,
      mirrorOnly: true
    });
  }
  function queueTask(task) {
    taskQueue.push(task);
    queueMicrotaskWithPriority(1, processQueue);
  }
  function massageToNodes(toNodes, relationship) {
    if (!Array.isArray(toNodes)) {
      toNodes = [toNodes];
    }
    toNodes = toNodes.filter(Boolean);
    if (toNodes.length > 1 && SINGLE_TARGET_ARIA_RELATIONSHIPS.includes(relationship)) {
      console.warn(`Multiple targets passed to aria relationship "${relationship}". This API only accepts a single target. Ignoring elements beyond the first one.`);
      toNodes = toNodes.slice(0, 1);
    }
    return toNodes;
  }
  function setAriaRelationship(fromNode, toNodes, relationship, options = {}) {
    const {
      track,
      signal
    } = options;
    toNodes = massageToNodes(toNodes, relationship);
    queueTask({
      fromNode,
      toNodes,
      relationship,
      track,
      signal
    });
  }
  function setAriaActiveDescendant(fromNode, toNodes, options) {
    setAriaRelationship(fromNode, toNodes, "aria-activedescendant", options);
  }
  function setAriaControls(fromNode, toNodes, options) {
    setAriaRelationship(fromNode, toNodes, "aria-controls", options);
  }
  function setAriaDescribedBy(fromNode, toNodes, options) {
    setAriaRelationship(fromNode, toNodes, "aria-describedby", options);
  }
  function setAriaLabelledBy(fromNode, toNodes, options) {
    setAriaRelationship(fromNode, toNodes, "aria-labelledby", options);
  }
  const SUPPORTED_ATTRIBUTES = new Map([["aria-controls", {
    ariaReflection: "ariaControlsElements",
    polyfill: setAriaControls
  }], ["aria-labelledby", {
    ariaReflection: "ariaLabelledByElements",
    polyfill: setAriaLabelledBy
  }], ["aria-describedby", {
    ariaReflection: "ariaDescribedByElements",
    polyfill: setAriaDescribedBy
  }], ["aria-activedescendant", {
    ariaReflection: "ariaActiveDescendantElement",
    polyfill: setAriaActiveDescendant
  }]]);
  function extractElements(root, ids) {
    if (typeof ids !== "string" || ids === "") {
      return [];
    }
    return splitIds(ids).map((id) => root.querySelector(`#${id}`)).filter((el) => !!el);
  }
  function splitIds(ids) {
    return ids ? (ids + "").trim().split(/\s+/) : [];
  }
  class AriaObserver {
    constructor(component) {
      this.component = component;
      this.template = component.template;
      this.isNativeShadow = isNativeComponent(component);
      this.state = {};
      this.liveIds = {};
      this.guid = guid();
      this.placeholderContainer = null;
    }
    connectLiveIdRef(refs, callback) {
      const selector = (refs + "").trim().split(/\s+/).map((ref) => `[id*="${ref}"]`).join(",");
      const liveId = {
        refs,
        selector,
        callback
      };
      this.liveIds[refs] = liveId;
    }
    connect({
      attribute,
      targetSelector,
      targetNode,
      relatedNodeIds,
      relatedNodes
    }) {
      this.state[attribute] = this.state[attribute] || {};
      const attrState = this.state[attribute];
      attrState.targetNode = targetNode;
      attrState.targetSelector = targetSelector;
      attrState.relatedNodes = (!Array.isArray(relatedNodes) ? [relatedNodes] : relatedNodes).filter(Boolean);
      attrState.relatedNodeIds = Array.isArray(relatedNodeIds) ? relatedNodeIds.join(" ") : relatedNodeIds;
      if (this.component.isConnected) {
        this.privateUpdate(attribute);
      }
    }
    sync(isNativeShadow) {
      if (isNativeShadow != null) {
        this.isNativeShadow = isNativeShadow;
      }
      if (!this.component.isConnected) {
        throw new Error(`Invalid sync invocation. It can only be invoked during renderedCallback().`);
      }
      if (!this.root) {
        this.root = this.template && this.template.host ? this.template.host.getRootNode() : null;
      }
      this.privateUpdateLiveIds();
      for (const attrName in this.state) {
        if (Object.prototype.hasOwnProperty.call(this.state, attrName)) {
          this.privateUpdate(attrName);
        }
      }
    }
    get privateIsMoRequired() {
      return this.isNativeShadow || Object.keys(this.liveIds).length !== 0;
    }
    get root() {
      return this._root;
    }
    set root(root) {
      this._root = root;
      if (this._root && this.privateIsMoRequired) {
        this.privateCreateMutationObserver();
      }
    }
    privateUpdate(attrName) {
      const {
        targetSelector,
        targetNode = this.template.querySelector(targetSelector),
        relatedNodeIds,
        relatedNodes
      } = this.state[attrName];
      if (!targetNode) {
        return;
      }
      const attribute = SUPPORTED_ATTRIBUTES.get(attrName);
      if (!attribute) {
        throw new Error(`${attrName} is not supported by AriaObserver. Supported attributes: ${Array.from(SUPPORTED_ATTRIBUTES.keys())}`);
      }
      if (this.isNativeShadow) {
        const allRelatedNodes = [...relatedNodes, ...extractElements(this.root, relatedNodeIds)];
        if (targetNode[attribute.ariaReflection]) {
          attribute.polyfill(targetNode, null, attrName);
          targetNode[attribute.ariaReflection] = relatedNodes;
        } else {
          attribute.polyfill(targetNode, allRelatedNodes, attrName);
        }
      } else {
        synchronizeAttrs(targetNode, {
          [attrName]: [...splitIds(relatedNodeIds), ...relatedNodes.map((n2) => n2.id)].join(" ")
        });
      }
    }
    privateExtractCorrectElements(selector = "", elements) {
      const selectors = selector.split(/\s/g);
      const matchSelectors = `(${selectors.join("|")})`;
      const regex = new RegExp(`^${matchSelectors}(-[0-9]+)$`);
      return [...elements].filter((element) => {
        return regex.test(element.id);
      });
    }
    privateCreateMutationObserver() {
      this.disconnect();
      this.mo = new MutationObserver(() => {
        if (!this.component.isConnected) {
          return;
        }
        this.sync();
      });
      this.mo.observe(this.root, {
        characterData: true,
        childList: true,
        subtree: true
      });
    }
    privateExtractIds(elements) {
      return elements.map((el) => {
        return el.getAttribute("id");
      }).join(" ");
    }
    privateUpdateLiveIds() {
      const root = this.template && this.template.host ? this.template.host.getRootNode() : null;
      if (!root) {
        return;
      }
      for (const liveId in this.liveIds) {
        if (Object.prototype.hasOwnProperty.call(this.liveIds, liveId)) {
          const thisId = this.liveIds[liveId];
          if (!thisId.elements || !thisId.elements.length) {
            const splitRefIds = splitIds(liveId);
            const refElements = [...root.querySelectorAll(thisId.selector)];
            thisId.elements = refElements.sort((a2, b2) => {
              const idA = a2.getAttribute("id")?.replace(/-[0-9]+$/g, "");
              const idB = b2.getAttribute("id")?.replace(/-[0-9]+$/g, "");
              return splitRefIds.indexOf(idA) - splitRefIds.indexOf(idB);
            });
          }
          const newThisId = this.privateExtractCorrectElements(thisId.refs, thisId.elements);
          const newIds = this.privateExtractIds(newThisId);
          if (newIds.length && newIds !== thisId.ids) {
            thisId.callback(newIds);
            thisId.ids = newIds;
          }
        }
      }
    }
    disconnect() {
      if (this.mo) {
        this.mo.disconnect();
        this.mo = void 0;
      }
    }
  }
  var AriaObserver$1 = _2_41_4.registerComponent(AriaObserver, {
    tmpl: _tmpl$a,
    sel: "lightning-ariaObserver"
  });
  function ownKeys$5(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$5(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty$5(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$5(obj, key, value) {
    key = _toPropertyKey$5(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$5(arg) {
    var key = _toPrimitive$5(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$5(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const BUBBLE_PREFIX = `salesforce-lightning-tooltip-bubble`;
  const BUBBLE_ID = `${BUBBLE_PREFIX}_${guid()}`;
  function isResizeObserverSupported() {
    return window.ResizeObserver != null;
  }
  let CACHED_BUBBLE_ELEMENT;
  let activeTooltip;
  function getCachedBubbleElement() {
    if (!CACHED_BUBBLE_ELEMENT) {
      CACHED_BUBBLE_ELEMENT = _2_41_4.createElement("lightning-primitive-bubble", {
        is: LightningPrimitiveBubble$1
      });
      CACHED_BUBBLE_ELEMENT.contentId = BUBBLE_ID;
      CACHED_BUBBLE_ELEMENT.style.position = "absolute";
      CACHED_BUBBLE_ELEMENT.style.minWidth = "75px";
      CACHED_BUBBLE_ELEMENT.disableVisibilityChangeOnLeave = true;
    }
    return CACHED_BUBBLE_ELEMENT;
  }
  const ARIA_DESCRIBEDBY = "aria-describedby";
  const NUBBIN_SIZE = 16;
  const NUBBIN_OFFSET = 24;
  const TooltipType = {
    Info: "info",
    Toggle: "toggle"
  };
  class Tooltip {
    constructor(value, config2) {
      this._autoPosition = null;
      this._disabled = true;
      this._initialized = false;
      this._visible = false;
      this._isFocusEvent = false;
      this._initialResize = true;
      this._ariaObserver = null;
      this._config = {};
      assert(config2.target, "target for tooltip is undefined or missing");
      this.value = value;
      this._root = config2.root;
      this._target = config2.target;
      this._config = _objectSpread$5({}, config2);
      this._config.align = config2.align || {};
      this._config.targetAlign = config2.targetAlign || {};
      this._type = normalizeString(config2.type, {
        fallbackValue: TooltipType.Info,
        validValues: Object.values(TooltipType)
      });
      this._element = config2.element;
      if (isCSR && !this._element) {
        this._element = getCachedBubbleElement;
        const bubbleElement = getCachedBubbleElement();
        if (bubbleElement.parentNode === null) {
          document.body.appendChild(bubbleElement);
        }
      }
      this.handleDocumentTouch = this.handleDocumentTouch.bind(this);
      this.handleEscape = this.handleEscape.bind(this);
      this.hide = this.hide.bind(this);
    }
    detach() {
      this._disabled = true;
    }
    attach() {
      this._disabled = false;
    }
    initialize() {
      const target = this._target();
      if (!this._initialized && target) {
        switch (this._type) {
          case TooltipType.Toggle:
            this.addToggleListeners();
            break;
          case TooltipType.Info:
          default:
            this.addInfoListeners();
            break;
        }
        this._ariaObserver = new AriaObserver$1(this._root);
        this._ariaObserver.connect({
          attribute: ARIA_DESCRIBEDBY,
          targetNode: this._target(),
          relatedNodes: this._element()
        });
        this._initialized = true;
      }
    }
    disconnect() {
      this._ariaObserver.disconnect();
    }
    addInfoListeners() {
      const target = this._target();
      if (!this._initialized && target) {
        ["mouseenter", "focus"].forEach((name) => target.addEventListener(name, () => this.show()));
        ["mouseleave", "blur", "click", "keydown"].forEach((name) => target.addEventListener(name, (event) => {
          if (!this._visible) {
            return;
          }
          this.hideIfNotSelfCover(event);
          if (event.key === "Escape") {
            event.stopPropagation();
          }
        }));
      }
    }
    hideIfNotSelfCover(event) {
      if (!this._visible) {
        return;
      }
      if (event.type === "mouseleave" && event.clientX && event.clientY) {
        try {
          const elementMouseIsOver = document.elementFromPoint ? document.elementFromPoint(event.clientX, event.clientY) : null;
          if (elementMouseIsOver === this._element()) {
            if (!isResizeObserverSupported()) {
              this.startPositioning();
            }
            return;
          }
        } catch (ex) {
        }
      }
      this.hide();
    }
    handleDocumentTouch() {
      if (this._visible) {
        this.hide();
      }
    }
    addToggleListeners() {
      const target = this._target();
      if (!this._initialized && target) {
        target.addEventListener("touchstart", (e2) => {
          e2.stopPropagation();
          this.toggle();
        });
        ["mouseenter", "focus"].forEach((name) => target.addEventListener(name, (event) => this.show(event)));
        ["mouseleave", "blur"].forEach((name) => target.addEventListener(name, (event) => this.hideIfNotSelfCover(event)));
        target.addEventListener("keydown", (event) => {
          if (event.keyCode === 13 && !this._visible) {
            this.toggle();
          } else if (this._visible) {
            this.hide();
            if (event.key === "Escape") {
              event.stopPropagation();
            }
          }
        });
      }
    }
    handleEscape(e2) {
      if (e2.key === "Escape" && this._isFocusEvent) {
        e2.stopPropagation();
        this.hideIfNotSelfCover(e2);
      }
    }
    get resizeObserver() {
      if (!this._resizeObserver) {
        this._resizeObserver = this._buildResizeObserver(() => {
          if (this._visible && this._autoPosition) {
            const tooltip = this._element();
            if (activeTooltip !== this) {
              this.hide(false);
              return;
            }
            this.startPositioning().then(() => {
              if (this._initialResize) {
                tooltip.addEventListener("mouseleave", this.hide);
                this._initialResize = false;
              }
            });
          }
        });
      }
      return this._resizeObserver;
    }
    show(ev) {
      if (this._disabled || this._visible) {
        return;
      }
      if (activeTooltip && activeTooltip !== this && activeTooltip._visible) {
        activeTooltip.hide(false);
      }
      activeTooltip = this;
      this._isFocusEvent = ev && (ev.type === "focus" ? true : false);
      this._visible = true;
      this._initialResize = true;
      const tooltip = this._element();
      tooltip.visible = this._visible;
      tooltip.content = this._value;
      this._ariaObserver.sync();
      this.startPositioning();
      document.addEventListener("keydown", this.handleEscape);
      document.addEventListener("touchstart", this.handleDocumentTouch);
      this.resizeObserver.observe(tooltip);
    }
    hide(hideBubble = true) {
      this._visible = false;
      const tooltip = this._element();
      if (hideBubble) {
        tooltip.visible = this._visible;
      }
      this.stopPositioning();
      document.removeEventListener("touchstart", this.handleDocumentTouch);
      document.removeEventListener("keydown", this.handleEscape);
      tooltip.removeEventListener("mouseleave", this.hide);
      this.resizeObserver.unobserve(tooltip);
      activeTooltip = null;
    }
    toggle() {
      if (this._visible) {
        this.hide();
      } else {
        this.show();
      }
    }
    get value() {
      return this._value;
    }
    set value(value) {
      this._value = value;
      this._disabled = !value;
    }
    get initialized() {
      return this._initialized;
    }
    get visible() {
      return this._visible;
    }
    startPositioning() {
      if (!this._autoPosition) {
        this._autoPosition = new AutoPosition(this._root);
      }
      const align = {
        horizontal: this._config.align.horizontal || Direction.Left,
        vertical: this._config.align.vertical || Direction.Bottom
      };
      const targetAlign = {
        horizontal: this._config.targetAlign.horizontal || Direction.Left,
        vertical: this._config.targetAlign.vertical || Direction.Top
      };
      const targetBox = this._target().getBoundingClientRect();
      const padLeft = targetBox.width * 0.5 - NUBBIN_OFFSET;
      return this._autoPosition.start({
        target: this._target,
        element: this._element,
        align,
        targetAlign,
        autoFlip: true,
        padTop: NUBBIN_SIZE,
        padLeft
      }).then((autoPositionUpdater) => {
        if (autoPositionUpdater) {
          const tooltip = this._element();
          tooltip.align = autoPositionUpdater.config.align;
          tooltip.visible = this._visible;
        }
      });
    }
    stopPositioning() {
      if (this._autoPosition) {
        this._autoPosition.stop();
      }
    }
    _buildResizeObserver(callback) {
      if (isResizeObserverSupported()) {
        return new ResizeObserver(callback);
      }
      return {
        observe() {
        },
        unobserve() {
        }
      };
    }
  }
  _2_41_4.registerDecorators(Tooltip, {
    fields: ["_autoPosition", "_disabled", "_initialized", "_visible", "_isFocusEvent", "_initialResize", "_ariaObserver", "_config"]
  });
  function findAllTabbableElements(container) {
    const result = [];
    traverseActiveTreeRecursively(container, (element) => {
      try {
        if (isTabbable({
          element,
          rootContainer: container
        })) {
          result.push(element);
        }
      } catch (e2) {
        console.warn(e2);
      }
    });
    return result;
  }
  function traverseActiveTreeRecursively(node, callback) {
    if (!node) {
      return;
    }
    if (node.nodeType === Node.ELEMENT_NODE) {
      if (node.hasAttribute("inert")) {
        return;
      }
      if (isIframe(node)) {
        if (isIframeOfSameOrigin(node)) {
          traverseActiveTreeRecursively(node.contentDocument, callback);
        } else {
          if (callback) {
            callback(node);
          }
        }
        return;
      }
      if (callback) {
        callback(node);
      }
      if (node.shadowRoot) {
        traverseActiveTreeRecursively(node.shadowRoot, callback);
        return;
      }
      if (node.localName === "slot") {
        const slottedNodes = node.assignedNodes({
          flatten: true
        });
        for (let i = 0; i < slottedNodes.length; i++) {
          traverseActiveTreeRecursively(slottedNodes[i], callback);
        }
        return;
      }
    }
    let child = node.firstChild;
    while (child !== null) {
      traverseActiveTreeRecursively(child, callback);
      child = child.nextSibling;
    }
  }
  function isIframe(node) {
    return node.tagName === "IFRAME" || node instanceof HTMLIFrameElement;
  }
  function isIframeOfSameOrigin(iframe) {
    return !!iframe.contentDocument;
  }
  const ELEMENTS_WITH_DISABLED_ATTRIBUTE = ["button", "select", "textarea", "input"];
  const ELEMENTS_WITH_TABINDEX_ZERO_BY_DEFAULT = ["a", "select", "textarea", "input", "button", "iframe", "object", "area", "frame"];
  function isTabbable({
    element,
    rootContainer
  }) {
    const elementLocalName = element.localName;
    if (elementLocalName === "input" && elementLocalName.type === "hidden") {
      return false;
    }
    const tabIndexAttribute = element.getAttribute("tabindex");
    if (tabIndexAttribute === "-1") {
      return false;
    }
    if (element.disabled && ELEMENTS_WITH_DISABLED_ATTRIBUTE.includes(element.localName)) {
      return false;
    }
    const hasTabIndexZero = tabIndexAttribute === "0" || element.tabIndex === 0 && ELEMENTS_WITH_TABINDEX_ZERO_BY_DEFAULT.includes(element.localName);
    return hasTabIndexZero && isElementVisible(element) && isParentCustomElementTabbable({
      element,
      rootContainer
    });
  }
  function isElementVisible(element) {
    const {
      width,
      height
    } = element.getBoundingClientRect();
    const nonZeroSize = width > 0 || height > 0;
    return nonZeroSize && getComputedStyle(element).visibility !== "hidden";
  }
  function isParentCustomElementTabbable({
    element,
    rootContainer
  }) {
    const parentRoot = rootContainer.getRootNode();
    const ownerDocument = element.ownerDocument;
    let root = element.getRootNode();
    while (root !== parentRoot && root !== ownerDocument) {
      const host = root.host;
      if (host.getAttribute("tabindex") === "-1") {
        return false;
      }
      root = host && host.getRootNode();
    }
    return true;
  }
  function ownKeys$4(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$4(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty$4(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$4(obj, key, value) {
    key = _toPropertyKey$4(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$4(arg) {
    var key = _toPrimitive$4(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$4(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const DEBOUNCE_KEY_DOWN = 300;
  const DEFAULT_CONFIG$1 = {
    navKey: "F6",
    f6RegionAttribute: "data-f6-region",
    f6RegionHighlightClass: "f6-highlight"
  };
  const getActiveElement = (element) => {
    if (!element) {
      return element;
    }
    if (!element.shadowRoot) {
      if (element.activeElement) {
        return getActiveElement(element.activeElement);
      }
      return element;
    }
    if (!element.shadowRoot.activeElement) {
      return element;
    }
    return getActiveElement(element.shadowRoot.activeElement);
  };
  class F6Controller {
    constructor(config2 = {}) {
      this.regions = [];
      this.config = DEFAULT_CONFIG$1;
      this._debounceKeyDownHandler = void 0;
      this._styleElement = void 0;
      this.handleClick = () => {
        this.clearRegionHighlights();
      };
      this.handleKeyDown = (event) => {
        this.clearRegionHighlights();
        const {
          key,
          ctrlKey,
          metaKey
        } = event;
        if (key === this.config.navKey && (ctrlKey || metaKey)) {
          this.populateRegions();
          this.handleNavigation(event);
        }
      };
      this.elementFilter = (element) => {
        if (element.parentElement && element.parentElement.matches(`*[${this.config.f6RegionAttribute}]`)) {
          return NodeFilter.FILTER_REJECT;
        }
        if (element.matches(`*[${this.config.f6RegionAttribute}]`) && this.isVisible(element) && !this.isEmpty(element)) {
          return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_SKIP;
      };
      this._debounceKeyDownHandler = debounce(this.handleKeyDown.bind(this), DEBOUNCE_KEY_DOWN);
      this.initialize(config2);
    }
    appendStyleElement() {
      this._styleElement = document.createElement("style");
      const selector = `[${this.config.f6RegionAttribute}].${this.config.f6RegionHighlightClass}`;
      this._styleElement.innerText = `${selector} { position: relative; }  ${selector}::after { width: 100%; height: 100%; content: ''; outline: rgb(94, 158, 214) 3px solid; outline-offset: -3px; position: absolute; top: 0; left: 0; z-index: 9999; }`;
      this._styleElement.setAttribute("type", "text/css");
      document.head.appendChild(this._styleElement);
    }
    clearRegionHighlights() {
      if (!this.regions || !this.regions.length) {
        return;
      }
      this.regions.forEach((region) => {
        region.classList.remove(this.config.f6RegionHighlightClass);
      });
    }
    addRegionHighlight(element) {
      element.classList.add(this.config.f6RegionHighlightClass);
    }
    findFocusableElement(element) {
      if (!element || !element.isConnected) {
        return void 0;
      }
      const tabbableElements = findAllTabbableElements(element);
      if (tabbableElements && tabbableElements.length) {
        return tabbableElements[0];
      }
      element.tabIndex = "-1";
      return element;
    }
    focusIn(region) {
      const element = this.findFocusableElement(region);
      if (element) {
        element.focus();
      }
    }
    handleNavigation(event) {
      event.preventDefault();
      if (!this.regions.length) {
        return;
      }
      const isPrevious = event.shiftKey;
      const currentRegionIndex = this.getElementRegionIndex(getActiveElement(event.target));
      const adjacentRegionIndex = this.getAdjacentRegionIndex(currentRegionIndex, isPrevious);
      if (adjacentRegionIndex === -1) {
        return;
      }
      const regionToFocus = this.regions[adjacentRegionIndex];
      this.focusIn(regionToFocus);
      this.addRegionHighlight(regionToFocus);
    }
    shadowContains(container, element) {
      if (container === element || container.contains(element)) {
        return true;
      }
      if (container.shadowRoot) {
        if (this.isElementInContainerElements(container.shadowRoot.children, element)) {
          return true;
        }
      }
      if (container.tagName === "SLOT") {
        if (this.isElementInContainerElements(container.assignedElements(), element)) {
          return true;
        }
      }
      return this.isElementInContainerElements(container.children, element);
    }
    isElementInContainerElements(containerElements, searchElement) {
      if (!containerElements || !containerElements.length) {
        return false;
      }
      const numElements = containerElements.length;
      for (let index2 = 0; index2 < numElements; index2++) {
        if (this.shadowContains(containerElements[index2], searchElement)) {
          return true;
        }
      }
      return false;
    }
    getElementRegionIndex(element) {
      if (!this.regions || !this.regions.length) {
        return -1;
      }
      return this.regions.findIndex((container) => {
        return this.shadowContains(container, element);
      });
    }
    getAdjacentRegionIndex(currentRegionIndex, isPrevious) {
      const lastRegionIndex = this.regions.length - 1;
      if (lastRegionIndex < 0) {
        return -1;
      }
      if (isPrevious) {
        if (currentRegionIndex <= 0) {
          return lastRegionIndex;
        }
        return currentRegionIndex - 1;
      }
      if (currentRegionIndex === lastRegionIndex) {
        return 0;
      }
      return currentRegionIndex + 1;
    }
    isVisible(element) {
      if (element === document.body || !(element instanceof Element)) {
        return true;
      }
      try {
        const computedStyle = window.getComputedStyle(element) || element.style;
        if (!computedStyle) {
          return false;
        }
        const {
          display,
          visibility
        } = computedStyle;
        if (display && display.toLowerCase() === "none" || visibility && visibility.toLowerCase() === "hidden") {
          return false;
        }
        return this.isVisible(element.parentNode);
      } catch (error2) {
        return false;
      }
    }
    isEmpty(element) {
      if (element.tagName === "SLOT") {
        if (!this.isEmptyChildren(element.assignedElements())) {
          return false;
        }
      }
      let children = element.children;
      if ((!children || !children.length) && element.shadowRoot) {
        children = element.shadowRoot.children;
      }
      return this.isEmptyChildren(children);
    }
    isEmptyChildren(children) {
      if (!children || !children.length) {
        return true;
      }
      const numChildren = children.length;
      for (let index2 = 0; index2 < numChildren; index2++) {
        const child = children[index2];
        if (child.tagName !== "SLOT" || !this.isEmpty(child)) {
          return false;
        }
      }
      return true;
    }
    populateRegions() {
      this.regions = [];
      const treeWalker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, this.elementFilter, false);
      while (treeWalker.nextNode()) {
        this.regions.push(treeWalker.currentNode);
      }
    }
    initialize(config2 = {}) {
      document.addEventListener("keydown", this._debounceKeyDownHandler);
      document.addEventListener("click", this.handleClick);
      this.regions = [];
      this.config = _objectSpread$4(_objectSpread$4({}, this.config), config2);
      this.appendStyleElement();
    }
    cleanUp() {
      document.removeEventListener("keydown", this._debounceKeyDownHandler);
      document.removeEventListener("click", this.handleClick);
      this._regions = [];
      this._config = DEFAULT_CONFIG$1;
      this._debounceKeyDownHandler = null;
      if (this._styleElement) {
        document.head.removeChild(this._styleElement);
        this._styleElement = null;
      }
    }
    getConfig() {
      return Object.freeze(this.config);
    }
  }
  _2_41_4.registerDecorators(F6Controller, {
    fields: ["regions", "config", "_debounceKeyDownHandler", "_styleElement", "handleClick", "handleKeyDown", "elementFilter"]
  });
  let f6Controller;
  const createF6Controller = (config2) => {
    if (!f6Controller) {
      f6Controller = new F6Controller(config2);
    }
    return f6Controller;
  };
  const DEFAULT_CONFIG = {
    guestUuidCookieMaxAge: 365 * 24 * 60 * 60
  };
  const {
    document: document$1
  } = globalThis;
  if (document$1 && guestUuidCookieName__default["default"]) {
    let idValue = getCookie(guestUuidCookieName__default["default"]);
    if (!uuidValidate(idValue)) {
      idValue = uuidv4();
    }
    document$1.cookie = `${guestUuidCookieName__default["default"]}=${idValue};Max-Age=${DEFAULT_CONFIG.guestUuidCookieMaxAge};SameSite=LAX;Path=/`;
    const experienceInteractionDetails = {
      name: "set-guest-uuid",
      guestUuid: idValue
    };
    document$1.dispatchEvent(new CustomEvent("experience_interaction", {
      bubbles: true,
      composed: true,
      detail: experienceInteractionDetails
    }));
  }
  function ownKeys$3(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$3(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$3(obj, key, value) {
    key = _toPropertyKey$3(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$3(arg) {
    var key = _toPrimitive$3(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$3(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  class InnerApp extends _2_41_4.LightningElement {
    constructor(...args) {
      super(...args);
      this.generatedTemplateHtml = _tmpl$8;
      this.attributes = {};
      this.routeParams = {};
      this.previousRouteId = null;
      this.route = {};
      this.isInitialized = void 0;
      this._f6Controller = void 0;
    }
    render() {
      return this.generatedTemplateHtml;
    }
    renderedCallback() {
      if (this.generatedTemplateHtml !== _tmpl$8) {
        const routeToSend = _objectSpread$3(_objectSpread$3({}, this.route), {}, {
          state: void 0
        });
        sendMetricsAndPageView({
          route: routeToSend,
          previousRouteId: this.previousRouteId
        });
      }
      if (this.isInitialized) {
        return;
      }
      this.isInitialized = true;
      window.performance.measure(`${WEBRUNTIME_PREFIX}-app-bootstrap`);
    }
    updateTemplate(template) {
      this.generatedTemplateHtml = template.html;
    }
    updateRoute(template, route) {
      handleExtraRouteParams(route);
      const {
        state,
        attributes
      } = route;
      this.previousRouteId = this.route?.id || null;
      this.routeParams = _objectSpread$3(_objectSpread$3({}, state), attributes);
      this.attributes = template.attributes(this, this.routeParams);
      this.route = route;
    }
    restoreDefaultTemplate() {
      this.generatedTemplateHtml = _tmpl$8;
    }
    async connectedCallback() {
      await designmodeInit();
      await mobileModuleInit();
      this.subscription = subscribe(this.loadThemeLayout.bind(this));
      this._f6Controller = createF6Controller();
    }
    async loadThemeLayout(e2) {
      let isViewLoaded = false;
      const view = e2.routeDefinition.view;
      const themeLayout = viewToThemeLayoutMap__default["default"][view];
      if (true) {
        assert$1(themeLayout, `No theme layout matching the "${view}" view.`);
      }
      setTimeout(async () => {
        if (!isViewLoaded && this.themeLayout !== themeLayout) {
          this.restoreDefaultTemplate();
        }
      }, 10);
      let module;
      try {
        module = await getViewModule(getViewModuleSpecifier(themeLayout));
      } catch (error2) {
        await this.handleFetchViewFailed(error2, e2.routeDefinition.metadata?.isPublic);
      }
      if (!module) {
        return;
      }
      try {
        isViewLoaded = true;
        window?.scrollTo(0, 0);
        if (this.themeLayout !== themeLayout) {
          this.themeLayout = themeLayout;
          this.updateTemplate(module.default);
        }
        this.updateRoute(module.default, e2.route);
      } catch (error2) {
        reportError({
          subject: "InnerApp.loadThemeLayout error",
          type: CLIENT_ERROR_TYPES.FAILED_TO_LOAD_RESOURCE,
          error: error2
        });
      }
    }
    async handleFetchViewFailed(error2, isPublic) {
      const res = await PageNavigationFailureOverrides.run({
        error: error2,
        isPublic
      });
      if (res) {
        reportError({
          subject: "InnerApp.loadThemeLayout#getViewModule error",
          type: CLIENT_ERROR_TYPES.FAILED_TO_LOAD_RESOURCE,
          error: error2
        });
      }
    }
    disconnectedCallback() {
      if (this.subscription) {
        this.subscription.unsubscribe();
      }
      if (this._f6Controller) {
        this._f6Controller.cleanUp();
        this._f6Controller = null;
      }
    }
  }
  InnerApp.renderMode = "light";
  _2_41_4.registerDecorators(InnerApp, {
    publicMethods: ["updateTemplate", "updateRoute", "restoreDefaultTemplate"],
    fields: ["generatedTemplateHtml", "attributes", "routeParams", "previousRouteId", "route", "isInitialized", "_f6Controller"]
  });
  var _webruntimeInnerApp = _2_41_4.registerComponent(InnerApp, {
    tmpl: _tmpl$8,
    sel: "webruntime-innerApp"
  });
  function stylesheet$2(token, useActualHostSelector, useNativeDirPseudoclass) {
    var shadowSelector = token ? "[" + token + "]" : "";
    return "span.router-title" + shadowSelector + " {position: absolute;margin: -1px;border: 0;padding: 0;width: 1px;height: 1px;overflow: hidden;clip: rect(0 0 0 0);text-transform: none;white-space: nowrap;}";
  }
  var _implicitStylesheets = [stylesheet$2];
  const $fragment1 = _2_41_4.parseFragment`<span class="router-title${0}" aria-live="polite" aria-atomic="true"${2}></span>`;
  const stc0$4 = {
    key: 0
  };
  const stc1$2 = [];
  function tmpl$5($api, $cmp, $slotset, $ctx) {
    const {s: api_slot, st: api_static_fragment, f: api_flatten} = $api;
    return api_flatten([api_slot("", stc0$4, stc1$2, $slotset), api_static_fragment($fragment1(), 2)]);
  }
  var _tmpl$5 = _2_41_4.registerTemplate(tmpl$5);
  tmpl$5.slots = [""];
  tmpl$5.stylesheets = [];
  tmpl$5.renderMode = "light";
  if (_implicitStylesheets) {
    tmpl$5.stylesheets.push.apply(tmpl$5.stylesheets, _implicitStylesheets);
  }
  tmpl$5.stylesheetToken = "lwr-routerContainer_routerContainer";
  _2_41_4.freezeTemplate(tmpl$5);
  const currentPageReferenceContextualizer = hasDocument ? _2_41_4.createContextProvider(CurrentPageReference) : void 0;
  const currentViewContextualizer = hasDocument ? _2_41_4.createContextProvider(CurrentView) : void 0;
  const navigationContextContextualizer = hasDocument ? _2_41_4.createContextProvider(NavigationContext) : void 0;
  function provideContext(contextValue, providerNode, contextualizer, contextualAdapter) {
    if (contextualizer && contextualAdapter) {
      contextualAdapter.setContext(providerNode, contextValue);
      contextualizer(providerNode, {
        consumerConnectedCallback: contextualAdapter.subscribeContext.bind(contextualAdapter, providerNode),
        consumerDisconnectedCallback: contextualAdapter.unsubscribeContext.bind(contextualAdapter, providerNode)
      });
    }
  }
  const ROUTER_PREFIX = "lwr.router.";
  const ROUTER_NAV = `${ROUTER_PREFIX}navigate`;
  const ROUTER_VIEW = `${ROUTER_PREFIX}view`;
  const ROUTER_ERROR = `${ROUTER_PREFIX}error`;
  var Phase;
  (function(Phase2) {
    Phase2[Phase2["Start"] = 0] = "Start";
    Phase2[Phase2["End"] = 1] = "End";
  })(Phase || (Phase = {}));
  const perf = globalThis.performance;
  const isPerfSupported = typeof perf !== "undefined" && typeof perf.mark === "function" && typeof perf.clearMarks === "function" && typeof perf.measure === "function" && typeof perf.clearMeasures === "function";
  function logOperationStart({
    id,
    specifier
  }) {
    if (isPerfSupported) {
      perf.mark(id + (specifier ? `.${specifier}` : ""));
    }
  }
  function logOperationEnd({
    id,
    specifier
  }) {
    if (isPerfSupported) {
      const suffix = specifier ? `.${specifier}` : "";
      const markName = id + suffix;
      const measureName = `${id}.duration${suffix}`;
      perf.measure(measureName, markName);
      perf.clearMarks(markName);
      perf.clearMeasures(measureName);
    }
  }
  function ownKeys$2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty$2(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$2(obj, key, value) {
    key = _toPropertyKey$2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$2(arg) {
    var key = _toPrimitive$2(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$2(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const NAV_EVENT = `universalcontainernavigationevent${guid$1()}`;
  const PARENT_EVENT = `universalcontainerparentevent${guid$1()}`;
  class DomRouterImpl {
    constructor(config2, router2, target) {
      this.pendingRoute = null;
      this.committedRoute = null;
      this.contextId = Object.freeze(() => void 0);
      this.connected = false;
      this.preNavFilters = createFilterChain();
      this.errorNavFilters = createFilterChain();
      this._handleNavigationEvent = (event) => {
        const navigationEvent = event;
        if (navigationEvent.detail && typeof navigationEvent.detail === "object") {
          const {
            url,
            replace: replace2,
            address
          } = navigationEvent.detail;
          const continueNavigation = this.config.handleNavigation(address, replace2);
          if (!continueNavigation) {
            navigationEvent.stopPropagation();
          } else {
            if (this.root && !url) {
              this.root.processError(generateMessageObject(messages.MISSING_URL, [JSON.stringify(address)]));
            } else if (!this.parent) {
              this.process(url, replace2);
            }
          }
        }
      };
      this._handleParentEvent = (event) => {
        event.stopImmediatePropagation();
        const parentRouterEvent = event;
        if (parentRouterEvent && parentRouterEvent.detail && typeof parentRouterEvent.detail === "function") {
          parentRouterEvent.detail(this);
        }
      };
      this.config = {
        handleNavigation: config2.handleNavigation || (() => true)
      };
      this.target = target || window;
      this.router = router2;
      this.router.contextId = this.contextId;
      this.routeObservable = createObservable();
    }
    get root() {
      if (!this.parent) {
        return this;
      }
      let maybe = this.parent;
      while (maybe) {
        if (!maybe.parent) {
          return maybe;
        }
        maybe = maybe.parent;
      }
      throw new Error("No root router could be found");
    }
    updateWires(result, url, error2) {
      if (error2) {
        this.processError(error2);
      } else {
        if (this.committedRoute && result.route === this.committedRoute.route) {
          return;
        }
        logOperationEnd({
          id: ROUTER_VIEW,
          specifier: this.eventId
        });
        this.pendingRoute = this.pendingRoute || _objectSpread$2(_objectSpread$2({}, result), {}, {
          url
        });
        this.committedRoute = _objectSpread$2(_objectSpread$2({}, this.pendingRoute), result);
        CurrentPageReference.setContext(this.target, result.route.pageReference);
        this.routeObservable.next(_objectSpread$2(_objectSpread$2({}, this.committedRoute), {}, {
          viewset: result.viewset
        }));
        logOperationEnd({
          id: ROUTER_NAV,
          specifier: this.eventId
        });
        if (this.child) {
          this.child.process(this._stripUrlForChild(this.committedRoute.url));
        }
      }
    }
    connect() {
      this._sendEvent(PARENT_EVENT, (router2) => {
        this.parent = router2;
        router2.addChild(this);
      });
      const contextApi = {
        navigate: (address, replace2) => this.navigate(address, replace2),
        generateUrl: (address) => this.generateUrl(address),
        subscribe: (callback, replay) => this.subscribe(callback, replay)
      };
      registerNavigationHelm(this.contextId, contextApi);
      provideContext(this.contextId, this.target, navigationContextContextualizer, NavigationContext);
      provideContext(void 0, this.target, currentPageReferenceContextualizer, CurrentPageReference);
      provideContext(void 0, this.target, currentViewContextualizer, CurrentView);
      this.router.subscribe((result) => {
        if (result.status === 404) {
          this.processError(generateMessageObject(messages.DESTINATION_NOT_FOUND));
          return;
        }
        if (result.status && result.status >= 400) {
          const error2 = result.error || new Error();
          this.processError(generateMessageObject(messages.DESTINATION_ERROR, [result.status.toString(), error2.message, error2.stack || ""]));
          return;
        }
        const pageReference = result.route.pageReference || {};
        const url = this.router.generateUrl(pageReference) || "";
        logOperationStart({
          id: ROUTER_VIEW,
          specifier: this.eventId
        });
        if (result.viewset) {
          const currentViewContext = {
            viewset: result.viewset,
            onComplete: this.updateWires.bind(this, result, url)
          };
          CurrentView.setContext(this.target, currentViewContext);
        } else if (result.route.pageReference) {
          this.updateWires(result, url);
        }
      }, true);
      if (hasDocument) {
        this.target.addEventListener(NAV_EVENT, this._handleNavigationEvent);
        this.target.addEventListener(PARENT_EVENT, this._handleParentEvent);
        this.target.addEventListener(CONTEXT_ID_BACKDOOR, (event) => {
          const navCtxEvent = event;
          if (navCtxEvent.detail.callback) {
            navCtxEvent.detail.callback(this.contextId);
          }
        });
      }
      this.connected = true;
    }
    disconnect() {
      this.target.removeEventListener(NAV_EVENT, this._handleNavigationEvent);
      this.target.removeEventListener(PARENT_EVENT, this._handleParentEvent);
      if (this.parent) {
        this.parent.child = void 0;
      }
      this.parent = void 0;
      if (this.child) {
        this.child.parent = void 0;
      }
      this.child = void 0;
      this.connected = false;
    }
    addPreNavigate(filters) {
      this.preNavFilters.add(filters);
    }
    addErrorNavigate(filters) {
      this.errorNavFilters.add(filters);
    }
    async addChild(child) {
      await new Promise((resolve) => {
        setTimeout(() => {
          invariant(!this.child, messages.MULTIPLE_CHILDREN);
          this.child = child;
          resolve();
        }, 0);
      });
      if (this.child && this.committedRoute) {
        const url = this._stripUrlForChild(this.committedRoute.url);
        const canContinue = await this.child.preProcess(url);
        if (canContinue) {
          this.child.process(url);
        }
      }
    }
    async process(url, replace2) {
      this.eventId = new Date().getTime().toString();
      logOperationStart({
        id: ROUTER_NAV,
        specifier: this.eventId
      });
      try {
        if (!this.parent) {
          await this.preProcess(url);
        }
      } catch (e2) {
        if (e2.code) {
          this.processError(e2);
          return false;
        }
        throw e2;
      }
      const address = this.router.parseUrl(url);
      if (address) {
        this.router.navigate(address);
      }
      return true;
    }
    preProcess(url) {
      const address = this.router.parseUrl(url);
      const routingMatch = address && this.router.matchRoute(address);
      if (!routingMatch) {
        return Promise.reject(generateMessageObject(messages.MISSING_ROUTE, [url]));
      }
      this.pendingRoute = _objectSpread$2({
        url
      }, routingMatch);
      const canGo = this.preNavFilters.empty() ? Promise.resolve(true) : this.preNavFilters.compile({
        current: this.committedRoute || void 0,
        next: this.pendingRoute
      });
      return canGo.then((canContinue) => {
        return canContinue && this.child ? this.child.preProcess(this._stripUrlForChild(url)) : canContinue;
      }).then((canContinue) => {
        return canContinue || Promise.reject(generateMessageObject(messages.PRENAV_FAILED, [url]));
      });
    }
    processError(messageObject) {
      logOperationStart({
        id: ROUTER_ERROR
      });
      this.errorNavFilters.compile(messageObject);
      if (this.child) {
        this.child.processError(messageObject);
      }
    }
    navigate(address, replace2) {
      let url = this.router.generateUrl(address);
      if (url) {
        const parentPath = this.parent && this.parent.committedRoute && this.parent.committedRoute.pathMatch || "";
        url = parentPath.concat(url);
      }
      this._sendEvent(NAV_EVENT, {
        url,
        replace: replace2,
        address
      });
    }
    generateUrl(address) {
      const url = this.router.generateUrl(address);
      if (!url) {
        return null;
      }
      const parentPath = this.parent && this.parent.committedRoute && this.parent.committedRoute.pathMatch || "";
      return `${parentPath}${url}`;
    }
    subscribe(callback, replay) {
      return this.routeObservable.subscribe({
        next: callback,
        error: () => {
        },
        complete: () => {
        }
      }, Boolean(replay));
    }
    _sendEvent(name, payload) {
      hasDocument && this.target.dispatchEvent(new CustomEvent(name, {
        bubbles: true,
        composed: true,
        detail: payload
      }));
    }
    _stripUrlForChild(url) {
      if (this.pendingRoute && url.indexOf(this.pendingRoute.pathMatch) === 0) {
        return url.replace(this.pendingRoute.pathMatch, "");
      }
      return url;
    }
  }
  _2_41_4.registerDecorators(DomRouterImpl, {
    fields: ["pendingRoute", "committedRoute", "contextId", "connected", "preNavFilters", "errorNavFilters", "_handleNavigationEvent", "_handleParentEvent"]
  });
  function getUrlObject(url = "") {
    url = url || "";
    if (url.indexOf("://") < 0) {
      const port = window.location.port ? `:${window.location.port}` : "";
      const origin = `${window.location.protocol}//${window.location.hostname}${port}`;
      const prefix2 = url.charAt(0) === "/" ? "" : "/";
      url = origin + prefix2 + url;
    }
    const searchParams = {};
    const link = document.createElement("a");
    link.href = url;
    const queryStr = link.search.substring(1);
    if (queryStr) {
      queryStr.split("&").forEach((pair) => {
        const [key, value = ""] = pair.split("=");
        searchParams[decode(key)] = decode(value);
      });
    }
    return {
      href: link.href,
      origin: `${link.protocol}//${link.hostname}${link.port ? `:${link.port}` : ""}`,
      pathname: link.pathname.replace(/(\/)?/, "/"),
      searchParams
    };
  }
  function getRelativeUrl(url) {
    const urlObj = getUrlObject(url);
    const href = urlObj.href.replace(/:\d+/, "");
    const origin = urlObj.origin.replace(/:\d+/, "");
    return href.replace(origin, "");
  }
  function set(path, route) {
    const data = route || {};
    window.history.pushState(data, "", path);
  }
  function replace(path, route) {
    const data = route || {};
    window.history.replaceState(data, "", path);
  }
  class HistoryRouter extends DomRouterImpl {
    constructor(...args) {
      super(...args);
      this.historyDisabled = false;
    }
    connect() {
      super.connect();
      if (!this.historyDisabled) {
        hasDocument && window.addEventListener("popstate", this.onpopstate.bind(this));
        this.onpopstate();
      }
    }
    onpopstate() {
      if (!this.parent && hasDocument) {
        this.catchBrowserUpdate(getRelativeUrl(document.location.href));
      }
    }
    disconnect() {
      super.disconnect();
      hasDocument && window.removeEventListener("popstate", this.onpopstate);
    }
    async process(url, shouldReplace, updateHistory = true) {
      const canContinue = await super.process(url);
      if (canContinue && !this.historyDisabled && updateHistory && this.connected && !this.parent) {
        if (shouldReplace) {
          replace(url);
        } else {
          set(url);
        }
      }
      return canContinue;
    }
    catchBrowserUpdate(url) {
      this.process(url, false, false);
    }
  }
  _2_41_4.registerDecorators(HistoryRouter, {
    fields: ["historyDisabled"]
  });
  let hasRoot = false;
  function createNavigationContext(node, config2 = {}, portableRouter) {
    const newRouter = config2.historyDisabled ? new DomRouterImpl(config2, portableRouter, node) : new HistoryRouter(config2, portableRouter, node);
    const routerAPI = {
      addPreNavigate: (listener) => {
        newRouter.addPreNavigate(listener);
        return routerAPI;
      },
      addPostNavigate: (listener) => {
        newRouter.subscribe(listener);
        return routerAPI;
      },
      addErrorNavigate: (listener) => {
        newRouter.addErrorNavigate(listener);
        return routerAPI;
      },
      connect: () => {
        newRouter.connect();
        invariant(!hasRoot || !!newRouter.parent, messages.MULTIPLE_ROOTS);
        hasRoot = hasRoot || !newRouter.parent;
        routerAPI.id = newRouter.contextId;
      },
      disconnect: () => {
        hasRoot = hasRoot && !!newRouter.parent;
        newRouter.disconnect();
      }
    };
    return routerAPI;
  }
  let RouterContainer$1 = class RouterContainer extends _2_41_4.LightningElement {
    constructor() {
      super();
      this.router = void 0;
      this.historyDisabled = false;
      this.currentTitle = hasDocument ? document.title : "";
    }
    connectedCallback() {
      const config2 = {
        historyDisabled: this.historyDisabled,
        handleNavigation: this.handleNavigation.bind(this)
      };
      if (this.router) {
        this.routerApi = createNavigationContext(this, config2, this.router);
        this.routerApi.addPreNavigate(this.preNavigate.bind(this)).addPostNavigate(this.postNavigate.bind(this)).addErrorNavigate(this.errorNavigate.bind(this)).connect();
      }
    }
    preNavigate(routeChange) {
      const event = this._createEvent("prenavigate", routeChange, true);
      this.dispatchEvent(event);
      return !event.defaultPrevented;
    }
    postNavigate(routingResult) {
      this.dispatchEvent(this._createEvent("postnavigate", routingResult));
      const title = routingResult.routeDefinition.metadata && routingResult.routeDefinition.metadata.title;
      if (title) {
        this.currentTitle = title;
        document.title = title;
      }
      const a11yTitle = this.querySelector("span.router-title");
      if (a11yTitle)
        a11yTitle.innerHTML = this.currentTitle;
    }
    errorNavigate(error2) {
      this.dispatchEvent(this._createEvent("errornavigate", error2));
      return true;
    }
    handleNavigation(address, replace2) {
      const event = this._createEvent("handlenavigation", {
        address,
        replace: replace2
      }, true);
      this.dispatchEvent(event);
      return !event.defaultPrevented;
    }
    disconnectedCallback() {
      if (this.routerApi) {
        this.routerApi.disconnect();
      }
    }
    _createEvent(name, payload, cancelable) {
      return new CustomEvent(name, {
        detail: payload,
        bubbles: false,
        composed: false,
        cancelable
      });
    }
  };
  RouterContainer$1.renderMode = "light";
  _2_41_4.registerDecorators(RouterContainer$1, {
    publicProps: {
      router: {
        config: 0
      },
      historyDisabled: {
        config: 0
      }
    }
  });
  var _lwrRouterContainer = _2_41_4.registerComponent(RouterContainer$1, {
    tmpl: _tmpl$5,
    sel: "lwr-routerContainer"
  });
  function tmpl$4($api, $cmp, $slotset, $ctx) {
    const {c: api_custom_element, b: api_bind} = $api;
    const {_m0} = $ctx;
    return [api_custom_element("lwr-router-container", _lwrRouterContainer, {
      props: {
        router: $cmp.router
      },
      key: 0
    }, [api_custom_element("experience-data-layer-object", _experienceDataLayerObject, {
      props: {
        scriptDataAttributes: $cmp.pageDataForDataLayer.scriptDataAttributes,
        customObject: $cmp.pageDataForDataLayer.customObject
      },
      key: 1
    }), api_custom_element("webruntime-inner-app", _webruntimeInnerApp, {
      key: 2,
      on: {
        viewchange: _m0 || ($ctx._m0 = api_bind($cmp.handleViewChanged))
      }
    })])];
  }
  var _tmpl$4 = _2_41_4.registerTemplate(tmpl$4);
  tmpl$4.stylesheets = [];
  tmpl$4.renderMode = "light";
  tmpl$4.stylesheetToken = "webruntime-app_app";
  _2_41_4.freezeTemplate(tmpl$4);
  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$1(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1(obj, key, value) {
    key = _toPropertyKey$1(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$1(arg) {
    var key = _toPrimitive$1(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive$1(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  _2_41_4.setHooks({
    sanitizeHtmlContent(content) {
      return content;
    }
  });
  class App extends _2_41_4.LightningElement {
    constructor(...args) {
      super(...args);
      this.themeLayout = void 0;
      this.isInitialized = void 0;
      this.router = router;
      this.routerContainer = void 0;
      this.pageDataForDataLayer = {
        scriptDataAttributes: {
          providerType: "page"
        }
      };
    }
    renderedCallback() {
      if (this.isInitialized) {
        return;
      }
      this.routerContainer = this.querySelector("lwr-router-container");
      initializeRouterContainer(this.routerContainer);
      window?.addEventListener("click", this.handleClick);
      this.isInitialized = true;
    }
    errorCallback(error2, wcstack) {
      reportError({
        subject: "app level error",
        error: error2,
        wcstack
      });
    }
    disconnectedCallback() {
      document.body.removeEventListener("click", this.handleClick);
      this.isInitialized = false;
    }
    render() {
      return _tmpl$4;
    }
    handleClick(evt) {
      const link = evt.composedPath().find((el) => el.tagName === "A");
      if (!link || evt.defaultPrevented || isMobileApp())
        return;
      let href = link.getAttribute("href");
      if (!href || href.includes("#"))
        return;
      const url = new URL(href, window.location.href);
      const isWebLink = url?.protocol === "http:" || url?.protocol === "https:";
      const isExternal = isAbsoluteURL(href);
      if (!(isExternal || href.startsWith("/"))) {
        href = window.location.pathname + href;
      }
      const isValidUrl = isExternal || Boolean(router.matchRoute(href));
      const targetTab = link.getAttribute("target");
      const isForCurrentTab = !targetTab && !isExternal || targetTab === "_self" || targetTab === window.name || targetTab === "_top" && window.top === window || targetTab === "_parent" && window.parent === window;
      const shouldRoute = isWebLink && isValidUrl && isForCurrentTab ^ isExternal;
      if (shouldRoute) {
        evt.preventDefault();
        navigate({
          type: "standard__webPage",
          attributes: {
            url: href
          }
        });
      }
    }
    handleViewChanged(evt) {
      const recordId = evt.detail?.route?.attributes?.recordId;
      let customObject = {
        type: evt.detail?.route?.pageReference?.type,
        url: window.location.href,
        urlReferrer: document.referrer
      };
      if (recordId) {
        customObject = _objectSpread$1(_objectSpread$1({}, customObject), {}, {
          recordId
        });
      }
      this.pageDataForDataLayer = _objectSpread$1(_objectSpread$1({}, this.pageDataForDataLayer), {}, {
        customObject
      });
    }
  }
  App.renderMode = "light";
  _2_41_4.registerDecorators(App, {
    fields: ["themeLayout", "isInitialized", "router", "routerContainer", "pageDataForDataLayer"]
  });
  var App$1 = _2_41_4.registerComponent(App, {
    tmpl: _tmpl$4,
    sel: "webruntime-app"
  });
  var auraStorage = {};
  const stc0$3 = [];
  function tmpl$3($api, $cmp, $slotset, $ctx) {
    return stc0$3;
  }
  var _tmpl$3 = _2_41_4.registerTemplate(tmpl$3);
  tmpl$3.stylesheets = [];
  tmpl$3.renderMode = "light";
  tmpl$3.stylesheetToken = "webruntime-routerContainer_routerContainer";
  _2_41_4.freezeTemplate(tmpl$3);
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  class RouterContainer extends _2_41_4.LightningElement {
    constructor(...args) {
      super(...args);
      this.generatedTemplateHtml = _tmpl$3;
      this.attributes = {};
      this.routeParams = {};
      this.route = {};
    }
    render() {
      return this.generatedTemplateHtml;
    }
    connectedCallback() {
      this.subscription = subscribe(this.routeChange.bind(this));
    }
    viewChange(view) {
      handleExtraRouteParams(this.route);
      this.generatedTemplateHtml = view.html;
      const {
        state,
        attributes
      } = this.route;
      this.routeParams = _objectSpread(_objectSpread({}, state), attributes);
      this.attributes = view.attributes(this, this.routeParams);
    }
    routeChange(routingResult) {
      this.route = routingResult.route || null;
    }
    disconnectedCallback() {
      if (this.subscription) {
        this.subscription.unsubscribe();
      }
    }
    errorCallback(error2, wcstack) {
      reportError({
        subject: "router level error",
        error: error2,
        wcstack
      });
    }
    renderedCallback() {
      this.dispatchEvent(new CustomEvent("viewchange", {
        bubbles: true,
        composed: true,
        detail: {
          route: this.route
        }
      }));
      this.dispatchEvent(new CustomEvent("experience_interaction", {
        bubbles: true,
        composed: true,
        detail: {
          name: "page-view"
        }
      }));
    }
  }
  RouterContainer.renderMode = "light";
  _2_41_4.registerDecorators(RouterContainer, {
    wire: {
      viewChange: {
        adapter: CurrentView,
        method: 1,
        config: function($cmp) {
          return {};
        }
      }
    },
    fields: ["generatedTemplateHtml", "attributes", "routeParams", "route"]
  });
  var WebruntimeRouterContainer = _2_41_4.registerComponent(RouterContainer, {
    tmpl: _tmpl$3,
    sel: "webruntime-routerContainer"
  });
  function stylesheet$1(token, useActualHostSelector, useNativeDirPseudoclass) {
    var hostSelector = token ? "." + token + "-host" : "";
    return (useActualHostSelector ? ":host {" : hostSelector + " {") + "display: flow-root;}";
  }
  stylesheet$1.$scoped$ = true;
  var _implicitScopedStylesheets$1 = [stylesheet$1];
  const stc0$2 = {
    key: 0
  };
  const stc1$1 = [];
  function tmpl$2($api, $cmp, $slotset, $ctx) {
    const {s: api_slot} = $api;
    return api_slot("", stc0$2, stc1$1, $slotset);
  }
  var _tmpl$2 = _2_41_4.registerTemplate(tmpl$2);
  tmpl$2.slots = [""];
  tmpl$2.stylesheets = [];
  tmpl$2.renderMode = "light";
  if (_implicitScopedStylesheets$1) {
    tmpl$2.stylesheets.push.apply(tmpl$2.stylesheets, _implicitScopedStylesheets$1);
  }
  tmpl$2.stylesheetToken = "webruntime-componentContainer_componentContainer";
  _2_41_4.freezeTemplate(tmpl$2);
  class ComponentContainer extends _2_41_4.LightningElement {
  }
  ComponentContainer.renderMode = "light";
  var ComponentContainer$1 = _2_41_4.registerComponent(ComponentContainer, {
    tmpl: _tmpl$2,
    sel: "webruntime-componentContainer"
  });
  const stc0$1 = [];
  function tmpl$1($api, $cmp, $slotset, $ctx) {
    const {s: api_slot} = $api;
    return $cmp.isVisible ? api_slot("", {
      key: 0,
      slotData: $cmp.variations
    }, stc0$1, $slotset) : stc0$1;
  }
  var _tmpl$1 = _2_41_4.registerTemplate(tmpl$1);
  tmpl$1.slots = [""];
  tmpl$1.stylesheets = [];
  tmpl$1.renderMode = "light";
  tmpl$1.stylesheetToken = "webruntime-slotContainer_slotContainer";
  _2_41_4.freezeTemplate(tmpl$1);
  class SlotContainer extends _2_41_4.LightningElement {
    constructor(...args) {
      super(...args);
      this.visibilityExpression = void 0;
      this.hidden = void 0;
      this.variationExpressions = void 0;
    }
    get isVisible() {
      return this.hidden ? !this.visibilityExpression : this.visibilityExpression;
    }
    get variations() {
      const variationMap = {};
      const foundVariationToShow = this.variationExpressions?.find((el) => {
        return el === true;
      });
      const variationIndexToShow = this.variationExpressions?.findIndex((el) => {
        return el === true;
      });
      const isAnyVariationUndefined = this.variationExpressions?.find((el) => {
        return typeof el === "undefined";
      });
      this.variationExpressions?.forEach(function(expr, idx) {
        const key = `variation${idx + 1}`;
        if (isAnyVariationUndefined || foundVariationToShow && variationIndexToShow !== idx) {
          variationMap[key] = false;
        } else if (expr === true) {
          variationMap[key] = true;
        } else if (typeof expr === "undefined") {
          variationMap[key] = false;
        } else {
          variationMap[key] = false;
        }
      });
      variationMap.variation0 = !foundVariationToShow && !isAnyVariationUndefined;
      return variationMap;
    }
  }
  SlotContainer.renderMode = "light";
  _2_41_4.registerDecorators(SlotContainer, {
    publicProps: {
      visibilityExpression: {
        config: 0
      },
      hidden: {
        config: 0
      },
      variationExpressions: {
        config: 0
      }
    }
  });
  var SlotContainer$1 = _2_41_4.registerComponent(SlotContainer, {
    tmpl: _tmpl$1,
    sel: "webruntime-slotContainer"
  });
  function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {
    var hostSelector = token ? "." + token + "-host" : "";
    return "@media only screen and (max-width: 47.9375em) {" + (useActualHostSelector ? ":host.webruntime-visibility-container.dxp-sm-hide {" : hostSelector + ".webruntime-visibility-container.dxp-sm-hide {") + "display: none;}}@media only screen and (min-width: 48em) and (max-width: 64em) {" + (useActualHostSelector ? ":host.webruntime-visibility-container.dxp-md-hide {" : hostSelector + ".webruntime-visibility-container.dxp-md-hide {") + "display: none;}}@media only screen and (min-width: 64.0625em) {" + (useActualHostSelector ? ":host.webruntime-visibility-container.dxp-lg-hide {" : hostSelector + ".webruntime-visibility-container.dxp-lg-hide {") + "display: none;}}";
  }
  stylesheet.$scoped$ = true;
  var _implicitScopedStylesheets = [stylesheet];
  const stc0 = {
    key: 0
  };
  const stc1 = [];
  function tmpl($api, $cmp, $slotset, $ctx) {
    const {s: api_slot} = $api;
    return !$cmp.hidden ? api_slot("", stc0, stc1, $slotset) : stc1;
  }
  var _tmpl = _2_41_4.registerTemplate(tmpl);
  tmpl.slots = [""];
  tmpl.stylesheets = [];
  tmpl.renderMode = "light";
  if (_implicitScopedStylesheets) {
    tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitScopedStylesheets);
  }
  tmpl.stylesheetToken = "webruntime-visibilityContainer_visibilityContainer";
  _2_41_4.freezeTemplate(tmpl);
  class VisibilityContainer extends _2_41_4.LightningElement {
    constructor(...args) {
      super(...args);
      this.hiddenInDesktop = false;
      this.hiddenInTablet = false;
      this.hiddenInMobile = false;
      this.hidden = true;
    }
    connectedCallback() {
      const formFactorsMetaObj = {
        Small: {
          isHidden: this.hiddenInMobile,
          mediaQuery: "only screen and (max-width: 47.9375em)",
          class: "dxp-sm-hide"
        },
        Medium: {
          isHidden: this.hiddenInTablet,
          mediaQuery: "only screen and (min-width: 48em) and (max-width: 64em)",
          class: "dxp-md-hide"
        },
        Large: {
          isHidden: this.hiddenInDesktop,
          mediaQuery: "only screen and (min-width: 64.0625em)",
          class: "dxp-lg-hide"
        }
      };
      let visibileMQ = "";
      Object.values(formFactorsMetaObj).forEach((value) => {
        if (value.isHidden) {
          this.classList.add(value.class);
        } else {
          visibileMQ += visibileMQ ? `, ${value.mediaQuery}` : value.mediaQuery;
        }
      });
      if (isDesignMode__default["default"]) {
        this.classList.add("interactions-element", "webruntime-design-visibility-container");
      } else {
        this.classList.add("webruntime-visibility-container");
      }
      Promise.resolve().then(function() {
        return formFactor;
      }).then(({
        getFormFactor: getFormFactor2
      }) => {
        if (typeof window !== "undefined" && !isDesignMode__default["default"] && formFactorsMetaObj[getFormFactor2()].isHidden) {
          if (visibileMQ) {
            const visibileMQL = window.matchMedia(visibileMQ);
            const mediaQueryHandler = (e2) => {
              if (e2.matches) {
                this.hidden = false;
                visibileMQL.removeEventListener("change", mediaQueryHandler);
              }
            };
            visibileMQL.addEventListener("change", mediaQueryHandler);
          }
        } else {
          this.hidden = false;
        }
      });
    }
  }
  VisibilityContainer.renderMode = "light";
  _2_41_4.registerDecorators(VisibilityContainer, {
    publicProps: {
      hiddenInDesktop: {
        config: 0
      },
      hiddenInTablet: {
        config: 0
      },
      hiddenInMobile: {
        config: 0
      }
    },
    track: {
      hidden: 1
    }
  });
  var VisibilityContainer$1 = _2_41_4.registerComponent(VisibilityContainer, {
    tmpl: _tmpl,
    sel: "webruntime-visibilityContainer"
  });
  let CONTEXT;
  const DEFAULT_DATE = "1970-01-01T";
  const ISO_DATE = "T00:00:00";
  const PROP_PROVIDER = "provider";
  const PROP_PROVIDERS = "providers";
  function isObjectLike(value) {
    return value !== null && typeof value === "object";
  }
  function createJsDate(value) {
    try {
      const containsTime = value?.indexOf(":") > -1;
      const containsDate = value?.indexOf("-") > -1;
      if (value === "" || !containsTime && !containsDate) {
        return null;
      }
      if (typeof value === "string") {
        if (!containsDate) {
          value = DEFAULT_DATE + value;
        }
        if (!containsTime) {
          value = value + ISO_DATE;
        }
        value = value.trim().replace(" ", "T");
        if (!value.endsWith("Z")) {
          value += "Z";
        }
      }
      return new Date(value);
    } catch (e2) {
      return null;
    }
  }
  function exprClosure(fn) {
    try {
      const result = fn();
      const providers = Reflect.get(this, PROP_PROVIDERS);
      for (const provider of providers) {
        if (!provider?.hasData?.()) {
          throw new Error();
        }
      }
      return result ?? null;
    } catch (e2) {
      return void 0;
    }
  }
  function exprProvider(provider) {
    if (isObjectLike(this)) {
      Reflect.set(this, PROP_PROVIDER, provider);
      Reflect.get(this, PROP_PROVIDERS).push(provider);
    }
    return provider?.getData?.();
  }
  function exprGlobal(route = {}, prop) {
    if (!!route && Object.prototype.hasOwnProperty.call(route, prop)) {
      return route[prop];
    }
  }
  function exprFilter(value, filter) {
    if (!Array.isArray(value)) {
      value = [value];
    }
    const r2 = value.filter(filter);
    if (!r2.length) {
      return void 0;
    }
    return r2.length === 1 ? r2[0] : r2;
  }
  function exprMember(data, name) {
    if (isObjectLike(this) && Reflect.has(this, PROP_PROVIDER)) {
      const provider = Reflect.get(this, PROP_PROVIDER);
      Reflect.deleteProperty(this, PROP_PROVIDER);
      if (!provider?.hasData?.(name)) {
        throw new Error();
      }
      const providers = Reflect.get(this, PROP_PROVIDERS);
      const i = providers.indexOf(provider);
      i >= 0 && providers.splice(providers.indexOf(provider), 1);
    }
    if (typeof name === "string" && Array.isArray(data)) {
      data = data.map((entry) => entry[name]).filter((entry) => entry !== void 0);
      if (data.length === 0) {
        return void 0;
      }
      if (data.length === 1) {
        return data[0];
      }
      return data;
    }
    return data?.[name];
  }
  function exprFunction() {
    return void 0;
  }
  const EXPR_RUNTIME = {
    toDate(value) {
      if (value != null) {
        const d2 = createJsDate(value)?.setUTCHours(0, 0, 0, 0);
        if (d2 !== void 0 && !isNaN(d2)) {
          return new Date(d2);
        }
      }
      return null;
    },
    toTime(value) {
      if (value != null) {
        const d2 = createJsDate(value)?.setUTCFullYear(1970, 0, 1);
        if (d2 !== void 0 && !isNaN(d2)) {
          return new Date(d2);
        }
      }
      return null;
    },
    toDatetime(value) {
      if (value != null) {
        return createJsDate(value);
      }
      return null;
    },
    isBlank(value) {
      return !value && typeof value !== "number";
    },
    contains(value1, value2) {
      if (value1 != null) {
        return value1.includes(value2);
      }
      return false;
    }
  };
  const EXPR_CLOSURE = (...args) => {
    CONTEXT = {
      [PROP_PROVIDERS]: [],
      [PROP_PROVIDER]: null
    };
    return exprClosure.apply(CONTEXT, args);
  };
  const EXPR_PROVIDER = (...args) => exprProvider.apply(CONTEXT, args);
  const EXPR_MEMBER = (...args) => exprMember.apply(CONTEXT, args);
  const EXPR_GLOBAL = (...args) => exprGlobal.apply(CONTEXT, args);
  const EXPR_FILTER = (...args) => exprFilter.apply(CONTEXT, args);
  const EXPR_FUNCTION = (...args) => exprFunction.apply(CONTEXT, args);
  var expressions = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    EXPR_CLOSURE,
    EXPR_FILTER,
    EXPR_FUNCTION,
    EXPR_GLOBAL,
    EXPR_MEMBER,
    EXPR_PROVIDER,
    EXPR_RUNTIME
  });
  function defineModules(modulesByName) {
    Object.entries(modulesByName).forEach(([name, module]) => {
      LWR.define(name, [], function() {
        return module;
      });
    });
  }
  defineModules({
    "@salesforce/client/formFactor": getFormFactor(),
    "aura-instrumentation": auraInstrumentationService,
    "aura-storage": auraStorage,
    "instrumentation/service": auraInstrumentationService,
    "instrumentation/utility": auraInstrumentationUtility,
    "webruntime/expressions": expressions,
    "lightning/configProvider": lightningConfigProvider$1,
    "lightning/navigation": navigation,
    "webruntime/routerContainer": WebruntimeRouterContainer,
    "webruntime/routingService": routingService,
    "webruntime/slotContainer": SlotContainer$1,
    "webruntime/visibilityContainer": VisibilityContainer$1,
    "webruntime/componentContainer": ComponentContainer$1,
    "webruntime/formFactor": getFormFactor,
    "wire-service": wireService,
    "webruntime/overrides": overrides,
    aura: webruntimeAura,
    logger,
    assert: assert$1
  });
  if (authenticationCookieName__default["default"] && !getCookie(authenticationCookieName__default["default"])) {
    defineModules({
      "@app/user": {
        isGuest: true,
        id: null,
        csrfToken: null
      }
    });
  }
  var index = _2_41_4.registerComponent(App$1, {
    tmpl: _tmpl$a,
    sel: "client-src"
  });
  exports.default = index;
  Object.defineProperty(exports, "__esModule", {value: true});
});
