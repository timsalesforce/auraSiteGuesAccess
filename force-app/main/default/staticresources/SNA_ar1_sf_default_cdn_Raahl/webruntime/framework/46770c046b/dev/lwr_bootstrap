LWR.define("lwr/metrics/v/0_9_0", ["exports"], function(exports) {
  "use strict";
  const BOOTSTRAP_PREFIX = "lwr.bootstrap.";
  const BOOTSTRAP_END = `${BOOTSTRAP_PREFIX}end`;
  const BOOTSTRAP_ERROR = `${BOOTSTRAP_PREFIX}error`;
  const BOOTSTRAP_ERROR_COUNT = `${BOOTSTRAP_ERROR}.count`;
  const BOOTSTRAP_DURATION = `${BOOTSTRAP_PREFIX}duration`;
  const LOADER_PREFIX = "lwr.loader.";
  const MODULE_DEFINE = `${LOADER_PREFIX}module.define`;
  const MODULE_DEFINE_COUNT = `${MODULE_DEFINE}.count`;
  const MODULE_FETCH = `${LOADER_PREFIX}module.fetch`;
  const MODULE_FETCH_COUNT = `${MODULE_FETCH}.count`;
  const MODULE_FETCH_DURATION = `${MODULE_FETCH}.duration`;
  const MODULE_ERROR = `${LOADER_PREFIX}module.error`;
  const MODULE_ERROR_COUNT = `${MODULE_ERROR}.count`;
  const MAPPINGS_FETCH = `${LOADER_PREFIX}mappings.fetch`;
  const MAPPINGS_FETCH_COUNT = `${MAPPINGS_FETCH}.count`;
  const MAPPINGS_FETCH_DURATION = `${MAPPINGS_FETCH}.duration`;
  const MAPPINGS_ERROR = `${LOADER_PREFIX}mappings.error`;
  const MAPPINGS_ERROR_COUNT = `${MAPPINGS_ERROR}.count`;
  const ROUTER_PREFIX = "lwr.router.";
  const ROUTER_NAV = `${ROUTER_PREFIX}navigate`;
  const ROUTER_NAV_COUNT = `${ROUTER_NAV}.count`;
  const ROUTER_NAV_DURATION = `${ROUTER_NAV}.duration`;
  const ROUTER_VIEW = `${ROUTER_PREFIX}view`;
  const ROUTER_VIEW_DURATION = `${ROUTER_VIEW}.duration`;
  const ROUTER_ERROR = `${ROUTER_PREFIX}error`;
  const ROUTER_ERROR_COUNT = `${ROUTER_ERROR}.count`;
  exports.BOOTSTRAP_DURATION = BOOTSTRAP_DURATION;
  exports.BOOTSTRAP_END = BOOTSTRAP_END;
  exports.BOOTSTRAP_ERROR = BOOTSTRAP_ERROR;
  exports.BOOTSTRAP_ERROR_COUNT = BOOTSTRAP_ERROR_COUNT;
  exports.BOOTSTRAP_PREFIX = BOOTSTRAP_PREFIX;
  exports.LOADER_PREFIX = LOADER_PREFIX;
  exports.MAPPINGS_ERROR = MAPPINGS_ERROR;
  exports.MAPPINGS_ERROR_COUNT = MAPPINGS_ERROR_COUNT;
  exports.MAPPINGS_FETCH = MAPPINGS_FETCH;
  exports.MAPPINGS_FETCH_COUNT = MAPPINGS_FETCH_COUNT;
  exports.MAPPINGS_FETCH_DURATION = MAPPINGS_FETCH_DURATION;
  exports.MODULE_DEFINE = MODULE_DEFINE;
  exports.MODULE_DEFINE_COUNT = MODULE_DEFINE_COUNT;
  exports.MODULE_ERROR = MODULE_ERROR;
  exports.MODULE_ERROR_COUNT = MODULE_ERROR_COUNT;
  exports.MODULE_FETCH = MODULE_FETCH;
  exports.MODULE_FETCH_COUNT = MODULE_FETCH_COUNT;
  exports.MODULE_FETCH_DURATION = MODULE_FETCH_DURATION;
  exports.ROUTER_ERROR = ROUTER_ERROR;
  exports.ROUTER_ERROR_COUNT = ROUTER_ERROR_COUNT;
  exports.ROUTER_NAV = ROUTER_NAV;
  exports.ROUTER_NAV_COUNT = ROUTER_NAV_COUNT;
  exports.ROUTER_NAV_DURATION = ROUTER_NAV_DURATION;
  exports.ROUTER_PREFIX = ROUTER_PREFIX;
  exports.ROUTER_VIEW = ROUTER_VIEW;
  exports.ROUTER_VIEW_DURATION = ROUTER_VIEW_DURATION;
  Object.defineProperty(exports, "__esModule", {value: true});
});
LWR.define("lwr/init/v/0_9_0", ["exports", "lwr/metrics/v/0_9_0", "lwr/profiler/v/0_9_0", "lwc/v/2_41_4"], function(exports, _0_9_0$1, _0_9_0, _2_41_4) {
  "use strict";
  function initializeWebComponent(elementName, Ctor) {
    return _2_41_4.createElement(elementName, {
      is: Ctor
    });
  }
  function toKebabCase(specifier) {
    return specifier.replace(/\/v\/[a-zA-Z0-9-_.]+$/, "").replace("/", "-").replace(/([A-Z])/g, (c) => `-${c.toLowerCase()}`);
  }
  const CAMEL_REGEX = /-([a-z])/g;
  function getPropFromAttrName(propName) {
    return propName.replace(CAMEL_REGEX, (g) => g[1].toUpperCase());
  }
  function init(rootModules) {
    if (typeof customElements !== "undefined" && typeof document !== "undefined") {
      const container = document.querySelector("[lwr-root]");
      rootModules.forEach(([moduleSpecifier, ctor]) => {
        const elementName = toKebabCase(moduleSpecifier);
        let el = document.body.querySelector(elementName);
        if (!el) {
          el = initializeWebComponent(elementName, ctor);
          if (container) {
            container.appendChild(el);
          } else {
            document.body.appendChild(el);
          }
        } else {
          const customElements2 = document.querySelectorAll(elementName);
          customElements2.forEach((customElement) => {
            const newElement = initializeWebComponent(elementName, ctor);
            for (const {
              name,
              value
            } of customElement.attributes) {
              newElement.setAttribute(name, value);
              const prop = getPropFromAttrName(name);
              if (prop in newElement) {
                newElement[prop] = value;
              }
            }
            while (customElement.childNodes.length > 0) {
              newElement.appendChild(customElement.childNodes[0]);
            }
            customElement.parentElement.replaceChild(newElement, customElement);
          });
        }
      });
    }
    _0_9_0.logOperationStart({
      id: _0_9_0$1.BOOTSTRAP_END
    });
  }
  exports.getPropFromAttrName = getPropFromAttrName;
  exports.init = init;
  exports.toKebabCase = toKebabCase;
  Object.defineProperty(exports, "__esModule", {value: true});
});
LWR.define("webruntime/dynamicImportResourceHook/v/1_66_319-244_0", ["exports", "@app/basePath/v/1", "@app/versionKey/v/1"], function(exports, basePath, versionKey) {
  "use strict";
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : {default: e};
  }
  var basePath__default = /* @__PURE__ */ _interopDefaultLegacy(basePath);
  var versionKey__default = /* @__PURE__ */ _interopDefaultLegacy(versionKey);
  function DynamicImportResourceHook(serviceAPI) {
    const resourceUrlSpecifier = "@salesforce/resourceUrl/";
    const resourceUrlResolvedBaseUrl = "resourceUrl://";
    serviceAPI.addLoaderPlugin({
      resolveModule: async (id) => {
        if (id.startsWith(resourceUrlSpecifier)) {
          return {
            url: `${resourceUrlResolvedBaseUrl}${id}`
          };
        }
        return null;
      },
      loadModule: async (url) => {
        if (url.startsWith(resourceUrlResolvedBaseUrl)) {
          const parts = url.split("/");
          const name = parts[parts.length - 1];
          return {
            data: `LWR.define('${resourceUrlSpecifier}${name}', ['exports'], function(exports) {
                        exports.default = '${basePath__default["default"]}/webruntime/org-asset/${versionKey__default["default"]}/resource-name/${name}';
                    });`,
            status: 200
          };
        }
        return null;
      }
    });
  }
  exports.default = DynamicImportResourceHook;
  Object.defineProperty(exports, "__esModule", {value: true});
});
LWR.define("webruntime/o11yHook/v/1_66_319-244_0", ["exports", "lwr/loaderLegacy/v/0_9_0", "@app/basePath/v/1", "@app/apiBasePath/v/1", "@salesforce/i18n/lang/v/1", "webruntime/dispatcher/v/1", "@app/o11yConfiguration/v/1", "@app/o11yGuestToken/v/1", "@app/isDesignMode/v/1", "@app/isMobileAppMode/v/1", "@app/isPreviewMode/v/1", "@app/versionKey/v/1", "@salesforce/site/Id/v/1"], function(exports, _0_9_0, basePath, apiBasePath, language, dispatcher, srvConfigJson, guestTokenExt, isDesignMode, isMobileAppMode, isPreviewMode, versionKey, siteId) {
  "use strict";
  function _interopDefaultLegacy(e2) {
    return e2 && typeof e2 === "object" && "default" in e2 ? e2 : {default: e2};
  }
  var basePath__default = /* @__PURE__ */ _interopDefaultLegacy(basePath);
  var apiBasePath__default = /* @__PURE__ */ _interopDefaultLegacy(apiBasePath);
  var language__default = /* @__PURE__ */ _interopDefaultLegacy(language);
  var dispatcher__default = /* @__PURE__ */ _interopDefaultLegacy(dispatcher);
  var srvConfigJson__default = /* @__PURE__ */ _interopDefaultLegacy(srvConfigJson);
  var guestTokenExt__default = /* @__PURE__ */ _interopDefaultLegacy(guestTokenExt);
  var isDesignMode__default = /* @__PURE__ */ _interopDefaultLegacy(isDesignMode);
  var isMobileAppMode__default = /* @__PURE__ */ _interopDefaultLegacy(isMobileAppMode);
  var isPreviewMode__default = /* @__PURE__ */ _interopDefaultLegacy(isPreviewMode);
  var versionKey__default = /* @__PURE__ */ _interopDefaultLegacy(versionKey);
  var siteId__default = /* @__PURE__ */ _interopDefaultLegacy(siteId);
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const _o11y$1 = {};
  var webruntimeO11y = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    _o11y: _o11y$1
  });
  class LazyMapToList {
    constructor(maxSize) {
      this._lazyMap = new Map();
      if (maxSize !== void 0) {
        if (typeof maxSize === "number" && maxSize > 0) {
          this._maxSize = Math.ceil(maxSize);
          return;
        }
        throw new Error("maxSize must be a positive number");
      }
    }
    get maxSize() {
      return this._maxSize;
    }
    get size() {
      return this._lazyMap.size;
    }
    push(key, value) {
      let buffer = this._lazyMap.get(key);
      if (!buffer) {
        if (this.maxSize !== void 0 && this.size === this.maxSize) {
          return false;
        }
        buffer = new Array();
        this._lazyMap.set(key, buffer);
      }
      buffer.push(value);
      return true;
    }
    getMessages(key, extract) {
      const msgs = this._lazyMap.get(key);
      if (extract && this._lazyMap.has(key)) {
        this._lazyMap.set(key, []);
      }
      return msgs || [];
    }
    getAllMessages(extract) {
      const map = new Map();
      for (const [key, value] of this._lazyMap.entries()) {
        if (value.length) {
          map.set(key, this.getMessages(key, extract));
        }
      }
      return map;
    }
    extractMessages(key) {
      return this.getMessages(key, true);
    }
    extractAllMessages() {
      return this.getAllMessages(true);
    }
    get totalItemCount() {
      let count = 0;
      for (const array of this._lazyMap.values()) {
        count += array.length;
      }
      return count;
    }
  }
  class Utility {
    constructor() {
      this.notImplemented = "Method not implemented.";
      const performanceExists = typeof performance !== "undefined";
      if (performanceExists) {
        if (performance.timeOrigin) {
          this._timeOrigin = performance.timeOrigin;
        } else {
          this._timeOrigin = Date.now();
        }
      } else {
        this._timeOrigin = Date.now();
      }
      const timeOrigin = this._timeOrigin;
      if (performanceExists && typeof performance.now === "function") {
        this.perfNow = performance.now.bind(performance);
        this.time = () => {
          const perfNow = this.perfNow();
          return {
            tsNow: timeOrigin + perfNow,
            perfNow,
            timeOrigin
          };
        };
      } else {
        this.perfNow = () => {
          return Date.now() - timeOrigin;
        };
        this.time = () => {
          const perfNow = this.perfNow();
          return {
            tsNow: Date.now(),
            perfNow,
            timeOrigin
          };
        };
      }
    }
    get isProduction() {
      return Utility._isProduction;
    }
    markProduction() {
      Utility._isProduction = true;
    }
    _checkArgument(argument, argKind) {
      if (typeof argKind === "string") {
        return typeof argument === argKind;
      }
      if (typeof argKind === "function") {
        return argument instanceof argKind;
      }
      if (Array.isArray(argKind)) {
        return argKind.some((arg) => this._checkArgument(argument, arg));
      }
      throw new Error(`Invalid argKind ${argKind}`);
    }
    requireArgument(argument, argumentName, argKind) {
      let disallowed = argument === void 0 || argument === null || argument === "";
      const kindSpecified = argKind !== void 0;
      if (!disallowed && kindSpecified) {
        disallowed = !this._checkArgument(argument, argKind);
      }
      if (disallowed) {
        throw new Error(`${argumentName} argument is required${kindSpecified ? " and must be of a supported type." : "."}`);
      }
    }
    requireArgumentIfDefined(argument, argumentName, argKind) {
      if (argument === void 0) {
        return false;
      }
      const disallowed = argument === null || argument === "" || !this._checkArgument(argument, argKind);
      if (disallowed) {
        throw new Error(`${argumentName} argument, if defined, must be of a supported type.`);
      }
      return true;
    }
    checkForDenyListedValues(argument, argumentName, denyList) {
      if (denyList.some((x) => argument === x)) {
        throw new Error(`The value ${argument} isn't allowed for ${argumentName} argument.`);
      }
    }
    checkForReservedCharacters(argument, argumentName, reservedChars) {
      if (argument && reservedChars.some((c2) => argument.indexOf(c2) >= 0)) {
        throw new Error(`The argument ${argumentName} isn't allowed to contain characters from ['${reservedChars.join(", ")}']. Received: ${argument}.`);
      }
    }
    generateUniqueId(length = 16) {
      const chars = [];
      const digits = "0123456789abcdef";
      if (!(length === void 0 || length > 0)) {
        throw new Error('If specified, the argument "length" must be a positive integer');
      }
      for (let i2 = 0; i2 < length; i2++) {
        const rand = Math.floor(Math.random() * 16);
        chars.push(digits[rand]);
      }
      return chars.join("");
    }
    getXpath(_element) {
      function hasSameSibs(elm) {
        const name = elm.localName;
        while (elm.nextElementSibling) {
          elm = elm.nextElementSibling;
          if (elm.localName === name) {
            return true;
          }
        }
        return false;
      }
      function idx(sib, name) {
        if (sib) {
          return idx(sib.previousElementSibling, name || sib.localName) + (sib.localName === name ? 1 : 0);
        }
        return 1;
      }
      function segs(elm) {
        if (!elm || elm.nodeType !== 1) {
          return [""];
        }
        const nodeValue = idx(elm) > 1 || hasSameSibs(elm) ? `${elm.localName.toLowerCase()}[${idx(elm)}]` : elm.localName.toLowerCase();
        return [...segs(elm.parentNode), nodeValue];
      }
      return segs(_element).join("/");
    }
    getAge(timestamp) {
      return timestamp - this._timeOrigin;
    }
    getConnectionType() {
      var _a;
      let connectionType;
      if (typeof navigator !== "undefined") {
        const expNav = navigator;
        connectionType = (_a = expNav === null || expNav === void 0 ? void 0 : expNav.connection) === null || _a === void 0 ? void 0 : _a.effectiveType;
      }
      return connectionType;
    }
    clone(value) {
      return JSON.parse(JSON.stringify(value));
    }
    definedValueOrDefault(value, defaultValue) {
      return value !== void 0 ? value : defaultValue;
    }
    getGlobal() {
      if (typeof globalThis === "object") {
        return globalThis;
      }
      if (typeof self === "object") {
        return self;
      }
      throw new Error("Unable to locate globalThis or self");
    }
    getIsBeaconSupported() {
      var _a;
      const g2 = this.getGlobal();
      return typeof ((_a = g2.navigator) === null || _a === void 0 ? void 0 : _a.sendBeacon) === "function" && typeof g2.Blob === "function";
    }
    estimateObjectSize(object) {
      const objectSet = new Set();
      const stack = [object];
      let bytes = 0;
      while (stack.length) {
        const value = stack.pop();
        if (typeof value === "boolean") {
          bytes += 4;
        } else if (typeof value === "string") {
          bytes += value.length * 2;
        } else if (typeof value === "number") {
          bytes += 8;
        } else if (value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Uint16Array || value instanceof Uint32Array || value instanceof Int8Array || value instanceof Int16Array || value instanceof Int32Array || value instanceof Float32Array || value instanceof Float64Array) {
          bytes += value.byteLength;
        } else if (typeof value === "object") {
          const obj = value;
          if (!objectSet.has(obj)) {
            objectSet.add(obj);
            for (const key in obj) {
              stack.push(obj[key]);
            }
          }
        }
      }
      return bytes;
    }
    noProdThrow(e2) {
      if (utility.isProduction) {
        return;
      }
      throw e2;
    }
  }
  Utility._isProduction = false;
  const utility = Object.freeze(new Utility());
  class PublicSafety {
    constructor(_errorCounter) {
      this._errorCounter = _errorCounter;
      this._safeCatchMode = false;
    }
    tryCatch(fn) {
      try {
        fn();
      } catch (err) {
        this._prodSafeCatch(err);
      }
    }
    tryCatchReturn(fn, noopValue) {
      try {
        utility.requireArgument(noopValue, "noopValue");
        return fn();
      } catch (err) {
        this._prodSafeCatch(err);
        return noopValue;
      }
    }
    _prodSafeCatch(error2) {
      let allowThrow;
      try {
        allowThrow = !utility.isProduction;
        if (allowThrow) {
          throw error2;
        }
        if (this._safeCatchMode) {
          this._safeCatchMode = false;
          throw new Error("Internal error in prodSafeCatch.");
        }
        this._safeCatchMode = true;
        if (this._errorCounter) {
          this._errorCounter.increment();
        }
        if (!(error2 instanceof Error)) {
          const errorText = error2 && error2.message || (typeof error2.toString === "function" ? error2.toString() : "");
          error2 = new Error(errorText);
        }
        this._safeCatchMode = false;
      } catch (internalError) {
        if (allowThrow) {
          throw internalError;
        }
        if (internalError && console && typeof console.error === "function") {
          try {
            console.error(internalError);
          } catch (_a) {
          }
        }
        this._safeCatchMode = false;
      }
    }
  }
  class SchemaUtil {
    getSchemaId(schema) {
      return `${schema.namespace}.${schema.name}`;
    }
    isInternal(schema) {
      return (schema === null || schema === void 0 ? void 0 : schema.namespace) === "sf.instrumentation";
    }
    makePayload(schema, data, onlyIfBoth = true) {
      if (!onlyIfBoth || schema !== void 0 && data !== void 0) {
        return {
          schema,
          payload: data
        };
      }
      return void 0;
    }
    checkSchema(schema) {
      utility.requireArgument(schema, "schema", "object");
      utility.requireArgument(schema.namespace, "schema.namespace", "string");
      utility.requireArgument(schema.name, "schema.name", "string");
      utility.requireArgument(schema.pbjsSchema, "schema.pbjsSchema", "object");
      const parts = schema.namespace.split(".");
      if (parts.length !== 2) {
        throw new Error(`Schema "${this.getSchemaId(schema)}" must have a namespace of the form "domain.feature".`);
      }
      return {
        domain: parts[0],
        feature: parts[1],
        message: schema.name
      };
    }
    _getAnyNestedObject(schema, scopes) {
      return scopes.reduce((prev, currentScope) => {
        const descriptor = prev.nested;
        if (descriptor) {
          const ano = descriptor[currentScope];
          if (ano) {
            return ano;
          }
        }
        throw new Error(`Cannot locate ${scopes.join(".")} in schema with ID ${this.getSchemaId(schema)}`);
      }, schema.pbjsSchema);
    }
    getTypes(schema) {
      const schemaTokens = this.checkSchema(schema);
      const namespace = this._getAnyNestedObject(schema, [schemaTokens.domain, schemaTokens.feature]);
      const descriptor = namespace.nested;
      if (!descriptor) {
        throw new Error(`Cannot parse schema with ID ${this.getSchemaId(schema)}`);
      }
      return descriptor;
    }
    getType(schema, messageName) {
      utility.requireArgument(messageName, "messageName", "string");
      const descriptor = this.getTypes(schema);
      const message = descriptor[messageName];
      if (!message) {
        throw new Error(`Cannot locate message ${messageName} in schema with ID ${this.getSchemaId(schema)}`);
      }
      return message;
    }
    getOptions(schema, messageName, fieldName) {
      if (fieldName) {
        utility.requireArgument(messageName, "messageName", "string");
      }
      const schemaTokens = this.checkSchema(schema);
      if (!messageName) {
        const namespace = this._getAnyNestedObject(schema, [schemaTokens.domain, schemaTokens.feature]);
        return namespace.options;
      }
      const type = this.getType(schema, messageName);
      if (!fieldName) {
        return type.options;
      }
      const field = type.fields[fieldName];
      if (!field) {
        const schemaId = this.getSchemaId(schema);
        throw new Error(`Cannot locate field ${fieldName} in message ${messageName} in schema with ID ${schemaId}`);
      }
      return field.options;
    }
  }
  const schemaUtil = new SchemaUtil();
  var o11yShared = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    LazyMapToList,
    PublicSafety,
    schemaUtil,
    utility
  });
  const activity = {
    namespace: "sf.instrumentation",
    name: "Activity",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            instrumentation: {
              nested: {
                Activity: {
                  reserved: [[5, 5], [7, 7]],
                  fields: {
                    duration: {
                      id: 3,
                      type: "double"
                    },
                    stopReason: {
                      id: 6,
                      type: "string"
                    },
                    isRoot: {
                      id: 8,
                      type: "bool"
                    },
                    timerOverridden: {
                      id: 12,
                      type: "uint32"
                    },
                    name: {
                      options: {
                        "(meta.max_length)": 25
                      },
                      id: 2,
                      type: "string"
                    },
                    isSampled: {
                      id: 11,
                      type: "bool"
                    },
                    preRootId: {
                      id: 9,
                      type: "string"
                    },
                    id: {
                      id: 1,
                      type: "string"
                    },
                    userPayload: {
                      id: 4,
                      type: "Payload"
                    },
                    errorCount: {
                      id: 10,
                      type: "uint32"
                    },
                    parentId: {
                      id: 13,
                      type: "string"
                    }
                  }
                },
                Payload: {
                  fields: {
                    payload: {
                      id: 2,
                      type: "bytes"
                    },
                    schemaName: {
                      id: 1,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const error = {
    namespace: "sf.instrumentation",
    name: "Error",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            instrumentation: {
              nested: {
                Error: {
                  reserved: [[5, 5], [7, 7]],
                  fields: {
                    activityId: {
                      id: 6,
                      type: "string"
                    },
                    stack: {
                      id: 3,
                      type: "string"
                    },
                    name: {
                      id: 1,
                      type: "string"
                    },
                    message: {
                      options: {
                        "(meta.max_length)": 200
                      },
                      id: 2,
                      type: "string"
                    },
                    userPayload: {
                      id: 4,
                      type: "Payload"
                    }
                  }
                },
                Payload: {
                  fields: {
                    payload: {
                      id: 2,
                      type: "bytes"
                    },
                    schemaName: {
                      id: 1,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const idle_detector_report = {
    namespace: "sf.instrumentation",
    name: "IdleDetectorReport",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            instrumentation: {
              nested: {
                IdleDetectorReport: {
                  fields: {
                    listenerCount: {
                      id: 3,
                      type: "uint32"
                    },
                    busyTasks: {
                      rule: "repeated",
                      id: 5,
                      type: "string"
                    },
                    busyDurations: {
                      rule: "repeated",
                      id: 6,
                      type: "double"
                    },
                    pollableCount: {
                      id: 4,
                      type: "uint32"
                    },
                    pollCounts: {
                      rule: "repeated",
                      id: 8,
                      type: "double"
                    },
                    logThreshold: {
                      id: 2,
                      type: "double"
                    },
                    maxDuration: {
                      id: 1,
                      type: "double"
                    },
                    pollables: {
                      rule: "repeated",
                      id: 7,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const instrumented_event = {
    namespace: "sf.instrumentation",
    name: "InstrumentedEvent",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            instrumentation: {
              nested: {
                MouseEvent: {
                  fields: {
                    cancelable: {
                      id: 5,
                      type: "bool"
                    },
                    ctrlKey: {
                      id: 9,
                      type: "bool"
                    },
                    type: {
                      id: 25,
                      type: "string"
                    },
                    button: {
                      id: 3,
                      type: "uint32"
                    },
                    offsetX: {
                      id: 17,
                      type: "uint32"
                    },
                    eventPhase: {
                      id: 12,
                      type: "uint32"
                    },
                    shiftKey: {
                      id: 23,
                      type: "bool"
                    },
                    offsetY: {
                      id: 18,
                      type: "uint32"
                    },
                    composed: {
                      id: 8,
                      type: "bool"
                    },
                    altKey: {
                      id: 1,
                      type: "bool"
                    },
                    isTrusted: {
                      id: 13,
                      type: "bool"
                    },
                    buttons: {
                      id: 4,
                      type: "uint32"
                    },
                    movementY: {
                      id: 16,
                      type: "uint32"
                    },
                    clientY: {
                      id: 7,
                      type: "uint32"
                    },
                    clientX: {
                      id: 6,
                      type: "uint32"
                    },
                    movementX: {
                      id: 15,
                      type: "uint32"
                    },
                    defaultPrevented: {
                      id: 10,
                      type: "bool"
                    },
                    metaKey: {
                      id: 14,
                      type: "bool"
                    },
                    timeStamp: {
                      id: 24,
                      type: "double"
                    },
                    bubbles: {
                      id: 2,
                      type: "bool"
                    },
                    detail: {
                      id: 11,
                      type: "int64"
                    },
                    pageY: {
                      id: 20,
                      type: "uint32"
                    },
                    pageX: {
                      id: 19,
                      type: "uint32"
                    },
                    screenX: {
                      id: 21,
                      type: "uint32"
                    },
                    screenY: {
                      id: 22,
                      type: "uint32"
                    }
                  }
                },
                InstrumentedEvent: {
                  oneofs: {
                    event: {
                      oneof: ["mouseEvent"]
                    }
                  },
                  reserved: [[4, 4], "xpath", [6, 6], [8, 8]],
                  fields: {
                    mouseEvent: {
                      id: 7,
                      type: "MouseEvent"
                    },
                    auto: {
                      id: 3,
                      type: "bool"
                    },
                    parentComponent: {
                      id: 2,
                      type: "string"
                    },
                    ownerComponent: {
                      id: 1,
                      type: "string"
                    },
                    userPayload: {
                      id: 5,
                      type: "Payload"
                    },
                    simplePath: {
                      id: 9,
                      type: "string"
                    }
                  }
                },
                Payload: {
                  fields: {
                    payload: {
                      id: 2,
                      type: "bytes"
                    },
                    schemaName: {
                      id: 1,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const simple = {
    namespace: "sf.instrumentation",
    name: "Simple",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            instrumentation: {
              nested: {
                Simple: {
                  fields: {
                    text: {
                      options: {
                        "(meta.max_length)": 25
                      },
                      id: 1,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  class TaskerImpl {
    get isBusy() {
      return this._isOk ? this._busyCount > 0 : void 0;
    }
    constructor(name, initialCount, _doneCallback, _overDoneCallback) {
      this.name = name;
      this._doneCallback = _doneCallback;
      this._overDoneCallback = _overDoneCallback;
      this._busyCount = 0;
      this._isOk = true;
      this._busyCount = initialCount;
    }
    add() {
      if (this._isOk) {
        this._busyCount += 1;
      }
    }
    done() {
      if (this._isOk) {
        if (this._busyCount > 0) {
          this._busyCount -= 1;
          if (!this._busyCount) {
            this._doneCallback();
          }
        } else {
          this._isOk = false;
          this._overDoneCallback();
        }
      }
    }
  }
  const defaultLogThreshold = 300;
  class IdleDetectorImpl {
    constructor(options) {
      this._taskers = new Map();
      this._listeners = new Set();
      this._busyCheckers = new Map();
      this._logThreshold = defaultLogThreshold;
      this._endedTasks = new Array();
      this._pollableReport = new Array();
      if (utility.requireArgumentIfDefined(options === null || options === void 0 ? void 0 : options.logThreshold, "options.logThreshold", "number")) {
        this._logThreshold = options.logThreshold;
      }
      if (utility.requireArgumentIfDefined(options === null || options === void 0 ? void 0 : options.reportListener, "options.reportListener", "function")) {
        this._reportListener = options.reportListener;
      }
      if (utility.requireArgumentIfDefined(options === null || options === void 0 ? void 0 : options.errorListener, "options.errorListener", "function")) {
        this._errorListener = options.errorListener;
      }
    }
    requestIdleDetectedCallback(callback) {
      utility.requireArgument(callback, "callback", "function");
      if (this._listeners.size === 0) {
        this._firstCallbackTime = utility.time().perfNow;
      }
      this._listeners.add(callback);
      this._checkIfLoaded();
    }
    _reportTaskEnded(tasker) {
      if (this._listeners.size) {
        const snapshot = Object.assign({}, this._taskers.get(tasker));
        this._endedTasks.push(snapshot);
      }
    }
    declareNotifierTaskSingle(name) {
      utility.requireArgument(name, "name", "string");
      const tasker = this._addTasker(name, 1);
      const retVal = {
        get isBusy() {
          return tasker.isBusy;
        },
        done: () => {
          tasker.done();
          this._taskers.delete(tasker);
        }
      };
      return retVal;
    }
    declareNotifierTaskMulti(name, existingBusyCount = 0) {
      utility.requireArgument(name, "name", "string");
      if (existingBusyCount !== void 0) {
        utility.requireArgument(existingBusyCount, "existingBusyCount", "number");
        if (!Number.isInteger(existingBusyCount) || existingBusyCount < 0) {
          throw new Error("existingBusyCount accepts only non-negative integers");
        }
      }
      const tasker = this._addTasker(name, existingBusyCount);
      const retVal = {
        get isBusy() {
          return tasker.isBusy;
        },
        add: () => {
          if (!tasker.isBusy) {
            const meta = this._taskers.get(tasker);
            meta.start = utility.time().perfNow;
            meta.end = void 0;
          }
          tasker.add();
        },
        done: tasker.done.bind(tasker)
      };
      return retVal;
    }
    declarePollableTaskMulti(name, isBusyChecker) {
      utility.requireArgument(name, "name", "string");
      utility.requireArgument(isBusyChecker, "isBusyChecker", "function");
      this._busyCheckers.set(isBusyChecker, name);
    }
    _addTasker(name, existingBusyCount) {
      const tasker = new TaskerImpl(name, existingBusyCount, () => {
        this._taskers.get(tasker).end = utility.time().perfNow;
        this._reportTaskEnded(tasker);
        this._checkIfLoaded();
      }, () => {
        var _a;
        (_a = this._errorListener) === null || _a === void 0 ? void 0 : _a.call(this, `Overdone: ${tasker.name}`);
        utility.noProdThrow(`Tasker '${tasker.name}' is done too many times.`);
      });
      this._taskers.set(tasker, {
        name,
        start: existingBusyCount > 0 ? utility.time().perfNow : void 0,
        end: void 0
      });
      return tasker;
    }
    _areAllNotifiersIdle() {
      return !Array.from(this._taskers.keys()).some((t2) => t2.isBusy);
    }
    _getFirstBusyPollable() {
      const entry = Array.from(this._busyCheckers).find((entry2) => {
        var _a;
        const isBusyChecker = entry2[0];
        const name = entry2[1];
        try {
          return isBusyChecker();
        } catch (e2) {
          (_a = this._errorListener) === null || _a === void 0 ? void 0 : _a.call(this, e2, `BusyChecker ${name}`);
          utility.noProdThrow(e2);
          return false;
        }
      });
      return entry ? entry[1] : void 0;
    }
    _checkIfLoaded() {
      if (!this._listeners.size) {
        return;
      }
      if (this._timerCheckQueued) {
        clearTimeout(this._timerCheckQueued);
      }
      if (this._areAllNotifiersIdle()) {
        this._timerCheckQueued = setTimeout(() => {
          this._timerCheckQueued = setTimeout(() => {
            this._doubleCheck();
          }, 40);
        }, 0);
      }
    }
    _doubleCheck() {
      this._timerCheckQueued = void 0;
      if (this._areAllNotifiersIdle()) {
        const pollableName = this._getFirstBusyPollable();
        if (pollableName !== void 0) {
          this._addToPollableReport(pollableName);
          this._timerCheckQueued = setTimeout(() => {
            this._doubleCheck();
          }, 15);
        } else {
          const maxDuration = utility.time().perfNow - this._firstCallbackTime;
          const listeners = Array.from(this._listeners.values());
          this._listeners.clear();
          this._firstCallbackTime = void 0;
          const endedTasks = this._endedTasks.splice(0);
          const pollableReport = this._pollableReport.splice(0);
          this._notify(listeners, maxDuration, endedTasks, pollableReport);
        }
      }
    }
    _addToPollableReport(name) {
      const lastEntry = this._pollableReport.length ? this._pollableReport[this._pollableReport.length - 1] : void 0;
      if ((lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.name) === name) {
        lastEntry.count += 1;
      } else {
        this._pollableReport.push({
          name,
          count: 1
        });
      }
    }
    _notify(listeners, maxDuration, taskReport, pollableReport) {
      var _a;
      if (maxDuration >= this._logThreshold && this._reportListener) {
        const logData = this._getReport(maxDuration, listeners.length, taskReport, pollableReport);
        this._reportListener(logData);
      }
      listeners.reverse();
      const tsNow = utility.time().tsNow;
      for (const [index2, listener] of listeners.entries()) {
        try {
          listener(tsNow);
        } catch (e2) {
          (_a = this._errorListener) === null || _a === void 0 ? void 0 : _a.call(this, e2, `Listener #${listeners.length - 1 - index2}`);
          utility.noProdThrow(e2);
        }
      }
    }
    getReport() {
      const perfNow = utility.time().perfNow;
      const maxDuration = this._firstCallbackTime > 0 ? perfNow - this._firstCallbackTime : void 0;
      const onGoingTasks = Array.from(this._taskers.entries()).filter((e2) => e2[0].isBusy).map((e2) => ({
        name: e2[1].name,
        start: e2[1].start,
        end: perfNow
      }));
      return this._getReport(maxDuration, this._listeners.size, this._endedTasks.concat(onGoingTasks), this._pollableReport);
    }
    _getReport(maxDuration, listenerCount, taskReport, pollableReport) {
      const sortedTaskers = taskReport.map((t2) => ({
        name: t2.name,
        duration: t2.end - t2.start
      })).sort((a2, b2) => b2.duration - a2.duration);
      return {
        logThreshold: this._logThreshold,
        maxDuration,
        listenerCount,
        pollableCount: this._busyCheckers.size,
        busyTasks: sortedTaskers.map((t2) => t2.name),
        busyDurations: sortedTaskers.map((t2) => t2.duration),
        pollables: pollableReport.map((p2) => p2.name),
        pollCounts: pollableReport.map((p2) => p2.count)
      };
    }
  }
  const defaultTraceIdLengthW3 = 32;
  const defaultTraceIdLengthB3 = 16;
  const defaultSpanIdLength = 16;
  const headerTraceParent = "traceparent";
  const headerB3 = "b3";
  const headerTraceId = "X-B3-TraceId";
  const headerSpanId = "X-B3-SpanId";
  const headerSampled = "X-B3-Sampled";
  const headerParentSpanId = "X-B3-ParentSpanId";
  const defaultActivityNameForFetch = "fetch";
  const defaultActivityNameForXhrSend = "xhr_send";
  class Tracing {
    constructor(_instr, _idleDetector) {
      this._instr = _instr;
      this._idleDetector = _idleDetector;
      utility.requireArgument(_instr, "_instr", "object");
      utility.requireArgument(_idleDetector, "_idleDetector", "object");
    }
    static _getB3CompactFormat(traceId, spanId, isSampled, parentSpanId) {
      let b3 = `${traceId}-${spanId}`;
      if (isSampled !== void 0 || parentSpanId !== void 0) {
        b3 += isSampled ? "-1" : "-0";
        if (parentSpanId !== void 0) {
          b3 += `-${parentSpanId}`;
        }
      }
      return b3;
    }
    static _getW3CompactFormat(traceId, spanId, isSampled) {
      return `00-${traceId}-${spanId}-${isSampled ? "01" : "00"}`;
    }
    static _conformTextAsId(text, numChars) {
      text = text.toLowerCase();
      const len = text.length;
      for (let i2 = 0; i2 < len; i2 += 1) {
        const c2 = text[i2];
        if (!(c2 >= "a" && c2 <= "f") && !(c2 >= "0" && c2 <= "9")) {
          throw new Error(`The text '${text}' has an invalid character at index #${i2}`);
        }
      }
      if (len > numChars) {
        return text.substr(len - numChars);
      }
      if (len < numChars) {
        return text.padStart(numChars, "0");
      }
      return text;
    }
    static getHeaders(traceId, spanId, isSampled, options) {
      utility.requireArgument(traceId, "traceId", "string");
      utility.requireArgument(spanId, "spanId", "string");
      const useB3Headers = options === null || options === void 0 ? void 0 : options.useB3Headers;
      traceId = this._conformTextAsId(traceId, (options === null || options === void 0 ? void 0 : options.traceIdEffectiveLength) !== void 0 ? options.traceIdEffectiveLength : useB3Headers ? defaultTraceIdLengthB3 : defaultTraceIdLengthW3);
      spanId = this._conformTextAsId(spanId, defaultSpanIdLength);
      const parentSpanId = options && options.parentSpanId !== void 0 && this._conformTextAsId(options.parentSpanId, defaultSpanIdLength) || void 0;
      const headers = {};
      if (useB3Headers) {
        const isCompact = options === null || options === void 0 ? void 0 : options.useCompactHeader;
        if (isCompact) {
          headers[headerB3] = this._getB3CompactFormat(traceId, spanId, isSampled, parentSpanId);
        } else {
          headers[headerTraceId] = traceId;
          headers[headerSpanId] = spanId;
          if (parentSpanId !== void 0) {
            headers[headerParentSpanId] = parentSpanId;
          }
          if (isSampled !== void 0) {
            headers[headerSampled] = isSampled ? "1" : "0";
          }
        }
      } else {
        headers[headerTraceParent] = this._getW3CompactFormat(traceId, spanId, isSampled);
      }
      return headers;
    }
    _disableNetworkInstrumentation() {
      if (Tracing._isNetworkInstrumentationEnabled) {
        if (Tracing._originalFetch) {
          Tracing._global.fetch = Tracing._originalFetch;
          Tracing._originalFetch = void 0;
        }
        if (Tracing._originalXhr) {
          Tracing._global.XMLHttpRequest = Tracing._originalXhr;
          Tracing._originalXhr = void 0;
        }
        if (Tracing._originalXhrOpen) {
          Tracing._global.XMLHttpRequest.prototype.open = Tracing._originalXhrOpen;
          Tracing._originalXhrOpen = void 0;
        }
        if (Tracing._originalXhrSend) {
          Tracing._global.XMLHttpRequest.prototype.send = Tracing._originalXhrSend;
          Tracing._originalXhrSend = void 0;
        }
        Tracing._isNetworkInstrumentationEnabled = false;
      }
    }
    _enableNetworkInstrumentation(instr, logErrors, activityName, useTracing, options, tasker) {
      if (typeof Tracing._global.fetch === "function") {
        this._overrideFetch(instr, logErrors, activityName, useTracing, options, tasker);
        Tracing._isNetworkInstrumentationEnabled = true;
      }
      if (typeof Tracing._global.XMLHttpRequest === "function") {
        this._overrideXhr(instr, logErrors, activityName, useTracing, options, tasker);
        Tracing._isNetworkInstrumentationEnabled = true;
      }
    }
    static _getTraceHeaders(activity2, options, method, url) {
      let traceHeaders = (activity2 === null || activity2 === void 0 ? void 0 : activity2.getTraceHeaders(options)) || {};
      if (typeof (options === null || options === void 0 ? void 0 : options.headerProcessor) === "function") {
        traceHeaders = options.headerProcessor({
          method,
          url,
          defaultHeaders: traceHeaders
        });
      } else if (typeof window === "object") {
        let newUrl;
        try {
          newUrl = new URL(url);
        } catch (_a) {
        }
        if (newUrl && newUrl.host !== window.location.host) {
          traceHeaders = void 0;
        }
      }
      return traceHeaders || {};
    }
    _overrideFetch(instr, logErrors, activityName, useTracing, tracingHeadersOptions, tasker) {
      Tracing._originalFetch = Tracing._global.fetch;
      const o11yFetch = async (resource, options, ...restArgs) => {
        let activity2;
        try {
          tasker === null || tasker === void 0 ? void 0 : tasker.add();
          const ofo = options === null || options === void 0 ? void 0 : options.o11y;
          if (!(ofo === null || ofo === void 0 ? void 0 : ofo.skipInstr)) {
            activity2 = instr.startActivity(activityName || defaultActivityNameForFetch);
          } else {
            Tracing._reqIndex += 1;
            try {
              if (resource instanceof URL) {
                resource.searchParams.append("o11y", Tracing._reqIndex.toString());
              } else if (typeof resource === "string") {
                const urlObj = new URL(resource);
                const kv = `o11y=${Tracing._reqIndex}`;
                urlObj.search += urlObj.search.startsWith("?") ? `&${kv}` : kv;
                resource = urlObj.toString();
              }
            } catch (_a) {
            }
          }
          options === null || options === void 0 ? true : delete options.o11y;
          if (useTracing) {
            let method = options === null || options === void 0 ? void 0 : options.method;
            let url = resource === null || resource === void 0 ? void 0 : resource.toString();
            if (resource instanceof Request) {
              if (!method) {
                method = resource.method;
              }
              url = resource.url;
            }
            const traceHeaders = Tracing._getTraceHeaders(activity2, tracingHeadersOptions, method, url);
            if (!this._applyTraceHeaders(resource, options, traceHeaders) && options === void 0) {
              options = {
                headers: traceHeaders
              };
            }
          }
          return await Tracing._originalFetch.call(Tracing._global, resource, options, ...restArgs);
        } catch (ex) {
          if (logErrors) {
            if (activity2) {
              activity2.error(ex);
            } else {
              instr.error(ex);
            }
          }
          throw ex;
        } finally {
          activity2 === null || activity2 === void 0 ? void 0 : activity2.stop();
          tasker === null || tasker === void 0 ? void 0 : tasker.done();
        }
      };
      Tracing._global.fetch = o11yFetch;
    }
    _overrideXhr(instr, logErrors, activityName, useTracing, options, tasker) {
      Tracing._originalXhr = Tracing._global.XMLHttpRequest;
      Tracing._originalXhrOpen = Tracing._originalXhr.prototype.open;
      Tracing._originalXhrSend = Tracing._originalXhr.prototype.send;
      Tracing._originalXhr.prototype.open = function(method, url, async, username, password) {
        this._o11y = {
          method,
          url: url === null || url === void 0 ? void 0 : url.toString()
        };
        Tracing._originalXhrOpen.call(this, method, url, async, username, password);
      };
      Tracing._originalXhr.prototype.send = function(...args) {
        let activity2;
        try {
          tasker === null || tasker === void 0 ? void 0 : tasker.add();
          const xhr = this;
          xhr._o11y = xhr._o11y || {};
          xhr._o11y.activity = activity2 = instr.startActivity(activityName || defaultActivityNameForXhrSend);
          if (useTracing) {
            const traceHeaders = Tracing._getTraceHeaders(activity2, options, xhr._o11y.method, xhr._o11y.url);
            Object.entries(traceHeaders).forEach((entry) => {
              xhr.setRequestHeader(entry[0], entry[1]);
            });
          }
          Tracing._originalXhrSend.call(this, ...args);
        } catch (ex) {
          if (logErrors) {
            if (activity2) {
              activity2.error(ex);
            } else {
              instr.error(ex);
            }
          }
          activity2 === null || activity2 === void 0 ? void 0 : activity2.stop();
          tasker === null || tasker === void 0 ? void 0 : tasker.done();
          throw ex;
        }
      };
      const xhrProxy = new Proxy(Tracing._originalXhr, {
        construct(target) {
          const newXhr = new target();
          newXhr.addEventListener("load", () => {
            var _a, _b;
            (_b = (_a = newXhr._o11y) === null || _a === void 0 ? void 0 : _a.activity) === null || _b === void 0 ? void 0 : _b.stop();
            tasker === null || tasker === void 0 ? void 0 : tasker.done();
          });
          newXhr.addEventListener("error", (__err) => {
            var _a;
            const error2 = new Error("XHR Network-Level Error");
            const activity2 = (_a = newXhr._o11y) === null || _a === void 0 ? void 0 : _a.activity;
            if (activity2) {
              if (logErrors) {
                activity2.error(error2);
              }
              activity2.stop();
            } else if (logErrors) {
              instr.error(error2);
            }
            tasker === null || tasker === void 0 ? void 0 : tasker.done();
          });
          newXhr.addEventListener("abort", () => {
            var _a, _b;
            (_b = (_a = newXhr._o11y) === null || _a === void 0 ? void 0 : _a.activity) === null || _b === void 0 ? void 0 : _b.discard();
            tasker === null || tasker === void 0 ? void 0 : tasker.done();
          });
          return newXhr;
        }
      });
      Tracing._global.XMLHttpRequest = xhrProxy;
    }
    networkInstrumentation(options) {
      var _a;
      utility.requireArgument(options, "options", ["boolean", "object"]);
      this._disableNetworkInstrumentation();
      if (options) {
        const tracingOptions = typeof options === "object" ? options : {};
        let tasker = void 0;
        if (utility.definedValueOrDefault(tracingOptions.useTasker, true)) {
          tasker = (_a = this._idleDetector) === null || _a === void 0 ? void 0 : _a.declareNotifierTaskMulti("o11y network");
        }
        this._enableNetworkInstrumentation(utility.definedValueOrDefault(tracingOptions.instrumentation, this._instr), utility.definedValueOrDefault(tracingOptions.logErrors, true), tracingOptions.activityName, utility.definedValueOrDefault(tracingOptions.useTracing, true), tracingOptions.tracingHeadersOptions, tasker);
      }
    }
    resetRequestCounter() {
      Tracing._reqIndex = 0;
    }
    _applyTraceHeaders(resource, options, traceHeaders) {
      if ((options === null || options === void 0 ? void 0 : options.headers) !== void 0) {
        if (options.headers instanceof Headers && typeof options.headers.set === "function") {
          Object.entries(traceHeaders).forEach(([key, value]) => {
            options.headers.set(key, value);
          });
          return true;
        }
        if (Array.isArray(options.headers)) {
          Object.entries(traceHeaders).forEach((entry) => {
            options.headers.push(entry);
          });
          return true;
        }
        if (typeof options.headers === "object") {
          options.headers = Object.assign(options.headers, traceHeaders);
          return true;
        }
      } else if (resource instanceof Request && resource.headers instanceof Headers) {
        Object.entries(traceHeaders).forEach(([key, value]) => {
          resource.headers.set(key, value);
        });
        return true;
      } else if (options) {
        options.headers = Object.assign({}, traceHeaders);
        return true;
      }
      return false;
    }
  }
  Tracing._global = utility.getGlobal();
  Tracing._isNetworkInstrumentationEnabled = false;
  Tracing._reqIndex = 0;
  var TimerOverride;
  (function(TimerOverride2) {
    TimerOverride2[TimerOverride2["none"] = 0] = "none";
    TimerOverride2[TimerOverride2["start"] = 1] = "start";
    TimerOverride2[TimerOverride2["stop"] = 2] = "stop";
    TimerOverride2[TimerOverride2["both"] = 3] = "both";
  })(TimerOverride || (TimerOverride = {}));
  const timedout = "timedout";
  const terminated = "terminated";
  const discarded = "discarded";
  const stopReason = {
    timedout,
    terminated,
    discarded
  };
  class ActivityImpl {
    constructor(_name, _rootId, _onStopped, _onError, timeout, id2, _isSampled) {
      this._name = _name;
      this._rootId = _rootId;
      this._onStopped = _onStopped;
      this._onError = _onError;
      this._isSampled = _isSampled;
      this._errorCount = 0;
      this._timerOverridden = TimerOverride.none;
      const {
        tsNow,
        perfNow
      } = utility.time();
      ActivityImpl._count += 1;
      this._id = id2 || utility.generateUniqueId();
      this._usePerf = typeof performance !== "undefined" && typeof performance.mark === "function" && typeof performance.measure === "function";
      if (this._usePerf) {
        this._perfName = `${this._name}__${ActivityImpl._count}`;
        this._perfId = `${this._name}__${this.id}`;
        try {
          performance.mark(this._perfId);
        } catch (_a) {
          this._usePerf = false;
        }
      }
      this._startTimestamp = tsNow;
      this._startPerfTime = perfNow;
      if (timeout > 0) {
        this._timer = setTimeout(() => {
          this._stopReason = this._stopReason || stopReason.timedout;
          this.stop();
        }, timeout);
      }
      this._safety = new PublicSafety();
    }
    get id() {
      return this._id;
    }
    getId() {
      return this.id;
    }
    getRootId() {
      return this._rootId;
    }
    get stopReason() {
      return this._stopReason;
    }
    error(error2, userSchemaOrText, userData) {
      this._safety.tryCatch(() => {
        this._errorCount += 1;
        if (typeof error2 === "string") {
          error2 = new Error(error2);
        }
        this._onError(error2, this._getDetail(userSchemaOrText, userData));
      });
    }
    stop(userSchemaOrText, userData, options) {
      this._safety.tryCatch(() => {
        utility.requireArgumentIfDefined(userSchemaOrText, "userSchemaOrText", ["object", "string"]);
        utility.requireArgumentIfDefined(userData, "userData", "object");
        if (options) {
          const perfStart = options.perfStartOverride;
          const isStartTimeDefined = utility.requireArgumentIfDefined(perfStart, "options.perfStartOverride", "number");
          const perfStop = options.perfStopOverride;
          const isStopTimeDefined = utility.requireArgumentIfDefined(perfStop, "options.perfStopOverride", "number");
          if (isStartTimeDefined && perfStart < 0) {
            throw new Error("perfStartOverride, if defined, must be >= 0");
          }
          if (isStopTimeDefined && (perfStop < 0 || perfStop < (isStartTimeDefined ? perfStart : this._startPerfTime))) {
            throw new Error("perfStopOverride, if defined, must be >= 0 and >= startTime");
          }
        }
        this._stopInternal(userSchemaOrText, userData, options);
      });
    }
    _overrideTimer(perfStartTime, perfStopTime) {
      if (perfStartTime !== void 0) {
        this._startTimestamp = Math.round(this._startTimestamp - (this._startPerfTime - perfStartTime));
        this._startPerfTime = perfStartTime;
        this._setTimerOverride(TimerOverride.start);
      }
      if (perfStopTime !== void 0) {
        this._stopPerfTime = perfStopTime;
        this._setTimerOverride(TimerOverride.stop);
      }
    }
    _setTimerOverride(value) {
      if (this._timerOverridden === TimerOverride.both || this._timerOverridden === value || value === TimerOverride.none) {
        return;
      }
      this._timerOverridden = this._timerOverridden === TimerOverride.none ? value : TimerOverride.both;
    }
    _stopInternal(userSchemaOrText, userData, options) {
      const stopPerfTime = utility.perfNow();
      if (this._usePerf) {
        try {
          if (this._stopReason !== stopReason.discarded) {
            performance.measure(this._perfName, this._perfId);
          }
          performance.clearMarks(this._perfId);
          performance.clearMeasures(this._perfName);
        } catch (_a) {
        }
      }
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = void 0;
      }
      if (this.isStopped) {
        return;
      }
      if (options) {
        this._overrideTimer(options.perfStartOverride, options.perfStopOverride);
      }
      this._stopPerfTime = this._timerOverridden === TimerOverride.none || this._timerOverridden === TimerOverride.start ? stopPerfTime : this._stopPerfTime;
      const activityDetail = this._getDetail(userSchemaOrText, userData);
      this._onStopped(activityDetail);
    }
    get isStopped() {
      return this._stopPerfTime !== void 0;
    }
    discard() {
      this._safety.tryCatch(() => {
        this._stopReason = this._stopReason || stopReason.discarded;
        this.stop();
      });
    }
    terminate(userSchemaOrText, userData, options) {
      this._safety.tryCatch(() => {
        this._stopReason = this._stopReason || stopReason.terminated;
        this.stop(userSchemaOrText, userData, options);
      });
    }
    getIsSampled() {
      return this._isSampled || false;
    }
    _getDetail(userSchemaOrText, userData) {
      return {
        id: this._id,
        rootId: this._rootId,
        name: this._name,
        userSchemaOrText,
        userData,
        stopReason: this._stopReason,
        startTimestamp: this._startTimestamp,
        startPerfTime: this._startPerfTime,
        stopPerfTime: this._stopPerfTime,
        errorCount: this._errorCount,
        isSampled: this.getIsSampled(),
        timerOverridden: this._timerOverridden
      };
    }
    getTraceHeaders(options) {
      const spanId = this.id;
      const traceId = this._rootId || spanId;
      return Tracing.getHeaders(traceId, spanId, this.getIsSampled(), options);
    }
    getStartTimestamp() {
      return this._startTimestamp;
    }
    getStartPerfTime() {
      return this._startPerfTime;
    }
    getStopPerfTime() {
      return this._stopPerfTime;
    }
  }
  ActivityImpl._count = 0;
  const id = new Array(16).fill(0).join("");
  class ActivityNoOp {
    getId() {
      return id;
    }
    getRootId() {
      return void 0;
    }
    error() {
    }
    stop() {
    }
    discard() {
    }
    terminate() {
    }
    getIsSampled() {
      return false;
    }
    getTraceHeaders(__options) {
      return {};
    }
    getStartTimestamp() {
      return void 0;
    }
    getStartPerfTime() {
      return void 0;
    }
    getStopPerfTime() {
      return void 0;
    }
  }
  const activityNoOp = Object.freeze(new ActivityNoOp());
  class DomEventHelpers {
    getInstrumentedEventData(eventData, handledBy, userPayload) {
      var _a;
      const instrumentedEvent = {
        ownerComponent: handledBy.tagName,
        parentComponent: ((_a = handledBy.parentElement) === null || _a === void 0 ? void 0 : _a.tagName) || void 0,
        event: eventData,
        simplePath: utility.getXpath(handledBy)
      };
      if (userPayload) {
        instrumentedEvent.userPayload = schemaUtil.makePayload(userPayload.schema, userPayload.payload, true);
      }
      return instrumentedEvent;
    }
    getMouseEventData(e2) {
      return {
        altKey: e2.altKey,
        bubbles: e2.bubbles,
        button: e2.button,
        buttons: e2.buttons,
        cancelable: e2.cancelable,
        clientX: e2.clientX,
        clientY: e2.clientY,
        composed: e2.composed,
        defaultPrevented: e2.defaultPrevented,
        detail: e2.detail,
        eventPhase: e2.eventPhase,
        isTrusted: e2.isTrusted,
        timeStamp: e2.timeStamp,
        type: e2.type,
        ctrlKey: e2.ctrlKey,
        metaKey: e2.metaKey,
        movementX: e2.movementX,
        movementY: e2.movementY,
        offsetX: e2.offsetX,
        offsetY: e2.offsetY,
        pageX: e2.pageX,
        pageY: e2.pageY,
        screenX: e2.screenX,
        screenY: e2.screenY,
        shiftKey: e2.shiftKey
      };
    }
  }
  const singleton = new DomEventHelpers();
  const domEventHelpers = singleton;
  const maxStringLengthAppLimit = 1e4;
  const maxItemCountAppLimit = 1e4;
  const minUnsigned = 0;
  const maxFourBytes = 2147483647;
  const minFourBytes = -2147483648;
  const maxFourBytesUnsigned = 4294967295;
  const maxEightBytes = 9223372036854776e3;
  const minEightBytes = -9223372036854776e3;
  const maxEightBytesUnsigned = 18446744073709552e3;
  class ValidationEntry {
    constructor(errorCode, fields, expected, received) {
      this.errorCode = errorCode;
      this.fields = fields;
      this.expected = expected;
      this.received = received;
    }
    asMessage(schemaId) {
      const key = this.fields[0] + this.fields.slice(1).reduce((prev, current) => Number(current) >= 0 ? `${prev}[${current}]` : `${prev}.${current}`, "");
      let msg;
      switch (this.errorCode) {
        case 1:
          msg = "Repeated field must be an array";
          break;
        case 2:
          msg = `Expected type ${this.expected} but received type ${this.received}`;
          break;
        case 3:
          msg = "Value must be finite";
          break;
        case 4:
          msg = "Value is out of range for its type";
          break;
        case 5:
          msg = "Bytes array is malformed";
          break;
        case 6:
          msg = "Exceeded app limit for maximum string length";
          break;
        case 7:
          msg = "Exceeded app limit for item count";
          break;
        case 12:
          msg = "Value must be an integer";
          break;
        case 13:
          msg = "Values like null or undefined are not allowed for items in repeated fields";
          break;
        default:
          msg = `Unknown error code: ${this.errorCode}`;
          break;
      }
      return `Schema ${schemaId} on field "${key}": ${msg}`;
    }
  }
  class LogValidator {
    validate(schema, data, noThrow = false) {
      const schemaTokens = schemaUtil.checkSchema(schema);
      utility.requireArgument(data, "data", "object");
      const schemaId = schemaUtil.getSchemaId(schema);
      const errorInfos = new Array();
      const nestedSchema = schemaUtil.getTypes(schema);
      this._validateFields(errorInfos, [], data, nestedSchema[schemaTokens.message], nestedSchema, schemaId);
      if (errorInfos.length && !noThrow) {
        throw new Error(errorInfos[0].asMessage(schemaId));
      }
      return errorInfos;
    }
    _validateFields(errorInfos, fieldNames, data, message, descriptor, schemaId) {
      const oneofs = message.oneofs || {};
      const fields = message.fields || {};
      for (const key in data) {
        const value = data[key];
        if (value !== void 0 && value !== null) {
          const mft = (fieldType, isRepeated, isItem) => this._matchFieldTypes(errorInfos, [...fieldNames, key], value, fieldType, descriptor, schemaId, key, isRepeated, isItem);
          if (oneofs[key]) {
            mft(fields[oneofs[key].oneof[0]].type);
          } else if (fields[key]) {
            mft(fields[key].type, fields[key].rule === "repeated");
          }
        }
      }
    }
    _matchFieldTypes(errorInfos, fieldNames, fieldDataValue, protobufType, descriptor, schemaId, key, isRepeated, isItem) {
      let errorCode;
      if (isRepeated) {
        if (Array.isArray(fieldDataValue)) {
          if (fieldDataValue.length > maxItemCountAppLimit) {
            errorCode = 7;
          }
          fieldDataValue.forEach((value, index2) => {
            this._matchFieldTypes(errorInfos, [...fieldNames, index2.toString()], value, protobufType, descriptor, schemaId, key, void 0, true);
          });
        } else {
          errorCode = 1;
        }
      } else if (fieldDataValue == null || fieldDataValue === void 0) {
        if (isItem) {
          errorCode = 13;
        }
      } else {
        let numOpts;
        let javaScriptType;
        switch (protobufType) {
          case "string":
            javaScriptType = "string";
            if (fieldDataValue.length > maxStringLengthAppLimit) {
              errorCode = 6;
            }
            break;
          case "bytes":
            javaScriptType = "object";
            if (!(fieldDataValue instanceof Uint8Array)) {
              errorCode = 5;
            }
            break;
          case "bool":
            javaScriptType = "boolean";
            break;
          case "uint32":
            javaScriptType = "number";
            numOpts = {
              min: minUnsigned,
              max: maxFourBytesUnsigned,
              isInt: true,
              isItem
            };
            break;
          case "int32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            javaScriptType = "number";
            numOpts = {
              min: minFourBytes,
              max: maxFourBytes,
              isInt: true,
              isItem
            };
            break;
          case "uint64":
            javaScriptType = "number";
            numOpts = {
              min: minUnsigned,
              max: maxEightBytesUnsigned,
              isInt: true,
              isItem
            };
            break;
          case "fixed64":
          case "sfixed64":
          case "int64":
          case "sint64":
            javaScriptType = "number";
            numOpts = {
              min: minEightBytes,
              max: maxEightBytes,
              isInt: true,
              isItem
            };
            break;
          case "double":
          case "float":
            javaScriptType = "number";
            numOpts = {
              min: Number.NEGATIVE_INFINITY,
              max: Number.POSITIVE_INFINITY,
              isInt: false,
              isItem
            };
            break;
          default:
            if (new Set(Object.keys(descriptor)).has(protobufType)) {
              this._validateFields(errorInfos, fieldNames, fieldDataValue, descriptor[protobufType], descriptor, schemaId);
              javaScriptType = "object";
            }
            break;
        }
        if (typeof fieldDataValue !== javaScriptType) {
          errorInfos.push(new ValidationEntry(2, fieldNames, protobufType, typeof fieldDataValue));
        } else if (numOpts) {
          if (numOpts.isInt && !Number.isFinite(fieldDataValue)) {
            errorCode = 3;
          } else if (numOpts.isInt && !Number.isInteger(fieldDataValue)) {
            errorCode = 12;
          } else if (!(!numOpts.isInt && Number.isNaN(fieldDataValue)) && !(fieldDataValue >= numOpts.min && fieldDataValue <= numOpts.max)) {
            errorCode = 4;
          }
        }
      }
      if (errorCode) {
        errorInfos.push(new ValidationEntry(errorCode, fieldNames));
      }
    }
  }
  const logValidator = new LogValidator();
  class BucketHistogramImpl {
    constructor(_name, _ownerName, _ownerAppName, _tags, _buckets) {
      this._name = _name;
      this._ownerName = _ownerName;
      this._ownerAppName = _ownerAppName;
      this._tags = _tags;
      this._buckets = _buckets;
      this._values = new Array();
      this._createdOn = utility.time().tsNow;
    }
    getName() {
      return this._name;
    }
    getCreatedOn() {
      return this._createdOn;
    }
    getLastUpdatedOn() {
      return this._lastUpdatedOn;
    }
    getData() {
      return this.values;
    }
    getBuckets() {
      return this.buckets;
    }
    get buckets() {
      return this._buckets.slice(0, this._buckets.length);
    }
    get values() {
      return this._values.slice(0, this._values.length);
    }
    record(value) {
      if (typeof value === "number") {
        this._values.push(value);
        this._lastUpdatedOn = utility.time().tsNow;
        return;
      }
      throw new Error("BucketHistogram can only record numbers.");
    }
    reset() {
      this._lastUpdatedOn = void 0;
      this._values = [];
    }
    getOwnerName() {
      return this._ownerName;
    }
    getOwnerAppName() {
      return this._ownerAppName;
    }
    getTags() {
      return this._tags;
    }
  }
  class UpCounterImpl {
    constructor(_name, _ownerName, _ownerAppName, _tags) {
      this._name = _name;
      this._ownerName = _ownerName;
      this._ownerAppName = _ownerAppName;
      this._tags = _tags;
      this._value = 0;
      this._createdOn = utility.time().tsNow;
    }
    getName() {
      return this._name;
    }
    getCreatedOn() {
      return this._createdOn;
    }
    getLastUpdatedOn() {
      return this._lastUpdatedOn;
    }
    getData() {
      return this._value;
    }
    increment(value = 1) {
      if (typeof value === "number" && value > 0) {
        this._value += Math.round(value);
        this._lastUpdatedOn = utility.time().tsNow;
        return;
      }
      throw new Error("UpCounter can only increment positive numbers.");
    }
    reset() {
      this._lastUpdatedOn = void 0;
      this._value = 0;
    }
    getOwnerName() {
      return this._ownerName;
    }
    getOwnerAppName() {
      return this._ownerAppName;
    }
    getTags() {
      return this._tags;
    }
  }
  class ValueRecorderImpl {
    constructor(_name, _ownerName, _ownerAppName, _tags) {
      this._name = _name;
      this._ownerName = _ownerName;
      this._ownerAppName = _ownerAppName;
      this._tags = _tags;
      this._values = new Array();
      this._createdOn = utility.time().tsNow;
    }
    getName() {
      return this._name;
    }
    getCreatedOn() {
      return this._createdOn;
    }
    getLastUpdatedOn() {
      return this._lastUpdatedOn;
    }
    getData() {
      return this.values;
    }
    get values() {
      return this._values.slice(0, this._values.length);
    }
    record(value) {
      if (typeof value === "number") {
        this._values.push(value);
        this._lastUpdatedOn = utility.time().tsNow;
        return;
      }
      throw new Error("ValueRecorder can only record numbers.");
    }
    reset() {
      this._lastUpdatedOn = void 0;
      this._values = [];
    }
    getOwnerName() {
      return this._ownerName;
    }
    getOwnerAppName() {
      return this._ownerAppName;
    }
    getTags() {
      return this._tags;
    }
  }
  class SizeLimitedMap {
    constructor(maxSize) {
      this._map = new Map();
      if (typeof maxSize === "number" && maxSize > 0) {
        this._maxSize = Math.ceil(maxSize);
        return;
      }
      throw new Error("maxSize must be a positive number");
    }
    get maxSize() {
      return this._maxSize;
    }
    get(key) {
      return this._map.get(key);
    }
    has(key) {
      return this._map.has(key);
    }
    set(key, value) {
      if (this.has(key) || this._map.size < this.maxSize) {
        this._map.set(key, value);
        return true;
      }
      return false;
    }
    getElements() {
      return Array.from(this._map.values());
    }
    clear() {
      this._map.clear();
    }
  }
  const maxCounters = 1e3;
  const maxValueRecorders = 500;
  const maxBucketHistograms = 500;
  var MetricType;
  (function(MetricType2) {
    MetricType2[MetricType2["Counter"] = 0] = "Counter";
    MetricType2[MetricType2["Percentile"] = 1] = "Percentile";
    MetricType2[MetricType2["BucketHistogram"] = 2] = "BucketHistogram";
  })(MetricType || (MetricType = {}));
  class MetricsImpl {
    constructor(_ownerName, _getOwnerAppName) {
      this._ownerName = _ownerName;
      this._getOwnerAppName = _getOwnerAppName;
      this._upCounters = new SizeLimitedMap(maxCounters);
      this._valueRecorders = new SizeLimitedMap(maxValueRecorders);
      this._bucketHistograms = new SizeLimitedMap(maxBucketHistograms);
    }
    incrementCounter(operation, increment, hasError = false, tags = {}) {
      this._tagError(tags, hasError);
      this._upCounter(operation, tags).increment(increment);
    }
    trackValue(operation, value, hasError = false, tags = {}) {
      this._tagError(tags, hasError);
      this._valueRecorder(operation, tags).record(value);
    }
    bucketValue(operation, value, buckets, hasError = false, tags = {}) {
      this._tagError(tags, hasError);
      this._bucketHistogram(operation, tags, buckets).record(value);
    }
    _bucketHistogram(name, tags, buckets) {
      const {
        key,
        sortedTags
      } = this._getKeyAndSortedTags(name, tags, MetricType.BucketHistogram);
      let instrument = this._bucketHistograms.get(key);
      if (!instrument) {
        instrument = new BucketHistogramImpl(name, this._ownerName, this._getOwnerAppName(), sortedTags, buckets);
        if (!this._bucketHistograms.set(key, instrument)) {
          throw new Error(`Max size of ${maxBucketHistograms} exceeded for BucketHistograms`);
        }
      }
      return instrument;
    }
    _upCounter(name, tags) {
      const {
        key,
        sortedTags
      } = this._getKeyAndSortedTags(name, tags, MetricType.Counter);
      let instrument = this._upCounters.get(key);
      if (!instrument) {
        instrument = new UpCounterImpl(name, this._ownerName, this._getOwnerAppName(), sortedTags);
        if (!this._upCounters.set(key, instrument)) {
          throw new Error(`Max size of ${maxCounters} exceeded for UpCounters`);
        }
      }
      return instrument;
    }
    _valueRecorder(name, tags) {
      const {
        key,
        sortedTags
      } = this._getKeyAndSortedTags(name, tags, MetricType.Percentile);
      let instrument = this._valueRecorders.get(key);
      if (!instrument) {
        instrument = new ValueRecorderImpl(name, this._ownerName, this._getOwnerAppName(), sortedTags);
        if (!this._valueRecorders.set(key, instrument)) {
          throw new Error(`Max size of ${maxValueRecorders} exceeded for ValueRecorders`);
        }
      }
      return instrument;
    }
    getUpCounters() {
      return this._upCounters.getElements();
    }
    getValueRecorders() {
      return this._valueRecorders.getElements();
    }
    getBucketHistograms() {
      return this._bucketHistograms.getElements();
    }
    _tagError(tags, hasError) {
      tags.status = hasError === true ? "error" : "success";
    }
    _getKeyAndSortedTags(operation, tags, metricType) {
      const sortedTags = Object.keys(tags).sort().reduce((prev, curr) => {
        prev[curr] = tags[curr];
        return prev;
      }, {});
      const key = `${MetricType[metricType]}:${operation}${JSON.stringify(sortedTags)}`;
      return {
        key,
        sortedTags
      };
    }
  }
  class MockBase {
    constructor() {
      this.isMock = true;
    }
  }
  const maxActivityDurationMsecs = void 0;
  const reservedMetricCharacters = ["`"];
  const reservedMetricNames = {
    internalError: "o11y-error"
  };
  const denyListMetricNames = Object.freeze(Array.from(Object.values(reservedMetricNames)));
  class InstrumentationImpl {
    constructor(_nextGen, _name) {
      this._nextGen = _nextGen;
      this._name = _name;
      this._onActivityStoppedCallback = this._handleActivityStop.bind(this);
      this._onActivityErrorCallback = this._handleActivityError.bind(this);
      for (const reservedChar of reservedMetricCharacters) {
        if (this._name.indexOf(reservedChar) >= 0) {
          throw new Error(`Name cannot include the reserved character "${reservedChar}"`);
        }
      }
      this._safety = new PublicSafety({
        increment: (increment) => this._incrementError(increment)
      });
      this._metrics = this._initMetrics();
      const simpleTextOptions = schemaUtil.getOptions(simple, "Simple", "text");
      this._simpleTextMaxLength = simpleTextOptions ? simpleTextOptions["(meta.max_length)"] : maxStringLengthAppLimit;
    }
    _initMetrics() {
      return new MetricsImpl(this.name, () => this._nextGen.appName || InstrumentationImpl.defaultAppName);
    }
    _incrementError(increment = 1) {
      this._metrics.incrementCounter(reservedMetricNames.internalError, increment, false);
    }
    get name() {
      return this._name;
    }
    _wrapUserPayload(userSchemaOrText, userData, onlyIfBoth = false) {
      let userSchema;
      if (typeof userSchemaOrText === "string") {
        userSchema = simple;
        if (userSchemaOrText) {
          userData = {
            text: userSchemaOrText.substring(0, this._simpleTextMaxLength)
          };
        } else {
          userData = void 0;
        }
      } else {
        userSchema = userSchemaOrText;
      }
      return schemaUtil.makePayload(userSchema, userData, onlyIfBoth);
    }
    _getEffectiveRootId(options) {
      var _a, _b;
      return (_b = (_a = options === null || options === void 0 ? void 0 : options.instrumentationContext) === null || _a === void 0 ? void 0 : _a.rootId) !== null && _b !== void 0 ? _b : this._nextGen.getDefaultInstrumentationContext().rootId;
    }
    log(userSchemaOrText, userData, options) {
      this._safety.tryCatch(() => {
        const timestamp = utility.time().tsNow;
        utility.requireArgument(userSchemaOrText, "userSchemaOrText", ["object", "string"]);
        utility.requireArgumentIfDefined(userData, "userData", "object");
        utility.requireArgumentIfDefined(options, "options", "object");
        const userPayload = this._wrapUserPayload(userSchemaOrText, userData);
        if (userPayload === null || userPayload === void 0 ? void 0 : userPayload.payload) {
          this._logInternal(this.name, userPayload.schema, userPayload.payload, timestamp, this._getEffectiveRootId(options));
        }
      });
    }
    _logInternal(loggerName, schema, data, timestamp, rootId2) {
      this._checkInputs(schema, data);
      const appPayload = this._getPayloadFromProvider(this._nextGen.appPayloadProvider);
      const pagePayload = this._getPayloadFromProvider(this._nextGen.pagePayloadProvider);
      return this._nextGen.addLog(loggerName, schema, data, timestamp, rootId2, pagePayload, appPayload);
    }
    error(error2, userSchemaOrText, userData, options) {
      return this._safety.tryCatch(() => {
        utility.requireArgumentIfDefined(userSchemaOrText, "userSchemaOrText", ["object", "string"]);
        utility.requireArgumentIfDefined(userData, "userData", "object");
        utility.requireArgumentIfDefined(options, "options", "object");
        const rootId2 = this._getEffectiveRootId(options);
        this._errorInternal(error2, userSchemaOrText, userData, void 0, rootId2);
      });
    }
    _errorInternal(err, userSchemaOrText, userData, activityId, rootActivityId) {
      const loggedTimestamp = utility.time().tsNow;
      let error$1;
      if (err instanceof Error) {
        error$1 = err;
      } else {
        let msg;
        if (err === void 0 || err === null || typeof err.toString !== "function") {
          msg = "UNKNOWN";
        } else {
          msg = err.toString();
        }
        error$1 = new Error(msg);
      }
      const userPayload = this._wrapUserPayload(userSchemaOrText, userData, true);
      const errorData = {
        name: error$1.name,
        message: error$1.message,
        stack: error$1.stack,
        userPayload,
        activityId
      };
      return this._logInternal(this.name, error, errorData, loggedTimestamp, rootActivityId);
    }
    startActivity(name, options) {
      return this._safety.tryCatchReturn(() => {
        var _a;
        utility.requireArgument(name, "name");
        utility.requireArgumentIfDefined(options, "options", "object");
        let context;
        const rootId2 = (_a = options === null || options === void 0 ? void 0 : options.instrumentationContext) === null || _a === void 0 ? void 0 : _a.rootId;
        if (rootId2) {
          context = {
            rootId: rootId2,
            isRootActivitySampled: options.instrumentationContext.isRootActivitySampled
          };
        } else {
          context = this._nextGen.getDefaultInstrumentationContext();
        }
        const activity2 = new ActivityImpl(name, context.rootId, this._onActivityStoppedCallback, this._onActivityErrorCallback, maxActivityDurationMsecs, void 0, context.isRootActivitySampled);
        return activity2;
      }, activityNoOp);
    }
    _getActivityData(detail) {
      const userPayload = this._wrapUserPayload(detail.userSchemaOrText, detail.userData, true);
      return {
        id: detail.id,
        name: detail.name,
        duration: detail.stopPerfTime - detail.startPerfTime,
        stopReason: detail.stopReason,
        userPayload,
        errorCount: detail.errorCount,
        isSampled: detail.isSampled,
        timerOverridden: detail.timerOverridden
      };
    }
    _handleActivityStop(detail) {
      if (detail.stopReason === discarded) {
        return;
      }
      const activityData = this._getActivityData(detail);
      this._logActivity(activityData, detail.startTimestamp, detail.rootId);
    }
    _logActivity(activityData, startTimestamp, rootId2) {
      this._logInternal(this.name, activity, activityData, startTimestamp, rootId2);
    }
    _handleActivityError(error2, detail) {
      this._errorInternal(error2, detail.userSchemaOrText, detail.userData, detail.id, detail.rootId);
    }
    _getPayloadFromProvider(provider) {
      const payload = (provider === null || provider === void 0 ? void 0 : provider.getPayload()) || void 0;
      if (payload) {
        this._checkInputs(payload.schema, payload.payload);
      }
      return payload;
    }
    domEvent(event, handledBy, userSchemaOrText, userData, options) {
      this._safety.tryCatch(() => {
        var _a;
        const tsNow = utility.time().tsNow;
        utility.requireArgument(event, "event", [Event, MockBase]);
        utility.requireArgument(handledBy, "handledBy", [HTMLElement, "object"]);
        let htmlElement;
        if (handledBy instanceof HTMLElement) {
          htmlElement = handledBy;
        } else {
          handledBy = handledBy;
          if (((_a = handledBy.template) === null || _a === void 0 ? void 0 : _a.host) instanceof HTMLElement) {
            htmlElement = handledBy.template.host;
          } else {
            utility.requireArgument(void 0, "handledBy");
          }
        }
        const userPayload = this._wrapUserPayload(userSchemaOrText, userData, true);
        const rootId2 = this._getEffectiveRootId(options);
        switch (event.type) {
          case "click": {
            const mouseEvent = event;
            const acd = this._nextGen.getClickTracker();
            if (acd) {
              acd.markEventHandled(mouseEvent);
            }
            const mouseEventData = domEventHelpers.getMouseEventData(mouseEvent);
            const instrumentedEvent = domEventHelpers.getInstrumentedEventData(mouseEventData, htmlElement, userPayload);
            instrumentedEvent.auto = options === null || options === void 0 ? void 0 : options._auto;
            this._logInternal(this.name, instrumented_event, instrumentedEvent, tsNow, rootId2);
            break;
          }
          default:
            throw new Error(utility.notImplemented);
        }
      });
    }
    incrementCounter(operation, increment = 1, hasError = false, tags = {}) {
      this._safety.tryCatch(() => {
        utility.requireArgument(operation, "operation", "string");
        utility.checkForDenyListedValues(operation, "operation", denyListMetricNames);
        utility.checkForReservedCharacters(operation, "operation", reservedMetricCharacters);
        utility.requireArgument(increment, "increment", "number");
        utility.requireArgument(hasError, "hasError", "boolean");
        utility.requireArgument(tags, "tags", "object");
        Object.entries(tags).forEach((entry) => {
          utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, ["string", "number", "boolean"]);
        });
        this._metrics.incrementCounter(operation, increment, hasError, tags);
      });
    }
    trackValue(operation, value, hasError = false, tags = {}) {
      this._safety.tryCatch(() => {
        utility.requireArgument(operation, "operation", "string");
        utility.checkForDenyListedValues(operation, "operation", denyListMetricNames);
        utility.checkForReservedCharacters(operation, "operation", reservedMetricCharacters);
        utility.requireArgument(value, "value", "number");
        utility.requireArgument(hasError, "hasError", "boolean");
        utility.requireArgument(tags, "tags", "object");
        Object.entries(tags).forEach((entry) => {
          utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, ["string", "number", "boolean"]);
        });
        this._metrics.trackValue(operation, value, hasError, tags);
      });
    }
    bucketValue(operation, value, buckets = [], hasError = false, tags = {}) {
      this._safety.tryCatch(() => {
        utility.requireArgument(operation, "operation", "string");
        utility.checkForDenyListedValues(operation, "operation", denyListMetricNames);
        utility.checkForReservedCharacters(operation, "operation", reservedMetricCharacters);
        utility.requireArgument(value, "value", "number");
        utility.requireArgument(buckets, "buckets", Array);
        Object.entries(buckets).forEach((entry) => {
          utility.requireArgument(entry[1], `Bucket value for '${entry[0]}'`, "number");
        });
        utility.requireArgument(hasError, "hasError", "boolean");
        utility.requireArgument(tags, "tags", "object");
        Object.entries(tags).forEach((entry) => {
          utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, ["string", "number", "boolean"]);
        });
        this._metrics.bucketValue(operation, value, buckets, hasError, tags);
      });
    }
    _checkInputs(schema, data) {
      schemaUtil.checkSchema(schema);
      utility.requireArgument(data, "data", "object");
      let vEntries;
      let savedUserPayload;
      if (data.userPayload !== void 0 && schemaUtil.isInternal(schema)) {
        savedUserPayload = data.userPayload;
        vEntries = logValidator.validate(savedUserPayload.schema, savedUserPayload.payload, true);
        this._processValidationResults(schemaUtil.getSchemaId(savedUserPayload.schema), savedUserPayload.payload, vEntries);
        data.userPayload = void 0;
      }
      vEntries = logValidator.validate(schema, data, true);
      this._processValidationResults(schemaUtil.getSchemaId(schema), data, vEntries);
      if (savedUserPayload !== void 0) {
        data.userPayload = savedUserPayload;
      }
    }
    _processValidationResults(schemaId, data, ventries) {
      for (let i2 = 0; i2 < ventries.length; i2 += 1) {
        const ei = ventries[i2];
        if (ei.errorCode == 6 || ei.errorCode == 7) {
          const lfi = ei.fields.length - 1;
          const obj = this._traverseFields(data, ei.fields.slice(0, lfi));
          const field = ei.fields[lfi];
          if (ei.errorCode == 6) {
            obj[field] = obj[field].substring(0, maxStringLengthAppLimit);
          } else {
            obj[field].splice(maxItemCountAppLimit);
          }
        } else {
          throw new Error(ei.asMessage(schemaId));
        }
      }
    }
    _traverseFields(data, fields) {
      if (!fields.length) {
        return data;
      }
      return this._traverseFields(data[fields[0]], fields.slice(1));
    }
    getUpCounters() {
      return this._metrics.getUpCounters().filter((m2) => m2.getLastUpdatedOn());
    }
    getValueRecorders() {
      return this._metrics.getValueRecorders().filter((m2) => m2.getLastUpdatedOn());
    }
    getBucketHistograms() {
      return this._metrics.getBucketHistograms().filter((m2) => m2.getLastUpdatedOn());
    }
    registerForLogPrompt(listener) {
      utility.requireArgument(listener, "listener", "function");
      this._nextGen.registerForLogPrompt(listener);
    }
    activity(name, execute, options) {
      var _a, _b, _c, _d;
      const act = this.startActivity(name, options);
      try {
        return execute(act);
      } catch (err) {
        act.error(err, (_a = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _a === void 0 ? void 0 : _a.schema, (_b = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _b === void 0 ? void 0 : _b.payload);
        throw err;
      } finally {
        act.stop((_c = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _c === void 0 ? void 0 : _c.schema, (_d = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _d === void 0 ? void 0 : _d.payload);
      }
    }
    async activityAsync(name, execute, options) {
      var _a, _b, _c, _d;
      const act = this.startActivity(name, options);
      try {
        return await execute(act);
      } catch (err) {
        act.error(err, (_a = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _a === void 0 ? void 0 : _a.schema, (_b = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _b === void 0 ? void 0 : _b.payload);
        throw err;
      } finally {
        act.stop((_c = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _c === void 0 ? void 0 : _c.schema, (_d = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _d === void 0 ? void 0 : _d.payload);
      }
    }
  }
  InstrumentationImpl.defaultAppName = "APP_NOT_REGISTERED";
  class RootActivityImpl extends ActivityImpl {
    constructor(name, onStopped, onError, rootId2, _isSampled) {
      super(name, void 0, onStopped, onError, void 0, rootId2 || utility.generateUniqueId(32), _isSampled);
    }
    get preRootId() {
      return this._preRootId;
    }
    set preRootId(value) {
      this._preRootId = value;
    }
    _getDetail(userSchema, userData) {
      const detail = super._getDetail(userSchema, userData);
      detail.isRoot = true;
      detail.preRootId = this.preRootId;
      return detail;
    }
  }
  const rootId = new Array(32).fill(0).join("");
  class RootActivityNoOp {
    getId() {
      return rootId;
    }
    getRootId() {
      return void 0;
    }
    error() {
    }
    stop() {
    }
    discard() {
    }
    terminate() {
    }
    getIsSampled() {
      return false;
    }
    getTraceHeaders(__options) {
      return {};
    }
    getStartTimestamp() {
      return void 0;
    }
    getStartPerfTime() {
      return void 0;
    }
    getStopPerfTime() {
      return void 0;
    }
  }
  const rootActivityNoOp = Object.freeze(new RootActivityNoOp());
  class AppInstrumentationImpl extends InstrumentationImpl {
    constructor(_nextGen, _name, _allowMulti) {
      super(_nextGen, _name);
      this._allowMulti = _allowMulti;
      this._onRootActivityStoppedCallback = this._handleRootActivityStop.bind(this);
    }
    startRootActivity(name, rootId2, isSampled) {
      return this._safety.tryCatchReturn(() => {
        utility.requireArgument(name, "name");
        const newRootActivity = new RootActivityImpl(name, this._onRootActivityStoppedCallback, this._onActivityErrorCallback, rootId2, isSampled);
        if (!this._allowMulti) {
          if (this._singleRootActivity && !this._singleRootActivity.isStopped) {
            const preRootId = this._singleRootActivity.getId();
            this._singleRootActivity.terminate();
            newRootActivity.preRootId = preRootId;
          }
          this._singleRootActivity = newRootActivity;
        }
        return newRootActivity;
      }, rootActivityNoOp);
    }
    _handleRootActivityStop(detail) {
      if (detail.stopReason === discarded) {
        return;
      }
      const activityData = this._getActivityData(detail);
      this._logActivity(activityData, detail.startTimestamp);
      this._singleRootActivity = void 0;
    }
    _getActivityData(detail) {
      const activityData = super._getActivityData(detail);
      activityData.isRoot = detail.isRoot;
      activityData.preRootId = detail.preRootId;
      return activityData;
    }
    getSingleRootActivityId() {
      var _a;
      return (_a = this._singleRootActivity) === null || _a === void 0 ? void 0 : _a.getId();
    }
    isSingleRootActivitySampled() {
      var _a;
      return (_a = this._singleRootActivity) === null || _a === void 0 ? void 0 : _a.getIsSampled();
    }
    _initMetrics() {
      return new MetricsImpl(this.name, () => this.name);
    }
  }
  const pathLimit = 5;
  class AutomaticClickTracker {
    constructor(_instr, _doc) {
      this._instr = _instr;
      this._doc = _doc;
      this._isActive = false;
      this._boundClickListener = this._clickListener.bind(this);
      utility.requireArgument(_instr, "_instr");
      utility.requireArgument(_doc, "_doc");
    }
    activate() {
      if (!this._isActive) {
        this._doc.addEventListener("click", this._boundClickListener, true);
        this._isActive = true;
      }
    }
    deactivate() {
      if (this._isActive) {
        this._doc.removeEventListener("click", this._boundClickListener, true);
        this._isActive = false;
      }
    }
    markEventHandled(event) {
      this._ignoredEvent = event;
    }
    _clickListener(event) {
      var _a;
      let eventTargets = (_a = event.composedPath) === null || _a === void 0 ? void 0 : _a.call(event);
      if (!eventTargets || !eventTargets.length) {
        eventTargets = event.path;
      }
      const handledBy = this._getClickableElement(eventTargets);
      if (handledBy) {
        setTimeout(() => {
          if (event !== this._ignoredEvent) {
            this._instr.domEvent(event, handledBy, void 0, void 0, {
              _auto: true
            });
          }
        });
      }
    }
    _getClickableElement(path) {
      var _a, _b;
      const limit = path ? Math.min(path.length, pathLimit) : 0;
      for (let x = 0; x < limit; x += 1) {
        const currentElement = path[x];
        const tagName = (_a = currentElement.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (tagName === "a" || tagName === "button") {
          return currentElement;
        }
        if (tagName === "input") {
          const inputElement = currentElement;
          if (((_b = inputElement.type) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === "button") {
            return inputElement;
          }
        }
      }
      return void 0;
    }
  }
  const maxInstrumentationLength = 80;
  const truncatedText = "_CUT";
  const maxInstrumentationLengthBeforeTruncated = maxInstrumentationLength - truncatedText.length;
  class NextgenImpl {
    get pagePayloadProvider() {
      return this._pagePayloadProvider;
    }
    set pagePayloadProvider(provider) {
      this._pagePayloadProvider = provider;
    }
    get appPayloadProvider() {
      return this._appPayloadProvider;
    }
    set appPayloadProvider(provider) {
      this._appPayloadProvider = provider;
    }
    constructor(_idleDetector) {
      this._idleDetector = _idleDetector;
      this._logCollectors = new Set();
      this._instruments = new Map();
      this._seqBySchema = new Map();
      this._sequence = 0;
      this._forceDisabledLogCollectors = new Set();
      this._logCollectorFailures = new Map();
      this._isBufferingEnabled = false;
      this._buffer = [];
      this._logCollectionListeners = new Set();
    }
    registerApp(name, options) {
      var _a;
      utility.requireArgument(name, "name", "string");
      if (this._appInstr) {
        throw new Error("An app has already been registered with instrumentation.");
      }
      const instr = this._instruments.get(name);
      if (instr) {
        throw new Error(`The instrumentation name ${name} is already taken`);
      }
      this._clientSessionId = ((_a = options === null || options === void 0 ? void 0 : options.clientSessionId) === null || _a === void 0 ? void 0 : _a.toString()) || utility.generateUniqueId();
      this._appInstr = new AppInstrumentationImpl(this, name, options === null || options === void 0 ? void 0 : options.allowMultipleRootActivities);
      this._instruments.set(name, this._appInstr);
      this._isBufferingEnabled = options === null || options === void 0 ? void 0 : options.enableBuffering;
      const tracing = new Tracing(this.getInstrumentation("Network"), this._idleDetector);
      return {
        log: this._appInstr.log.bind(this._appInstr),
        error: this._appInstr.error.bind(this._appInstr),
        startActivity: this._appInstr.startActivity.bind(this._appInstr),
        domEvent: this._appInstr.domEvent.bind(this._appInstr),
        incrementCounter: this._appInstr.incrementCounter.bind(this._appInstr),
        trackValue: this._appInstr.trackValue.bind(this._appInstr),
        bucketValue: this._appInstr.bucketValue.bind(this._appInstr),
        networkInstrumentation: tracing.networkInstrumentation.bind(tracing),
        registerForLogPrompt: this._appInstr.registerForLogPrompt.bind(this._appInstr),
        activity: this._appInstr.activity.bind(this._appInstr),
        activityAsync: this._appInstr.activityAsync.bind(this._appInstr),
        startRootActivity: this._appInstr.startRootActivity.bind(this._appInstr),
        registerLogCollector: this.registerLogCollector.bind(this),
        registerMetricsCollector: this.registerMetricsCollector.bind(this),
        activateClickTracker: this.activateClickTracker.bind(this),
        deactivateClickTracker: this.deactivateClickTracker.bind(this),
        disableBuffering: this.disableBuffering.bind(this),
        promptLogCollection: this.promptLogCollection.bind(this),
        getClientSessionId: this.getClientSessionId.bind(this)
      };
    }
    getInstrumentation(name) {
      utility.requireArgument(name, "name", "string");
      if (name.length > maxInstrumentationLength) {
        name = name.substr(0, maxInstrumentationLengthBeforeTruncated) + truncatedText;
      }
      let instr = this._instruments.get(name);
      if (!instr) {
        instr = new InstrumentationImpl(this, name);
        this._instruments.set(name, instr);
      } else if (instr === this._appInstr) {
        throw new Error(`The instrumentation name ${name} is being used by the app.`);
      }
      return instr;
    }
    get appName() {
      var _a;
      return (_a = this._appInstr) === null || _a === void 0 ? void 0 : _a.name;
    }
    addLog(loggerName, schema, data, timestamp, rootId2, pagePayload, appPayload) {
      this._sequence += 1;
      const userSchema = schemaUtil.isInternal(schema) && (data === null || data === void 0 ? void 0 : data.userPayload) ? data.userPayload.schema : schema;
      const schemaId = schemaUtil.getSchemaId(userSchema);
      let schemaSequence = this._seqBySchema.get(schemaId) || 0;
      schemaSequence += 1;
      this._seqBySchema.set(schemaId, schemaSequence);
      const logMeta = {
        timestamp,
        rootId: rootId2,
        sequence: this._sequence,
        schemaSequence,
        loggerName,
        pagePayload: pagePayload ? utility.clone(pagePayload) : void 0,
        appPayload: appPayload ? utility.clone(appPayload) : void 0,
        loggerAppName: this.appName,
        connectionType: utility.getConnectionType(),
        clientSessionId: this._clientSessionId
      };
      if (this._isBufferingEnabled) {
        this._buffer.push({
          schema,
          data: utility.clone(data),
          logMeta
        });
      }
      const eligibleCollectors = Array.from(this._logCollectors).filter((collector) => {
        var _a;
        return !this._forceDisabledLogCollectors.has(collector) && !((_a = collector.getIsCollectDisabled) === null || _a === void 0 ? void 0 : _a.call(collector));
      });
      if (eligibleCollectors.length > 0) {
        for (const collector of eligibleCollectors) {
          const dataClone = utility.clone(data);
          let failures = this._logCollectorFailures.get(collector) || 0;
          try {
            collector.collect(schema, dataClone, logMeta);
            if (failures > 0) {
              this._logCollectorFailures.set(collector, failures - 1);
            }
          } catch (err) {
            failures += 1;
            if (failures >= NextgenImpl._collectorFailureLimit) {
              this._forceDisabledLogCollectors.add(collector);
              if (this._appInstr && (typeof err === "string" || err instanceof Error)) {
                this._appInstr.error(err);
              }
            } else {
              this._logCollectorFailures.set(collector, failures);
            }
          }
        }
      }
      return this._sequence;
    }
    getBuffer() {
      return this._buffer;
    }
    disableBuffering() {
      this._isBufferingEnabled = false;
      this._buffer = [];
    }
    getClickTracker() {
      return this._autoClickTracker;
    }
    getDefaultInstrumentationContext() {
      var _a, _b;
      return {
        rootId: (_a = this._appInstr) === null || _a === void 0 ? void 0 : _a.getSingleRootActivityId(),
        isRootActivitySampled: (_b = this._appInstr) === null || _b === void 0 ? void 0 : _b.isSingleRootActivitySampled()
      };
    }
    activateClickTracker() {
      if (typeof document !== "undefined") {
        if (!this._autoClickTracker) {
          this._autoClickTracker = new AutomaticClickTracker(this._appInstr, document);
        }
        this._autoClickTracker.activate();
      }
    }
    deactivateClickTracker() {
      if (this._autoClickTracker) {
        this._autoClickTracker.deactivate();
        this._autoClickTracker = void 0;
      }
    }
    registerLogCollector(collector, options) {
      utility.requireArgument(collector, "collector");
      if (this._logCollectors.has(collector)) {
        return;
      }
      this._logCollectors.add(collector);
      this._logCollectorFailures.set(collector, 0);
      if ((!collector.getIsCollectDisabled || !collector.getIsCollectDisabled()) && options && options.retroactive) {
        for (const log of this._buffer) {
          collector.collect(log.schema, log.data, log.logMeta);
        }
      }
    }
    registerMetricsCollector(collector) {
      utility.requireArgument(collector, "collector");
      if (this._metricsCollector) {
        throw new Error("A metrics Collector is already registered.");
      }
      this._metricsCollector = collector;
      this._metricsCollector.receiveMetricsExtractors({
        getAllUpCounters: this._getAllUpCounters.bind(this),
        getAllValueRecorders: this._getAllValueRecorders.bind(this),
        getAllBucketHistograms: this._getAllBucketHistograms.bind(this)
      });
    }
    _getAllUpCounters() {
      const arrOfArrs = Array.from(this._instruments.values()).map((instr) => instr.getUpCounters());
      return arrOfArrs.reduce((pv, cv) => pv.concat(cv), []);
    }
    _getAllValueRecorders() {
      const arrOfArrs = Array.from(this._instruments.values()).map((instr) => instr.getValueRecorders());
      return arrOfArrs.reduce((pv, cv) => pv.concat(cv), []);
    }
    _getAllBucketHistograms() {
      const arrOfArrs = Array.from(this._instruments.values()).map((instr) => instr.getBucketHistograms());
      return arrOfArrs.reduce((pv, cv) => pv.concat(cv), []);
    }
    registerForLogPrompt(listener) {
      this._logCollectionListeners.add(listener);
    }
    promptLogCollection(reason) {
      for (const listener of this._logCollectionListeners.keys()) {
        try {
          listener(reason);
        } catch (err) {
          if (!utility.isProduction) {
            throw err;
          }
        }
      }
    }
    getClientSessionId() {
      return this._clientSessionId;
    }
  }
  NextgenImpl._collectorFailureLimit = 5;
  class Index {
    get _lazyNextGen() {
      if (!this._nextgen) {
        this._nextgen = new NextgenImpl(this._idleDetector);
      }
      return this._nextgen;
    }
    constructor(_idleDetector) {
      this._idleDetector = _idleDetector;
      utility.requireArgument(_idleDetector, "_idleDetector");
    }
    registerInstrumentedApp(name, options) {
      if (!options || options.isProduction !== false) {
        utility.markProduction();
      }
      const retVal = this._lazyNextGen.registerApp(name, options);
      if (options) {
        this._nextgen.appPayloadProvider = options.appPayloadProvider;
        this._nextgen.pagePayloadProvider = options.pagePayloadProvider;
      }
      return retVal;
    }
    getInstrumentation(name) {
      return this._lazyNextGen.getInstrumentation(name);
    }
  }
  const time = utility.time.bind(utility);
  const bgColorMap = {
    Error: "Crimson",
    Activity: "CadetBlue",
    InstrumentedEvent: "DarkOliveGreen",
    O11ySample: "BlueViolet"
  };
  const colorMap = {
    Error: "white",
    Activity: "white",
    InstrumentedEvent: "white",
    O11ySample: "white"
  };
  const defaultColor = "black";
  const defaultBgColor = "Gainsboro";
  let ConsoleCollector$1 = class ConsoleCollector {
    constructor(environment) {
      if (environment) {
        this._log("ConsoleCollector", environment);
      }
    }
    collect(schema, data, logMeta) {
      let label, color, bgColor;
      if (schema.namespace === "sf.instrumentation") {
        label = schema.name;
        color = colorMap[schema.name] || defaultColor;
        bgColor = bgColorMap[schema.name] || defaultBgColor;
      } else {
        label = schemaUtil.getSchemaId(schema);
      }
      this._log(label, data, logMeta, color, bgColor);
    }
    _log(label, first, second, color = defaultColor, bgColor = defaultBgColor) {
      const css = `color:${color};background-color:${bgColor}`;
      console.log(`%cO11Y%c ${label}`, "color:white;background-color:#FF6600;font-weight:bold", css, first || "", second || "");
    }
  };
  const version$1 = "244.9.0";
  const idleDetector$1 = new IdleDetectorImpl({
    logThreshold: 300,
    reportListener: (report) => {
      idleDetectorInstr === null || idleDetectorInstr === void 0 ? void 0 : idleDetectorInstr.log(idle_detector_report, report);
    },
    errorListener: (e2, text) => {
      idleDetectorInstr === null || idleDetectorInstr === void 0 ? void 0 : idleDetectorInstr.error(e2, text);
    }
  });
  const index = new Index(idleDetector$1);
  const registerInstrumentedApp$1 = index.registerInstrumentedApp.bind(index);
  const getInstrumentation = index.getInstrumentation.bind(index);
  const idleDetectorInstr = getInstrumentation("IdleDetector");
  var o11yClient = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ConsoleCollector: ConsoleCollector$1,
    _version: version$1,
    getInstrumentation,
    idleDetector: idleDetector$1,
    registerInstrumentedApp: registerInstrumentedApp$1,
    time
  });
  const version = "244.39.0";
  const web_vitals = {
    namespace: "sf.instrumentation",
    name: "WebVitals",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            instrumentation: {
              nested: {
                WebVitals: {
                  fields: {
                    name: {
                      id: 1,
                      type: "string"
                    },
                    delta: {
                      id: 3,
                      type: "double"
                    },
                    value: {
                      id: 2,
                      type: "double"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  var e, t, n, i, r = function(e2, t2) {
    return {
      name: e2,
      value: t2 === void 0 ? -1 : t2,
      delta: 0,
      entries: [],
      id: "v2-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12)
    };
  }, a = function(e2, t2) {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(e2)) {
        if (e2 === "first-input" && !("PerformanceEventTiming" in self))
          return;
        var n2 = new PerformanceObserver(function(e3) {
          return e3.getEntries().map(t2);
        });
        return n2.observe({
          type: e2,
          buffered: true
        }), n2;
      }
    } catch (e3) {
    }
  }, o = function(e2, t2) {
    var n2 = function n3(i2) {
      i2.type !== "pagehide" && document.visibilityState !== "hidden" || (e2(i2), t2 && (removeEventListener("visibilitychange", n3, true), removeEventListener("pagehide", n3, true)));
    };
    addEventListener("visibilitychange", n2, true), addEventListener("pagehide", n2, true);
  }, u = function(e2) {
    addEventListener("pageshow", function(t2) {
      t2.persisted && e2(t2);
    }, true);
  }, c = function(e2, t2, n2) {
    var i2;
    return function(r2) {
      t2.value >= 0 && (r2 || n2) && (t2.delta = t2.value - (i2 || 0), (t2.delta || i2 === void 0) && (i2 = t2.value, e2(t2)));
    };
  }, f = -1, s = function() {
    return document.visibilityState === "hidden" ? 0 : 1 / 0;
  }, m = function() {
    o(function(e2) {
      var t2 = e2.timeStamp;
      f = t2;
    }, true);
  }, v = function() {
    return f < 0 && (f = s(), m(), u(function() {
      setTimeout(function() {
        f = s(), m();
      }, 0);
    })), {
      get firstHiddenTime() {
        return f;
      }
    };
  }, d = function(e2, t2) {
    var n2, i2 = v(), o2 = r("FCP"), f2 = function(e3) {
      e3.name === "first-contentful-paint" && (m2 && m2.disconnect(), e3.startTime < i2.firstHiddenTime && (o2.value = e3.startTime, o2.entries.push(e3), n2(true)));
    }, s2 = window.performance && performance.getEntriesByName && performance.getEntriesByName("first-contentful-paint")[0], m2 = s2 ? null : a("paint", f2);
    (s2 || m2) && (n2 = c(e2, o2, t2), s2 && f2(s2), u(function(i3) {
      o2 = r("FCP"), n2 = c(e2, o2, t2), requestAnimationFrame(function() {
        requestAnimationFrame(function() {
          o2.value = performance.now() - i3.timeStamp, n2(true);
        });
      });
    }));
  }, p = false, l = -1, h = function(e2, t2) {
    p || (d(function(e3) {
      l = e3.value;
    }), p = true);
    var n2, i2 = function(t3) {
      l > -1 && e2(t3);
    }, f2 = r("CLS", 0), s2 = 0, m2 = [], v2 = function(e3) {
      if (!e3.hadRecentInput) {
        var t3 = m2[0], i3 = m2[m2.length - 1];
        s2 && e3.startTime - i3.startTime < 1e3 && e3.startTime - t3.startTime < 5e3 ? (s2 += e3.value, m2.push(e3)) : (s2 = e3.value, m2 = [e3]), s2 > f2.value && (f2.value = s2, f2.entries = m2, n2());
      }
    }, h2 = a("layout-shift", v2);
    h2 && (n2 = c(i2, f2, t2), o(function() {
      h2.takeRecords().map(v2), n2(true);
    }), u(function() {
      s2 = 0, l = -1, f2 = r("CLS", 0), n2 = c(i2, f2, t2);
    }));
  }, T = {
    passive: true,
    capture: true
  }, y = new Date(), g = function(i2, r2) {
    e || (e = r2, t = i2, n = new Date(), w(removeEventListener), E());
  }, E = function() {
    if (t >= 0 && t < n - y) {
      var r2 = {
        entryType: "first-input",
        name: e.type,
        target: e.target,
        cancelable: e.cancelable,
        startTime: e.timeStamp,
        processingStart: e.timeStamp + t
      };
      i.forEach(function(e2) {
        e2(r2);
      }), i = [];
    }
  }, S = function(e2) {
    if (e2.cancelable) {
      var t2 = (e2.timeStamp > 1e12 ? new Date() : performance.now()) - e2.timeStamp;
      e2.type == "pointerdown" ? function(e3, t3) {
        var n2 = function() {
          g(e3, t3), r2();
        }, i2 = function() {
          r2();
        }, r2 = function() {
          removeEventListener("pointerup", n2, T), removeEventListener("pointercancel", i2, T);
        };
        addEventListener("pointerup", n2, T), addEventListener("pointercancel", i2, T);
      }(t2, e2) : g(t2, e2);
    }
  }, w = function(e2) {
    ["mousedown", "keydown", "touchstart", "pointerdown"].forEach(function(t2) {
      return e2(t2, S, T);
    });
  }, L = function(n2, f2) {
    var s2, m2 = v(), d2 = r("FID"), p2 = function(e2) {
      e2.startTime < m2.firstHiddenTime && (d2.value = e2.processingStart - e2.startTime, d2.entries.push(e2), s2(true));
    }, l2 = a("first-input", p2);
    s2 = c(n2, d2, f2), l2 && o(function() {
      l2.takeRecords().map(p2), l2.disconnect();
    }, true), l2 && u(function() {
      var a2;
      d2 = r("FID"), s2 = c(n2, d2, f2), i = [], t = -1, e = null, w(addEventListener), a2 = p2, i.push(a2), E();
    });
  }, b = {}, F = function(e2, t2) {
    var n2, i2 = v(), f2 = r("LCP"), s2 = function(e3) {
      var t3 = e3.startTime;
      t3 < i2.firstHiddenTime && (f2.value = t3, f2.entries.push(e3), n2());
    }, m2 = a("largest-contentful-paint", s2);
    if (m2) {
      n2 = c(e2, f2, t2);
      var d2 = function() {
        b[f2.id] || (m2.takeRecords().map(s2), m2.disconnect(), b[f2.id] = true, n2(true));
      };
      ["keydown", "click"].forEach(function(e3) {
        addEventListener(e3, d2, {
          once: true,
          capture: true
        });
      }), o(d2, true), u(function(i3) {
        f2 = r("LCP"), n2 = c(e2, f2, t2), requestAnimationFrame(function() {
          requestAnimationFrame(function() {
            f2.value = performance.now() - i3.timeStamp, b[f2.id] = true, n2(true);
          });
        });
      });
    }
  }, P = function(e2) {
    var t2, n2 = r("TTFB");
    t2 = function() {
      try {
        var t3 = performance.getEntriesByType("navigation")[0] || function() {
          var e3 = performance.timing, t4 = {
            entryType: "navigation",
            startTime: 0
          };
          for (var n3 in e3)
            n3 !== "navigationStart" && n3 !== "toJSON" && (t4[n3] = Math.max(e3[n3] - e3.navigationStart, 0));
          return t4;
        }();
        if (n2.value = n2.delta = t3.responseStart, n2.value < 0 || n2.value > performance.now())
          return;
        n2.entries = [t3], e2(n2);
      } catch (e3) {
      }
    }, document.readyState === "complete" ? setTimeout(t2, 0) : addEventListener("load", function() {
      return setTimeout(t2, 0);
    });
  };
  var WebVitalsMetrics;
  (function(WebVitalsMetrics2) {
    WebVitalsMetrics2[WebVitalsMetrics2["CLS"] = 0] = "CLS";
    WebVitalsMetrics2[WebVitalsMetrics2["FCP"] = 1] = "FCP";
    WebVitalsMetrics2[WebVitalsMetrics2["FID"] = 2] = "FID";
    WebVitalsMetrics2[WebVitalsMetrics2["LCP"] = 3] = "LCP";
    WebVitalsMetrics2[WebVitalsMetrics2["TBT"] = 4] = "TBT";
    WebVitalsMetrics2[WebVitalsMetrics2["TTFB"] = 5] = "TTFB";
  })(WebVitalsMetrics || (WebVitalsMetrics = {}));
  const defaultMetrics = [WebVitalsMetrics.CLS, WebVitalsMetrics.FCP, WebVitalsMetrics.FID, WebVitalsMetrics.LCP, WebVitalsMetrics.TTFB];
  class WebVitals {
    constructor() {
      this._isInitialized = false;
      this._safety = new PublicSafety();
      this._instr = getInstrumentation("WebVitals");
    }
    activate(__instr, metrics) {
      this._safety.tryCatch(() => {
        if (this._isInitialized) {
          throw new Error("WebVitals is already activated.");
        }
        utility.requireArgumentIfDefined(metrics, "metrics", Array);
        this._isInitialized = true;
        const metricSet = new Set(metrics || defaultMetrics);
        if (metricSet.delete(WebVitalsMetrics.CLS)) {
          h(this._logHandler.bind(this));
        }
        if (metricSet.delete(WebVitalsMetrics.FCP)) {
          d(this._activityHandler.bind(this));
        }
        if (metricSet.delete(WebVitalsMetrics.FID)) {
          L(this._logHandler.bind(this));
        }
        if (metricSet.delete(WebVitalsMetrics.LCP)) {
          F(this._activityHandler.bind(this));
        }
        if (metricSet.delete(WebVitalsMetrics.TTFB)) {
          P(this._activityHandler.bind(this));
        }
        if (metricSet.size > 0) {
          const unsupported = JSON.stringify(Array.from(metricSet.keys()));
          this._instr.error(`Unsupported WebVital metrics: ${unsupported}`);
        }
      });
    }
    _logHandler(metric) {
      this._instr.log(web_vitals, {
        name: metric.name,
        value: metric.value,
        delta: metric.delta
      });
    }
    _activityHandler(metric) {
      this._instr.startActivity(metric.name).stop(void 0, void 0, {
        perfStartOverride: 0,
        perfStopOverride: metric.value
      });
    }
  }
  const webVitals = new WebVitals();
  function assert(assertion, message) {
    if (!assertion) {
      throw new Error(message);
    }
  }
  const CLIENT_ERROR_TYPES = {
    APEX_ACTION_ERROR: "APEX_ACTION_ERROR",
    FAILED_TO_LOAD_RESOURCE: "FAILED_TO_LOAD_RESOURCE",
    TOO_MANY_REQUESTS: "TOO_MANY_REQUESTS",
    UNKNOWN_ERROR: "UNKNOWN_ERROR"
  };
  const METHODS_WITH_CSRF = ["POST", "PATCH", "PUT", "DELETE"];
  const SFDC_REQUEST_ID_HEADER = "X-SFDC-Request-Id";
  const TOO_MANY_REQUESTS_RESPONSE_HEADER = "X-Salesforce-Too-Many-Requests";
  const PUBLIC_SIGIL_QUERY_PARAM_NAME = "asGuest";
  const LOCALE_SIGIL_QUERY_PARAM_NAME = "language";
  const ENCODE_SIGIL_QUERY_PARAM_NAME = "htmlEncode";
  const {
    location,
    navigator: navigator$1
  } = globalThis;
  async function webruntimeFetch(path, init = {}) {
    assert(typeof path === "string", "Valid path not provided for fetch request");
    const initParams = _objectSpread(_objectSpread({}, init), {}, {
      headers: _objectSpread({}, init.headers),
      credentials: init.credentials || "same-origin"
    });
    if (init.credentials === null) {
      delete initParams.credentials;
    }
    const isNonApiRequest = initParams.isNonApiRequest === true;
    const asGuest = initParams.asGuest === true || await getIsGuest();
    const actualBasePath = initParams.basePath !== void 0 ? initParams.basePath : apiBasePath__default["default"];
    const url = new URL(actualBasePath + path, location);
    if (!isNonApiRequest) {
      const sp = url.searchParams;
      if (!sp.has(LOCALE_SIGIL_QUERY_PARAM_NAME)) {
        sp.append(LOCALE_SIGIL_QUERY_PARAM_NAME, language__default["default"]);
      }
      if (!sp.has(PUBLIC_SIGIL_QUERY_PARAM_NAME)) {
        sp.append(PUBLIC_SIGIL_QUERY_PARAM_NAME, asGuest);
      }
      if (!sp.has(ENCODE_SIGIL_QUERY_PARAM_NAME)) {
        sp.append(ENCODE_SIGIL_QUERY_PARAM_NAME, false);
      }
    }
    const contentType = initParams.headers["Content-Type"];
    if (contentType === null) {
      delete initParams.headers["Content-Type"];
    } else {
      if (contentType) {
        initParams.headers["Content-Type"] = contentType;
      } else if (init.body) {
        initParams.headers["Content-Type"] = "application/json; charset=utf-8";
      }
    }
    initParams.headers[SFDC_REQUEST_ID_HEADER] = generateRequestId();
    await addCSRFToken(initParams);
    const response = await globalThis.fetch(url.toString(), initParams);
    if (hasTooManyRequestsHeader(response)) {
      dispatchTooManyRequestsClientError();
    }
    return response;
  }
  function dispatchTooManyRequestsClientError() {
    document.dispatchEvent(new CustomEvent("client-error", {
      detail: {
        type: CLIENT_ERROR_TYPES.TOO_MANY_REQUESTS
      }
    }));
  }
  function hasTooManyRequestsHeader(response) {
    if (response.status === 503 || response.status === 429) {
      if (response.headers.get(TOO_MANY_REQUESTS_RESPONSE_HEADER)) {
        return true;
      }
    }
    return false;
  }
  async function addCSRFToken(params) {
    if (params.method && METHODS_WITH_CSRF.includes(params.method)) {
      const {
        default: user
      } = await _0_9_0.load("@app/user/v/1");
      params.headers["CSRF-Token"] = user.csrfToken;
    }
  }
  async function sendBeacon({
    path,
    payload,
    contentType
  }) {
    const url = basePath__default["default"] + path;
    const sentBeacon = navigator$1 && navigator$1.sendBeacon && navigator$1.sendBeacon(url, payload);
    if (!sentBeacon) {
      await globalThis.fetch(path, {
        headers: {
          "Content-Type": contentType
        },
        basePath: basePath__default["default"],
        body: payload,
        method: "POST",
        isNonApiRequest: true
      });
    }
  }
  function generateRequestId() {
    return (Date.now() + guid() + Math.round(Math.random() * 1e8)).substring(0, 18);
  }
  function guid() {
    function s4() {
      return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
    }
    return s4() + s4();
  }
  async function getIsGuest() {
    const {
      default: user
    } = await _0_9_0.load("@app/user/v/1");
    return user.isGuest;
  }
  var transport = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fetch: webruntimeFetch,
    sendBeacon
  });
  const app_payload = {
    namespace: "sf.clwr",
    name: "AppPayload",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            clwr: {
              nested: {
                AppPayload: {
                  fields: {
                    visd: {
                      id: 1,
                      type: "double"
                    },
                    isPreview: {
                      id: 4,
                      type: "bool"
                    },
                    siteId: {
                      id: 6,
                      type: "string"
                    },
                    isMobile: {
                      id: 3,
                      type: "bool"
                    },
                    lang: {
                      id: 5,
                      type: "string"
                    },
                    isDesign: {
                      id: 2,
                      type: "bool"
                    },
                    vKey: {
                      id: 7,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const nav = {
    namespace: "sf.clwr",
    name: "Nav",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            clwr: {
              nested: {
                Nav: {
                  fields: {
                    isIdleHit: {
                      id: 1,
                      type: "bool"
                    },
                    isManual: {
                      id: 2,
                      type: "bool"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const nav_transition = {
    namespace: "sf.clwr",
    name: "NavTransition",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            clwr: {
              nested: {
                NavTransition: {
                  fields: {
                    code: {
                      id: 4,
                      type: "string"
                    },
                    isSsr: {
                      id: 3,
                      type: "bool"
                    },
                    level: {
                      id: 5,
                      type: "string"
                    },
                    nextUrl: {
                      id: 1,
                      type: "string"
                    },
                    type: {
                      id: 2,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const page_payload = {
    namespace: "sf.clwr",
    name: "PagePayload",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            clwr: {
              nested: {
                PagePayload: {
                  fields: {
                    isSsr: {
                      id: 3,
                      type: "bool"
                    },
                    type: {
                      id: 2,
                      type: "string"
                    },
                    url: {
                      id: 1,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const root = {
    namespace: "sf.clwr",
    name: "Root",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            clwr: {
              nested: {
                Root: {
                  fields: {
                    sequence: {
                      id: 1,
                      type: "uint32"
                    },
                    navCount: {
                      id: 2,
                      type: "uint32"
                    },
                    clickCount: {
                      id: 3,
                      type: "uint32"
                    },
                    isManual: {
                      id: 4,
                      type: "bool"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const CORE_UPLOAD_THRESHOLD = 5e4;
  const MAX_IDLE_WAIT_MSECS = 3e3;
  const MIN_ROOT_ACTIVITY_DURATION_MSECS = 300;
  const INVALID_API_ENDPOINT = "O11Y_ENDPOINT_NOT_CONFIGURED";
  const randomPerApp = Math.random();
  const config = {
    coreEnabled: false,
    coreSamplingRate: 0,
    coreRelativeEndpoint: "",
    falconEnabled: false,
    falconSamplingRate: 0,
    falconAbsoluteEndpoint: "",
    guestToken: "",
    traceSamplingRate: 0
  };
  const isProduction = false;
  if (isProduction) {
    utility.markProduction();
  }
  let guestInfo;
  let disallowCoreAccess;
  new PublicSafety().tryCatch(() => {
    const srvConfig = JSON.parse(srvConfigJson__default["default"]);
    Object.keys(config).forEach((key) => {
      const value = srvConfig[key];
      const expectedType = typeof config[key];
      if (expectedType === "string" && value === "" || utility.requireArgumentIfDefined(value, `srvConfig.${key}`, expectedType)) {
        config[key] = srvConfig[key];
      }
    });
    guestInfo = parseGuestTokenExt(guestTokenExt__default["default"]);
    config.guestToken = guestInfo.guestToken;
  });
  function getRawConfig() {
    return config;
  }
  function canUploadToEndpoint(enabled, apiEndpoint) {
    return enabled && apiEndpoint !== "" && apiEndpoint !== INVALID_API_ENDPOINT;
  }
  function willSampleLog(sampleRate) {
    return !isProduction || sampleRate > 0 && sampleRate >= randomPerApp;
  }
  function shouldUploadToCore() {
    return !disallowCoreAccess && canUploadToEndpoint(config.coreEnabled, config.coreRelativeEndpoint) && willSampleLog(config.coreSamplingRate);
  }
  function shouldUploadToFalcon() {
    return canUploadToEndpoint(config.falconEnabled, config.falconAbsoluteEndpoint) && willSampleLog(config.falconSamplingRate);
  }
  function parseGuestTokenExt(guestTokenExt2) {
    if (!guestTokenExt2) {
      throw new Error("o11yGuestToken not set");
    }
    const options = {};
    const barIndex = guestTokenExt2.indexOf("|");
    if (barIndex >= 0) {
      options.guestToken = guestTokenExt2.substring(0, barIndex);
      options.meta = JSON.parse(guestTokenExt2.substring(barIndex + 1));
    } else {
      options.guestToken = guestTokenExt2;
    }
    return options;
  }
  function usesConnectApi() {
    const index2 = config.coreRelativeEndpoint?.indexOf("services/data/");
    return index2 === 0 || index2 === 1;
  }
  function useApiBasePath() {
    const ep = config.coreRelativeEndpoint || "";
    return usesConnectApi() && ep.length > 1 && ep[0] !== "/";
  }
  async function checkCoreUserAccess() {
    if (disallowCoreAccess === void 0) {
      disallowCoreAccess = false;
      if (usesConnectApi() && !guestInfo.meta?.isGuestApiAccessEnabled) {
        const {
          default: user
        } = await _0_9_0.load("@app/user/v/1");
        if (user.isGuest) {
          disallowCoreAccess = true;
        }
      }
    }
  }
  function sampleRootActivity() {
    const randomPerInvocation = Math.random();
    const rate = config.traceSamplingRate || 0;
    return rate > 0 && rate >= randomPerInvocation;
  }
  const actOptionsStartAtZero = {
    perfStartOverride: 0
  };
  let debugMsg;
  class O11yRoutingSupport {
    constructor(o11yApp) {
      this._rootPayload = {
        sequence: 0,
        navCount: 0,
        clickCount: 0,
        isManual: false
      };
      this._navPayload = {
        isIdleHit: false,
        isManual: false
      };
      this._hadRootActivity = false;
      this._hadNavActivity = false;
      this._isFirstNavActivity = true;
      const debugMode = true;
      debugMsg = (msg) => debugMode && console.log(`O11YR ${msg}`);
      debugMsg("Started");
      this._o11yApp = o11yApp;
      this._startRoot();
      document.body.addEventListener("click", this._handleClick.bind(this), {
        capture: true,
        passive: true
      });
      window.addEventListener("visibilitychange", this._handleVisibilityChange.bind(this));
    }
    _handleClick() {
      if (!this._rootActivity) {
        this._startRoot();
      } else {
        this._rootPayload.clickCount += 1;
      }
    }
    _handleVisibilityChange() {
      const isHide = document.visibilityState === "hidden";
      debugMsg(isHide ? "Hide" : "Show");
      if (isHide) {
        this._stopNavTransition();
        this._stopNav();
        this._stopRoot(false);
      } else {
        if (this._hadRootActivity) {
          this._startRoot(true);
        }
        if (this._hadNavActivity && !this._navActivity) {
          this._startNav(this._navData, true);
        }
      }
    }
    get _isFirstRootActivity() {
      return this._rootPayload.sequence === 1;
    }
    _startRoot(isManual = false) {
      if (this._rootActivity) {
        this._stopRoot(false);
      }
      this._rootPayload.clickCount = 0;
      this._rootPayload.navCount = 0;
      this._rootPayload.sequence += 1;
      this._rootPayload.isManual = isManual;
      this._rootActivity = this._o11yApp.startRootActivity("root", void 0, sampleRootActivity());
      this._hadRootActivity = true;
      debugMsg(`Root Started ${this._rootActivity.getId()}`);
      idleDetector$1.requestIdleDetectedCallback(() => {
        this._stopRoot(true);
      });
    }
    _stopRoot(idleStop) {
      if (!this._rootActivity) {
        return;
      }
      debugMsg(`Root Stop ${idleStop ? "idle" : "busy"} ${this._rootActivity.getId()}`);
      try {
        if (!this._isFirstRootActivity && this._rootPayload.navCount === 0 && time().perfNow - this._rootActivity.getStartPerfTime() < MIN_ROOT_ACTIVITY_DURATION_MSECS) {
          this._rootActivity.discard();
          this._rootPayload.sequence -= 1;
          return;
        }
        const options = this._isFirstRootActivity ? actOptionsStartAtZero : void 0;
        if (idleStop) {
          this._rootActivity.stop(root, this._rootPayload, options);
        } else {
          this._rootActivity.terminate(root, this._rootPayload, options);
        }
      } finally {
        this._rootActivity = void 0;
        this._hadRootActivity = false;
      }
    }
    _startNav(data, isManual) {
      this._stopNav();
      this._navPayload.isIdleHit = false;
      this._navPayload.isManual = isManual;
      this._rootPayload.navCount += 1;
      this._navData = data ? {
        url: data.url,
        pageRef: data.pageRef,
        isSsr: data.isSsr
      } : void 0;
      this._navActivity = this._o11yApp.startActivity("navigation");
      this._hadNavActivity = true;
      debugMsg(`Nav Started ${this._navActivity.getId()}`);
      idleDetector$1.requestIdleDetectedCallback(() => {
        debugMsg(`Nav Idle ${this._navActivity?.getId()}`);
        this._navPayload.isIdleHit = true;
      });
    }
    _stopNav() {
      if (this._navActivity) {
        debugMsg(`Nav Stop ${this._navActivity.getId()}`);
        try {
          const options = this._isFirstNavActivity ? actOptionsStartAtZero : void 0;
          this._isFirstNavActivity = false;
          this._navActivity.stop(nav, this._navPayload, options);
        } finally {
          this._navActivity = void 0;
        }
      }
    }
    _startNavTransition(data) {
      if (this._navTransitionActivity) {
        this._stopNavTransition(void 0, true);
      }
      this._navTransitionData = data;
      this._navTransitionActivity = this._o11yApp.startActivity("navigation transition");
      debugMsg(`Trans Started ${this._navTransitionActivity.getId()}`);
    }
    _stopNavTransition(errorData, shouldTerminate = false) {
      if (this._navTransitionActivity) {
        debugMsg(`Trans ${shouldTerminate ? "Terminate" : "Stop"} ${this._navTransitionActivity.getId()}`);
        try {
          if (errorData) {
            const {
              code,
              message,
              level
            } = errorData;
            const levelText = ["Fatal", "Error", "Warning", "Log"][level];
            this._navTransitionActivity.error(message, nav_transition, {
              code: code?.toString(),
              level: levelText
            });
          }
          const payload = this._navTransitionData ? {
            nextUrl: this._navTransitionData.url,
            type: this._navTransitionData.pageRef?.type,
            isSsr: this._navTransitionData.isSsr
          } : void 0;
          if (shouldTerminate) {
            this._navTransitionActivity.terminate(nav_transition, payload);
          } else {
            this._navTransitionActivity.stop(nav_transition, payload);
          }
        } finally {
          this._navTransitionActivity = void 0;
          this._navTransitionData = void 0;
        }
      }
    }
    preNavigate(data) {
      this._startNavTransition({
        url: data.next.url,
        pageRef: data.next.route.pageReference,
        isSsr: data.next.routeDefinition?.bootstrap?.ssr
      });
    }
    postNavigate(data) {
      this._stopNavTransition();
      this._startNav({
        url: data.url,
        pageRef: data.route.pageReference,
        isSsr: data.routeDefinition?.bootstrap?.ssr
      }, false);
    }
    errorNavigate(data) {
      debugMsg(`Err level ${data?.level}: ${data?.code}`);
      this._stopNavTransition(data);
    }
    getCurrentPageData() {
      if (this._navData) {
        const {
          pageRef,
          url,
          isSsr
        } = this._navData;
        return {
          url,
          type: pageRef?.type,
          isSsr
        };
      }
      return void 0;
    }
  }
  class O11yAppPayloadProvider {
    constructor() {
      this._totalVisibleDuration = 0;
      this._isVisible = document?.visibilityState === "visible";
      if (this._isVisible) {
        this._lastVisibleTime = 0;
      }
      window?.addEventListener("visibilitychange", this._handleVisibilityChange.bind(this));
    }
    _handleVisibilityChange() {
      if (document.visibilityState === "hidden") {
        this._isVisible = false;
        if (this._lastVisibleTime !== void 0) {
          const perfNow = time().perfNow;
          this._totalVisibleDuration += perfNow - this._lastVisibleTime;
          this._lastVisibleTime = perfNow;
        }
      } else {
        this._isVisible = true;
        this._lastVisibleTime = time().perfNow;
      }
    }
    getPayload() {
      const _durationSinceLastRecorded = this._isVisible && this._lastVisibleTime !== void 0 ? time().perfNow - this._lastVisibleTime : 0;
      const payload = {
        isDesign: isDesignMode__default["default"],
        isMobile: isMobileAppMode__default["default"],
        isPreview: isPreviewMode__default["default"],
        lang: language__default["default"],
        siteId: siteId__default["default"],
        vKey: versionKey__default["default"],
        visd: this._totalVisibleDuration + _durationSinceLastRecorded
      };
      return {
        schema: app_payload,
        payload
      };
    }
  }
  class O11yPagePayloadProvider {
    linkWithRouterSupport(routerSupport) {
      this._routingSupport = routerSupport;
    }
    getPayload() {
      if (this._routingSupport) {
        const payload = this._routingSupport.getCurrentPageData();
        if (payload)
          return {
            schema: page_payload,
            payload
          };
      }
      return void 0;
    }
  }
  const {
    ConsoleCollector,
    idleDetector,
    registerInstrumentedApp,
    _version
  } = o11yClient;
  const INSTR_APP_NAME = "lwr_experience";
  let simpleCollector;
  let protoEncoderFunc;
  const _o11y = _o11y$1;
  _o11y.clientVersion = _version;
  _o11y.schemaVersion = version;
  const versionLabel = `${_version}:${version}`;
  const transportFetch = webruntimeFetch;
  if (globalThis.LWR?.define) {
    globalThis.LWR.define("o11y/shared", [], () => o11yShared);
    globalThis.LWR.define("o11y/client", [], () => o11yClient);
    globalThis.LWR.define("transport", [], () => transport);
    globalThis.LWR.define("webruntime/o11y", [], () => webruntimeO11y);
  }
  async function hookO11ySetup(serviceApi) {
    const isProduction2 = false;
    try {
      if (typeof window === "undefined") {
        _o11y.isUnavailable = true;
        return;
      }
      const moduleFetchTasker = idleDetector.declareNotifierTaskMulti("o11y LWR module fetch");
      _o11y.willUpload = shouldUploadToCore() || shouldUploadToFalcon();
      const appPayloadProvider = new O11yAppPayloadProvider();
      const pagePayloadProvider = new O11yPagePayloadProvider();
      _o11y.app = registerInstrumentedApp(INSTR_APP_NAME, {
        isProduction: isProduction2,
        enableBuffering: true,
        appPayloadProvider,
        pagePayloadProvider
      });
      dispatcher__default["default"]?.((info) => {
        if (info.id === "lwr.loader.module.fetch") {
          if (info.phase === 0) {
            moduleFetchTasker.add();
          } else {
            moduleFetchTasker.done();
          }
        }
      });
      _o11y.app.networkInstrumentation({
        tracingHeadersOptions: {
          useB3Headers: true
        }
      });
      webVitals.activate();
      _o11y.routingSupport = new O11yRoutingSupport(_o11y.app);
      pagePayloadProvider.linkWithRouterSupport(_o11y.routingSupport);
      let isConsoleInitialized = false;
      _o11y.initConsole = (options) => {
        if (!isConsoleInitialized && _o11y.app) {
          const consoleCollector = new ConsoleCollector();
          _o11y.app.registerLogCollector(consoleCollector, options);
          isConsoleInitialized = true;
        }
      };
      if (!isProduction2) {
        _o11y.initConsole();
        _o11y.app.log(`o11y ${versionLabel}`);
      }
      _o11y.upload = uploadAsNeededAsync;
      if (_o11y.willUpload) {
        await waitForLoad();
        await checkCoreUserAccess();
        _o11y.willUpload = shouldUploadToCore() || shouldUploadToFalcon();
        if (!_o11y.willUpload) {
          return;
        }
        await initSimpleCollector(_o11y.app, {
          appName: serviceApi.appMetadata.bootstrapModule,
          sdkVersion: `o11y ${versionLabel}`
        });
        addEventListenersForUpload();
        await uploadAsNeededAsync(true);
      }
    } catch (err) {
      if (!isProduction2) {
        throw err;
      }
      try {
        console?.error("Failed to start o11y", err);
      } catch {
      }
    } finally {
      try {
        _o11y.app?.disableBuffering();
      } catch {
      }
    }
  }
  function addEventListenersForUpload() {
    window.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        uploadAsNeededAsync(true);
      }
    });
  }
  async function waitForLoad() {
    const waitForIdleWithTimeout = (resolve) => {
      let resolved = false;
      setTimeout(() => {
        if (!resolved) {
          resolved = true;
          resolve();
        }
      }, MAX_IDLE_WAIT_MSECS);
      idleDetector.requestIdleDetectedCallback(() => {
        if (!resolved) {
          resolved = true;
          resolve();
        }
      });
    };
    return new Promise((resolve) => {
      if (document.readyState === "complete") {
        waitForIdleWithTimeout(resolve);
      } else {
        window.addEventListener("load", () => waitForIdleWithTimeout(resolve));
      }
    });
  }
  async function initSimpleCollector(o11yApp, environment) {
    const [simpleCollectorModule, collectorsModule] = await Promise.all([_0_9_0.load("o11y/simple_collector/v/244_9_0"), _0_9_0.load("o11y/collectors/v/244_9_0")]);
    protoEncoderFunc = (collectorsModule.default || collectorsModule).encodeCoreEnvelopeContentsRaw;
    simpleCollector = new (simpleCollectorModule.default || simpleCollectorModule).SimpleCollector({
      environment
    });
    o11yApp.registerLogCollector(simpleCollector, {
      retroactive: true
    });
    o11yApp.registerMetricsCollector(simpleCollector);
  }
  function uploadAsNeededAsync(ignoreThreshold = false) {
    const promises = [];
    const doCore = shouldUploadToCore();
    const doFalcon = shouldUploadToFalcon();
    if (simpleCollector?.hasData && (doCore || doFalcon) && (ignoreThreshold || simpleCollector.estimatedByteSize >= CORE_UPLOAD_THRESHOLD)) {
      const rawContents = simpleCollector.getRawContentsOfCoreEnvelope();
      const binary = protoEncoderFunc(rawContents);
      if (doCore) {
        promises.push(uploadToCoreAsync(binary));
      }
      if (doFalcon) {
        promises.push(uploadToFalconAsync(binary));
      }
    }
    return Promise.allSettled(promises);
  }
  function uploadToCoreAsync(binary) {
    const fromCharCode = String.fromCharCode;
    const output = [];
    for (let i2 = 0, length = binary.length; i2 < length; i2++) {
      output.push(fromCharCode(binary[i2]));
    }
    const b64 = window.btoa(output.join(""));
    const options = {
      method: "POST",
      body: JSON.stringify({
        base64Env: b64
      }),
      keepalive: true,
      isNonApiRequest: !usesConnectApi(),
      o11y: {
        skipInstr: true
      }
    };
    let path = getRawConfig().coreRelativeEndpoint;
    if (useApiBasePath()) {
      if (path[0] !== "/") {
        path = `/${path}`;
      }
    } else {
      options.basePath = basePath__default["default"];
    }
    return transportFetch(path, options);
  }
  function uploadToFalconAsync(binary) {
    const config2 = getRawConfig();
    const reqInit = {
      method: "POST",
      body: binary,
      headers: {
        "x-sfdc-o11y-token": config2.guestToken || "",
        "Content-Type": "application/octet-stream"
      },
      keepalive: true,
      o11y: {
        skipInstr: true
      }
    };
    return fetch(config2.falconAbsoluteEndpoint, reqInit);
  }
  exports.default = hookO11ySetup;
  Object.defineProperty(exports, "__esModule", {value: true});
});
LWR.define("webruntime/hook/v/1_66_319-244_0", ["exports"], function(exports) {
  "use strict";
  var inlinedModules = ["@app/apexApiBasePath", "@app/apiBasePath", "@app/authenticationCookieName", "@app/basePath", "@app/guestUuidCookieName", "@app/isDesignMode", "@app/isPreviewMode", "@app/isMobileAppMode", "@app/loginPath", "@app/o11yGuestToken", "@app/o11yConfiguration", "@app/routes", "@app/extraRouteParams", "@app/uiBasePath", "@app/versionKey", "@app/viewToThemeLayoutMap", "@app/views", "@salesforce/community/basePath", "@salesforce/i18n/lang", "@salesforce/site/Id", "@salesforce/webstore/Id", "webruntime/dispatcher"];
  var bundled = ["@salesforce/cssvars/customProperties", "aura-instrumentation", "aura-storage", "aura", "instrumentation/service", "instrumentation/utility", "lightning/configProvider", "lightning/navigation", "transport", "webruntime/transport", "logger", "assert", "o11y/shared", "o11y/client", "webruntime/o11y", "webruntime_navigation/link", "webruntime/expressions", "webruntime/routerContainer", "webruntime/componentContainer", "webruntime/slotContainer", "webruntime/visibilityContainer", "webruntime/routingService", "webruntime/overrides", "webruntimedesign/componentWrapper", "webruntimedesign/regionWrapper", "webruntimedesign/dropRegion", "webruntimedesign/componentService", "webruntimedesign/designComponent", "mobileruntime/hybridAppManager", "wire-service", "@salesforce/client/formFactor"];
  const designBundled = ["webruntimedesign/componentWrapper", "webruntimedesign/regionWrapper", "webruntimedesign/dropRegion", "webruntimedesign/componentService", "webruntimedesign/designComponent"];
  function communitiesHook(serviceAPI) {
    serviceAPI.addLoaderPlugin({
      resolveModule: async (id) => {
        const [specifier] = id.split("/v/");
        if (specifier === "webruntime/transport") {
          return "transport";
        }
        if (specifier && (bundled.includes(specifier) || designBundled.includes(specifier) || inlinedModules.includes(specifier))) {
          return specifier;
        }
        if (specifier === "@salesforce/loader") {
          return "lwr/loaderLegacy/v/0_9_0";
        }
        return null;
      }
    });
  }
  exports.default = communitiesHook;
  Object.defineProperty(exports, "__esModule", {value: true});
});
LWR.define("@lwc/synthetic-shadow/v/2_41_4", function() {
  "use strict";
  function invariant(value, msg) {
    if (!value) {
      throw new Error(`Invariant Violation: ${msg}`);
    }
  }
  function isTrue$1(value, msg) {
    if (!value) {
      throw new Error(`Assert Violation: ${msg}`);
    }
  }
  function isFalse$1(value, msg) {
    if (value) {
      throw new Error(`Assert Violation: ${msg}`);
    }
  }
  function fail(msg) {
    throw new Error(msg);
  }
  var assert = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fail,
    invariant,
    isFalse: isFalse$1,
    isTrue: isTrue$1
  });
  const {
    assign,
    create,
    defineProperties,
    defineProperty,
    freeze,
    getOwnPropertyDescriptor,
    getOwnPropertyNames,
    getPrototypeOf,
    hasOwnProperty,
    isFrozen,
    keys,
    seal,
    setPrototypeOf
  } = Object;
  const {
    isArray
  } = Array;
  const {
    concat: ArrayConcat,
    copyWithin: ArrayCopyWithin,
    fill: ArrayFill,
    filter: ArrayFilter,
    find: ArrayFind,
    indexOf: ArrayIndexOf,
    join: ArrayJoin,
    map: ArrayMap,
    pop: ArrayPop,
    push: ArrayPush,
    reduce: ArrayReduce,
    reverse: ArrayReverse,
    shift: ArrayShift,
    slice: ArraySlice,
    some: ArraySome,
    sort: ArraySort,
    splice: ArraySplice,
    unshift: ArrayUnshift,
    forEach
  } = Array.prototype;
  const {
    charCodeAt: StringCharCodeAt,
    replace: StringReplace,
    split: StringSplit,
    slice: StringSlice,
    toLowerCase: StringToLowerCase
  } = String.prototype;
  function isUndefined(obj) {
    return obj === void 0;
  }
  function isNull(obj) {
    return obj === null;
  }
  function isTrue(obj) {
    return obj === true;
  }
  function isFalse(obj) {
    return obj === false;
  }
  function isFunction(obj) {
    return typeof obj === "function";
  }
  function isObject(obj) {
    return typeof obj === "object";
  }
  const OtS = {}.toString;
  function toString(obj) {
    if (obj && obj.toString) {
      if (isArray(obj)) {
        return ArrayJoin.call(ArrayMap.call(obj, toString), ",");
      }
      return obj.toString();
    } else if (typeof obj === "object") {
      return OtS.call(obj);
    } else {
      return obj + "";
    }
  }
  const _globalThis = typeof globalThis === "object" ? globalThis : window;
  const KEY__IS_NATIVE_SHADOW_ROOT_DEFINED = "$isNativeShadowRootDefined$";
  const KEY__SHADOW_RESOLVER = "$shadowResolver$";
  const KEY__SHADOW_RESOLVER_PRIVATE = "$$ShadowResolverKey$$";
  const KEY__SHADOW_STATIC = "$shadowStaticNode$";
  const KEY__SHADOW_STATIC_PRIVATE = "$shadowStaticNodeKey$";
  const KEY__SHADOW_TOKEN = "$shadowToken$";
  const KEY__SHADOW_TOKEN_PRIVATE = "$$ShadowTokenKey$$";
  const KEY__SYNTHETIC_MODE = "$$lwc-synthetic-mode";
  const KEY__NATIVE_GET_ELEMENT_BY_ID = "$nativeGetElementById$";
  const KEY__NATIVE_QUERY_SELECTOR_ALL = "$nativeQuerySelectorAll$";
  const hasNativeSymbolSupport = /* @__PURE__ */ (() => Symbol("x").toString() === "Symbol(x)")();
  if (!_globalThis.lwcRuntimeFlags) {
    Object.defineProperty(_globalThis, "lwcRuntimeFlags", {
      value: create(null)
    });
  }
  const _Node = Node;
  const nodePrototype = _Node.prototype;
  const {
    DOCUMENT_POSITION_CONTAINED_BY,
    DOCUMENT_POSITION_CONTAINS,
    DOCUMENT_POSITION_PRECEDING,
    DOCUMENT_POSITION_FOLLOWING,
    ELEMENT_NODE,
    TEXT_NODE,
    CDATA_SECTION_NODE,
    PROCESSING_INSTRUCTION_NODE,
    COMMENT_NODE,
    DOCUMENT_FRAGMENT_NODE
  } = _Node;
  const {
    appendChild,
    cloneNode,
    compareDocumentPosition,
    insertBefore,
    removeChild,
    replaceChild,
    hasChildNodes
  } = nodePrototype;
  const {
    contains
  } = HTMLElement.prototype;
  const firstChildGetter = getOwnPropertyDescriptor(nodePrototype, "firstChild").get;
  const lastChildGetter = getOwnPropertyDescriptor(nodePrototype, "lastChild").get;
  const textContentGetter = getOwnPropertyDescriptor(nodePrototype, "textContent").get;
  const parentNodeGetter = getOwnPropertyDescriptor(nodePrototype, "parentNode").get;
  const ownerDocumentGetter = getOwnPropertyDescriptor(nodePrototype, "ownerDocument").get;
  const parentElementGetter = hasOwnProperty.call(nodePrototype, "parentElement") ? getOwnPropertyDescriptor(nodePrototype, "parentElement").get : getOwnPropertyDescriptor(HTMLElement.prototype, "parentElement").get;
  const textContextSetter = getOwnPropertyDescriptor(nodePrototype, "textContent").set;
  const childNodesGetter = hasOwnProperty.call(nodePrototype, "childNodes") ? getOwnPropertyDescriptor(nodePrototype, "childNodes").get : getOwnPropertyDescriptor(HTMLElement.prototype, "childNodes").get;
  const isConnected = hasOwnProperty.call(nodePrototype, "isConnected") ? getOwnPropertyDescriptor(nodePrototype, "isConnected").get : function() {
    const doc = ownerDocumentGetter.call(this);
    return doc === null || (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  };
  const {
    getAttribute,
    getBoundingClientRect,
    getElementsByTagName: getElementsByTagName$1,
    getElementsByTagNameNS: getElementsByTagNameNS$1,
    hasAttribute,
    querySelector,
    querySelectorAll: querySelectorAll$1,
    removeAttribute,
    setAttribute
  } = Element.prototype;
  const attachShadow$1 = hasOwnProperty.call(Element.prototype, "attachShadow") ? Element.prototype.attachShadow : () => {
    throw new TypeError("attachShadow() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill and use Lightning Web Components");
  };
  const childElementCountGetter = getOwnPropertyDescriptor(Element.prototype, "childElementCount").get;
  const firstElementChildGetter = getOwnPropertyDescriptor(Element.prototype, "firstElementChild").get;
  const lastElementChildGetter = getOwnPropertyDescriptor(Element.prototype, "lastElementChild").get;
  const innerTextDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, "innerText");
  const innerTextGetter = innerTextDescriptor ? innerTextDescriptor.get : null;
  const innerTextSetter = innerTextDescriptor ? innerTextDescriptor.set : null;
  const outerTextDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, "outerText");
  const outerTextGetter = outerTextDescriptor ? outerTextDescriptor.get : null;
  const outerTextSetter = outerTextDescriptor ? outerTextDescriptor.set : null;
  const innerHTMLDescriptor = hasOwnProperty.call(Element.prototype, "innerHTML") ? getOwnPropertyDescriptor(Element.prototype, "innerHTML") : getOwnPropertyDescriptor(HTMLElement.prototype, "innerHTML");
  const innerHTMLGetter = innerHTMLDescriptor.get;
  const innerHTMLSetter = innerHTMLDescriptor.set;
  const outerHTMLDescriptor = hasOwnProperty.call(Element.prototype, "outerHTML") ? getOwnPropertyDescriptor(Element.prototype, "outerHTML") : getOwnPropertyDescriptor(HTMLElement.prototype, "outerHTML");
  const outerHTMLGetter = outerHTMLDescriptor.get;
  const outerHTMLSetter = outerHTMLDescriptor.set;
  const tagNameGetter = getOwnPropertyDescriptor(Element.prototype, "tagName").get;
  const tabIndexDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, "tabIndex");
  const tabIndexGetter = tabIndexDescriptor.get;
  const tabIndexSetter = tabIndexDescriptor.set;
  const matches = hasOwnProperty.call(Element.prototype, "matches") ? Element.prototype.matches : Element.prototype.msMatchesSelector;
  const childrenGetter = hasOwnProperty.call(Element.prototype, "children") ? getOwnPropertyDescriptor(Element.prototype, "children").get : getOwnPropertyDescriptor(HTMLElement.prototype, "children").get;
  const {
    getElementsByClassName: getElementsByClassName$1
  } = HTMLElement.prototype;
  const shadowRootGetter = hasOwnProperty.call(Element.prototype, "shadowRoot") ? getOwnPropertyDescriptor(Element.prototype, "shadowRoot").get : () => null;
  const assignedSlotGetter$1 = hasOwnProperty.call(Element.prototype, "assignedSlot") ? getOwnPropertyDescriptor(Element.prototype, "assignedSlot").get : () => null;
  let assignedNodes, assignedElements;
  if (typeof HTMLSlotElement !== "undefined") {
    assignedNodes = HTMLSlotElement.prototype.assignedNodes;
    assignedElements = HTMLSlotElement.prototype.assignedElements;
  } else {
    assignedNodes = () => {
      throw new TypeError("assignedNodes() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
    };
    assignedElements = () => {
      throw new TypeError("assignedElements() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
    };
  }
  const eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, "target").get;
  const eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, "currentTarget").get;
  const focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, "relatedTarget").get;
  const composedPath = hasOwnProperty.call(Event.prototype, "composedPath") ? Event.prototype.composedPath : () => [];
  const DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, "activeElement").get;
  const elementFromPoint = hasOwnProperty.call(Document.prototype, "elementFromPoint") ? Document.prototype.elementFromPoint : Document.prototype.msElementFromPoint;
  const elementsFromPoint = hasOwnProperty.call(Document.prototype, "elementsFromPoint") ? Document.prototype.elementsFromPoint : Document.prototype.msElementsFromPoint;
  const defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, "defaultView").get;
  const {
    createComment,
    querySelectorAll,
    getElementById,
    getElementsByClassName,
    getElementsByTagName,
    getElementsByTagNameNS
  } = Document.prototype;
  const {
    getElementsByName
  } = HTMLDocument.prototype;
  const {
    addEventListener: windowAddEventListener,
    removeEventListener: windowRemoveEventListener,
    getComputedStyle: windowGetComputedStyle,
    getSelection: windowGetSelection
  } = window;
  const MO = MutationObserver;
  const MutationObserverObserve = MO.prototype.observe;
  let NativeShadowRoot = null;
  if (typeof ShadowRoot !== "undefined") {
    NativeShadowRoot = ShadowRoot;
  }
  const isNativeShadowRootDefined = !isNull(NativeShadowRoot);
  const isInstanceOfNativeShadowRoot = isNull(NativeShadowRoot) ? () => false : (node) => node instanceof NativeShadowRoot;
  function detect$4() {
    return typeof HTMLSlotElement === "undefined";
  }
  const {
    createElement
  } = Document.prototype;
  const CHAR_S = 115;
  const CHAR_L = 108;
  const CHAR_O = 111;
  const CHAR_T = 116;
  function apply$4() {
    class HTMLSlotElement2 {
    }
    setPrototypeOf(HTMLSlotElement2, HTMLElement.constructor);
    setPrototypeOf(HTMLSlotElement2.prototype, HTMLElement.prototype);
    Window.prototype.HTMLSlotElement = HTMLSlotElement2;
    defineProperty(Document.prototype, "createElement", {
      value: function(tagName, _options) {
        const elm = createElement.apply(this, ArraySlice.call(arguments));
        if (tagName.length === 4 && StringCharCodeAt.call(tagName, 0) === CHAR_S && StringCharCodeAt.call(tagName, 1) === CHAR_L && StringCharCodeAt.call(tagName, 2) === CHAR_O && StringCharCodeAt.call(tagName, 3) === CHAR_T) {
          setPrototypeOf(elm, HTMLSlotElement2.prototype);
        }
        return elm;
      }
    });
  }
  if (detect$4()) {
    apply$4();
  }
  function getOwnerDocument(node) {
    const doc = ownerDocumentGetter.call(node);
    return doc === null ? node : doc;
  }
  function getOwnerWindow(node) {
    const doc = getOwnerDocument(node);
    const win = defaultViewGetter.call(doc);
    if (win === null) {
      throw new TypeError();
    }
    return win;
  }
  let skipGlobalPatching;
  function isGlobalPatchingSkipped(node) {
    if (isUndefined(skipGlobalPatching)) {
      const ownerDocument = getOwnerDocument(node);
      skipGlobalPatching = ownerDocument.body && getAttribute.call(ownerDocument.body, "data-global-patching-bypass") === "temporary-bypass";
    }
    return isTrue(skipGlobalPatching);
  }
  function arrayFromCollection(collection) {
    const size = collection.length;
    const cloned = [];
    if (size > 0) {
      for (let i = 0; i < size; i++) {
        cloned[i] = collection[i];
      }
    }
    return cloned;
  }
  const eventTargetPrototype = typeof EventTarget !== "undefined" ? EventTarget.prototype : _Node.prototype;
  const {
    addEventListener: addEventListener2,
    dispatchEvent,
    removeEventListener: removeEventListener2
  } = eventTargetPrototype;
  const HostElementKey = "$$HostElementKey$$";
  const ShadowedNodeKey = "$$ShadowedNodeKey$$";
  function fastDefineProperty(node, propName, config) {
    const shadowedNode = node;
    if (true) {
      defineProperty(shadowedNode, propName, config);
    } else {
      const {
        value
      } = config;
      shadowedNode[propName] = value;
    }
  }
  function setNodeOwnerKey(node, value) {
    fastDefineProperty(node, HostElementKey, {
      value,
      configurable: true
    });
  }
  function setNodeKey(node, value) {
    fastDefineProperty(node, ShadowedNodeKey, {
      value
    });
  }
  function getNodeOwnerKey(node) {
    return node[HostElementKey];
  }
  function getNodeNearestOwnerKey(node) {
    let host = node;
    let hostKey;
    while (!isNull(host)) {
      hostKey = getNodeOwnerKey(host);
      if (!isUndefined(hostKey)) {
        return hostKey;
      }
      host = parentNodeGetter.call(host);
      if (!isNull(host) && isSyntheticSlotElement(host)) {
        return void 0;
      }
    }
  }
  function getNodeKey(node) {
    return node[ShadowedNodeKey];
  }
  function isNodeShadowed(node) {
    return !isUndefined(getNodeOwnerKey(node));
  }
  function foldSlotElement(slot) {
    let parent = parentElementGetter.call(slot);
    while (!isNull(parent) && isSlotElement(parent)) {
      slot = parent;
      parent = parentElementGetter.call(slot);
    }
    return slot;
  }
  function isNodeSlotted(host, node) {
    if (true) {
      assert.invariant(host instanceof HTMLElement, `isNodeSlotted() should be called with a host as the first argument instead of ${host}`);
      assert.invariant(node instanceof _Node, `isNodeSlotted() should be called with a node as the second argument instead of ${node}`);
      assert.invariant(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS, `isNodeSlotted() should never be called with a node that is not a child node of ${host}`);
    }
    const hostKey = getNodeKey(host);
    let currentElement = node instanceof Element ? node : parentElementGetter.call(node);
    while (!isNull(currentElement) && currentElement !== host) {
      const elmOwnerKey = getNodeNearestOwnerKey(currentElement);
      const parent = parentElementGetter.call(currentElement);
      if (elmOwnerKey === hostKey) {
        return isSlotElement(currentElement);
      } else if (parent === host) {
        return false;
      } else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
        if (isSlotElement(parent)) {
          currentElement = getNodeOwner(foldSlotElement(parent));
          if (!isNull(currentElement)) {
            if (currentElement === host) {
              return true;
            } else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
              return true;
            }
          }
        } else {
          return false;
        }
      } else {
        currentElement = parent;
      }
    }
    return false;
  }
  function getNodeOwner(node) {
    if (!(node instanceof _Node)) {
      return null;
    }
    const ownerKey = getNodeNearestOwnerKey(node);
    if (isUndefined(ownerKey)) {
      return null;
    }
    let nodeOwner = node;
    while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
      nodeOwner = parentNodeGetter.call(nodeOwner);
    }
    if (isNull(nodeOwner)) {
      return null;
    }
    return nodeOwner;
  }
  function isSyntheticSlotElement(node) {
    return isSlotElement(node) && isNodeShadowed(node);
  }
  function isSlotElement(node) {
    return node instanceof HTMLSlotElement;
  }
  function isNodeOwnedBy(owner, node) {
    if (true) {
      assert.invariant(owner instanceof HTMLElement, `isNodeOwnedBy() should be called with an element as the first argument instead of ${owner}`);
      assert.invariant(node instanceof _Node, `isNodeOwnedBy() should be called with a node as the second argument instead of ${node}`);
      assert.invariant(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS, `isNodeOwnedBy() should never be called with a node that is not a child node of ${owner}`);
    }
    const ownerKey = getNodeNearestOwnerKey(node);
    if (isUndefined(ownerKey)) {
      const host = parentNodeGetter.call(node);
      if (!isNull(host) && isSyntheticSlotElement(host)) {
        return false;
      }
      return true;
    }
    return getNodeKey(owner) === ownerKey;
  }
  function shadowRootChildNodes(root) {
    const elm = getHost(root);
    return getAllMatches(elm, arrayFromCollection(childNodesGetter.call(elm)));
  }
  function getAllSlottedMatches(host, nodeList) {
    const filteredAndPatched = [];
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];
      if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
        ArrayPush.call(filteredAndPatched, node);
      }
    }
    return filteredAndPatched;
  }
  function getFirstSlottedMatch(host, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];
      if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
        return node;
      }
    }
    return null;
  }
  function getAllMatches(owner, nodeList) {
    const filteredAndPatched = [];
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];
      const isOwned = isNodeOwnedBy(owner, node);
      if (isOwned) {
        ArrayPush.call(filteredAndPatched, node);
      }
    }
    return filteredAndPatched;
  }
  function getFirstMatch(owner, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      if (isNodeOwnedBy(owner, nodeList[i])) {
        return nodeList[i];
      }
    }
    return null;
  }
  function shadowRootQuerySelector(root, selector) {
    const elm = getHost(root);
    const nodeList = arrayFromCollection(querySelectorAll$1.call(elm, selector));
    return getFirstMatch(elm, nodeList);
  }
  function shadowRootQuerySelectorAll(root, selector) {
    const elm = getHost(root);
    const nodeList = querySelectorAll$1.call(elm, selector);
    return getAllMatches(elm, arrayFromCollection(nodeList));
  }
  function getFilteredChildNodes(node) {
    if (!isSyntheticShadowHost(node) && !isSlotElement(node)) {
      const children = childNodesGetter.call(node);
      return arrayFromCollection(children);
    }
    if (isSyntheticShadowHost(node)) {
      const slots = arrayFromCollection(querySelectorAll$1.call(node, "slot"));
      const resolver = getShadowRootResolver(getShadowRoot(node));
      return ArrayReduce.call(slots, (seed, slot) => {
        if (resolver === getShadowRootResolver(slot)) {
          ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
        }
        return seed;
      }, []);
    } else {
      const children = arrayFromCollection(childNodesGetter.call(node));
      const resolver = getShadowRootResolver(node);
      return ArrayFilter.call(children, (child) => resolver === getShadowRootResolver(child));
    }
  }
  function getFilteredSlotAssignedNodes(slot) {
    const owner = getNodeOwner(slot);
    if (isNull(owner)) {
      return [];
    }
    const childNodes = arrayFromCollection(childNodesGetter.call(slot));
    return ArrayFilter.call(childNodes, (child) => !isNodeShadowed(child) || !isNodeOwnedBy(owner, child));
  }
  function getInnerHTML(node) {
    let s = "";
    const childNodes = getFilteredChildNodes(node);
    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      s += getOuterHTML(childNodes[i]);
    }
    return s;
  }
  const escapeAttrRegExp = /[&\u00A0"]/g;
  const escapeDataRegExp = /[&\u00A0<>]/g;
  const {
    replace,
    toLowerCase
  } = String.prototype;
  function escapeReplace(c) {
    switch (c) {
      case "&":
        return "&amp;";
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case "\xA0":
        return "&nbsp;";
      default:
        return "";
    }
  }
  function escapeAttr(s) {
    return replace.call(s, escapeAttrRegExp, escapeReplace);
  }
  function escapeData(s) {
    return replace.call(s, escapeDataRegExp, escapeReplace);
  }
  const voidElements = new Set(["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "META", "PARAM", "SOURCE", "TRACK", "WBR"]);
  const plaintextParents = new Set(["STYLE", "SCRIPT", "XMP", "IFRAME", "NOEMBED", "NOFRAMES", "PLAINTEXT", "NOSCRIPT"]);
  function getOuterHTML(node) {
    switch (node.nodeType) {
      case ELEMENT_NODE: {
        const {
          attributes: attrs
        } = node;
        const tagName = tagNameGetter.call(node);
        let s = "<" + toLowerCase.call(tagName);
        for (let i = 0, attr; attr = attrs[i]; i++) {
          s += " " + attr.name + '="' + escapeAttr(attr.value) + '"';
        }
        s += ">";
        if (voidElements.has(tagName)) {
          return s;
        }
        return s + getInnerHTML(node) + "</" + toLowerCase.call(tagName) + ">";
      }
      case TEXT_NODE: {
        const {
          data,
          parentNode
        } = node;
        if (parentNode instanceof Element && plaintextParents.has(tagNameGetter.call(parentNode))) {
          return data;
        }
        return escapeData(data);
      }
      case CDATA_SECTION_NODE: {
        return `<!CDATA[[${node.data}]]>`;
      }
      case PROCESSING_INSTRUCTION_NODE: {
        return `<?${node.target} ${node.data}?>`;
      }
      case COMMENT_NODE: {
        return `<!--${node.data}-->`;
      }
      default: {
        return "";
      }
    }
  }
  function getTextContent(node) {
    switch (node.nodeType) {
      case ELEMENT_NODE: {
        const childNodes = getFilteredChildNodes(node);
        let content = "";
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          const currentNode = childNodes[i];
          if (currentNode.nodeType !== COMMENT_NODE) {
            content += getTextContent(currentNode);
          }
        }
        return content;
      }
      default:
        return node.nodeValue;
    }
  }
  const Items$1 = new WeakMap();
  function StaticNodeList() {
    throw new TypeError("Illegal constructor");
  }
  StaticNodeList.prototype = create(NodeList.prototype, {
    constructor: {
      writable: true,
      configurable: true,
      value: StaticNodeList
    },
    item: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(index) {
        return this[index];
      }
    },
    length: {
      enumerable: true,
      configurable: true,
      get() {
        return Items$1.get(this).length;
      }
    },
    forEach: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(cb, thisArg) {
        forEach.call(Items$1.get(this), cb, thisArg);
      }
    },
    entries: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        return ArrayMap.call(Items$1.get(this), (v, i) => [i, v]);
      }
    },
    keys: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        return ArrayMap.call(Items$1.get(this), (_v, i) => i);
      }
    },
    values: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        return Items$1.get(this);
      }
    },
    [Symbol.iterator]: {
      writable: true,
      configurable: true,
      value() {
        let nextIndex = 0;
        return {
          next: () => {
            const items = Items$1.get(this);
            return nextIndex < items.length ? {
              value: items[nextIndex++],
              done: false
            } : {
              done: true
            };
          }
        };
      }
    },
    [Symbol.toStringTag]: {
      configurable: true,
      get() {
        return "NodeList";
      }
    },
    toString: {
      writable: true,
      configurable: true,
      value() {
        return "[object NodeList]";
      }
    }
  });
  setPrototypeOf(StaticNodeList, NodeList);
  function createStaticNodeList(items) {
    const nodeList = create(StaticNodeList.prototype);
    Items$1.set(nodeList, items);
    forEach.call(items, (item, index) => {
      defineProperty(nodeList, index, {
        value: item,
        enumerable: true,
        configurable: true
      });
    });
    return nodeList;
  }
  function getAllRootNodes(node) {
    var _a;
    const rootNodes = [];
    let currentRootNode = node.getRootNode();
    while (!isUndefined(currentRootNode)) {
      rootNodes.push(currentRootNode);
      currentRootNode = (_a = currentRootNode.host) === null || _a === void 0 ? void 0 : _a.getRootNode();
    }
    return rootNodes;
  }
  const findAncestorHostInImmediateShadowRoot = (rootNode, targetRootNode) => {
    let host;
    while (!isUndefined(host = rootNode.host)) {
      const thisRootNode = host.getRootNode();
      if (thisRootNode === targetRootNode) {
        return host;
      }
      rootNode = thisRootNode;
    }
  };
  function fauxElementsFromPoint(context, doc, left, top) {
    const elements = elementsFromPoint.call(doc, left, top);
    const result = [];
    const rootNodes = getAllRootNodes(context);
    if (!isNull(elements)) {
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        if (isSyntheticSlotElement(element)) {
          continue;
        }
        const elementRootNode = element.getRootNode();
        if (ArrayIndexOf.call(rootNodes, elementRootNode) !== -1) {
          ArrayPush.call(result, element);
          continue;
        }
        const ancestorHost = findAncestorHostInImmediateShadowRoot(elementRootNode, rootNodes[0]);
        if (!isUndefined(ancestorHost) && ArrayIndexOf.call(elements, ancestorHost) === -1 && ArrayIndexOf.call(result, ancestorHost) === -1) {
          ArrayPush.call(result, ancestorHost);
        }
      }
    }
    return result;
  }
  const Items = new WeakMap();
  function StaticHTMLCollection() {
    throw new TypeError("Illegal constructor");
  }
  StaticHTMLCollection.prototype = create(HTMLCollection.prototype, {
    constructor: {
      writable: true,
      configurable: true,
      value: StaticHTMLCollection
    },
    item: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(index) {
        return this[index];
      }
    },
    length: {
      enumerable: true,
      configurable: true,
      get() {
        return Items.get(this).length;
      }
    },
    namedItem: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(name) {
        if (name === "") {
          return null;
        }
        const items = Items.get(this);
        for (let i = 0, len = items.length; i < len; i++) {
          const item = items[len];
          if (name === getAttribute.call(item, "id") || name === getAttribute.call(item, "name")) {
            return item;
          }
        }
        return null;
      }
    },
    [Symbol.toStringTag]: {
      configurable: true,
      get() {
        return "HTMLCollection";
      }
    },
    toString: {
      writable: true,
      configurable: true,
      value() {
        return "[object HTMLCollection]";
      }
    }
  });
  setPrototypeOf(StaticHTMLCollection, HTMLCollection);
  function createStaticHTMLCollection(items) {
    const collection = create(StaticHTMLCollection.prototype);
    Items.set(collection, items);
    forEach.call(items, (item, index) => {
      defineProperty(collection, index, {
        value: item,
        enumerable: true,
        configurable: true
      });
    });
    return collection;
  }
  function hasMountedChildren(node) {
    return isSyntheticSlotElement(node) || isSyntheticShadowHost(node);
  }
  function getShadowParent(node, value) {
    const owner = getNodeOwner(node);
    if (value === owner) {
      return getShadowRoot(owner);
    } else if (value instanceof Element) {
      if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
        return value;
      } else if (!isNull(owner) && isSlotElement(value)) {
        const slotOwner = getNodeOwner(value);
        if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
          return slotOwner;
        }
      }
    }
    return null;
  }
  function hasChildNodesPatched() {
    return getInternalChildNodes(this).length > 0;
  }
  function firstChildGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    return childNodes[0] || null;
  }
  function lastChildGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    return childNodes[childNodes.length - 1] || null;
  }
  function textContentGetterPatched() {
    return getTextContent(this);
  }
  function textContentSetterPatched(value) {
    textContextSetter.call(this, value);
  }
  function parentNodeGetterPatched() {
    const value = parentNodeGetter.call(this);
    if (isNull(value)) {
      return value;
    }
    return getShadowParent(this, value);
  }
  function parentElementGetterPatched() {
    const value = parentNodeGetter.call(this);
    if (isNull(value)) {
      return null;
    }
    const parentNode = getShadowParent(this, value);
    return parentNode instanceof Element ? parentNode : null;
  }
  function compareDocumentPositionPatched(otherNode) {
    if (this === otherNode) {
      return 0;
    } else if (this.getRootNode() === otherNode) {
      return 10;
    } else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
      return 35;
    }
    return compareDocumentPosition.call(this, otherNode);
  }
  function containsPatched(otherNode) {
    if (otherNode == null || getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
      return false;
    }
    return (compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  }
  function cloneNodePatched(deep) {
    const clone = cloneNode.call(this, false);
    if (!deep) {
      return clone;
    }
    const childNodes = getInternalChildNodes(this);
    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      clone.appendChild(childNodes[i].cloneNode(true));
    }
    return clone;
  }
  function childNodesGetterPatched() {
    if (isSyntheticShadowHost(this)) {
      const owner = getNodeOwner(this);
      const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
      if (isFalse(hasNativeSymbolSupport) && isExternalChildNodeAccessorFlagOn()) {
        ArrayUnshift.call(childNodes, getIE11FakeShadowRootPlaceholder(this));
      }
      return createStaticNodeList(childNodes);
    }
    return childNodesGetter.call(this);
  }
  const nativeGetRootNode = _Node.prototype.getRootNode;
  const getDocumentOrRootNode = !isUndefined(nativeGetRootNode) ? nativeGetRootNode : function() {
    let node = this;
    let nodeParent;
    while (!isNull(nodeParent = parentNodeGetter.call(node))) {
      node = nodeParent;
    }
    return node;
  };
  function getNearestRoot(node) {
    const ownerNode = getNodeOwner(node);
    if (isNull(ownerNode)) {
      return getDocumentOrRootNode.call(node);
    }
    return getShadowRoot(ownerNode);
  }
  function getRootNodePatched(options) {
    const composed = isUndefined(options) ? false : !!options.composed;
    return isTrue(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
  }
  defineProperties(_Node.prototype, {
    firstChild: {
      get() {
        if (hasMountedChildren(this)) {
          return firstChildGetterPatched.call(this);
        }
        return firstChildGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    lastChild: {
      get() {
        if (hasMountedChildren(this)) {
          return lastChildGetterPatched.call(this);
        }
        return lastChildGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    textContent: {
      get() {
        if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
          return textContentGetterPatched.call(this);
        }
        return textContentGetter.call(this);
      },
      set: textContentSetterPatched,
      enumerable: true,
      configurable: true
    },
    parentNode: {
      get() {
        if (isNodeShadowed(this)) {
          return parentNodeGetterPatched.call(this);
        }
        const parentNode = parentNodeGetter.call(this);
        if (!isNull(parentNode) && isSyntheticSlotElement(parentNode)) {
          return getNodeOwner(parentNode);
        }
        return parentNode;
      },
      enumerable: true,
      configurable: true
    },
    parentElement: {
      get() {
        if (isNodeShadowed(this)) {
          return parentElementGetterPatched.call(this);
        }
        const parentElement = parentElementGetter.call(this);
        if (!isNull(parentElement) && isSyntheticSlotElement(parentElement)) {
          return getNodeOwner(parentElement);
        }
        return parentElement;
      },
      enumerable: true,
      configurable: true
    },
    childNodes: {
      get() {
        if (hasMountedChildren(this)) {
          return childNodesGetterPatched.call(this);
        }
        return childNodesGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    hasChildNodes: {
      value() {
        if (hasMountedChildren(this)) {
          return hasChildNodesPatched.call(this);
        }
        return hasChildNodes.call(this);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    compareDocumentPosition: {
      value(otherNode) {
        if (isGlobalPatchingSkipped(this)) {
          return compareDocumentPosition.call(this, otherNode);
        }
        return compareDocumentPositionPatched.call(this, otherNode);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    contains: {
      value(otherNode) {
        if (this === otherNode) {
          return true;
        }
        if (otherNode == null) {
          return false;
        }
        if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
          return containsPatched.call(this, otherNode);
        }
        return contains.call(this, otherNode);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    cloneNode: {
      value(deep) {
        if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
          return cloneNodePatched.call(this, deep);
        }
        return cloneNode.call(this, deep);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    getRootNode: {
      value: getRootNodePatched,
      enumerable: true,
      configurable: true,
      writable: true
    },
    isConnected: {
      enumerable: true,
      configurable: true,
      get() {
        return isConnected.call(this);
      }
    }
  });
  let internalChildNodeAccessorFlag = false;
  function isExternalChildNodeAccessorFlagOn() {
    return !internalChildNodeAccessorFlag;
  }
  const getInternalChildNodes = isFalse(hasNativeSymbolSupport) ? function(node) {
    internalChildNodeAccessorFlag = true;
    let childNodes;
    let error = null;
    try {
      childNodes = node.childNodes;
    } catch (e) {
      error = e;
    } finally {
      internalChildNodeAccessorFlag = false;
      if (!isNull(error)) {
        throw error;
      }
    }
    return childNodes;
  } : function(node) {
    return node.childNodes;
  };
  if (hasOwnProperty.call(HTMLElement.prototype, "contains")) {
    defineProperty(HTMLElement.prototype, "contains", getOwnPropertyDescriptor(_Node.prototype, "contains"));
  }
  if (hasOwnProperty.call(HTMLElement.prototype, "parentElement")) {
    defineProperty(HTMLElement.prototype, "parentElement", getOwnPropertyDescriptor(_Node.prototype, "parentElement"));
  }
  const EventListenerMap = new WeakMap();
  const ComposedPathMap = new WeakMap();
  function isEventListenerOrEventListenerObject(fnOrObj) {
    return isFunction(fnOrObj) || isObject(fnOrObj) && !isNull(fnOrObj) && isFunction(fnOrObj.handleEvent);
  }
  function shouldInvokeListener(event, target, currentTarget) {
    if (target === currentTarget) {
      return true;
    }
    let composedPath2 = ComposedPathMap.get(event);
    if (isUndefined(composedPath2)) {
      composedPath2 = event.composedPath();
      ComposedPathMap.set(event, composedPath2);
    }
    return composedPath2.includes(currentTarget);
  }
  function getEventListenerWrapper(fnOrObj) {
    if (!isEventListenerOrEventListenerObject(fnOrObj)) {
      return fnOrObj;
    }
    let wrapperFn = EventListenerMap.get(fnOrObj);
    if (isUndefined(wrapperFn)) {
      wrapperFn = function(event) {
        const currentTarget = eventCurrentTargetGetter.call(event);
        if (true) {
          assert.invariant(isFalse(isSyntheticShadowHost(currentTarget)), "This routine should not be used to wrap event listeners for host elements and shadow roots.");
        }
        const actualTarget = getActualTarget(event);
        if (!shouldInvokeListener(event, actualTarget, currentTarget)) {
          return;
        }
        return isFunction(fnOrObj) ? fnOrObj.call(this, event) : fnOrObj.handleEvent && fnOrObj.handleEvent(event);
      };
      EventListenerMap.set(fnOrObj, wrapperFn);
    }
    return wrapperFn;
  }
  const eventToContextMap = new WeakMap();
  const customElementToWrappedListeners = new WeakMap();
  function getEventMap(elm) {
    let listenerInfo = customElementToWrappedListeners.get(elm);
    if (isUndefined(listenerInfo)) {
      listenerInfo = create(null);
      customElementToWrappedListeners.set(elm, listenerInfo);
    }
    return listenerInfo;
  }
  function getActualTarget(event) {
    var _a;
    return (_a = eventToShadowRootMap.get(event)) !== null && _a !== void 0 ? _a : eventTargetGetter.call(event);
  }
  const shadowRootEventListenerMap = new WeakMap();
  function getWrappedShadowRootListener(listener) {
    if (!isFunction(listener)) {
      throw new TypeError();
    }
    let shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);
    if (isUndefined(shadowRootWrappedListener)) {
      shadowRootWrappedListener = function(event) {
        let currentTarget = eventCurrentTargetGetter.call(event);
        if (!isInstanceOfNativeShadowRoot(currentTarget)) {
          currentTarget = getShadowRoot(currentTarget);
        }
        const actualTarget = getActualTarget(event);
        if (shouldInvokeListener(event, actualTarget, currentTarget)) {
          listener.call(currentTarget, event);
        }
      };
      shadowRootWrappedListener.placement = 1;
      shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
    }
    return shadowRootWrappedListener;
  }
  const customElementEventListenerMap = new WeakMap();
  function getWrappedCustomElementListener(listener) {
    if (!isFunction(listener)) {
      throw new TypeError();
    }
    let customElementWrappedListener = customElementEventListenerMap.get(listener);
    if (isUndefined(customElementWrappedListener)) {
      customElementWrappedListener = function(event) {
        const currentTarget = eventCurrentTargetGetter.call(event);
        const actualTarget = getActualTarget(event);
        if (shouldInvokeListener(event, actualTarget, currentTarget)) {
          listener.call(currentTarget, event);
        }
      };
      customElementWrappedListener.placement = 0;
      customElementEventListenerMap.set(listener, customElementWrappedListener);
    }
    return customElementWrappedListener;
  }
  function domListener(evt) {
    let immediatePropagationStopped = false;
    let propagationStopped = false;
    const {
      type,
      stopImmediatePropagation,
      stopPropagation
    } = evt;
    const currentTarget = eventCurrentTargetGetter.call(evt);
    const listenerMap = getEventMap(currentTarget);
    const listeners = listenerMap[type];
    defineProperty(evt, "stopImmediatePropagation", {
      value() {
        immediatePropagationStopped = true;
        stopImmediatePropagation.call(evt);
      },
      writable: true,
      enumerable: true,
      configurable: true
    });
    defineProperty(evt, "stopPropagation", {
      value() {
        propagationStopped = true;
        stopPropagation.call(evt);
      },
      writable: true,
      enumerable: true,
      configurable: true
    });
    const bookkeeping = ArraySlice.call(listeners);
    function invokeListenersByPlacement(placement) {
      forEach.call(bookkeeping, (listener) => {
        if (isFalse(immediatePropagationStopped) && listener.placement === placement) {
          if (ArrayIndexOf.call(listeners, listener) !== -1) {
            listener.call(void 0, evt);
          }
        }
      });
    }
    eventToContextMap.set(evt, 1);
    invokeListenersByPlacement(1);
    if (isFalse(immediatePropagationStopped) && isFalse(propagationStopped)) {
      eventToContextMap.set(evt, 0);
      invokeListenersByPlacement(0);
    }
    eventToContextMap.set(evt, 2);
  }
  function attachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let cmpEventHandlers = listenerMap[type];
    if (isUndefined(cmpEventHandlers)) {
      cmpEventHandlers = listenerMap[type] = [];
    }
    if (ArrayIndexOf.call(cmpEventHandlers, wrappedListener) !== -1) {
      return;
    }
    if (cmpEventHandlers.length === 0) {
      addEventListener2.call(elm, type, domListener);
    }
    ArrayPush.call(cmpEventHandlers, wrappedListener);
  }
  function detachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let p;
    let listeners;
    if (!isUndefined(listeners = listenerMap[type]) && (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
      ArraySplice.call(listeners, p, 1);
      if (listeners.length === 0) {
        removeEventListener2.call(elm, type, domListener);
      }
    }
  }
  function addCustomElementEventListener(type, listener, _options) {
    if (true) {
      if (!isFunction(listener)) {
        throw new TypeError(`Invalid second argument for Element.addEventListener() in ${toString(this)} for event "${type}". Expected an EventListener but received ${listener}.`);
      }
    }
    if (isFunction(listener)) {
      const wrappedListener = getWrappedCustomElementListener(listener);
      attachDOMListener(this, type, wrappedListener);
    }
  }
  function removeCustomElementEventListener(type, listener, _options) {
    if (isFunction(listener)) {
      const wrappedListener = getWrappedCustomElementListener(listener);
      detachDOMListener(this, type, wrappedListener);
    }
  }
  function addShadowRootEventListener(sr, type, listener, _options) {
    if (true) {
      if (!isFunction(listener)) {
        throw new TypeError(`Invalid second argument for ShadowRoot.addEventListener() in ${toString(sr)} for event "${type}". Expected an EventListener but received ${listener}.`);
      }
    }
    if (isFunction(listener)) {
      const elm = getHost(sr);
      const wrappedListener = getWrappedShadowRootListener(listener);
      attachDOMListener(elm, type, wrappedListener);
    }
  }
  function removeShadowRootEventListener(sr, type, listener, _options) {
    if (isFunction(listener)) {
      const elm = getHost(sr);
      const wrappedListener = getWrappedShadowRootListener(listener);
      detachDOMListener(elm, type, wrappedListener);
    }
  }
  const InternalSlot = new WeakMap();
  const {
    createDocumentFragment
  } = document;
  function hasInternalSlot(root) {
    return InternalSlot.has(root);
  }
  function getInternalSlot(root) {
    const record = InternalSlot.get(root);
    if (isUndefined(record)) {
      throw new TypeError();
    }
    return record;
  }
  defineProperty(_Node.prototype, KEY__SHADOW_RESOLVER, {
    set(fn) {
      if (isUndefined(fn))
        return;
      this[KEY__SHADOW_RESOLVER_PRIVATE] = fn;
      setNodeOwnerKey(this, fn.nodeKey);
    },
    get() {
      return this[KEY__SHADOW_RESOLVER_PRIVATE];
    },
    configurable: true,
    enumerable: true
  });
  defineProperty(_globalThis, KEY__IS_NATIVE_SHADOW_ROOT_DEFINED, {
    value: isNativeShadowRootDefined
  });
  if (isUndefined(_globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID])) {
    defineProperty(_globalThis, KEY__NATIVE_GET_ELEMENT_BY_ID, {
      value: getElementById,
      configurable: true
    });
  }
  if (isUndefined(_globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL])) {
    defineProperty(_globalThis, KEY__NATIVE_QUERY_SELECTOR_ALL, {
      value: querySelectorAll,
      configurable: true
    });
  }
  function getShadowRootResolver(node) {
    return node[KEY__SHADOW_RESOLVER];
  }
  function setShadowRootResolver(node, fn) {
    node[KEY__SHADOW_RESOLVER] = fn;
  }
  function isDelegatingFocus(host) {
    return getInternalSlot(host).delegatesFocus;
  }
  function getHost(root) {
    return getInternalSlot(root).host;
  }
  function getShadowRoot(elm) {
    return getInternalSlot(elm).shadowRoot;
  }
  function isSyntheticShadowHost(node) {
    const shadowRootRecord = InternalSlot.get(node);
    return !isUndefined(shadowRootRecord) && node === shadowRootRecord.host;
  }
  function isSyntheticShadowRoot(node) {
    const shadowRootRecord = InternalSlot.get(node);
    return !isUndefined(shadowRootRecord) && node === shadowRootRecord.shadowRoot;
  }
  let uid = 0;
  function attachShadow(elm, options) {
    if (InternalSlot.has(elm)) {
      throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);
    }
    const {
      mode,
      delegatesFocus
    } = options;
    const doc = getOwnerDocument(elm);
    const sr = createDocumentFragment.call(doc);
    const record = {
      mode,
      delegatesFocus: !!delegatesFocus,
      host: elm,
      shadowRoot: sr
    };
    InternalSlot.set(sr, record);
    InternalSlot.set(elm, record);
    const shadowResolver = () => sr;
    const x = shadowResolver.nodeKey = uid++;
    setNodeKey(elm, x);
    setShadowRootResolver(sr, shadowResolver);
    setPrototypeOf(sr, SyntheticShadowRoot.prototype);
    return sr;
  }
  const SyntheticShadowRootDescriptors = {
    constructor: {
      writable: true,
      configurable: true,
      value: SyntheticShadowRoot
    },
    toString: {
      writable: true,
      configurable: true,
      value() {
        return `[object ShadowRoot]`;
      }
    },
    synthetic: {
      writable: false,
      enumerable: false,
      configurable: false,
      value: true
    }
  };
  const ShadowRootDescriptors = {
    activeElement: {
      enumerable: true,
      configurable: true,
      get() {
        const host = getHost(this);
        const doc = getOwnerDocument(host);
        const activeElement = DocumentPrototypeActiveElement.call(doc);
        if (isNull(activeElement)) {
          return activeElement;
        }
        if ((compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) === 0) {
          return null;
        }
        let node = activeElement;
        while (!isNodeOwnedBy(host, node)) {
          node = parentElementGetter.call(node);
        }
        if (isSlotElement(node)) {
          return null;
        }
        return node;
      }
    },
    delegatesFocus: {
      configurable: true,
      get() {
        return getInternalSlot(this).delegatesFocus;
      }
    },
    elementFromPoint: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(left, top) {
        const host = getHost(this);
        const doc = getOwnerDocument(host);
        return fauxElementFromPoint(this, doc, left, top);
      }
    },
    elementsFromPoint: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(left, top) {
        const host = getHost(this);
        const doc = getOwnerDocument(host);
        return fauxElementsFromPoint(this, doc, left, top);
      }
    },
    getSelection: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        throw new Error('Disallowed method "getSelection" on ShadowRoot.');
      }
    },
    host: {
      enumerable: true,
      configurable: true,
      get() {
        return getHost(this);
      }
    },
    mode: {
      configurable: true,
      get() {
        return getInternalSlot(this).mode;
      }
    },
    styleSheets: {
      enumerable: true,
      configurable: true,
      get() {
        throw new Error();
      }
    }
  };
  const eventToShadowRootMap = new WeakMap();
  const NodePatchDescriptors = {
    insertBefore: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(newChild, refChild) {
        insertBefore.call(getHost(this), newChild, refChild);
        return newChild;
      }
    },
    removeChild: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(oldChild) {
        removeChild.call(getHost(this), oldChild);
        return oldChild;
      }
    },
    appendChild: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(newChild) {
        appendChild.call(getHost(this), newChild);
        return newChild;
      }
    },
    replaceChild: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(newChild, oldChild) {
        replaceChild.call(getHost(this), newChild, oldChild);
        return oldChild;
      }
    },
    addEventListener: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(type, listener, options) {
        addShadowRootEventListener(this, type, listener);
      }
    },
    dispatchEvent: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(evt) {
        eventToShadowRootMap.set(evt, this);
        return dispatchEvent.apply(getHost(this), arguments);
      }
    },
    removeEventListener: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(type, listener, options) {
        removeShadowRootEventListener(this, type, listener);
      }
    },
    baseURI: {
      enumerable: true,
      configurable: true,
      get() {
        return getHost(this).baseURI;
      }
    },
    childNodes: {
      enumerable: true,
      configurable: true,
      get() {
        return createStaticNodeList(shadowRootChildNodes(this));
      }
    },
    cloneNode: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        throw new Error('Disallowed method "cloneNode" on ShadowRoot.');
      }
    },
    compareDocumentPosition: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(otherNode) {
        const host = getHost(this);
        if (this === otherNode) {
          return 0;
        } else if (this.contains(otherNode)) {
          return 20;
        } else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
          return 37;
        } else {
          return 35;
        }
      }
    },
    contains: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(otherNode) {
        if (this === otherNode) {
          return true;
        }
        const host = getHost(this);
        return (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 && isNodeOwnedBy(host, otherNode);
      }
    },
    firstChild: {
      enumerable: true,
      configurable: true,
      get() {
        const childNodes = getInternalChildNodes(this);
        return childNodes[0] || null;
      }
    },
    lastChild: {
      enumerable: true,
      configurable: true,
      get() {
        const childNodes = getInternalChildNodes(this);
        return childNodes[childNodes.length - 1] || null;
      }
    },
    hasChildNodes: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        const childNodes = getInternalChildNodes(this);
        return childNodes.length > 0;
      }
    },
    isConnected: {
      enumerable: true,
      configurable: true,
      get() {
        return isConnected.call(getHost(this));
      }
    },
    nextSibling: {
      enumerable: true,
      configurable: true,
      get() {
        return null;
      }
    },
    previousSibling: {
      enumerable: true,
      configurable: true,
      get() {
        return null;
      }
    },
    nodeName: {
      enumerable: true,
      configurable: true,
      get() {
        return "#document-fragment";
      }
    },
    nodeType: {
      enumerable: true,
      configurable: true,
      get() {
        return 11;
      }
    },
    nodeValue: {
      enumerable: true,
      configurable: true,
      get() {
        return null;
      }
    },
    ownerDocument: {
      enumerable: true,
      configurable: true,
      get() {
        return getHost(this).ownerDocument;
      }
    },
    parentElement: {
      enumerable: true,
      configurable: true,
      get() {
        return null;
      }
    },
    parentNode: {
      enumerable: true,
      configurable: true,
      get() {
        return null;
      }
    },
    textContent: {
      enumerable: true,
      configurable: true,
      get() {
        const childNodes = getInternalChildNodes(this);
        let textContent = "";
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          const currentNode = childNodes[i];
          if (currentNode.nodeType !== COMMENT_NODE) {
            textContent += getTextContent(currentNode);
          }
        }
        return textContent;
      },
      set(v) {
        const host = getHost(this);
        textContextSetter.call(host, v);
      }
    },
    getRootNode: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(options) {
        return !isUndefined(options) && isTrue(options.composed) ? getHost(this).getRootNode(options) : this;
      }
    }
  };
  const ElementPatchDescriptors = {
    innerHTML: {
      enumerable: true,
      configurable: true,
      get() {
        const childNodes = getInternalChildNodes(this);
        let innerHTML = "";
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          innerHTML += getOuterHTML(childNodes[i]);
        }
        return innerHTML;
      },
      set(v) {
        const host = getHost(this);
        innerHTMLSetter.call(host, v);
      }
    }
  };
  const ParentNodePatchDescriptors = {
    childElementCount: {
      enumerable: true,
      configurable: true,
      get() {
        return this.children.length;
      }
    },
    children: {
      enumerable: true,
      configurable: true,
      get() {
        return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), (elm) => elm instanceof Element));
      }
    },
    firstElementChild: {
      enumerable: true,
      configurable: true,
      get() {
        return this.children[0] || null;
      }
    },
    lastElementChild: {
      enumerable: true,
      configurable: true,
      get() {
        const {
          children
        } = this;
        return children.item(children.length - 1) || null;
      }
    },
    getElementById: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        throw new Error('Disallowed method "getElementById" on ShadowRoot.');
      }
    },
    querySelector: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(selectors) {
        return shadowRootQuerySelector(this, selectors);
      }
    },
    querySelectorAll: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(selectors) {
        return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
      }
    }
  };
  assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);
  function SyntheticShadowRoot() {
    throw new TypeError("Illegal constructor");
  }
  SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);
  defineProperty(SyntheticShadowRoot, Symbol.hasInstance, {
    value: function(object) {
      return isObject(object) && !isNull(object) && (isInstanceOfNativeShadowRoot(object) || getPrototypeOf(object) === SyntheticShadowRoot.prototype);
    }
  });
  function getIE11FakeShadowRootPlaceholder(host) {
    const shadowRoot = getShadowRoot(host);
    let c = shadowRoot.$$placeholder$$;
    if (!isUndefined(c)) {
      return c;
    }
    const doc = getOwnerDocument(host);
    c = shadowRoot.$$placeholder$$ = createComment.call(doc, "");
    defineProperties(c, {
      childNodes: {
        get() {
          return shadowRoot.childNodes;
        },
        enumerable: true,
        configurable: true
      },
      tagName: {
        get() {
          return `#shadow-root (${shadowRoot.mode})`;
        },
        enumerable: true,
        configurable: true
      }
    });
    return c;
  }
  function pathComposer(startNode, composed) {
    const composedPath2 = [];
    let startRoot;
    if (startNode instanceof Window) {
      startRoot = startNode;
    } else if (startNode instanceof _Node) {
      startRoot = startNode.getRootNode();
    } else {
      return composedPath2;
    }
    let current = startNode;
    while (!isNull(current)) {
      composedPath2.push(current);
      if (current instanceof Element || current instanceof Text) {
        const assignedSlot = current.assignedSlot;
        if (!isNull(assignedSlot)) {
          current = assignedSlot;
        } else {
          current = current.parentNode;
        }
      } else if ((isSyntheticShadowRoot(current) || isInstanceOfNativeShadowRoot(current)) && (composed || current !== startRoot)) {
        current = current.host;
      } else if (current instanceof _Node) {
        current = current.parentNode;
      } else {
        current = null;
      }
    }
    let doc;
    if (startNode instanceof Window) {
      doc = startNode.document;
    } else {
      doc = getOwnerDocument(startNode);
    }
    if (composedPath2[composedPath2.length - 1] === doc) {
      composedPath2.push(window);
    }
    return composedPath2;
  }
  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  function retarget(refNode, path) {
    if (isNull(refNode)) {
      return null;
    }
    const refNodePath = pathComposer(refNode, true);
    const p$ = path;
    for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
      ancestor = p$[i];
      root = ancestor instanceof Window ? ancestor : ancestor.getRootNode();
      if (root !== lastRoot) {
        rootIdx = refNodePath.indexOf(root);
        lastRoot = root;
      }
      if (!isSyntheticShadowRoot(root) || !isUndefined(rootIdx) && rootIdx > -1) {
        return ancestor;
      }
    }
    return null;
  }
  function fauxElementFromPoint(context, doc, left, top) {
    const element = elementFromPoint.call(doc, left, top);
    if (isNull(element)) {
      return element;
    }
    return retarget(context, pathComposer(element, true));
  }
  function elemFromPoint(left, top) {
    return fauxElementFromPoint(this, this, left, top);
  }
  Document.prototype.elementFromPoint = elemFromPoint;
  function elemsFromPoint(left, top) {
    return fauxElementsFromPoint(this, this, left, top);
  }
  Document.prototype.elementsFromPoint = elemsFromPoint;
  defineProperty(Document.prototype, "activeElement", {
    get() {
      let node = DocumentPrototypeActiveElement.call(this);
      if (isNull(node)) {
        return node;
      }
      while (!isUndefined(getNodeOwnerKey(node))) {
        node = parentElementGetter.call(node);
        if (isNull(node)) {
          return null;
        }
      }
      if (node.tagName === "HTML") {
        node = this.body;
      }
      return node;
    },
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, "getElementById", {
    value() {
      const elm = getElementById.apply(this, ArraySlice.call(arguments));
      if (isNull(elm)) {
        return null;
      }
      return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, "querySelector", {
    value() {
      const elements = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFind.call(elements, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return !isUndefined(filtered) ? filtered : null;
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, "querySelectorAll", {
    value() {
      const elements = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticNodeList(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, "getElementsByClassName", {
    value() {
      const elements = arrayFromCollection(getElementsByClassName.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, "getElementsByTagName", {
    value() {
      const elements = arrayFromCollection(getElementsByTagName.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, "getElementsByTagNameNS", {
    value() {
      const elements = arrayFromCollection(getElementsByTagNameNS.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(getOwnPropertyDescriptor(HTMLDocument.prototype, "getElementsByName") ? HTMLDocument.prototype : Document.prototype, "getElementsByName", {
    value() {
      const elements = arrayFromCollection(getElementsByName.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticNodeList(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(window, "ShadowRoot", {
    value: SyntheticShadowRoot,
    configurable: true,
    writable: true
  });
  const composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "composed");
  function detect$3() {
    if (!composedDescriptor) {
      return false;
    }
    let clickEvent = new Event("click");
    const button = document.createElement("button");
    button.addEventListener("click", (event) => clickEvent = event);
    button.click();
    return !composedDescriptor.get.call(clickEvent);
  }
  const originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "click");
  function handleClick(event) {
    Object.defineProperty(event, "composed", {
      configurable: true,
      enumerable: true,
      get() {
        return true;
      }
    });
  }
  function apply$3() {
    HTMLElement.prototype.click = function() {
      addEventListener2.call(this, "click", handleClick);
      try {
        originalClickDescriptor.value.call(this);
      } finally {
        removeEventListener2.call(this, "click", handleClick);
      }
    };
  }
  if (detect$3()) {
    apply$3();
  }
  function detect$2() {
    return new Event("test", {
      composed: true
    }).composed !== true;
  }
  function apply$2() {
    const composedEvents = assign(create(null), {
      beforeinput: 1,
      blur: 1,
      click: 1,
      compositionend: 1,
      compositionstart: 1,
      compositionupdate: 1,
      copy: 1,
      cut: 1,
      dblclick: 1,
      DOMActivate: 1,
      DOMFocusIn: 1,
      DOMFocusOut: 1,
      drag: 1,
      dragend: 1,
      dragenter: 1,
      dragleave: 1,
      dragover: 1,
      dragstart: 1,
      drop: 1,
      focus: 1,
      focusin: 1,
      focusout: 1,
      gotpointercapture: 1,
      input: 1,
      keydown: 1,
      keypress: 1,
      keyup: 1,
      lostpointercapture: 1,
      mousedown: 1,
      mouseenter: 1,
      mouseleave: 1,
      mousemove: 1,
      mouseout: 1,
      mouseover: 1,
      mouseup: 1,
      paste: 1,
      pointercancel: 1,
      pointerdown: 1,
      pointerenter: 1,
      pointerleave: 1,
      pointermove: 1,
      pointerout: 1,
      pointerover: 1,
      pointerup: 1,
      touchcancel: 1,
      touchend: 1,
      touchmove: 1,
      touchstart: 1,
      wheel: 1
    });
    const EventConstructor = Event;
    function PatchedEvent(type, eventInitDict) {
      const event = new EventConstructor(type, eventInitDict);
      const isComposed = !!(eventInitDict && eventInitDict.composed);
      Object.defineProperties(event, {
        composed: {
          get() {
            return isComposed;
          },
          configurable: true,
          enumerable: true
        }
      });
      return event;
    }
    PatchedEvent.prototype = EventConstructor.prototype;
    PatchedEvent.AT_TARGET = EventConstructor.AT_TARGET;
    PatchedEvent.BUBBLING_PHASE = EventConstructor.BUBBLING_PHASE;
    PatchedEvent.CAPTURING_PHASE = EventConstructor.CAPTURING_PHASE;
    PatchedEvent.NONE = EventConstructor.NONE;
    window.Event = PatchedEvent;
    Object.defineProperties(Event.prototype, {
      composed: {
        get() {
          const {
            type
          } = this;
          return composedEvents[type] === 1;
        },
        configurable: true,
        enumerable: true
      }
    });
  }
  if (detect$2()) {
    apply$2();
  }
  const CustomEventConstructor = CustomEvent;
  function PatchedCustomEvent(type, eventInitDict) {
    const event = new CustomEventConstructor(type, eventInitDict);
    const isComposed = !!(eventInitDict && eventInitDict.composed);
    Object.defineProperties(event, {
      composed: {
        get() {
          return isComposed;
        },
        configurable: true,
        enumerable: true
      }
    });
    return event;
  }
  PatchedCustomEvent.prototype = CustomEventConstructor.prototype;
  window.CustomEvent = PatchedCustomEvent;
  if (typeof ClipboardEvent !== "undefined") {
    const isComposedType = assign(create(null), {
      copy: 1,
      cut: 1,
      paste: 1
    });
    defineProperties(ClipboardEvent.prototype, {
      composed: {
        get() {
          const {
            type
          } = this;
          return isComposedType[type] === 1;
        },
        configurable: true,
        enumerable: true
      }
    });
  }
  function detect$1() {
    const hasIframe = typeof HTMLIFrameElement !== "undefined";
    const isCompat = typeof Proxy !== "undefined" && isTrue(Proxy.isCompat);
    return hasIframe && isCompat;
  }
  function apply$1() {
    const desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, "contentWindow");
    const {
      get: originalGetter
    } = desc;
    desc.get = function() {
      const original = originalGetter.call(this);
      if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {
        return original;
      }
      return wrapIframeWindow(original);
    };
    defineProperty(HTMLIFrameElement.prototype, "contentWindow", desc);
  }
  function wrapIframeWindow(win) {
    return {
      addEventListener() {
        return win.addEventListener.apply(win, arguments);
      },
      blur() {
        return win.blur.apply(win, arguments);
      },
      close() {
        return win.close.apply(win, arguments);
      },
      focus() {
        return win.focus.apply(win, arguments);
      },
      postMessage() {
        return win.postMessage.apply(win, arguments);
      },
      removeEventListener() {
        return win.removeEventListener.apply(win, arguments);
      },
      get closed() {
        return win.closed;
      },
      get frames() {
        return win.frames;
      },
      get length() {
        return win.length;
      },
      get location() {
        return win.location;
      },
      set location(value) {
        win.location = value;
      },
      get opener() {
        return win.opener;
      },
      get parent() {
        return win.parent;
      },
      get self() {
        return win.self;
      },
      get top() {
        return win.top;
      },
      get window() {
        return win.window;
      }
    };
  }
  if (detect$1()) {
    apply$1();
  }
  const OriginalMutationObserver = MutationObserver;
  const {
    disconnect: originalDisconnect,
    observe: originalObserve,
    takeRecords: originalTakeRecords
  } = OriginalMutationObserver.prototype;
  const wrapperLookupField = "$$lwcObserverCallbackWrapper$$";
  const observerLookupField = "$$lwcNodeObservers$$";
  const observerToNodesMap = new WeakMap();
  function getNodeObservers(node) {
    return node[observerLookupField];
  }
  function setNodeObservers(node, observers) {
    node[observerLookupField] = observers;
  }
  function retargetMutationRecord(originalRecord) {
    const {
      addedNodes,
      removedNodes,
      target,
      type
    } = originalRecord;
    const retargetedRecord = create(MutationRecord.prototype);
    defineProperties(retargetedRecord, {
      addedNodes: {
        get() {
          return addedNodes;
        },
        enumerable: true,
        configurable: true
      },
      removedNodes: {
        get() {
          return removedNodes;
        },
        enumerable: true,
        configurable: true
      },
      type: {
        get() {
          return type;
        },
        enumerable: true,
        configurable: true
      },
      target: {
        get() {
          return target.shadowRoot;
        },
        enumerable: true,
        configurable: true
      }
    });
    return retargetedRecord;
  }
  function isQualifiedObserver(observer2, target) {
    let parentNode = target;
    while (!isNull(parentNode)) {
      const parentNodeObservers = getNodeObservers(parentNode);
      if (!isUndefined(parentNodeObservers) && (parentNodeObservers[0] === observer2 || ArrayIndexOf.call(parentNodeObservers, observer2) !== -1)) {
        return true;
      }
      parentNode = parentNode.parentNode;
    }
    return false;
  }
  function filterMutationRecords(mutations, observer2) {
    return ArrayReduce.call(mutations, (filteredSet, record) => {
      const {
        target,
        addedNodes,
        removedNodes,
        type
      } = record;
      if (type === "childList" && !isUndefined(getNodeKey(target))) {
        if (addedNodes.length > 0) {
          const sampleNode = addedNodes[0];
          if (isQualifiedObserver(observer2, sampleNode)) {
            const nodeObservers = getNodeObservers(target);
            if (nodeObservers && (nodeObservers[0] === observer2 || ArrayIndexOf.call(nodeObservers, observer2) !== -1)) {
              ArrayPush.call(filteredSet, record);
            } else {
              ArrayPush.call(filteredSet, retargetMutationRecord(record));
            }
          }
        } else {
          const shadowRoot = target.shadowRoot;
          const sampleNode = removedNodes[0];
          if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) && isQualifiedObserver(observer2, target)) {
            ArrayPush.call(filteredSet, record);
          } else if (shadowRoot) {
            const shadowRootObservers = getNodeObservers(shadowRoot);
            if (shadowRootObservers && (shadowRootObservers[0] === observer2 || ArrayIndexOf.call(shadowRootObservers, observer2) !== -1)) {
              ArrayPush.call(filteredSet, retargetMutationRecord(record));
            }
          }
        }
      } else {
        if (isQualifiedObserver(observer2, target)) {
          ArrayPush.call(filteredSet, record);
        }
      }
      return filteredSet;
    }, []);
  }
  function getWrappedCallback(callback) {
    let wrappedCallback = callback[wrapperLookupField];
    if (isUndefined(wrappedCallback)) {
      wrappedCallback = callback[wrapperLookupField] = (mutations, observer2) => {
        const filteredRecords = filterMutationRecords(mutations, observer2);
        if (filteredRecords.length === 0) {
          return;
        }
        callback.call(observer2, filteredRecords, observer2);
      };
    }
    return wrappedCallback;
  }
  function PatchedMutationObserver(callback) {
    const wrappedCallback = getWrappedCallback(callback);
    const observer2 = new OriginalMutationObserver(wrappedCallback);
    return observer2;
  }
  function patchedDisconnect() {
    originalDisconnect.call(this);
    const observedNodes = observerToNodesMap.get(this);
    if (!isUndefined(observedNodes)) {
      forEach.call(observedNodes, (observedNode) => {
        const observers = observedNode[observerLookupField];
        if (!isUndefined(observers)) {
          const index = ArrayIndexOf.call(observers, this);
          if (index !== -1) {
            ArraySplice.call(observers, index, 1);
          }
        }
      });
      observedNodes.length = 0;
    }
  }
  function patchedObserve(target, options) {
    let targetObservers = getNodeObservers(target);
    if (isUndefined(targetObservers)) {
      targetObservers = [];
      setNodeObservers(target, targetObservers);
    }
    if (ArrayIndexOf.call(targetObservers, this) === -1) {
      ArrayPush.call(targetObservers, this);
    }
    if (isSyntheticShadowRoot(target)) {
      target = target.host;
    }
    if (observerToNodesMap.has(this)) {
      const observedNodes = observerToNodesMap.get(this);
      if (ArrayIndexOf.call(observedNodes, target) === -1) {
        ArrayPush.call(observedNodes, target);
      }
    } else {
      observerToNodesMap.set(this, [target]);
    }
    return originalObserve.call(this, target, options);
  }
  function patchedTakeRecords() {
    return filterMutationRecords(originalTakeRecords.call(this), this);
  }
  PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
  PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
  PatchedMutationObserver.prototype.observe = patchedObserve;
  PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
  defineProperty(window, "MutationObserver", {
    value: PatchedMutationObserver,
    configurable: true,
    writable: true
  });
  function patchedAddEventListener$1(type, listener, optionsOrCapture) {
    if (isSyntheticShadowHost(this)) {
      return addCustomElementEventListener.apply(this, arguments);
    }
    if (arguments.length < 2) {
      const args = ArraySlice.call(arguments);
      if (args.length > 1) {
        args[1] = getEventListenerWrapper(args[1]);
      }
      return addEventListener2.apply(this, args);
    }
    const wrappedListener = getEventListenerWrapper(listener);
    return addEventListener2.call(this, type, wrappedListener, optionsOrCapture);
  }
  function patchedRemoveEventListener$1(_type, _listener, _optionsOrCapture) {
    if (isSyntheticShadowHost(this)) {
      return removeCustomElementEventListener.apply(this, arguments);
    }
    const args = ArraySlice.call(arguments);
    if (arguments.length > 1) {
      args[1] = getEventListenerWrapper(args[1]);
    }
    removeEventListener2.apply(this, args);
    removeEventListener2.apply(this, arguments);
  }
  defineProperties(eventTargetPrototype, {
    addEventListener: {
      value: patchedAddEventListener$1,
      enumerable: true,
      writable: true,
      configurable: true
    },
    removeEventListener: {
      value: patchedRemoveEventListener$1,
      enumerable: true,
      writable: true,
      configurable: true
    }
  });
  function detect() {
    return typeof EventTarget === "undefined";
  }
  function patchedAddEventListener(_type, _listener, _options) {
    if (arguments.length > 1) {
      const args = ArraySlice.call(arguments);
      args[1] = getEventListenerWrapper(args[1]);
      return windowAddEventListener.apply(this, args);
    }
    return windowAddEventListener.apply(this, arguments);
  }
  function patchedRemoveEventListener(_type, _listener, _options) {
    if (arguments.length > 1) {
      const args = ArraySlice.call(arguments);
      args[1] = getEventListenerWrapper(args[1]);
      windowRemoveEventListener.apply(this, args);
    }
    windowRemoveEventListener.apply(this, arguments);
  }
  function apply() {
    defineProperties(Window.prototype, {
      addEventListener: {
        value: patchedAddEventListener,
        enumerable: true,
        writable: true,
        configurable: true
      },
      removeEventListener: {
        value: patchedRemoveEventListener,
        enumerable: true,
        writable: true,
        configurable: true
      }
    });
  }
  if (detect()) {
    apply();
  }
  function patchedCurrentTargetGetter() {
    const currentTarget = eventCurrentTargetGetter.call(this);
    if (isNull(currentTarget)) {
      return null;
    }
    if (eventToContextMap.get(this) === 1) {
      return getShadowRoot(currentTarget);
    }
    return currentTarget;
  }
  function patchedTargetGetter() {
    const originalTarget = eventTargetGetter.call(this);
    if (!(originalTarget instanceof _Node)) {
      return originalTarget;
    }
    const doc = getOwnerDocument(originalTarget);
    const composedPath2 = pathComposer(originalTarget, this.composed);
    const originalCurrentTarget = eventCurrentTargetGetter.call(this);
    if (!(originalCurrentTarget instanceof _Node)) {
      if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
        return originalTarget;
      }
      return retarget(doc, composedPath2);
    } else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
      if (isUndefined(getNodeOwnerKey(originalTarget))) {
        return originalTarget;
      }
      return retarget(doc, composedPath2);
    }
    let actualCurrentTarget = originalCurrentTarget;
    let actualPath = composedPath2;
    if (isSyntheticShadowHost(originalCurrentTarget)) {
      const context = eventToContextMap.get(this);
      if (context === 1) {
        actualCurrentTarget = getShadowRoot(originalCurrentTarget);
      }
    }
    if (isSyntheticShadowHost(originalTarget) && eventToShadowRootMap.has(this)) {
      actualPath = pathComposer(getShadowRoot(originalTarget), this.composed);
    }
    return retarget(actualCurrentTarget, actualPath);
  }
  function patchedComposedPathValue() {
    const originalTarget = eventTargetGetter.call(this);
    if (!(originalTarget instanceof _Node)) {
      return [];
    }
    const hasShadowRoot = Boolean(originalTarget.shadowRoot);
    const hasSyntheticShadowRootAttached = hasInternalSlot(originalTarget);
    if (hasShadowRoot && !hasSyntheticShadowRootAttached) {
      return composedPath.call(this);
    }
    const originalCurrentTarget = eventCurrentTargetGetter.call(this);
    if (isNull(originalCurrentTarget)) {
      return [];
    }
    let actualTarget = originalTarget;
    if (isSyntheticShadowHost(originalTarget) && eventToShadowRootMap.has(this)) {
      actualTarget = getShadowRoot(originalTarget);
    }
    return pathComposer(actualTarget, this.composed);
  }
  defineProperties(Event.prototype, {
    target: {
      get: patchedTargetGetter,
      enumerable: true,
      configurable: true
    },
    currentTarget: {
      get: patchedCurrentTargetGetter,
      enumerable: true,
      configurable: true
    },
    composedPath: {
      value: patchedComposedPathValue,
      writable: true,
      enumerable: true,
      configurable: true
    },
    srcElement: {
      get: patchedTargetGetter,
      enumerable: true,
      configurable: true
    },
    path: {
      get: patchedComposedPathValue,
      enumerable: true,
      configurable: true
    }
  });
  function retargetRelatedTarget(Ctor) {
    const relatedTargetGetter = getOwnPropertyDescriptor(Ctor.prototype, "relatedTarget").get;
    defineProperty(Ctor.prototype, "relatedTarget", {
      get() {
        const relatedTarget = relatedTargetGetter.call(this);
        if (isNull(relatedTarget)) {
          return null;
        }
        if (!(relatedTarget instanceof _Node) || !isNodeShadowed(relatedTarget)) {
          return relatedTarget;
        }
        let pointOfReference = eventCurrentTargetGetter.call(this);
        if (isNull(pointOfReference)) {
          pointOfReference = getOwnerDocument(relatedTarget);
        }
        return retarget(pointOfReference, pathComposer(relatedTarget, true));
      },
      enumerable: true,
      configurable: true
    });
  }
  retargetRelatedTarget(FocusEvent);
  retargetRelatedTarget(MouseEvent);
  const assignedSlotGetter = hasOwnProperty.call(Text.prototype, "assignedSlot") ? getOwnPropertyDescriptor(Text.prototype, "assignedSlot").get : () => null;
  let observer;
  const observerConfig = {
    childList: true
  };
  const SlotChangeKey = new WeakMap();
  function initSlotObserver() {
    return new MO((mutations) => {
      const slots = [];
      forEach.call(mutations, (mutation) => {
        if (true) {
          assert.invariant(mutation.type === "childList", `Invalid mutation type: ${mutation.type}. This mutation handler for slots should only handle "childList" mutations.`);
        }
        const {
          target: slot
        } = mutation;
        if (ArrayIndexOf.call(slots, slot) === -1) {
          ArrayPush.call(slots, slot);
          dispatchEvent.call(slot, new CustomEvent("slotchange"));
        }
      });
    });
  }
  function getFilteredSlotFlattenNodes(slot) {
    const childNodes = arrayFromCollection(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, (seed, child) => {
      if (child instanceof Element && isSlotElement(child)) {
        ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
      } else {
        ArrayPush.call(seed, child);
      }
      return seed;
    }, []);
  }
  function assignedSlotGetterPatched() {
    const parentNode = parentNodeGetter.call(this);
    if (parentNode instanceof Element) {
      const sr = shadowRootGetter.call(parentNode);
      if (isInstanceOfNativeShadowRoot(sr)) {
        if (this instanceof Text) {
          return assignedSlotGetter.call(this);
        }
        return assignedSlotGetter$1.call(this);
      }
    }
    if (!isNull(parentNode) && isSlotElement(parentNode) && getNodeOwnerKey(parentNode) !== getNodeOwnerKey(this)) {
      return parentNode;
    }
    return null;
  }
  defineProperties(HTMLSlotElement.prototype, {
    addEventListener: {
      value(type, listener, options) {
        HTMLElement.prototype.addEventListener.call(this, type, listener, options);
        if (type === "slotchange" && !SlotChangeKey.get(this)) {
          SlotChangeKey.set(this, true);
          if (!observer) {
            observer = initSlotObserver();
          }
          MutationObserverObserve.call(observer, this, observerConfig);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    assignedElements: {
      value(options) {
        if (isNodeShadowed(this)) {
          const flatten = !isUndefined(options) && isTrue(options.flatten);
          const nodes = flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
          return ArrayFilter.call(nodes, (node) => node instanceof Element);
        } else {
          return assignedElements.apply(this, ArraySlice.call(arguments));
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    assignedNodes: {
      value(options) {
        if (isNodeShadowed(this)) {
          const flatten = !isUndefined(options) && isTrue(options.flatten);
          return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
        } else {
          return assignedNodes.apply(this, ArraySlice.call(arguments));
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    name: {
      get() {
        const name = getAttribute.call(this, "name");
        return isNull(name) ? "" : name;
      },
      set(value) {
        setAttribute.call(this, "name", value);
      },
      enumerable: true,
      configurable: true
    },
    childNodes: {
      get() {
        if (isNodeShadowed(this)) {
          const owner = getNodeOwner(this);
          const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
          return createStaticNodeList(childNodes);
        }
        return childNodesGetter.call(this);
      },
      enumerable: true,
      configurable: true
    }
  });
  defineProperties(Text.prototype, {
    assignedSlot: {
      get: assignedSlotGetterPatched,
      enumerable: true,
      configurable: true
    }
  });
  function getNonPatchedFilteredArrayOfNodes(context, unfilteredNodes) {
    let filtered;
    const ownerKey = getNodeOwnerKey(context);
    if (!isUndefined(ownerKey)) {
      if (isSyntheticShadowHost(context)) {
        const owner = getNodeOwner(context);
        if (isNull(owner)) {
          filtered = [];
        } else if (getNodeKey(context)) {
          filtered = getAllSlottedMatches(context, unfilteredNodes);
        } else {
          filtered = getAllMatches(owner, unfilteredNodes);
        }
      } else {
        filtered = ArrayFilter.call(unfilteredNodes, (elm) => getNodeNearestOwnerKey(elm) === ownerKey);
      }
    } else if (context instanceof HTMLBodyElement) {
      filtered = ArrayFilter.call(unfilteredNodes, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
    } else {
      filtered = ArraySlice.call(unfilteredNodes);
    }
    return filtered;
  }
  function innerHTMLGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    let innerHTML = "";
    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      innerHTML += getOuterHTML(childNodes[i]);
    }
    return innerHTML;
  }
  function outerHTMLGetterPatched() {
    return getOuterHTML(this);
  }
  function attachShadowPatched(options) {
    if (options[KEY__SYNTHETIC_MODE]) {
      return attachShadow(this, options);
    }
    return attachShadow$1.call(this, options);
  }
  function shadowRootGetterPatched() {
    if (isSyntheticShadowHost(this)) {
      const shadow = getShadowRoot(this);
      if (shadow.mode === "open") {
        return shadow;
      }
    }
    return shadowRootGetter.call(this);
  }
  function childrenGetterPatched() {
    const owner = getNodeOwner(this);
    const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
    return createStaticHTMLCollection(ArrayFilter.call(childNodes, (node) => node instanceof Element));
  }
  function childElementCountGetterPatched() {
    return this.children.length;
  }
  function firstElementChildGetterPatched() {
    return this.children[0] || null;
  }
  function lastElementChildGetterPatched() {
    const {
      children
    } = this;
    return children.item(children.length - 1) || null;
  }
  defineProperties(Element.prototype, {
    innerHTML: {
      get() {
        if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
          return innerHTMLGetterPatched.call(this);
        }
        return innerHTMLGetter.call(this);
      },
      set(v) {
        innerHTMLSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    },
    outerHTML: {
      get() {
        if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
          return outerHTMLGetterPatched.call(this);
        }
        return outerHTMLGetter.call(this);
      },
      set(v) {
        outerHTMLSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    },
    attachShadow: {
      value: attachShadowPatched,
      enumerable: true,
      writable: true,
      configurable: true
    },
    shadowRoot: {
      get: shadowRootGetterPatched,
      enumerable: true,
      configurable: true
    },
    children: {
      get() {
        if (hasMountedChildren(this)) {
          return childrenGetterPatched.call(this);
        }
        return childrenGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    childElementCount: {
      get() {
        if (hasMountedChildren(this)) {
          return childElementCountGetterPatched.call(this);
        }
        return childElementCountGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    firstElementChild: {
      get() {
        if (hasMountedChildren(this)) {
          return firstElementChildGetterPatched.call(this);
        }
        return firstElementChildGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    lastElementChild: {
      get() {
        if (hasMountedChildren(this)) {
          return lastElementChildGetterPatched.call(this);
        }
        return lastElementChildGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    assignedSlot: {
      get: assignedSlotGetterPatched,
      enumerable: true,
      configurable: true
    }
  });
  if (hasOwnProperty.call(HTMLElement.prototype, "innerHTML")) {
    defineProperty(HTMLElement.prototype, "innerHTML", getOwnPropertyDescriptor(Element.prototype, "innerHTML"));
  }
  if (hasOwnProperty.call(HTMLElement.prototype, "outerHTML")) {
    defineProperty(HTMLElement.prototype, "outerHTML", getOwnPropertyDescriptor(Element.prototype, "outerHTML"));
  }
  if (hasOwnProperty.call(HTMLElement.prototype, "children")) {
    defineProperty(HTMLElement.prototype, "children", getOwnPropertyDescriptor(Element.prototype, "children"));
  }
  function querySelectorPatched() {
    const nodeList = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
    if (isSyntheticShadowHost(this)) {
      const owner = getNodeOwner(this);
      if (!isUndefined(getNodeKey(this))) {
        return getFirstSlottedMatch(this, nodeList);
      } else if (isNull(owner)) {
        return null;
      } else {
        return getFirstMatch(owner, nodeList);
      }
    } else if (isNodeShadowed(this)) {
      const ownerKey = getNodeOwnerKey(this);
      if (!isUndefined(ownerKey)) {
        const elm = ArrayFind.call(nodeList, (elm2) => getNodeNearestOwnerKey(elm2) === ownerKey);
        return isUndefined(elm) ? null : elm;
      } else {
        return nodeList.length === 0 ? null : nodeList[0];
      }
    } else {
      if (!(this instanceof HTMLBodyElement)) {
        const elm2 = nodeList[0];
        return isUndefined(elm2) ? null : elm2;
      }
      const elm = ArrayFind.call(nodeList, (elm2) => isUndefined(getNodeOwnerKey(elm2)) || isGlobalPatchingSkipped(this));
      return isUndefined(elm) ? null : elm;
    }
  }
  function getFilteredArrayOfNodes(context, unfilteredNodes) {
    let filtered;
    if (isSyntheticShadowHost(context)) {
      const owner = getNodeOwner(context);
      if (!isUndefined(getNodeKey(context))) {
        filtered = getAllSlottedMatches(context, unfilteredNodes);
      } else if (isNull(owner)) {
        filtered = [];
      } else {
        filtered = getAllMatches(owner, unfilteredNodes);
      }
    } else if (isNodeShadowed(context)) {
      const ownerKey = getNodeOwnerKey(context);
      if (!isUndefined(ownerKey)) {
        filtered = ArrayFilter.call(unfilteredNodes, (elm) => getNodeNearestOwnerKey(elm) === ownerKey);
      } else {
        filtered = ArraySlice.call(unfilteredNodes);
      }
    } else {
      if (context instanceof HTMLBodyElement) {
        filtered = ArrayFilter.call(unfilteredNodes, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
      } else {
        filtered = ArraySlice.call(unfilteredNodes);
      }
    }
    return filtered;
  }
  defineProperties(Element.prototype, {
    querySelector: {
      value: querySelectorPatched,
      writable: true,
      enumerable: true,
      configurable: true
    },
    querySelectorAll: {
      value() {
        const nodeList = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
        const filteredResults = getFilteredArrayOfNodes(this, nodeList);
        return createStaticNodeList(filteredResults);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });
  if (true) {
    defineProperties(Element.prototype, {
      getElementsByClassName: {
        value() {
          const elements = arrayFromCollection(getElementsByClassName$1.apply(this, ArraySlice.call(arguments)));
          return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
        },
        writable: true,
        enumerable: true,
        configurable: true
      },
      getElementsByTagName: {
        value() {
          const elements = arrayFromCollection(getElementsByTagName$1.apply(this, ArraySlice.call(arguments)));
          return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
        },
        writable: true,
        enumerable: true,
        configurable: true
      },
      getElementsByTagNameNS: {
        value() {
          const elements = arrayFromCollection(getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments)));
          return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
        },
        writable: true,
        enumerable: true,
        configurable: true
      }
    });
  }
  if (hasOwnProperty.call(HTMLElement.prototype, "getElementsByClassName")) {
    defineProperty(HTMLElement.prototype, "getElementsByClassName", getOwnPropertyDescriptor(Element.prototype, "getElementsByClassName"));
  }
  const FocusableSelector = `
    [contenteditable],
    [tabindex],
    a[href],
    area[href],
    audio[controls],
    button,
    iframe,
    input,
    select,
    textarea,
    video[controls]
`;
  const formElementTagNames = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA"]);
  function filterSequentiallyFocusableElements(elements) {
    return elements.filter((element) => {
      if (hasAttribute.call(element, "tabindex")) {
        return getAttribute.call(element, "tabindex") === "0";
      }
      if (formElementTagNames.has(tagNameGetter.call(element))) {
        return !hasAttribute.call(element, "disabled");
      }
      return true;
    });
  }
  const DidAddMouseEventListeners = new WeakMap();
  function isVisible(element) {
    const {
      width,
      height
    } = getBoundingClientRect.call(element);
    const noZeroSize = width > 0 || height > 0;
    const isAreaElement = element.tagName === "AREA";
    return (noZeroSize || isAreaElement) && getComputedStyle(element).visibility !== "hidden";
  }
  function isTabbable(element) {
    if (isSyntheticShadowHost(element) && isDelegatingFocus(element)) {
      return false;
    }
    return matches.call(element, FocusableSelector) && isVisible(element);
  }
  function hostElementFocus() {
    const _rootNode = this.getRootNode();
    if (_rootNode === this) {
      const focusable = querySelector.call(this, FocusableSelector);
      if (!isNull(focusable)) {
        focusable.focus.apply(focusable, arguments);
      }
      return;
    }
    const rootNode = _rootNode;
    if (rootNode.activeElement === this) {
      return;
    }
    const focusables = arrayFromCollection(querySelectorAll$1.call(this, FocusableSelector));
    let didFocus = false;
    while (!didFocus && focusables.length !== 0) {
      const focusable = focusables.shift();
      focusable.focus.apply(focusable, arguments);
      const currentRootNode = focusable.getRootNode();
      didFocus = currentRootNode.activeElement === focusable;
    }
  }
  function getTabbableSegments(host) {
    const doc = getOwnerDocument(host);
    const all = filterSequentiallyFocusableElements(arrayFromCollection(querySelectorAll.call(doc, FocusableSelector)));
    const inner = filterSequentiallyFocusableElements(arrayFromCollection(querySelectorAll$1.call(host, FocusableSelector)));
    if (true) {
      assert.invariant(getAttribute.call(host, "tabindex") === "-1" || isDelegatingFocus(host), `The focusin event is only relevant when the tabIndex property is -1 on the host.`);
    }
    const firstChild = inner[0];
    const lastChild = inner[inner.length - 1];
    const hostIndex = ArrayIndexOf.call(all, host);
    const firstChildIndex = hostIndex > -1 ? hostIndex : ArrayIndexOf.call(all, firstChild);
    const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : ArrayIndexOf.call(all, lastChild) + 1;
    const prev = ArraySlice.call(all, 0, firstChildIndex);
    const next = ArraySlice.call(all, lastChildIndex);
    return {
      prev,
      inner,
      next
    };
  }
  function getActiveElement(host) {
    const doc = getOwnerDocument(host);
    const activeElement = DocumentPrototypeActiveElement.call(doc);
    if (isNull(activeElement)) {
      return activeElement;
    }
    return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 ? activeElement : null;
  }
  function relatedTargetPosition(host, relatedTarget) {
    const pos = compareDocumentPosition.call(host, relatedTarget);
    if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
      return 0;
    } else if (pos & DOCUMENT_POSITION_PRECEDING) {
      return 1;
    } else if (pos & DOCUMENT_POSITION_FOLLOWING) {
      return 2;
    }
    return -1;
  }
  function muteEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }
  function muteFocusEventsDuringExecution(win, func) {
    windowAddEventListener.call(win, "focusin", muteEvent, true);
    windowAddEventListener.call(win, "focusout", muteEvent, true);
    func();
    windowRemoveEventListener.call(win, "focusin", muteEvent, true);
    windowRemoveEventListener.call(win, "focusout", muteEvent, true);
  }
  function focusOnNextOrBlur(segment, target, relatedTarget) {
    const win = getOwnerWindow(relatedTarget);
    const next = getNextTabbable(segment, relatedTarget);
    if (isNull(next)) {
      muteFocusEventsDuringExecution(win, () => {
        target.blur();
      });
    } else {
      muteFocusEventsDuringExecution(win, () => {
        next.focus();
      });
    }
  }
  let letBrowserHandleFocus = false;
  function disableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = true;
  }
  function enableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = false;
  }
  function isKeyboardFocusNavigationRoutineEnabled() {
    return !letBrowserHandleFocus;
  }
  function skipHostHandler(event) {
    if (letBrowserHandleFocus) {
      return;
    }
    const host = eventCurrentTargetGetter.call(event);
    const target = eventTargetGetter.call(event);
    if (host !== target) {
      return;
    }
    const relatedTarget = focusEventRelatedTargetGetter.call(event);
    if (isNull(relatedTarget)) {
      return;
    }
    const segments = getTabbableSegments(host);
    const position = relatedTargetPosition(host, relatedTarget);
    if (position === 1) {
      const findTabbableElms = isTabbableFrom.bind(null, host.getRootNode());
      const first = ArrayFind.call(segments.inner, findTabbableElms);
      if (!isUndefined(first)) {
        const win = getOwnerWindow(first);
        muteFocusEventsDuringExecution(win, () => {
          first.focus();
        });
      } else {
        focusOnNextOrBlur(segments.next, target, relatedTarget);
      }
    } else if (host === target) {
      focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
  }
  function skipShadowHandler(event) {
    if (letBrowserHandleFocus) {
      return;
    }
    const relatedTarget = focusEventRelatedTargetGetter.call(event);
    if (isNull(relatedTarget)) {
      return;
    }
    const host = eventCurrentTargetGetter.call(event);
    const segments = getTabbableSegments(host);
    if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
      return;
    }
    const target = eventTargetGetter.call(event);
    const position = relatedTargetPosition(host, relatedTarget);
    if (position === 1) {
      focusOnNextOrBlur(segments.next, target, relatedTarget);
    }
    if (position === 2) {
      focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
  }
  function isTabbableFrom(fromRoot, toElm) {
    if (!isTabbable(toElm)) {
      return false;
    }
    const ownerDocument = getOwnerDocument(toElm);
    let root = toElm.getRootNode();
    while (root !== ownerDocument && root !== fromRoot) {
      const sr = root;
      const host = sr.host;
      if (getAttribute.call(host, "tabindex") === "-1") {
        return false;
      }
      root = host && host.getRootNode();
    }
    return true;
  }
  function getNextTabbable(tabbables, relatedTarget) {
    const len = tabbables.length;
    if (len > 0) {
      for (let i = 0; i < len; i += 1) {
        const next = tabbables[i];
        if (isTabbableFrom(relatedTarget.getRootNode(), next)) {
          return next;
        }
      }
    }
    return null;
  }
  function handleFocus(elm) {
    if (true) {
      assert.invariant(isDelegatingFocus(elm), `Invalid attempt to handle focus event for ${toString(elm)}. ${toString(elm)} should have delegates focus true, but is not delegating focus`);
    }
    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocusIn(elm);
    addEventListener2.call(elm, "focusin", skipHostHandler, true);
  }
  function ignoreFocus(elm) {
    removeEventListener2.call(elm, "focusin", skipHostHandler, true);
  }
  function bindDocumentMousedownMouseupHandlers(elm) {
    const ownerDocument = getOwnerDocument(elm);
    if (!DidAddMouseEventListeners.get(ownerDocument)) {
      DidAddMouseEventListeners.set(ownerDocument, true);
      addEventListener2.call(ownerDocument, "mousedown", disableKeyboardFocusNavigationRoutines, true);
      addEventListener2.call(ownerDocument, "mouseup", () => {
        setTimeout(enableKeyboardFocusNavigationRoutines);
      }, true);
      addEventListener2.call(ownerDocument, "dragstart", enableKeyboardFocusNavigationRoutines, true);
    }
  }
  function handleFocusIn(elm) {
    if (true) {
      assert.invariant(tabIndexGetter.call(elm) === -1, `Invalid attempt to handle focus in  ${toString(elm)}. ${toString(elm)} should have tabIndex -1, but has tabIndex ${tabIndexGetter.call(elm)}`);
    }
    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocus(elm);
    addEventListener2.call(elm, "focusin", skipShadowHandler, true);
  }
  function ignoreFocusIn(elm) {
    removeEventListener2.call(elm, "focusin", skipShadowHandler, true);
  }
  const {
    blur,
    focus
  } = HTMLElement.prototype;
  function tabIndexGetterPatched() {
    if (isDelegatingFocus(this) && isFalse(hasAttribute.call(this, "tabindex"))) {
      return 0;
    }
    return tabIndexGetter.call(this);
  }
  function tabIndexSetterPatched(value) {
    const delegatesFocus = isDelegatingFocus(this);
    const prevValue = tabIndexGetter.call(this);
    const prevHasAttr = hasAttribute.call(this, "tabindex");
    tabIndexSetter.call(this, value);
    const currValue = tabIndexGetter.call(this);
    const currHasAttr = hasAttribute.call(this, "tabindex");
    const didValueChange = prevValue !== currValue;
    if (prevHasAttr && (didValueChange || isFalse(currHasAttr))) {
      if (prevValue === -1) {
        ignoreFocusIn(this);
      }
      if (prevValue === 0 && delegatesFocus) {
        ignoreFocus(this);
      }
    }
    if (isFalse(currHasAttr)) {
      return;
    }
    if (prevHasAttr && currHasAttr && isFalse(didValueChange)) {
      return;
    }
    if (currValue === -1) {
      handleFocusIn(this);
    }
    if (currValue === 0 && delegatesFocus) {
      handleFocus(this);
    }
  }
  function blurPatched() {
    if (isDelegatingFocus(this)) {
      const currentActiveElement = getActiveElement(this);
      if (!isNull(currentActiveElement)) {
        currentActiveElement.blur();
        return;
      }
    }
    return blur.call(this);
  }
  function focusPatched() {
    const originallyEnabled = isKeyboardFocusNavigationRoutineEnabled();
    if (originallyEnabled) {
      disableKeyboardFocusNavigationRoutines();
    }
    if (isSyntheticShadowHost(this) && isDelegatingFocus(this)) {
      hostElementFocus.call(this);
      return;
    }
    focus.apply(this, arguments);
    if (originallyEnabled) {
      enableKeyboardFocusNavigationRoutines();
    }
  }
  defineProperties(HTMLElement.prototype, {
    tabIndex: {
      get() {
        if (isSyntheticShadowHost(this)) {
          return tabIndexGetterPatched.call(this);
        }
        return tabIndexGetter.call(this);
      },
      set(v) {
        if (isSyntheticShadowHost(this)) {
          return tabIndexSetterPatched.call(this, v);
        }
        return tabIndexSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    },
    blur: {
      value() {
        if (isSyntheticShadowHost(this)) {
          return blurPatched.call(this);
        }
        blur.call(this);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    focus: {
      value() {
        focusPatched.apply(this, arguments);
      },
      enumerable: true,
      writable: true,
      configurable: true
    }
  });
  if (innerTextGetter !== null && innerTextSetter !== null) {
    defineProperty(HTMLElement.prototype, "innerText", {
      get() {
        return innerTextGetter.call(this);
      },
      set(v) {
        innerTextSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    });
  }
  if (outerTextGetter !== null && outerTextSetter !== null) {
    defineProperty(HTMLElement.prototype, "outerText", {
      get() {
        return outerTextGetter.call(this);
      },
      set(v) {
        outerTextSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    });
  }
  function getShadowToken(node) {
    return node[KEY__SHADOW_TOKEN];
  }
  function setShadowToken(node, shadowToken) {
    node[KEY__SHADOW_TOKEN] = shadowToken;
  }
  defineProperty(Element.prototype, KEY__SHADOW_TOKEN, {
    set(shadowToken) {
      const oldShadowToken = this[KEY__SHADOW_TOKEN_PRIVATE];
      if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
        removeAttribute.call(this, oldShadowToken);
      }
      if (!isUndefined(shadowToken)) {
        setAttribute.call(this, shadowToken, "");
      }
      this[KEY__SHADOW_TOKEN_PRIVATE] = shadowToken;
    },
    get() {
      return this[KEY__SHADOW_TOKEN_PRIVATE];
    },
    configurable: true
  });
  function recursivelySetShadowResolver(node, fn) {
    node[KEY__SHADOW_RESOLVER] = fn;
    const childNodes = childNodesGetter.call(node);
    for (let i = 0, n = childNodes.length; i < n; i++) {
      recursivelySetShadowResolver(childNodes[i], fn);
    }
  }
  defineProperty(Element.prototype, KEY__SHADOW_STATIC, {
    set(v) {
      if (v) {
        const fn = this[KEY__SHADOW_RESOLVER];
        recursivelySetShadowResolver(this, fn);
      }
      this[KEY__SHADOW_STATIC_PRIVATE] = v;
    },
    get() {
      return this[KEY__SHADOW_STATIC_PRIVATE];
    },
    configurable: true
  });
  const DomManualPrivateKey = "$$DomManualKey$$";
  const DocumentResolverFn = function() {
  };
  let portalObserver;
  const portalObserverConfig = {
    childList: true
  };
  function adoptChildNode(node, fn, shadowToken) {
    const previousNodeShadowResolver = getShadowRootResolver(node);
    if (previousNodeShadowResolver === fn) {
      return;
    }
    setShadowRootResolver(node, fn);
    if (node instanceof Element) {
      setShadowToken(node, shadowToken);
      if (isSyntheticShadowHost(node)) {
        return;
      }
      if (isUndefined(previousNodeShadowResolver)) {
        MutationObserverObserve.call(portalObserver, node, portalObserverConfig);
      }
      const childNodes = childNodesGetter.call(node);
      for (let i = 0, len = childNodes.length; i < len; i += 1) {
        adoptChildNode(childNodes[i], fn, shadowToken);
      }
    }
  }
  function initPortalObserver() {
    return new MO((mutations) => {
      forEach.call(mutations, (mutation) => {
        const {
          target: elm,
          addedNodes,
          removedNodes
        } = mutation;
        const fn = getShadowRootResolver(elm);
        const shadowToken = getShadowToken(elm);
        for (let i = 0, len = removedNodes.length; i < len; i += 1) {
          const node = removedNodes[i];
          if (!(compareDocumentPosition.call(elm, node) & _Node.DOCUMENT_POSITION_CONTAINED_BY)) {
            adoptChildNode(node, DocumentResolverFn, void 0);
          }
        }
        for (let i = 0, len = addedNodes.length; i < len; i += 1) {
          const node = addedNodes[i];
          if (compareDocumentPosition.call(elm, node) & _Node.DOCUMENT_POSITION_CONTAINED_BY) {
            adoptChildNode(node, fn, shadowToken);
          }
        }
      });
    });
  }
  function markElementAsPortal(elm) {
    if (isUndefined(portalObserver)) {
      portalObserver = initPortalObserver();
    }
    if (isUndefined(getShadowRootResolver(elm))) {
      throw new Error(`Invalid Element`);
    }
    MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);
  }
  defineProperty(Element.prototype, "$domManual$", {
    set(v) {
      this[DomManualPrivateKey] = v;
      if (isTrue(v)) {
        markElementAsPortal(this);
      }
    },
    get() {
      return this[DomManualPrivateKey];
    },
    configurable: true
  });
});
LWR.define("@lwrjs/app-service/communities_app/module/amd/v/0_9_0", ["lwr/loaderLegacy/v/0_9_0", "@lwc/synthetic-shadow/v/2_41_4", "webruntime/hook/v/1_66_319-244_0", "webruntime/o11yHook/v/1_66_319-244_0", "webruntime/dynamicImportResourceHook/v/1_66_319-244_0", "lwr/init/v/0_9_0"], function(_0_9_0, _2_41_4, loaderService_webruntime_hook, loaderService_webruntime_o11yHook, loaderService_webruntime_dynamicImportResourceHook, _0_9_0$1) {
  "use strict";
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : {default: e};
  }
  var loaderService_webruntime_hook__default = /* @__PURE__ */ _interopDefaultLegacy(loaderService_webruntime_hook);
  var loaderService_webruntime_o11yHook__default = /* @__PURE__ */ _interopDefaultLegacy(loaderService_webruntime_o11yHook);
  var loaderService_webruntime_dynamicImportResourceHook__default = /* @__PURE__ */ _interopDefaultLegacy(loaderService_webruntime_dynamicImportResourceHook);
  loaderService_webruntime_hook__default["default"](_0_9_0.services);
  loaderService_webruntime_o11yHook__default["default"](_0_9_0.services);
  loaderService_webruntime_dynamicImportResourceHook__default["default"](_0_9_0.services);
  const clientBootstrapConfig = globalThis.LWR;
  const {rootComponents, ssrProps} = clientBootstrapConfig;
  Promise.all(rootComponents.map(async (rootSpecifier) => {
    const element = _0_9_0$1.toKebabCase(rootSpecifier);
    return _0_9_0.load(rootSpecifier, "@lwrjs/app-service/communities_app/module/amd/v/0_9_0").then(({default: Ctor}) => {
      _0_9_0$1.init([[element, Ctor]], ssrProps);
    });
  }));
  globalThis.LWR = Object.freeze({
    define: globalThis.LWR.define
  });
});
