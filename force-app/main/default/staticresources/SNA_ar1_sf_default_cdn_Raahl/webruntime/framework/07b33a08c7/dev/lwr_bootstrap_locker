LWR.define("lwr/lockerDefine/v/0_9_0", ["exports"], function(exports) {
  "use strict";
  /*!
   * Copyright (C) 2019 salesforce.com, inc.
   */
  var _URLCtor$prototype$LWS;
  const {
    apply: ReflectApply$LWS$1,
    construct: ReflectConstruct$LWS,
    defineProperty: ReflectDefineProperty$LWS$1,
    deleteProperty: ReflectDeleteProperty$LWS$1,
    get: ReflectGet$LWS,
    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
    getPrototypeOf: ReflectGetPrototypeOf$LWS$1,
    has: ReflectHas$LWS,
    isExtensible: ReflectIsExtensible$LWS,
    ownKeys: ReflectOwnKeys$LWS$1,
    preventExtensions: ReflectPreventExtensions$LWS,
    set: ReflectSet$LWS,
    setPrototypeOf: ReflectSetPrototypeOf$LWS$1
  } = Reflect;
  const ObjectCtor$LWS$1 = Object;
  const {
    assign: ObjectAssign$LWS$1,
    freeze: ObjectFreeze$LWS$1,
    defineProperties: ObjectDefineProperties$LWS,
    getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
    getOwnPropertySymbols: ObjectGetOwnPropertySymbols$LWS,
    keys: ObjectKeys$LWS$1,
    preventExtensions: ObjectPreventExtensions$LWS,
    prototype: ObjectProto$LWS$1
  } = ObjectCtor$LWS$1;
  const {
    hasOwn: OriginalObjectHasOwn$LWS$1
  } = ObjectCtor$LWS$1;
  const {
    __lookupGetter__: ObjectProtoLookupGetter$LWS$1,
    __lookupSetter__: ObjectProtoLookupSetter$LWS$1,
    hasOwnProperty: ObjectProtoHasOwnProperty$LWS$1
  } = ObjectProto$LWS$1;
  const {
    toString: ObjectProtoToString$LWS$1
  } = ObjectProto$LWS$1;
  function isObject$LWS$1(value$LWS) {
    return typeof value$LWS === "object" && value$LWS !== null;
  }
  function isObjectLike$LWS(value$LWS) {
    return typeof value$LWS === "object" && value$LWS !== null || typeof value$LWS === "function";
  }
  const ObjectHasOwn$LWS$1 = typeof OriginalObjectHasOwn$LWS$1 === "function" ? OriginalObjectHasOwn$LWS$1 : function ObjectHasOwn$LWS2(object$LWS, key$LWS) {
    return ReflectApply$LWS$1(ObjectProtoHasOwnProperty$LWS$1, object$LWS, [key$LWS]);
  };
  function ObjectLookupOwnGetter$LWS$1(object$LWS, key$LWS) {
    return object$LWS === null || object$LWS === void 0 || !ObjectHasOwn$LWS$1(object$LWS, key$LWS) ? void 0 : ReflectApply$LWS$1(ObjectProtoLookupGetter$LWS$1, object$LWS, [key$LWS]);
  }
  function ObjectLookupOwnSetter$LWS(object$LWS, key$LWS) {
    return object$LWS === null || object$LWS === void 0 || !ObjectHasOwn$LWS$1(object$LWS, key$LWS) ? void 0 : ReflectApply$LWS$1(ObjectProtoLookupSetter$LWS$1, object$LWS, [key$LWS]);
  }
  function ObjectLookupOwnValue$LWS(object$LWS, key$LWS) {
    return object$LWS === null || object$LWS === void 0 || !ObjectHasOwn$LWS$1(object$LWS, key$LWS) ? void 0 : object$LWS[key$LWS];
  }
  const SymbolCtor$LWS$1 = Symbol;
  const {
    asyncIterator: SymbolAsyncIterator$LWS,
    for: SymbolFor$LWS$1,
    iterator: SymbolIterator$LWS$1,
    toStringTag: SymbolToStringTag$LWS$1,
    unscopables: SymbolUnscopables$LWS$1
  } = SymbolCtor$LWS$1;
  const {
    toString: SymbolProtoToString$LWS,
    valueOf: SymbolProtoValueOf$LWS
  } = SymbolCtor$LWS$1.prototype;
  const ArrayCtor$LWS$1 = Array;
  const {
    prototype: ArrayProto$LWS$1
  } = ArrayCtor$LWS$1;
  const {
    at: ArrayProtoAt$LWS$1,
    concat: ArrayProtoConcat$LWS$1,
    copyWithin: ArrayProtoCopyWithin$LWS$1,
    entries: ArrayProtoEntries$LWS$1,
    every: ArrayProtoEvery$LWS$1,
    fill: ArrayProtoFill$LWS$1,
    findIndex: ArrayProtoFindIndex$LWS$1,
    flat: ArrayProtoFlat$LWS$1,
    flatMap: ArrayProtoFlatMap$LWS$1,
    forEach: ArrayProtoForEach$LWS$1,
    keys: ArrayProtoKeys$LWS$1,
    lastIndexOf: ArrayProtoLastIndexOf$LWS$1,
    map: ArrayProtoMap$LWS$1,
    pop: ArrayProtoPop$LWS$1,
    reduce: ArrayProtoReduce$LWS$1,
    reduceRight: ArrayProtoReduceRight$LWS$1,
    reverse: ArrayProtoReverse$LWS$1,
    some: ArrayProtoSome$LWS$1,
    splice: ArrayProtoSplice$LWS$1,
    toLocaleString: ArrayProtoToLocaleString$LWS$1,
    values: ArrayProtoValues$LWS$1,
    [SymbolIterator$LWS$1]: ArrayProtoSymbolIterator$LWS$1
  } = ArrayProto$LWS$1;
  const ArrayUnscopables$LWS$1 = ObjectFreeze$LWS$1(ObjectAssign$LWS$1({
    __proto__: null
  }, ArrayProto$LWS$1[SymbolUnscopables$LWS$1]));
  const {
    includes: ArrayProtoIncludes$LWS$1,
    sort: ArrayProtoSort$LWS$1,
    unshift: ArrayProtoUnshift$LWS$1
  } = ArrayProto$LWS$1;
  const {
    filter: ArrayProtoFilter$LWS$1,
    find: ArrayProtoFind$LWS$1,
    indexOf: ArrayProtoIndexOf$LWS$1,
    join: ArrayProtoJoin$LWS$1,
    push: ArrayProtoPush$LWS$1,
    shift: ArrayProtoShift$LWS$1,
    slice: ArrayProtoSlice$LWS$1,
    toString: ArrayProtoToString$LWS$1
  } = ArrayProto$LWS$1;
  const {
    isArray: ArrayIsArray$LWS$1
  } = ArrayCtor$LWS$1;
  function ArrayConcat$LWS(array$LWS, ...args$LWS) {
    const result$LWS = ReflectApply$LWS$1(ArrayProtoSlice$LWS$1, array$LWS, [0]);
    for (let i$LWS = 0, {
      length: length$LWS2
    } = args$LWS; i$LWS < length$LWS2; i$LWS += 1) {
      const value$LWS = args$LWS[i$LWS];
      if (ArrayIsArray$LWS$1(value$LWS)) {
        ReflectApply$LWS$1(ArrayProtoPush$LWS$1, result$LWS, value$LWS);
      } else {
        result$LWS[result$LWS.length] = value$LWS;
      }
    }
    return result$LWS;
  }
  function toSafeArray$LWS$1(array$LWS) {
    ReflectSetPrototypeOf$LWS$1(array$LWS, null);
    array$LWS.at = ArrayProtoAt$LWS$1;
    array$LWS.concat = ArrayProtoConcat$LWS$1;
    array$LWS.copyWithin = ArrayProtoCopyWithin$LWS$1;
    array$LWS.entries = ArrayProtoEntries$LWS$1;
    array$LWS.every = ArrayProtoEvery$LWS$1;
    array$LWS.fill = ArrayProtoFill$LWS$1;
    array$LWS.filter = ArrayProtoFilter$LWS$1;
    array$LWS.find = ArrayProtoFind$LWS$1;
    array$LWS.findIndex = ArrayProtoFindIndex$LWS$1;
    array$LWS.flat = ArrayProtoFlat$LWS$1;
    array$LWS.flatMap = ArrayProtoFlatMap$LWS$1;
    array$LWS.forEach = ArrayProtoForEach$LWS$1;
    array$LWS.includes = ArrayProtoIncludes$LWS$1;
    array$LWS.indexOf = ArrayProtoIndexOf$LWS$1;
    array$LWS.join = ArrayProtoJoin$LWS$1;
    array$LWS.keys = ArrayProtoKeys$LWS$1;
    array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS$1;
    array$LWS.map = ArrayProtoMap$LWS$1;
    array$LWS.pop = ArrayProtoPop$LWS$1;
    array$LWS.push = ArrayProtoPush$LWS$1;
    array$LWS.reduce = ArrayProtoReduce$LWS$1;
    array$LWS.reduceRight = ArrayProtoReduceRight$LWS$1;
    array$LWS.reverse = ArrayProtoReverse$LWS$1;
    array$LWS.shift = ArrayProtoShift$LWS$1;
    array$LWS.slice = ArrayProtoSlice$LWS$1;
    array$LWS.some = ArrayProtoSome$LWS$1;
    array$LWS.sort = ArrayProtoSort$LWS$1;
    array$LWS.splice = ArrayProtoSplice$LWS$1;
    array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS$1;
    array$LWS.toString = ArrayProtoToString$LWS$1;
    array$LWS.unshift = ArrayProtoUnshift$LWS$1;
    array$LWS.values = ArrayProtoValues$LWS$1;
    array$LWS[SymbolIterator$LWS$1] = ArrayProtoSymbolIterator$LWS$1;
    array$LWS[SymbolUnscopables$LWS$1] = ArrayUnscopables$LWS$1;
    ReflectSetPrototypeOf$LWS$1(array$LWS, ArrayProto$LWS$1);
    return array$LWS;
  }
  const ArrayBufferCtor$LWS = ArrayBuffer;
  const {
    isView: ArrayBufferIsView$LWS
  } = ArrayBufferCtor$LWS;
  const ArrayBufferProtoByteLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(ArrayBufferCtor$LWS.prototype, "byteLength");
  const SUPPORTS_BIG_INT$LWS = typeof BigInt === "function";
  const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf : void 0;
  const {
    valueOf: BooleanProtoValueOf$LWS
  } = Boolean.prototype;
  const LOCKER_IDENTIFIER_MARKER$LWS = "$LWS";
  const LOCKER_UNMINIFIED_FLAG$LWS$1 = `${function LOCKER_UNMINIFIED_FLAG$LWS2() {
    return LOCKER_UNMINIFIED_FLAG$LWS2.name;
  }()}`.includes("LOCKER_UNMINIFIED_FLAG");
  const LOCKER_SERVICE_KEY$LWS = "LSKey";
  const LOCKER_SERVICE_KEY_LOWERED$LWS = "lskey";
  const CHAR_QUOTE_DOUBLE$LWS = '"';
  const CHAR_QUOTE_SINGLE$LWS = "'";
  const UNCOMPILED_LOCATION_NAME$LWS = `uncompiledLocation${LOCKER_IDENTIFIER_MARKER$LWS}`;
  const UNCOMPILED_TOP_NAME$LWS = `uncompiledTop${LOCKER_IDENTIFIER_MARKER$LWS}`;
  const WEBPACK_REQUIRE_NAME$LWS = "__webpack_require__";
  const ERR_ILLEGAL_PROPERTY_ACCESS$LWS = "Illegal property access.";
  const ERR_INVALID_SANDBOX_KEY$LWS = "Invalid sandbox key.";
  const LOCKER_NEAR_MEMBRANE_PROXY_MASKED_SYMBOL$LWS = SymbolFor$LWS$1("@@lockerNearMembraneProxyMasked");
  const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS$1 = SymbolFor$LWS$1("@@lockerNearMembraneSerializedValue");
  const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS$1 = SymbolFor$LWS$1("@@lockerNearMembrane");
  const SYMBOL_LIVE_OBJECT$LWS = SymbolFor$LWS$1("@@lockerLiveValue");
  const TO_STRING_BRAND_ARRAY$LWS = "[object Array]";
  const TO_STRING_BRAND_ARRAY_BUFFER$LWS = "[object ArrayBuffer]";
  const TO_STRING_BRAND_BIG_INT$LWS$1 = "[object BigInt]";
  const TO_STRING_BRAND_BOOLEAN$LWS$1 = "[object Boolean]";
  const TO_STRING_BRAND_DATE$LWS = "[object Date]";
  const TO_STRING_BRAND_FUNCTION$LWS = "[object Function]";
  const TO_STRING_BRAND_MAP$LWS = "[object Map]";
  const TO_STRING_BRAND_NULL$LWS = "[object Null]";
  const TO_STRING_BRAND_NUMBER$LWS$1 = "[object Number]";
  const TO_STRING_BRAND_OBJECT$LWS = "[object Object]";
  const TO_STRING_BRAND_REG_EXP$LWS = "[object RegExp]";
  const TO_STRING_BRAND_SET$LWS = "[object Set]";
  const TO_STRING_BRAND_STRING$LWS$1 = "[object String]";
  const TO_STRING_BRAND_SYMBOL$LWS$1 = "[object Symbol]";
  const TO_STRING_BRAND_UNDEFINED$LWS = "[object Undefined]";
  const TO_STRING_BRAND_WEAK_MAP$LWS = "[object WeakMap]";
  const TO_STRING_BRAND_WEAK_SET$LWS = "[object WeakSet]";
  const SANDBOX_EVAL_CONTEXT_NAME$LWS = "$lockerEvalContext$";
  const SANDBOX_EVAL_HELPERS_NAME$LWS = "$lockerEvalHelpers$";
  const DateCtor$LWS = Date;
  const {
    now: DateNow$LWS
  } = DateCtor$LWS;
  const {
    valueOf: DateProtoValueOf$LWS
  } = DateCtor$LWS.prototype;
  const ErrorCtor$LWS$1 = Error;
  const TypeErrorCtor$LWS$1 = TypeError;
  class LockerSecurityError$LWS extends Error {
    constructor(message$LWS) {
      super(`Lightning Web Security: ${message$LWS}`);
    }
  }
  const ProxyCtor$LWS = Proxy;
  const {
    revocable: ProxyRevocable$LWS
  } = ProxyCtor$LWS;
  function createRevokedProxy$LWS(object$LWS) {
    const revocable$LWS = ProxyRevocable$LWS(object$LWS, {
      __proto__: null
    });
    revocable$LWS.revoke();
    return revocable$LWS.proxy;
  }
  const {
    bind: FunctionProtoBind$LWS,
    toString: FunctionProtoToString$LWS
  } = Function.prototype;
  function isProxyMaskedFunction$LWS(value$LWS) {
    return typeof value$LWS === "function" && !(LOCKER_NEAR_MEMBRANE_PROXY_MASKED_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_PROXY_MASKED_SYMBOL$LWS] === true;
  }
  function noop$LWS$1() {
  }
  function proxyMaskFunction$LWS(func$LWS, maskFunc$LWS, trapInvokers$LWS) {
    let applyTrapInvoker$LWS = ReflectApply$LWS$1;
    let constructTrapInvoker$LWS = ReflectConstruct$LWS;
    let definePropertyTrapInvoker$LWS = ReflectDefineProperty$LWS$1;
    let getTrapInvoker$LWS = ReflectGet$LWS;
    let getOwnPropertyDescriptorTrapInvoker$LWS = ReflectGetOwnPropertyDescriptor$LWS;
    let hasTrapInvoker$LWS = ReflectHas$LWS;
    let setTrapInvoker$LWS = ReflectSet$LWS;
    if (trapInvokers$LWS) {
      ({
        apply: applyTrapInvoker$LWS = ReflectApply$LWS$1,
        construct: constructTrapInvoker$LWS = ReflectConstruct$LWS,
        defineProperty: definePropertyTrapInvoker$LWS = ReflectDefineProperty$LWS$1,
        get: getTrapInvoker$LWS = ReflectGet$LWS,
        getOwnPropertyDescriptor: getOwnPropertyDescriptorTrapInvoker$LWS = ReflectGetOwnPropertyDescriptor$LWS,
        has: hasTrapInvoker$LWS = ReflectHas$LWS,
        set: setTrapInvoker$LWS = ReflectSet$LWS
      } = trapInvokers$LWS);
    }
    let handshakeFlag$LWS = false;
    let handshakeProxyMaskedFlag$LWS = false;
    let lastProxyTrapCalled$LWS = 0;
    const proxy$LWS = new ProxyCtor$LWS(maskFunc$LWS, {
      apply(_target$LWS, thisArg$LWS, args$LWS) {
        lastProxyTrapCalled$LWS = 1;
        if (thisArg$LWS === proxy$LWS || thisArg$LWS === maskFunc$LWS) {
          thisArg$LWS = func$LWS;
        }
        return applyTrapInvoker$LWS(func$LWS, thisArg$LWS, args$LWS);
      },
      construct(_target$LWS, args$LWS, newTarget$LWS) {
        lastProxyTrapCalled$LWS = 2;
        if (newTarget$LWS === proxy$LWS || newTarget$LWS === maskFunc$LWS) {
          newTarget$LWS = func$LWS;
        }
        return constructTrapInvoker$LWS(func$LWS, args$LWS, newTarget$LWS);
      },
      defineProperty(target$LWS, key$LWS, desc$LWS) {
        lastProxyTrapCalled$LWS = 4;
        if (key$LWS === LOCKER_NEAR_MEMBRANE_PROXY_MASKED_SYMBOL$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return definePropertyTrapInvoker$LWS(target$LWS, key$LWS, desc$LWS);
      },
      deleteProperty(target$LWS, key$LWS) {
        lastProxyTrapCalled$LWS = 32;
        return ReflectDeleteProperty$LWS$1(target$LWS, key$LWS);
      },
      get(target$LWS, key$LWS, receiver$LWS) {
        handshakeFlag$LWS && (handshakeFlag$LWS = lastProxyTrapCalled$LWS === 128);
        handshakeProxyMaskedFlag$LWS && (handshakeProxyMaskedFlag$LWS = handshakeFlag$LWS);
        lastProxyTrapCalled$LWS = 16;
        const isProxyMaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_PROXY_MASKED_SYMBOL$LWS;
        if (handshakeProxyMaskedFlag$LWS) {
          if (isProxyMaskedSymbol$LWS) {
            return true;
          }
        }
        const result$LWS = getTrapInvoker$LWS(target$LWS, key$LWS, receiver$LWS, handshakeFlag$LWS);
        if (result$LWS !== void 0 && isProxyMaskedSymbol$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return result$LWS;
      },
      getOwnPropertyDescriptor(target$LWS, key$LWS) {
        lastProxyTrapCalled$LWS = 32;
        const result$LWS = getOwnPropertyDescriptorTrapInvoker$LWS(target$LWS, key$LWS);
        if (result$LWS && key$LWS === LOCKER_NEAR_MEMBRANE_PROXY_MASKED_SYMBOL$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return result$LWS;
      },
      getPrototypeOf(target$LWS) {
        lastProxyTrapCalled$LWS = 64;
        return ReflectGetPrototypeOf$LWS$1(target$LWS);
      },
      has(target$LWS, key$LWS) {
        lastProxyTrapCalled$LWS = 128;
        const result$LWS = hasTrapInvoker$LWS(target$LWS, key$LWS);
        const isProxyMaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_PROXY_MASKED_SYMBOL$LWS;
        if (result$LWS) {
          handshakeFlag$LWS = false;
          if (isProxyMaskedSymbol$LWS) {
            throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
          }
        } else {
          handshakeFlag$LWS = true;
          handshakeProxyMaskedFlag$LWS = isProxyMaskedSymbol$LWS;
        }
        return result$LWS;
      },
      isExtensible(target$LWS) {
        lastProxyTrapCalled$LWS = 256;
        return ReflectIsExtensible$LWS(target$LWS);
      },
      ownKeys(target$LWS) {
        lastProxyTrapCalled$LWS = 512;
        return ReflectOwnKeys$LWS$1(target$LWS);
      },
      preventExtensions(target$LWS) {
        lastProxyTrapCalled$LWS = 1024;
        return ReflectPreventExtensions$LWS(target$LWS);
      },
      set(target$LWS, key$LWS, value$LWS, receiver$LWS) {
        lastProxyTrapCalled$LWS = 2048;
        if (key$LWS === LOCKER_NEAR_MEMBRANE_PROXY_MASKED_SYMBOL$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return setTrapInvoker$LWS(target$LWS, key$LWS, value$LWS, receiver$LWS);
      },
      setPrototypeOf(target$LWS, proto$LWS) {
        lastProxyTrapCalled$LWS = 4096;
        return ReflectSetPrototypeOf$LWS$1(target$LWS, proto$LWS);
      }
    });
    return proxy$LWS;
  }
  const MapCtor$LWS$1 = Map;
  const {
    prototype: MapProto$LWS$1
  } = MapCtor$LWS$1;
  const {
    clear: MapProtoClear$LWS$1,
    delete: MapProtoDelete$LWS$1,
    forEach: MapProtoForEach$LWS$1,
    get: MapProtoGet$LWS$1,
    has: MapProtoHas$LWS$1,
    keys: MapProtoKeys$LWS$1,
    values: MapProtoValues$LWS$1,
    [SymbolIterator$LWS$1]: MapProtoSymbolIterator$LWS$1,
    [SymbolToStringTag$LWS$1]: MapProtoSymbolToStringTag$LWS$1
  } = MapProto$LWS$1;
  const {
    entries: MapProtoEntries$LWS$1,
    set: MapProtoSet$LWS$1
  } = MapProto$LWS$1;
  const MapProtoSizeGetter$LWS$1 = ObjectLookupOwnGetter$LWS$1(MapProto$LWS$1, "size");
  function toSafeMap$LWS$1(map$LWS) {
    ReflectSetPrototypeOf$LWS$1(map$LWS, null);
    map$LWS.clear = MapProtoClear$LWS$1;
    map$LWS.delete = MapProtoDelete$LWS$1;
    map$LWS.entries = MapProtoEntries$LWS$1;
    map$LWS.forEach = MapProtoForEach$LWS$1;
    map$LWS.get = MapProtoGet$LWS$1;
    map$LWS.has = MapProtoHas$LWS$1;
    map$LWS.keys = MapProtoKeys$LWS$1;
    map$LWS.set = MapProtoSet$LWS$1;
    ReflectDefineProperty$LWS$1(map$LWS, "size", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get: MapProtoSizeGetter$LWS$1,
      set: void 0
    });
    map$LWS.values = MapProtoValues$LWS$1;
    map$LWS[SymbolIterator$LWS$1] = MapProtoSymbolIterator$LWS$1;
    map$LWS[SymbolToStringTag$LWS$1] = MapProtoSymbolToStringTag$LWS$1;
    ReflectSetPrototypeOf$LWS$1(map$LWS, MapProto$LWS$1);
    return map$LWS;
  }
  const NumberCtor$LWS$1 = Number;
  const {
    isFinite: NumberIsFinite$LWS$1,
    isInteger: NumberIsInteger$LWS$1
  } = NumberCtor$LWS$1;
  const {
    toFixed: NumberProtoToFixed$LWS,
    valueOf: NumberProtoValueOf$LWS
  } = NumberCtor$LWS$1.prototype;
  const StringCtor$LWS$1 = String;
  const {
    prototype: StringProto$LWS$1
  } = StringCtor$LWS$1;
  const {
    endsWith: StringProtoEndsWith$LWS,
    includes: StringProtoIncludes$LWS,
    indexOf: StringProtoIndexOf$LWS,
    match: StringProtoMatch$LWS,
    replace: StringProtoReplace$LWS,
    slice: StringProtoSlice$LWS$1,
    split: StringProtoSplit$LWS,
    startsWith: StringProtoStartsWith$LWS,
    toLowerCase: StringProtoToLowerCase$LWS,
    toUpperCase: StringProtoToUpperCase$LWS,
    valueOf: StringProtoValueOf$LWS$1
  } = StringProto$LWS$1;
  const quoteCharRegExpRegistry$LWS = {
    __proto__: null,
    [CHAR_QUOTE_DOUBLE$LWS]: /\\?"/g,
    [CHAR_QUOTE_SINGLE$LWS]: /\\?'/g
  };
  const URLCtor$LWS = typeof URL === "function" ? URL : void 0;
  const URLProtoToString$LWS = URLCtor$LWS == null ? void 0 : (_URLCtor$prototype$LWS = URLCtor$LWS.prototype) == null ? void 0 : _URLCtor$prototype$LWS.toString;
  const funcBodyRegExp$LWS = /^[\s\S]+?\{[\t ]*(?:\r?\n)?([\s\S]*?)(?:\r?\n)?[\t ]*\}$|[\s\S]+?=>\s*([\s\S]+?)\s*$/;
  function capitalizeFirstChar$LWS(string$LWS) {
    const {
      length: length$LWS2
    } = string$LWS;
    if (length$LWS2) {
      const upper$LWS = ReflectApply$LWS$1(StringProtoToUpperCase$LWS, string$LWS[0], []);
      return length$LWS2 === 1 ? upper$LWS : upper$LWS + ReflectApply$LWS$1(StringProtoSlice$LWS$1, string$LWS, [1]);
    }
    return "";
  }
  function enquote$LWS(string$LWS, quoteChar$LWS = CHAR_QUOTE_SINGLE$LWS) {
    return quoteChar$LWS + ReflectApply$LWS$1(StringProtoReplace$LWS, string$LWS, [quoteCharRegExpRegistry$LWS[quoteChar$LWS], `\\${quoteChar$LWS}`]) + quoteChar$LWS;
  }
  function extractFunctionBodySource$LWS(func$LWS) {
    var _ref$LWS, _match$$LWS;
    const source$LWS = ReflectApply$LWS$1(FunctionProtoToString$LWS, func$LWS, []);
    const match$LWS = ReflectApply$LWS$1(StringProtoMatch$LWS, source$LWS, [funcBodyRegExp$LWS]);
    return (_ref$LWS = (_match$$LWS = match$LWS == null ? void 0 : match$LWS[1]) != null ? _match$$LWS : match$LWS == null ? void 0 : match$LWS[2]) != null ? _ref$LWS : "";
  }
  function isConvertibleToString$LWS(value$LWS) {
    if (typeof value$LWS !== "symbol") {
      try {
        return `${value$LWS}` !== void 0;
      } catch (_unused$LWS) {
      }
    }
    return false;
  }
  function toString$LWS(value$LWS) {
    return typeof value$LWS === "string" ? value$LWS : `${value$LWS}`;
  }
  function toSafeTemplateStringValue$LWS(value$LWS) {
    if (typeof value$LWS === "string") {
      return value$LWS;
    }
    try {
      if (typeof value$LWS === "function") {
        return ReflectApply$LWS$1(FunctionProtoToString$LWS, value$LWS, []);
      }
      if (typeof value$LWS === "object" && value$LWS !== null) {
        if (URLCtor$LWS && value$LWS instanceof URLCtor$LWS) {
          return ReflectApply$LWS$1(URLProtoToString$LWS, value$LWS, []);
        }
        const result$LWS = ReflectApply$LWS$1(ObjectProtoToString$LWS$1, value$LWS, []);
        return result$LWS === TO_STRING_BRAND_SYMBOL$LWS$1 ? ReflectApply$LWS$1(SymbolProtoToString$LWS, value$LWS, []) : result$LWS;
      }
      if (typeof value$LWS === "symbol") {
        return ReflectApply$LWS$1(SymbolProtoToString$LWS, value$LWS, []);
      }
      return StringCtor$LWS$1(value$LWS);
    } catch (_unused2$LWS) {
    }
    return "[object Unknown]";
  }
  const RegExpCtor$LWS$1 = RegExp;
  const {
    prototype: RegExpProto$LWS$1
  } = RegExpCtor$LWS$1;
  const {
    exec: RegExpProtoExec$LWS,
    test: RegExpProtoTest$LWS$1
  } = RegExpProto$LWS$1;
  const RegExpProtoSourceGetter$LWS = ObjectLookupOwnGetter$LWS$1(RegExpProto$LWS$1, "source");
  const specialCharRegExp$LWS = /[\\^$.*+?()[\]{}|]/g;
  function escapeRegExp$LWS(string$LWS) {
    return ReflectApply$LWS$1(StringProtoReplace$LWS, string$LWS, [specialCharRegExp$LWS, "\\$&"]);
  }
  const SetCtor$LWS$1 = Set;
  const {
    prototype: SetProto$LWS$1
  } = SetCtor$LWS$1;
  const {
    clear: SetProtoClear$LWS,
    delete: SetProtoDelete$LWS,
    entries: SetProtoEntries$LWS,
    forEach: SetProtoForEach$LWS,
    has: SetProtoHas$LWS,
    keys: SetProtoKeys$LWS,
    [SymbolIterator$LWS$1]: SetProtoSymbolIterator$LWS,
    [SymbolToStringTag$LWS$1]: SetProtoSymbolToStringTag$LWS
  } = SetProto$LWS$1;
  const {
    add: SetProtoAdd$LWS,
    values: SetProtoValues$LWS
  } = SetProto$LWS$1;
  const SetProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS$1(SetProto$LWS$1, "size");
  function toSafeSet$LWS(set$LWS) {
    ReflectSetPrototypeOf$LWS$1(set$LWS, null);
    set$LWS.add = SetProtoAdd$LWS;
    set$LWS.clear = SetProtoClear$LWS;
    set$LWS.delete = SetProtoDelete$LWS;
    set$LWS.entries = SetProtoEntries$LWS;
    set$LWS.forEach = SetProtoForEach$LWS;
    set$LWS.has = SetProtoHas$LWS;
    set$LWS.keys = SetProtoKeys$LWS;
    ReflectDefineProperty$LWS$1(set$LWS, "size", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get: SetProtoSizeGetter$LWS,
      set: void 0
    });
    set$LWS.values = SetProtoValues$LWS;
    set$LWS[SymbolIterator$LWS$1] = SetProtoSymbolIterator$LWS;
    set$LWS[SymbolToStringTag$LWS$1] = SetProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS$1(set$LWS, SetProto$LWS$1);
    return set$LWS;
  }
  const WeakMapCtor$LWS$1 = WeakMap;
  const {
    prototype: WeakMapProto$LWS$1
  } = WeakMapCtor$LWS$1;
  const {
    has: WeakMapProtoHas$LWS$1
  } = WeakMapProto$LWS$1;
  const {
    delete: WeakMapProtoDelete$LWS$1,
    get: WeakMapProtoGet$LWS$1,
    set: WeakMapProtoSet$LWS$1,
    [SymbolToStringTag$LWS$1]: WeakMapProtoSymbolToStringTag$LWS$1
  } = WeakMapProto$LWS$1;
  function toSafeWeakMap$LWS$1(weakMap$LWS) {
    ReflectSetPrototypeOf$LWS$1(weakMap$LWS, null);
    weakMap$LWS.delete = WeakMapProtoDelete$LWS$1;
    weakMap$LWS.get = WeakMapProtoGet$LWS$1;
    weakMap$LWS.has = WeakMapProtoHas$LWS$1;
    weakMap$LWS.set = WeakMapProtoSet$LWS$1;
    weakMap$LWS[SymbolToStringTag$LWS$1] = WeakMapProtoSymbolToStringTag$LWS$1;
    ReflectSetPrototypeOf$LWS$1(weakMap$LWS, WeakMapProto$LWS$1);
    return weakMap$LWS;
  }
  const WeakSetCtor$LWS$1 = WeakSet;
  const {
    prototype: WeakSetProto$LWS$1
  } = WeakSetCtor$LWS$1;
  const {
    has: WeakSetProtoHas$LWS$1
  } = WeakSetProto$LWS$1;
  const {
    add: WeakSetProtoAdd$LWS$1,
    delete: WeakSetProtoDelete$LWS$1,
    [SymbolToStringTag$LWS$1]: WeakSetProtoSymbolToStringTag$LWS$1
  } = WeakSetProto$LWS$1;
  function toSafeWeakSet$LWS$1(weakSet$LWS) {
    ReflectSetPrototypeOf$LWS$1(weakSet$LWS, null);
    weakSet$LWS.add = WeakSetProtoAdd$LWS$1;
    weakSet$LWS.delete = WeakSetProtoDelete$LWS$1;
    weakSet$LWS.has = WeakSetProtoHas$LWS$1;
    weakSet$LWS[SymbolToStringTag$LWS$1] = WeakSetProtoSymbolToStringTag$LWS$1;
    ReflectSetPrototypeOf$LWS$1(weakSet$LWS, WeakSetProto$LWS$1);
    return weakSet$LWS;
  }
  const {
    toStringTag: TO_STRING_TAG_SYMBOL$LWS
  } = Symbol;
  const expressionCharRegExp$LWS = /[(`.[+\-/*%<>=,?^&]/;
  const lineBreakRegExp$LWS = /\r\n?|\n|\u2028|\u2029/;
  const skipWhiteSpacesRegExp$LWS = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  const stringLiteralRegExp$LWS = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
  function getBrandByTrialAndError$LWS(value$LWS) {
    try {
      if ("byteLength" in value$LWS) {
        ReflectApply$LWS$1(ArrayBufferProtoByteLengthGetter$LWS, value$LWS, []);
        return TO_STRING_BRAND_ARRAY_BUFFER$LWS;
      }
    } catch (_unused3$LWS) {
    }
    try {
      if ("toLocaleDateString" in value$LWS) {
        ReflectApply$LWS$1(DateProtoValueOf$LWS, value$LWS, []);
        return TO_STRING_BRAND_DATE$LWS;
      }
    } catch (_unused4$LWS) {
    }
    try {
      if ("get" in value$LWS && "size" in value$LWS) {
        ReflectApply$LWS$1(MapProtoSizeGetter$LWS$1, value$LWS, []);
        return TO_STRING_BRAND_MAP$LWS;
      }
    } catch (_unused5$LWS) {
    }
    try {
      if ("add" in value$LWS && "size" in value$LWS) {
        ReflectApply$LWS$1(SetProtoSizeGetter$LWS, value$LWS, []);
        return TO_STRING_BRAND_SET$LWS;
      }
    } catch (_unused6$LWS) {
    }
    try {
      if ("get" in value$LWS && !("size" in value$LWS)) {
        ReflectApply$LWS$1(WeakMapProtoHas$LWS$1, value$LWS, []);
        return TO_STRING_BRAND_WEAK_MAP$LWS;
      }
    } catch (_unused7$LWS) {
    }
    try {
      if ("add" in value$LWS && !("size" in value$LWS)) {
        ReflectApply$LWS$1(WeakSetProtoHas$LWS$1, value$LWS, []);
        return TO_STRING_BRAND_WEAK_SET$LWS;
      }
    } catch (_unused8$LWS) {
    }
    try {
      if ("toPrecision" in value$LWS) {
        ReflectApply$LWS$1(NumberProtoValueOf$LWS, value$LWS, []);
        return TO_STRING_BRAND_NUMBER$LWS$1;
      }
    } catch (_unused9$LWS) {
    }
    try {
      if ("description" in value$LWS) {
        ReflectApply$LWS$1(SymbolProtoValueOf$LWS, value$LWS, []);
        return TO_STRING_BRAND_SYMBOL$LWS$1;
      }
    } catch (_unused10$LWS) {
    }
    try {
      if (ObjectHasOwn$LWS$1(value$LWS, "lastIndex")) {
        ReflectApply$LWS$1(RegExpProtoSourceGetter$LWS, value$LWS, []);
        return TO_STRING_BRAND_REG_EXP$LWS;
      }
    } catch (_unused11$LWS) {
    }
    try {
      if (ObjectHasOwn$LWS$1(value$LWS, "length")) {
        ReflectApply$LWS$1(StringProtoValueOf$LWS$1, value$LWS, []);
        return TO_STRING_BRAND_STRING$LWS$1;
      }
    } catch (_unused12$LWS) {
    }
    try {
      ReflectApply$LWS$1(BooleanProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_BOOLEAN$LWS$1;
    } catch (_unused13$LWS) {
    }
    if (SUPPORTS_BIG_INT$LWS) {
      try {
        ReflectApply$LWS$1(BigIntProtoValueOf$LWS, value$LWS, []);
        return TO_STRING_BRAND_BIG_INT$LWS$1;
      } catch (_unused14$LWS) {
      }
    }
    return TO_STRING_BRAND_OBJECT$LWS;
  }
  function getBrand$LWS(value$LWS) {
    if (value$LWS === null) {
      return TO_STRING_BRAND_NULL$LWS;
    }
    if (value$LWS === void 0) {
      return TO_STRING_BRAND_UNDEFINED$LWS;
    }
    switch (typeof value$LWS) {
      case "bigint":
        return TO_STRING_BRAND_BIG_INT$LWS$1;
      case "boolean":
        return TO_STRING_BRAND_BOOLEAN$LWS$1;
      case "function":
        return TO_STRING_BRAND_FUNCTION$LWS;
      case "number":
        return TO_STRING_BRAND_NUMBER$LWS$1;
      case "string":
        return TO_STRING_BRAND_STRING$LWS$1;
      case "symbol":
        return TO_STRING_BRAND_SYMBOL$LWS$1;
    }
    if (ArrayIsArray$LWS$1(value$LWS)) {
      return TO_STRING_BRAND_ARRAY$LWS;
    }
    return TO_STRING_TAG_SYMBOL$LWS in value$LWS ? getBrandByTrialAndError$LWS(value$LWS) : ReflectApply$LWS$1(ObjectProtoToString$LWS$1, value$LWS, []);
  }
  typeof performance === "undefined" ? DateNow$LWS : ReflectApply$LWS$1(FunctionProtoBind$LWS, performance.now, [performance]);
  function indexOfPragma$LWS(source$LWS, pragma$LWS) {
    let pos$LWS = 0;
    while (true) {
      skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
      pos$LWS += ReflectApply$LWS$1(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;
      const stringLiteralMatch$LWS = ReflectApply$LWS$1(RegExpProtoExec$LWS, stringLiteralRegExp$LWS, [ReflectApply$LWS$1(StringProtoSlice$LWS$1, source$LWS, [pos$LWS])]);
      if (stringLiteralMatch$LWS === null) {
        return -1;
      }
      if ((stringLiteralMatch$LWS[1] || stringLiteralMatch$LWS[2]) === pragma$LWS) {
        skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS + stringLiteralMatch$LWS[0].length;
        const spaceAfterMatch$LWS = ReflectApply$LWS$1(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS]);
        const end$LWS = spaceAfterMatch$LWS.index + spaceAfterMatch$LWS[0].length;
        const nextChar$LWS = source$LWS[end$LWS];
        if (nextChar$LWS === ";" || nextChar$LWS === "}") {
          return pos$LWS;
        }
        const indexAfterNext$LWS = end$LWS + 1;
        if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, lineBreakRegExp$LWS, [spaceAfterMatch$LWS[0]]) && !(nextChar$LWS === "!" && indexAfterNext$LWS < source$LWS.length && source$LWS[indexAfterNext$LWS] === "=" || ReflectApply$LWS$1(RegExpProtoTest$LWS$1, expressionCharRegExp$LWS, [nextChar$LWS]))) {
          return pos$LWS;
        }
      }
      pos$LWS += stringLiteralMatch$LWS[0].length;
      skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
      pos$LWS += ReflectApply$LWS$1(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;
      if (source$LWS[pos$LWS] === ";") {
        pos$LWS += 1;
      }
    }
  }
  const {
    parse: JSONParse$LWS
  } = JSON;
  function getNearMembraneProxySerializedValue$LWS$1(object$LWS) {
    if (typeof object$LWS === "object" && object$LWS !== null || typeof object$LWS === "function") {
      return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS$1 in object$LWS ? void 0 : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS$1];
    }
    return void 0;
  }
  function isNearMembraneProxy$LWS$1(value$LWS) {
    if (typeof value$LWS === "object" && value$LWS !== null || typeof value$LWS === "function") {
      return !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS$1 in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS$1] === true;
    }
    return false;
  }
  const SEEN_OBJECTS$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
  function cloneBoxedPrimitive$LWS(object$LWS) {
    return ObjectCtor$LWS$1(getNearMembraneProxySerializedValue$LWS$1(object$LWS));
  }
  function cloneMap$LWS(map$LWS, queue$LWS2) {
    const clone$LWS = new MapCtor$LWS$1();
    const entriesIterable$LWS = ReflectApply$LWS$1(MapProtoEntries$LWS$1, map$LWS, []);
    let {
      length: queueOffset$LWS
    } = queue$LWS2;
    while (true) {
      const {
        done: done$LWS,
        value: subKeyValuePair$LWS
      } = entriesIterable$LWS.next();
      if (done$LWS) {
        break;
      }
      const {
        0: subKey$LWS,
        1: subValue$LWS
      } = subKeyValuePair$LWS;
      let subCloneKey$LWS;
      queue$LWS2[queueOffset$LWS++] = [(subClone$LWS) => {
        subCloneKey$LWS = subClone$LWS;
      }, subKey$LWS];
      queue$LWS2[queueOffset$LWS++] = [(subCloneValue$LWS) => {
        ReflectApply$LWS$1(MapProtoSet$LWS$1, clone$LWS, [subCloneKey$LWS, subCloneValue$LWS]);
      }, subValue$LWS];
    }
    return clone$LWS;
  }
  function cloneRegExp$LWS(regexp$LWS) {
    const {
      flags: flags$LWS,
      source: source$LWS
    } = JSONParse$LWS(getNearMembraneProxySerializedValue$LWS$1(regexp$LWS));
    return new RegExpCtor$LWS$1(source$LWS, flags$LWS);
  }
  function cloneSet$LWS(set$LWS, queue$LWS2) {
    const clone$LWS = new SetCtor$LWS$1();
    const valuesIterable$LWS = ReflectApply$LWS$1(SetProtoValues$LWS, set$LWS, []);
    let {
      length: queueOffset$LWS
    } = queue$LWS2;
    while (true) {
      const {
        done: done$LWS,
        value: subValue$LWS
      } = valuesIterable$LWS.next();
      if (done$LWS) {
        break;
      }
      queue$LWS2[queueOffset$LWS++] = [(subCloneValue$LWS) => {
        ReflectApply$LWS$1(SetProtoAdd$LWS, clone$LWS, [subCloneValue$LWS]);
      }, subValue$LWS];
    }
    return clone$LWS;
  }
  function enqueue$LWS(queue$LWS2, originalValue$LWS, cloneValue$LWS) {
    const keys$LWS = ObjectKeys$LWS$1(originalValue$LWS);
    let {
      length: queueOffset$LWS
    } = queue$LWS2;
    for (let i$LWS = 0, {
      length: length$LWS2
    } = keys$LWS; i$LWS < length$LWS2; i$LWS += 1) {
      const key$LWS = keys$LWS[i$LWS];
      const subValue$LWS = originalValue$LWS[key$LWS];
      queue$LWS2[queueOffset$LWS++] = [(subCloneValue$LWS) => {
        cloneValue$LWS[key$LWS] = subCloneValue$LWS;
      }, subValue$LWS];
    }
  }
  function partialStructuredCloneInternal$LWS(value$LWS) {
    let result$LWS;
    const queue$LWS2 = [[(subClone$LWS) => {
      result$LWS = subClone$LWS;
    }, value$LWS]];
    queueLoop:
      while (queue$LWS2.length) {
        const {
          0: setter$LWS,
          1: originalValue$LWS
        } = ReflectApply$LWS$1(ArrayProtoShift$LWS$1, queue$LWS2, []);
        if (originalValue$LWS === null || originalValue$LWS === void 0 || typeof originalValue$LWS === "boolean" || typeof originalValue$LWS === "number" || typeof originalValue$LWS === "string" || typeof originalValue$LWS === "bigint") {
          setter$LWS(originalValue$LWS);
          continue queueLoop;
        }
        if (typeof originalValue$LWS === "symbol") {
          setter$LWS(originalValue$LWS);
          break queueLoop;
        }
        let cloneValue$LWS = SEEN_OBJECTS$LWS.get(originalValue$LWS);
        if (cloneValue$LWS) {
          setter$LWS(cloneValue$LWS);
          continue queueLoop;
        }
        const brand$LWS = getBrand$LWS(originalValue$LWS);
        switch (brand$LWS) {
          case TO_STRING_BRAND_OBJECT$LWS: {
            const proto$LWS = ReflectGetPrototypeOf$LWS$1(originalValue$LWS);
            if (proto$LWS === ObjectProto$LWS$1 || proto$LWS === null || ReflectGetPrototypeOf$LWS$1(proto$LWS) === null) {
              cloneValue$LWS = {};
              enqueue$LWS(queue$LWS2, originalValue$LWS, cloneValue$LWS);
            }
            break;
          }
          case TO_STRING_BRAND_ARRAY$LWS:
            cloneValue$LWS = ArrayCtor$LWS$1(originalValue$LWS.length);
            enqueue$LWS(queue$LWS2, originalValue$LWS, cloneValue$LWS);
            break;
          case TO_STRING_BRAND_MAP$LWS:
            cloneValue$LWS = cloneMap$LWS(originalValue$LWS, queue$LWS2);
            break;
          case TO_STRING_BRAND_SET$LWS:
            cloneValue$LWS = cloneSet$LWS(originalValue$LWS, queue$LWS2);
            break;
        }
        if (cloneValue$LWS === void 0) {
          if (!isNearMembraneProxy$LWS$1(originalValue$LWS)) {
            SEEN_OBJECTS$LWS.set(originalValue$LWS, originalValue$LWS);
            setter$LWS(originalValue$LWS);
            continue queueLoop;
          }
          switch (brand$LWS) {
            case TO_STRING_BRAND_REG_EXP$LWS:
              cloneValue$LWS = cloneRegExp$LWS(originalValue$LWS);
              break;
            case TO_STRING_BRAND_BOOLEAN$LWS$1:
            case TO_STRING_BRAND_NUMBER$LWS$1:
            case TO_STRING_BRAND_BIG_INT$LWS$1:
            case TO_STRING_BRAND_STRING$LWS$1:
              cloneValue$LWS = cloneBoxedPrimitive$LWS(originalValue$LWS);
              break;
          }
        }
        if (cloneValue$LWS === void 0) {
          setter$LWS(originalValue$LWS);
          break queueLoop;
        }
        SEEN_OBJECTS$LWS.set(originalValue$LWS, cloneValue$LWS);
        setter$LWS(cloneValue$LWS);
      }
    return result$LWS;
  }
  function partialStructuredClone$LWS(value$LWS) {
    let result$LWS = value$LWS;
    if (typeof value$LWS === "object" && value$LWS !== null) {
      try {
        result$LWS = partialStructuredCloneInternal$LWS(value$LWS);
      } catch (_unused15$LWS) {
      }
      SEEN_OBJECTS$LWS.clear();
    }
    return result$LWS;
  }
  function shallowCloneArray$LWS(array$LWS) {
    return ReflectApply$LWS$1(ArrayProtoSlice$LWS$1, array$LWS, [0]);
  }
  function shallowCloneOptions$LWS(options$LWS) {
    const ownKeys$LWS = ReflectOwnKeys$LWS$1(options$LWS);
    const clone$LWS = {
      __proto__: null
    };
    for (let i$LWS = 0, {
      length: length$LWS2
    } = ownKeys$LWS; i$LWS < length$LWS2; i$LWS += 1) {
      const key$LWS = ownKeys$LWS[i$LWS];
      clone$LWS[key$LWS] = options$LWS[key$LWS];
    }
    return clone$LWS;
  }
  const consoleRef$LWS = console;
  const {
    warn: consoleWarnRef$LWS
  } = consoleRef$LWS;
  function consoleWarn$LWS(...args$LWS) {
    ReflectApply$LWS$1(consoleWarnRef$LWS, consoleRef$LWS, args$LWS);
  }
  const trackedLiveTargets$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
  function isTargetLive$LWS(target$LWS, targetTraits$LWS = 0) {
    if (targetTraits$LWS & 1 || targetTraits$LWS & 2 || targetTraits$LWS & 64 || target$LWS === null || target$LWS === void 0 || target$LWS === ObjectProto$LWS$1 || target$LWS === RegExpProto$LWS$1) {
      return false;
    }
    if (typeof target$LWS === "function") {
      try {
        return trackedLiveTargets$LWS.has(target$LWS) || ObjectHasOwn$LWS$1(target$LWS, SYMBOL_LIVE_OBJECT$LWS);
      } catch (_unused16$LWS) {
      }
      return false;
    }
    if (typeof target$LWS === "object") {
      try {
        if (trackedLiveTargets$LWS.has(target$LWS) || ObjectHasOwn$LWS$1(target$LWS, SYMBOL_LIVE_OBJECT$LWS)) {
          return true;
        }
      } catch (_unused17$LWS) {
      }
      let constructor$LWS;
      try {
        ({
          constructor: constructor$LWS
        } = target$LWS);
        if (constructor$LWS === ObjectCtor$LWS$1) {
          return true;
        }
      } catch (_unused18$LWS) {
      }
      try {
        if (ReflectGetPrototypeOf$LWS$1(target$LWS) === null && (typeof constructor$LWS !== "function" || constructor$LWS.prototype !== target$LWS)) {
          return true;
        }
      } catch (_unused19$LWS) {
      }
      if (targetTraits$LWS === 0) {
        try {
          if (ArrayIsArray$LWS$1(target$LWS)) {
            return true;
          }
        } catch (_unused20$LWS) {
          return false;
        }
        if (ArrayBufferIsView$LWS(target$LWS)) {
          return true;
        }
      }
      try {
        if (ObjectHasOwn$LWS$1(target$LWS, "lastIndex")) {
          ReflectApply$LWS$1(RegExpProtoSourceGetter$LWS, target$LWS, []);
          return true;
        }
      } catch (_unused21$LWS) {
      }
      try {
        if ("byteLength" in target$LWS) {
          ReflectApply$LWS$1(ArrayBufferProtoByteLengthGetter$LWS, target$LWS, []);
          return true;
        }
      } catch (_unused22$LWS) {
      }
    }
    return false;
  }
  function trackAsLiveTarget$LWS(target$LWS) {
    trackedLiveTargets$LWS.add(target$LWS);
    return target$LWS;
  }
  const NS_HEAD$LWS = `${LOCKER_SERVICE_KEY$LWS}-`;
  const NS_TAIL$LWS = "$";
  const STORAGE_NS_HEAD$LWS = `${LOCKER_SERVICE_KEY$LWS}[`;
  const STORAGE_NS_TAIL$LWS = "]";
  function getNamespaceMarker$LWS(namespace$LWS) {
    return `${NS_HEAD$LWS}${namespace$LWS}${NS_TAIL$LWS}`;
  }
  function getStorageNamespaceMarker$LWS(namespace$LWS) {
    return `${STORAGE_NS_HEAD$LWS}${namespace$LWS}${STORAGE_NS_TAIL$LWS}`;
  }
  function prependNamespaceMarker$LWS(key$LWS, namespace$LWS) {
    return `${getNamespaceMarker$LWS(namespace$LWS)}${key$LWS}`;
  }
  function prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS) {
    return `${getStorageNamespaceMarker$LWS(namespace$LWS)}${key$LWS}`;
  }
  function removeNamespaceMarker$LWS(key$LWS, namespace$LWS) {
    if (typeof key$LWS === "string") {
      const marker$LWS = getNamespaceMarker$LWS(namespace$LWS);
      return ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [marker$LWS]) ? ReflectApply$LWS$1(StringProtoSlice$LWS$1, key$LWS, [marker$LWS.length]) : key$LWS;
    }
    return "";
  }
  function removeStorageNamespaceMarker$LWS(key$LWS, namespace$LWS) {
    if (typeof key$LWS === "string") {
      const marker$LWS = getStorageNamespaceMarker$LWS(namespace$LWS);
      return ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [marker$LWS]) ? ReflectApply$LWS$1(StringProtoSlice$LWS$1, key$LWS, [marker$LWS.length]) : key$LWS;
    }
    return "";
  }
  function startsWithNamespaceMarker$LWS(key$LWS, namespace$LWS) {
    return typeof key$LWS === "string" && ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [getNamespaceMarker$LWS(namespace$LWS)]);
  }
  function startsWithStorageNamespaceMarker$LWS(key$LWS, namespace$LWS) {
    return typeof key$LWS === "string" && ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [getStorageNamespaceMarker$LWS(namespace$LWS)]);
  }
  const PromiseCtor$LWS = Promise;
  const {
    catch: PromiseProtoCatch$LWS,
    then: PromiseProtoThen$LWS
  } = PromiseCtor$LWS.prototype;
  const PromiseResolve$LWS = PromiseCtor$LWS.resolve.bind(PromiseCtor$LWS);
  const PromiseReject$LWS = PromiseCtor$LWS.reject.bind(PromiseCtor$LWS);
  /*! version: 0.18.14 */
  /*!
   * Copyright (C) 2019 salesforce.com, inc.
   */
  var _rootWindow$CustomEle$LWS;
  const AbortControllerCtor$LWS = AbortController;
  const {
    prototype: AbortControllerProto$LWS
  } = AbortControllerCtor$LWS;
  const {
    abort: AbortControllerProtoAbort$LWS
  } = AbortControllerProto$LWS;
  const AbortControllerProtoSignalGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbortControllerProto$LWS, "signal");
  const {
    prototype: AttrProto$LWS
  } = Attr;
  const AttrProtoNameGetter$LWS = ObjectLookupOwnGetter$LWS$1(AttrProto$LWS, "name");
  const AttrProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS$1(AttrProto$LWS, "namespaceURI");
  const AttrProtoOwnerElementGetter$LWS = ObjectLookupOwnGetter$LWS$1(AttrProto$LWS, "ownerElement");
  const {
    get: AttrProtoValueGetter$LWS,
    set: AttrProtoValueSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(AttrProto$LWS, "value");
  const rootDocument$LWS = document;
  const {
    prototype: DocumentProto$LWS
  } = Document;
  const {
    createComment: DocumentProtoCreateComment$LWS,
    createElement: DocumentProtoCreateElement$LWS$1,
    createElementNS: DocumentProtoCreateElementNS$LWS,
    getElementById: DocumentProtoGetElementById$LWS
  } = DocumentProto$LWS;
  const DocumentProtoBodyGetter$LWS$1 = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS, "body");
  const {
    get: DocumentProtoCookieGetter$LWS,
    set: DocumentProtoCookieSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(DocumentProto$LWS, "cookie");
  const DocumentProtoDefaultViewGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS, "defaultView");
  const DocumentProtoDocumentElementGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS, "documentElement");
  const DocumentProtoHeadGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS, "head");
  const DocumentProtoImplementationGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS, "implementation");
  const {
    prototype: ElementProto$LWS
  } = Element;
  const {
    closest: ElementProtoClosest$LWS,
    getAttribute: ElementProtoGetAttribute$LWS,
    getAttributeNode: ElementProtoGetAttributeNode$LWS,
    getAttributeNodeNS: ElementProtoGetAttributeNodeNS$LWS,
    hasAttribute: ElementProtoHasAttribute$LWS,
    querySelector: ElementProtoQuerySelector$LWS,
    querySelectorAll: ElementProtoQuerySelectorAll$LWS,
    removeAttribute: ElementProtoRemoveAttribute$LWS,
    removeAttributeNode: ElementProtoRemoveAttributeNode$LWS,
    removeAttributeNS: ElementProtoRemoveAttributeNS$LWS,
    setAttribute: ElementProtoSetAttribute$LWS$1,
    setAttributeNS: ElementProtoSetAttributeNS$LWS,
    toggleAttribute: ElementProtoToggleAttribute$LWS
  } = ElementProto$LWS;
  const {
    get: ElementProtoInnerHTMLGetter$LWS,
    set: ElementProtoInnerHTMLSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, "innerHTML");
  const ElementProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS$1(ElementProto$LWS, "namespaceURI");
  const {
    get: ElementProtoOuterHTMLGetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, "outerHTML");
  const ElementProtoTagNameGetter$LWS = ObjectLookupOwnGetter$LWS$1(ElementProto$LWS, "tagName");
  const HTMLTemplateElementProtoContentGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLTemplateElement.prototype, "content");
  const {
    prototype: NodeProto$LWS$1
  } = Node;
  const {
    appendChild: NodeProtoAppendChild$LWS$1,
    cloneNode: NodeProtoCloneNode$LWS,
    isEqualNode: NodeProtoIsEqualNode$LWS
  } = NodeProto$LWS$1;
  const NodeProtoChildNodesGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, "childNodes");
  const NodeProtoFirstChildGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, "firstChild");
  const NodeProtoIsConnectedGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, "isConnected");
  ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, "lastChild");
  const NodeProtoNodeNameGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, "nodeName");
  const NodeProtoOwnerDocumentGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, "ownerDocument");
  ReflectGetOwnPropertyDescriptor$LWS(NodeProto$LWS$1, "textContent");
  const rootWindow$LWS$1 = window;
  const {
    location: rootWindowLocation$LWS,
    top: rootWindowTop$LWS
  } = rootWindow$LWS$1;
  const {
    setTimeout: WindowSetTimeout$LWS
  } = rootWindow$LWS$1;
  const {
    clearInterval: WindowClearInterval$LWS,
    decodeURIComponent: WindowDecodeURIComponent$LWS,
    encodeURIComponent: WindowEncodeURIComponent$LWS,
    fetch: WindowFetch$LWS,
    setInterval: WindowSetInterval$LWS,
    top: topWindow$LWS
  } = rootWindow$LWS$1;
  const WindowQueueMicrotask$LWS = (() => {
    const {
      queueMicrotask: queueMicrotask$LWS
    } = rootWindow$LWS$1;
    if (typeof queueMicrotask$LWS === "function") {
      return queueMicrotask$LWS;
    }
    return function queueMicrotask$LWS2(callback$LWS) {
      let promise$LWS = PromiseResolve$LWS();
      promise$LWS = ReflectApply$LWS$1(PromiseProtoThen$LWS, promise$LWS, [callback$LWS]);
      ReflectApply$LWS$1(PromiseProtoCatch$LWS, promise$LWS, [(error) => WindowSetTimeout$LWS(() => {
        throw error;
      }, 0)]);
    };
  })();
  const WindowDocumentGetter$LWS = ObjectLookupOwnGetter$LWS$1(rootWindow$LWS$1, "document");
  const WindowFrameElementGetter$LWS = ObjectLookupOwnGetter$LWS$1(rootWindow$LWS$1, "frameElement");
  const WindowLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(rootWindow$LWS$1, "length");
  const WindowLocationGetter$LWS = ObjectLookupOwnGetter$LWS$1(rootWindow$LWS$1, "location");
  function isWindow$LWS(value$LWS) {
    if (typeof value$LWS === "object" && value$LWS !== null && ObjectHasOwn$LWS$1(value$LWS, "window") && value$LWS.window === value$LWS) {
      try {
        ReflectApply$LWS$1(WindowLocationGetter$LWS, value$LWS, []);
        return true;
      } catch (_unused$LWS) {
      }
    }
    return false;
  }
  class Validator$LWS {
    constructor(document$LWS, {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS
    }) {
      this.isAllowedSharedElementChild = (element$LWS) => element$LWS instanceof this._constructors.HTMLLinkElement || element$LWS instanceof this._constructors.HTMLScriptElement;
      this.isEqualDomString = (leftString$LWS, rightString$LWS) => {
        ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, this._templates.left, [leftString$LWS]);
        ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, this._templates.right, [rightString$LWS]);
        return deepIsEqualNode$LWS(this._templates.left, this._templates.right);
      };
      this.isSharedElement = (element$LWS) => element$LWS === ReflectApply$LWS$1(DocumentProtoHeadGetter$LWS, this._document, []) || element$LWS === ReflectApply$LWS$1(DocumentProtoBodyGetter$LWS$1, this._document, []) || element$LWS === ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, this._document, []);
      this._constructors = {
        HTMLLinkElement: HTMLLinkElement$LWS,
        HTMLScriptElement: HTMLScriptElement$LWS
      };
      this._document = document$LWS;
      this._templates = {
        left: ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, this._document, ["template"]),
        right: ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, this._document, ["template"])
      };
    }
  }
  function deepIsEqualNode$LWS(leftRoot$LWS, rightRoot$LWS) {
    const leftRootNode$LWS = leftRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS$1(HTMLTemplateElementProtoContentGetter$LWS, leftRoot$LWS, []) : leftRoot$LWS;
    const rightRootNode$LWS = rightRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS$1(HTMLTemplateElementProtoContentGetter$LWS, rightRoot$LWS, []) : rightRoot$LWS;
    if (ReflectApply$LWS$1(NodeProtoIsEqualNode$LWS, leftRootNode$LWS, [rightRootNode$LWS])) {
      const leftChildNodes$LWS = ReflectApply$LWS$1(NodeProtoChildNodesGetter$LWS, leftRootNode$LWS, []);
      const childCount$LWS = leftChildNodes$LWS.length;
      if (childCount$LWS > 0) {
        const rightChildNodes$LWS = ReflectApply$LWS$1(NodeProtoChildNodesGetter$LWS, rightRootNode$LWS, []);
        for (let i$LWS = 0; i$LWS < childCount$LWS; i$LWS += 1) {
          if (deepIsEqualNode$LWS(leftChildNodes$LWS[i$LWS], rightChildNodes$LWS[i$LWS]) === false) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }
  const rootValidator$LWS = new Validator$LWS(rootDocument$LWS, rootWindow$LWS$1);
  const documentToValidatorMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1([[rootDocument$LWS, rootValidator$LWS]]));
  function getValidator$LWS(document$LWS, globalObject$LWS) {
    if (globalObject$LWS === void 0 || globalObject$LWS === rootWindow$LWS$1) {
      return rootValidator$LWS;
    }
    let validator$LWS = documentToValidatorMap$LWS.get(document$LWS);
    if (validator$LWS === void 0) {
      validator$LWS = new Validator$LWS(document$LWS, globalObject$LWS);
      documentToValidatorMap$LWS.set(document$LWS, validator$LWS);
    }
    return validator$LWS;
  }
  const BlobCtor$LWS = Blob;
  const {
    prototype: BlobProto$LWS
  } = BlobCtor$LWS;
  const {
    slice: BlobProtoSlice$LWS
  } = BlobProto$LWS;
  const BlobProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS$1(BlobProto$LWS, "size");
  const BlobProtoTypeGetter$LWS = ObjectLookupOwnGetter$LWS$1(BlobProto$LWS, "type");
  const {
    navigator: navigator$LWS$1,
    navigator: {
      userAgentData: userAgentData$LWS$1
    }
  } = rootWindow$LWS$1;
  const brands$LWS$1 = userAgentData$LWS$1 == null ? void 0 : userAgentData$LWS$1.brands;
  const chromiumUserAgentRegExp$LWS$1 = / (?:Headless)?Chrome\/\d+/;
  const webKitUserAgentRegExp$LWS = /WebKit/i;
  let userAgent$LWS$1;
  function getUserAgent$LWS$1() {
    if (userAgent$LWS$1 === void 0) {
      userAgent$LWS$1 = navigator$LWS$1.userAgent;
    }
    return userAgent$LWS$1;
  }
  const CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS = LOCKER_SERVICE_KEY_LOWERED$LWS;
  const IS_CHROMIUM_BROWSER$LWS$1 = ArrayIsArray$LWS$1(brands$LWS$1) && brands$LWS$1.length ? ReflectApply$LWS$1(ArrayProtoFind$LWS$1, brands$LWS$1, [
    (item$LWS) => (item$LWS == null ? void 0 : item$LWS.brand) === "Chromium"
  ]) !== void 0 : ReflectApply$LWS$1(RegExpProtoTest$LWS$1, chromiumUserAgentRegExp$LWS$1, [getUserAgent$LWS$1()]);
  const IS_WEBKIT_BROWSER$LWS = !IS_CHROMIUM_BROWSER$LWS$1 && (ArrayIsArray$LWS$1(brands$LWS$1) && brands$LWS$1.length ? ReflectApply$LWS$1(ArrayProtoFind$LWS$1, brands$LWS$1, [
    (item$LWS) => {
      const brand$LWS = item$LWS == null ? void 0 : item$LWS.brand;
      return typeof brand$LWS === "string" && ReflectApply$LWS$1(RegExpProtoTest$LWS$1, webKitUserAgentRegExp$LWS, [brand$LWS]);
    }
  ]) !== void 0 : ReflectApply$LWS$1(RegExpProtoTest$LWS$1, webKitUserAgentRegExp$LWS, [getUserAgent$LWS$1()]));
  const CustomElementRegistryProto$LWS = rootWindow$LWS$1 == null ? void 0 : (_rootWindow$CustomEle$LWS = rootWindow$LWS$1.CustomElementRegistry) == null ? void 0 : _rootWindow$CustomEle$LWS.prototype;
  const CustomElementRegistryProtoDefine$LWS = CustomElementRegistryProto$LWS == null ? void 0 : CustomElementRegistryProto$LWS.define;
  const CustomElementRegistryProtoGet$LWS = CustomElementRegistryProto$LWS == null ? void 0 : CustomElementRegistryProto$LWS.get;
  const CustomElementRegistryProtoWhenDefined$LWS = CustomElementRegistryProto$LWS == null ? void 0 : CustomElementRegistryProto$LWS.whenDefined;
  const {
    getElementById: DocumentFragmentProtoGetElementById$LWS
  } = DocumentFragment.prototype;
  const DOMExceptionCtor$LWS$1 = DOMException;
  ObjectLookupOwnGetter$LWS$1(DOMExceptionCtor$LWS$1.prototype, "code");
  const {
    createDocument: DOMImplementationProtoCreateDocument$LWS
  } = DOMImplementation.prototype;
  const DOMTokenListProtoValueGetter$LWS = ObjectLookupOwnGetter$LWS$1(DOMTokenList.prototype, "value");
  const EventCtor$LWS = Event;
  const {
    prototype: EventProto$LWS
  } = EventCtor$LWS;
  const {
    stopPropagation: EventProtoStopPropagation$LWS
  } = EventProto$LWS;
  const EventProtoCurrentTargetGetter$LWS = ObjectLookupOwnGetter$LWS$1(EventProto$LWS, "currentTarget");
  const {
    addEventListener: EventTargetProtoAddEventListener$LWS,
    dispatchEvent: EventTargetProtoDispatchEvent$LWS,
    removeEventListener: EventTargetProtoRemoveEventListener$LWS
  } = EventTarget.prototype;
  const {
    get: HTMLAnchorElementProtoHrefGetter$LWS,
    set: HTMLAnchorElementProtoHrefSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(HTMLAnchorElement.prototype, "href");
  const HTMLAnchorElementProtoPathnameGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLAnchorElement.prototype, "pathname");
  const HTMLAnchorElementProtoProtocolGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLAnchorElement.prototype, "protocol");
  ObjectLookupOwnGetter$LWS$1(HTMLElement.prototype, "style");
  const {
    prototype: HTMLIFrameElementProto$LWS
  } = HTMLIFrameElement;
  ObjectLookupOwnGetter$LWS$1(HTMLIFrameElementProto$LWS, "contentWindow");
  const HTMLIFrameElementProtoSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElementProto$LWS, "src");
  const HTMLScriptElementCtor$LWS = HTMLScriptElement;
  const {
    prototype: HTMLScriptElementProto$LWS
  } = HTMLScriptElementCtor$LWS;
  const {
    get: HTMLScriptElementProtoSrcGetter$LWS,
    set: HTMLScriptElementProtoSrcSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElementProto$LWS, "src");
  const NAMESPACE_DEFAULT$LWS = "default";
  const NAMESPACE_SVG$LWS = "http://www.w3.org/2000/svg";
  const NAMESPACE_XHTML$LWS = "http://www.w3.org/1999/xhtml";
  const NAMESPACE_XLINK$LWS = "http://www.w3.org/1999/xlink";
  const RequestProtoURLGetter$LWS = ObjectLookupOwnGetter$LWS$1(Request.prototype, "url");
  const ResponseCtor$LWS = Response;
  const ResponseProto$LWS = ResponseCtor$LWS.prototype;
  const ResponseProtoOkGetter$LWS = ObjectLookupOwnGetter$LWS$1(ResponseProto$LWS, "ok");
  ObjectLookupOwnGetter$LWS$1(ResponseProto$LWS, "status");
  ObjectLookupOwnGetter$LWS$1(ResponseProto$LWS, "statusText");
  const {
    text: ResponseProtoText$LWS
  } = ResponseProto$LWS;
  const {
    createObjectURL: URLCreateObjectURL$LWS,
    revokeObjectURL: URLRevokeObjectURL$LWS
  } = URL;
  const SCRIPT_EVALUATOR_PROPERTY_NAME$LWS = "$evaluator$";
  const SCRIPT_HOOK_SOURCE_TEXT$LWS = `document.currentScript.${SCRIPT_EVALUATOR_PROPERTY_NAME$LWS}`;
  const evaluatedScriptElements$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
  const originalTextContentCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const resolvedURLRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function defineScriptAccessorProperty$LWS(script$LWS, propKey$LWS, getter$LWS, setter$LWS) {
    ReflectDefineProperty$LWS$1(script$LWS, propKey$LWS, {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get: getter$LWS,
      set: setter$LWS
    });
  }
  function defineScriptEvaluatorProperty$LWS(script$LWS, callback$LWS) {
    if (!ReflectDefineProperty$LWS$1(script$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS, {
      __proto__: null,
      configurable: true,
      get: ReflectApply$LWS$1(FunctionProtoBind$LWS, () => {
        evaluatedScriptElements$LWS.add(script$LWS);
        deleteScriptEvaluatorProperty$LWS(script$LWS);
        const ownerDoc$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, script$LWS, []);
        const defaultView$LWS = ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, ownerDoc$LWS, []);
        const context$LWS = {
          [UNCOMPILED_LOCATION_NAME$LWS]: defaultView$LWS.location,
          [UNCOMPILED_TOP_NAME$LWS]: defaultView$LWS.top
        };
        callback$LWS(context$LWS, defaultView$LWS, ownerDoc$LWS);
      }, [])
    })) {
      throw new LockerSecurityError$LWS(`Cannot evaluate ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, script$LWS, [])}`);
    }
  }
  function deleteOriginalTextContent$LWS(script$LWS) {
    originalTextContentCache$LWS.delete(script$LWS);
  }
  function deleteScriptEvaluatorProperty$LWS(script$LWS) {
    ReflectDeleteProperty$LWS$1(script$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS);
  }
  function getOriginalScriptTextContent$LWS(script$LWS) {
    return originalTextContentCache$LWS.get(script$LWS);
  }
  function isScriptEvaluated$LWS(script$LWS) {
    return evaluatedScriptElements$LWS.has(script$LWS);
  }
  function isScriptURLEvaluatorHookDefined$LWS(script$LWS) {
    return resolvedURLRegistryCache$LWS.has(script$LWS);
  }
  function isTextContentEvaluatorHookDefined$LWS(script$LWS) {
    return originalTextContentCache$LWS.has(script$LWS);
  }
  function setOriginalScriptTextContent$LWS(script$LWS, textContent$LWS) {
    return originalTextContentCache$LWS.set(script$LWS, textContent$LWS);
  }
  const documentPattern$LWS = "document";
  const windowPattern$LWS = "document\\.defaultView|frames|globalThis|self|window";
  const webpackGlobalPattern$LWS = `${windowPattern$LWS}|global`;
  const webpackGlobalDocumentPattern$LWS = `${documentPattern$LWS}|global.document`;
  const locationReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(`${documentPattern$LWS}|${windowPattern$LWS}`, "location");
  const locationReferencesWithWebpackRegExp$LWS = createPropertyReferenceRegExp$LWS(`${webpackGlobalDocumentPattern$LWS}|${webpackGlobalPattern$LWS}`, "location");
  const sandboxEvalContextNameRegExp$LWS = new RegExpCtor$LWS$1(`(?:^|\\W)${escapeRegExp$LWS(SANDBOX_EVAL_CONTEXT_NAME$LWS)}(?:\\W|$)`);
  const webpackRequireNameRegExp$LWS = new RegExpCtor$LWS$1(`\\b${escapeRegExp$LWS(WEBPACK_REQUIRE_NAME$LWS)}\\b`);
  const windowTopReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(windowPattern$LWS, "top");
  const windowTopReferencesWithWebpackRegExp$LWS = createPropertyReferenceRegExp$LWS(webpackGlobalPattern$LWS, "top");
  function createPropertyReferenceRegExp$LWS(objectPattern$LWS, key$LWS) {
    return new RegExpCtor$LWS$1(`\\b(?:${objectPattern$LWS})\\.${key$LWS}(\\s*(?:[?*/%&^|+-]|>>>?|<<)*=(?=[^=]))?`, "g");
  }
  function compileSourceText$LWS(sourceText$LWS) {
    const transforms$LWS = {
      location: false,
      windowTop: false
    };
    if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, sandboxEvalContextNameRegExp$LWS, [sourceText$LWS])) {
      return {
        code: sourceText$LWS,
        transforms: transforms$LWS
      };
    }
    let locationRegExp$LWS;
    let topRegExp$LWS;
    if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, webpackRequireNameRegExp$LWS, [sourceText$LWS])) {
      locationRegExp$LWS = locationReferencesWithWebpackRegExp$LWS;
      topRegExp$LWS = windowTopReferencesWithWebpackRegExp$LWS;
    } else {
      locationRegExp$LWS = locationReferencesRegExp$LWS;
      topRegExp$LWS = windowTopReferencesRegExp$LWS;
    }
    sourceText$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, sourceText$LWS, [locationRegExp$LWS, (_match$LWS, assignmentOperator$LWS) => {
      transforms$LWS.location = true;
      return assignmentOperator$LWS ? `${UNCOMPILED_LOCATION_NAME$LWS}.href${assignmentOperator$LWS}` : UNCOMPILED_LOCATION_NAME$LWS;
    }]);
    sourceText$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, sourceText$LWS, [topRegExp$LWS, () => {
      transforms$LWS.windowTop = true;
      return UNCOMPILED_TOP_NAME$LWS;
    }]);
    return {
      code: sourceText$LWS,
      transforms: transforms$LWS
    };
  }
  function generateContextAssignmentCodeFromContextNames$LWS(names$LWS) {
    names$LWS[names$LWS.length] = "location";
    names$LWS[names$LWS.length] = "top";
    return `const {${ReflectApply$LWS$1(ArrayProtoToString$LWS$1, names$LWS, [])}}=${SANDBOX_EVAL_CONTEXT_NAME$LWS}`;
  }
  function getContextNamesFromCompilationTransforms$LWS(transforms$LWS) {
    const names$LWS = toSafeArray$LWS$1([]);
    if (transforms$LWS.location) {
      names$LWS[names$LWS.length] = UNCOMPILED_LOCATION_NAME$LWS;
    }
    if (transforms$LWS.windowTop) {
      names$LWS[names$LWS.length] = UNCOMPILED_TOP_NAME$LWS;
    }
    return names$LWS;
  }
  function transformSourceText$LWS(sourceText$LWS) {
    const {
      code: code$LWS,
      transforms: transforms$LWS
    } = compileSourceText$LWS(sourceText$LWS);
    const contextNames$LWS = getContextNamesFromCompilationTransforms$LWS(transforms$LWS);
    if (!contextNames$LWS.length) {
      return code$LWS;
    }
    const prefix$LWS = `${generateContextAssignmentCodeFromContextNames$LWS(contextNames$LWS)};`;
    const pragmaIndex$LWS = indexOfPragma$LWS(code$LWS, "use strict");
    if (pragmaIndex$LWS === -1) {
      return prefix$LWS + code$LWS;
    }
    let afterPragmaIndex$LWS = pragmaIndex$LWS + 12;
    if (afterPragmaIndex$LWS < code$LWS.length && code$LWS[afterPragmaIndex$LWS] === ";") {
      afterPragmaIndex$LWS += 1;
    }
    return ReflectApply$LWS$1(StringProtoSlice$LWS$1, code$LWS, [0, afterPragmaIndex$LWS]) + prefix$LWS + ReflectApply$LWS$1(StringProtoSlice$LWS$1, code$LWS, [afterPragmaIndex$LWS]);
  }
  const {
    key: StorageProtoKey$LWS,
    getItem: StorageProtoGetItem$LWS,
    removeItem: StorageProtoRemoveItem$LWS,
    setItem: StorageProtoSetItem$LWS
  } = Storage.prototype;
  ReflectGetOwnPropertyDescriptor$LWS(SVGScriptElement.prototype, "href");
  const XhrCtor$LWS = XMLHttpRequest;
  const {
    prototype: XhrProto$LWS
  } = XhrCtor$LWS;
  const {
    abort: XhrProtoAbort$LWS,
    open: XhrProtoOpen$LWS,
    send: XhrProtoSend$LWS
  } = XhrProto$LWS;
  const XhrProtoResponseTextGetter$LWS = ObjectLookupOwnGetter$LWS$1(XhrProto$LWS, "responseText");
  const XhrProtoStatusGetter$LWS = ObjectLookupOwnGetter$LWS$1(XhrProto$LWS, "status");
  ObjectLookupOwnSetter$LWS(XhrProto$LWS, "withCredentials");
  /*! version: 0.18.14 */
  /*!
   * Copyright (C) 2019 salesforce.com, inc.
   */
  const ALLOWED_MIME_TYPES$LWS = ["application/octet-stream", "application/json", "application/pdf", "video/", "audio/", "image/", "font/", "text/plain", "text/markdown", "application/zip", "application/x-bzip", "application/x-rar-compressed", "application/x-tar"];
  const validMimeTypeRegExp$LWS = /^[a-z]+\/[a-z0-9.+-]+$/;
  function isMIMETypeAllowed$LWS(mimeType$LWS) {
    if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, validMimeTypeRegExp$LWS, [mimeType$LWS])) {
      for (let i$LWS = 0, {
        length: length$LWS2
      } = ALLOWED_MIME_TYPES$LWS; i$LWS < length$LWS2; i$LWS += 1) {
        if (ReflectApply$LWS$1(StringProtoStartsWith$LWS, mimeType$LWS, [ALLOWED_MIME_TYPES$LWS[i$LWS]])) {
          return true;
        }
      }
    }
    return false;
  }
  const DISALLOWED_ENDPOINTS_LIST$LWS = ["/aura", "/webruntime"];
  const URL_SCHEMES_LIST$LWS = toSafeArray$LWS$1(["http:", "https:"]);
  const newlinesAndTabsRegExp$LWS = /[\u2028\u2029\n\r\t]/g;
  const normalizerAnchor$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, rootDocument$LWS, ["a"]);
  function isValidURL$LWS(parsedURL$LWS) {
    const loweredPathname$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, parsedURL$LWS.pathname, []);
    for (let i$LWS = 0, {
      length: length$LWS2
    } = DISALLOWED_ENDPOINTS_LIST$LWS; i$LWS < length$LWS2; i$LWS += 1) {
      if (ReflectApply$LWS$1(StringProtoEndsWith$LWS, loweredPathname$LWS, [DISALLOWED_ENDPOINTS_LIST$LWS[i$LWS]]) || ReflectApply$LWS$1(StringProtoIncludes$LWS, loweredPathname$LWS, [`${DISALLOWED_ENDPOINTS_LIST$LWS[i$LWS]}/`])) {
        return false;
      }
    }
    return true;
  }
  function isValidURLScheme$LWS(url$LWS) {
    ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
    return URL_SCHEMES_LIST$LWS.includes(ReflectApply$LWS$1(HTMLAnchorElementProtoProtocolGetter$LWS, normalizerAnchor$LWS, []));
  }
  function parseURL$LWS(url$LWS) {
    const normalizedURL$LWS = sanitizeURLForElement$LWS(url$LWS);
    return {
      normalizedURL: normalizedURL$LWS,
      pathname: WindowDecodeURIComponent$LWS(ReflectApply$LWS$1(HTMLAnchorElementProtoPathnameGetter$LWS, normalizerAnchor$LWS, []))
    };
  }
  function resolveURL$LWS(url$LWS) {
    ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
    return ReflectApply$LWS$1(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []);
  }
  function sanitizeURLForElement$LWS(url$LWS) {
    return resolveURL$LWS(sanitizeURLString$LWS(url$LWS));
  }
  function sanitizeURLString$LWS(urlString$LWS) {
    return urlString$LWS === "" ? urlString$LWS : ReflectApply$LWS$1(StringProtoReplace$LWS, urlString$LWS, [newlinesAndTabsRegExp$LWS, ""]);
  }
  /*! version: 0.18.14 */
  /*! @license DOMPurify 2.4.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.0/LICENSE */
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray(arr);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze, seal = Object.seal, create = Object.create;
  var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
  if (!apply) {
    apply = function apply2(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }
  if (!freeze) {
    freeze = function freeze2(x) {
      return x;
    };
  }
  if (!seal) {
    seal = function seal2(x) {
      return x;
    };
  }
  if (!construct) {
    construct = function construct2(Func, args) {
      return _construct(Func, _toConsumableArray(args));
    };
  }
  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);
  var regExpTest = unapply(RegExp.prototype.test);
  var typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return apply(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return construct(func, args);
    };
  }
  function addToSet(set, array, transformCaseFunc) {
    transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;
    if (setPrototypeOf) {
      setPrototypeOf(set, null);
    }
    var l = array.length;
    while (l--) {
      var element = array[l];
      if (typeof element === "string") {
        var lcElement = transformCaseFunc(element);
        if (lcElement !== element) {
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }
          element = lcElement;
        }
      }
      set[element] = true;
    }
    return set;
  }
  function clone(object) {
    var newObject = create(null);
    var property;
    for (property in object) {
      if (apply(hasOwnProperty, object, [property])) {
        newObject[property] = object[property];
      }
    }
    return newObject;
  }
  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object = getPrototypeOf(object);
    }
    function fallbackValue(element) {
      console.warn("fallback value for", element);
      return null;
    }
    return fallbackValue;
  }
  var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
  var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  var text = freeze(["#text"]);
  var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
  var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
  var DOCTYPE_NAME = seal(/^html$/i);
  var getGlobal = function getGlobal2() {
    return typeof window === "undefined" ? null : window;
  };
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes2, document2) {
    if (_typeof(trustedTypes2) !== "object" || typeof trustedTypes2.createPolicy !== "function") {
      return null;
    }
    var suffix = null;
    var ATTR_NAME = "data-tt-policy-suffix";
    if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document2.currentScript.getAttribute(ATTR_NAME);
    }
    var policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes2.createPolicy(policyName, {
        createHTML: function createHTML(html2) {
          return html2;
        },
        createScriptURL: function createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_) {
      console.warn("TrustedTypes policy " + policyName + " could not be created.");
      return null;
    }
  };
  function createDOMPurify() {
    var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    var DOMPurify = function DOMPurify2(root) {
      return createDOMPurify(root);
    };
    DOMPurify.version = "2.4.0";
    DOMPurify.removed = [];
    if (!window2 || !window2.document || window2.document.nodeType !== 9) {
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    var originalDocument = window2.document;
    var document2 = window2.document;
    var DocumentFragment2 = window2.DocumentFragment, HTMLTemplateElement2 = window2.HTMLTemplateElement, Node2 = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser = window2.DOMParser, trustedTypes2 = window2.trustedTypes;
    var ElementPrototype = Element2.prototype;
    var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    var getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement2 === "function") {
      var template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes2, originalDocument);
    var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
    var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;
    var documentMode = {};
    try {
      documentMode = clone(document2).documentMode ? document2.documentMode : {};
    } catch (_) {
    }
    var hooks = {};
    DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
    var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    var FORBID_TAGS = null;
    var FORBID_ATTR = null;
    var ALLOW_ARIA_ATTR = true;
    var ALLOW_DATA_ATTR = true;
    var ALLOW_UNKNOWN_PROTOCOLS = false;
    var SAFE_FOR_TEMPLATES = false;
    var WHOLE_DOCUMENT = false;
    var SET_CONFIG = false;
    var FORCE_BODY = false;
    var RETURN_DOM = false;
    var RETURN_DOM_FRAGMENT = false;
    var RETURN_TRUSTED_TYPE = false;
    var SANITIZE_DOM = true;
    var SANITIZE_NAMED_PROPS = false;
    var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    var KEEP_CONTENT = true;
    var IN_PLACE = false;
    var USE_PROFILES = {};
    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
    var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;
    var PARSER_MEDIA_TYPE;
    var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
    var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    var transformCaseFunc;
    var CONFIG = null;
    var formElement = document2.createElement("form");
    var isRegexOrFunction = function isRegexOrFunction2(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    var _parseConfig = function _parseConfig2(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      if (!cfg || _typeof(cfg) !== "object") {
        cfg = {};
      }
      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x) {
        return x;
      } : stringToLowerCase;
      ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
      }
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    };
    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
    var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
    var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
    var ALL_SVG_TAGS = addToSet({}, svg$1);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);
    var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
    var _checkValidNamespace = function _checkValidNamespace2(element) {
      var parent = getParentNode(element);
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: HTML_NAMESPACE,
          tagName: "template"
        };
      }
      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);
      if (element.namespaceURI === SVG_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      return false;
    };
    var _forceRemove = function _forceRemove2(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });
      try {
        node.parentNode.removeChild(node);
      } catch (_) {
        try {
          node.outerHTML = emptyHTML;
        } catch (_2) {
          node.remove();
        }
      }
    };
    var _removeAttribute = function _removeAttribute2(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }
      node.removeAttribute(name);
      if (name === "is" && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {
          }
        } else {
          try {
            node.setAttribute(name, "");
          } catch (_) {
          }
        }
      }
    };
    var _initDocument = function _initDocument2(dirty) {
      var doc;
      var leadingWhitespace;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
      }
      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_) {
        }
      }
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
        } catch (_) {
        }
      }
      var body = doc.body || doc.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
      }
      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    var _createIterator = function _createIterator2(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    };
    var _isClobbered = function _isClobbered2(elm) {
      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
    };
    var _isNode = function _isNode2(object) {
      return _typeof(Node2) === "object" ? object instanceof Node2 : object && _typeof(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
    };
    var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }
      arrayForEach(hooks[entryPoint], function(hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };
    var _sanitizeElements = function _sanitizeElements2(currentNode) {
      var content;
      _executeHook("beforeSanitizeElements", currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
        _forceRemove(currentNode);
        return true;
      }
      var tagName = transformCaseFunc(currentNode.nodeName);
      _executeHook("uponSanitizeElement", currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
            return false;
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
            return false;
        }
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            var childCount = childNodes.length;
            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$1, " ");
        content = stringReplace(content, ERB_EXPR$1, " ");
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      _executeHook("afterSanitizeElements", currentNode, null);
      return false;
    };
    var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
        ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
        ;
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
          ;
        else {
          return false;
        }
      } else if (URI_SAFE_ATTRIBUTES[lcName])
        ;
      else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
        ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
        ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
        ;
      else if (!value)
        ;
      else {
        return false;
      }
      return true;
    };
    var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
      return tagName.indexOf("-") > 0;
    };
    var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
      var attr;
      var value;
      var lcName;
      var l;
      _executeHook("beforeSanitizeAttributes", currentNode, null);
      var attributes = currentNode.attributes;
      if (!attributes) {
        return;
      }
      var hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;
      while (l--) {
        attr = attributes[l];
        var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
        value = name === "value" ? attr.value : stringTrim(attr.value);
        lcName = transformCaseFunc(name);
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
        value = hookEvent.attrValue;
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        _removeAttribute(name, currentNode);
        if (!hookEvent.keepAttr) {
          continue;
        }
        if (regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$1, " ");
          value = stringReplace(value, ERB_EXPR$1, " ");
        }
        var lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
          _removeAttribute(name, currentNode);
          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        if (trustedTypesPolicy && _typeof(trustedTypes2) === "object" && typeof trustedTypes2.getAttributeType === "function") {
          if (namespaceURI)
            ;
          else {
            switch (trustedTypes2.getAttributeType(lcTag, lcName)) {
              case "TrustedHTML":
                value = trustedTypesPolicy.createHTML(value);
                break;
              case "TrustedScriptURL":
                value = trustedTypesPolicy.createScriptURL(value);
                break;
            }
          }
        }
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            currentNode.setAttribute(name, value);
          }
          arrayPop(DOMPurify.removed);
        } catch (_) {
        }
      }
      _executeHook("afterSanitizeAttributes", currentNode, null);
    };
    var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      var shadowNode;
      var shadowIterator = _createIterator(fragment);
      _executeHook("beforeSanitizeShadowDOM", fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHook("uponSanitizeShadowNode", shadowNode, null);
        if (_sanitizeElements(shadowNode)) {
          continue;
        }
        if (shadowNode.content instanceof DocumentFragment2) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
        _sanitizeAttributes(shadowNode);
      }
      _executeHook("afterSanitizeShadowDOM", fragment, null);
    };
    DOMPurify.sanitize = function(dirty) {
      var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var body;
      var importedNode;
      var currentNode;
      var oldNode;
      var returnNode;
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString !== "function") {
          throw typeErrorCreate("toString is not a function");
        } else {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        }
      }
      if (!DOMPurify.isSupported) {
        if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
          if (typeof dirty === "string") {
            return window2.toStaticHTML(dirty);
          }
          if (_isNode(dirty)) {
            return window2.toStaticHTML(dirty.outerHTML);
          }
        }
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        if (dirty.nodeName) {
          var tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
          }
        }
      } else if (dirty instanceof Node2) {
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          body.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body = _initDocument(dirty);
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
      while (currentNode = nodeIterator.nextNode()) {
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }
        if (_sanitizeElements(currentNode)) {
          continue;
        }
        if (currentNode.content instanceof DocumentFragment2) {
          _sanitizeShadowDOM(currentNode.content);
        }
        _sanitizeAttributes(currentNode);
        oldNode = currentNode;
      }
      oldNode = null;
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
      }
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function(cfg) {
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag, attr, value) {
      if (!CONFIG) {
        _parseConfig({});
      }
      var lcTag = transformCaseFunc(tag);
      var lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint) {
      if (hooks[entryPoint]) {
        return arrayPop(hooks[entryPoint]);
      }
    };
    DOMPurify.removeHooks = function(entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };
    DOMPurify.removeAllHooks = function() {
      hooks = {};
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();
  /*!
   * Copyright (C) 2019 salesforce.com, inc.
   */
  const ariaAttributes$LWS = ["aria-activedescendant", "aria-atomic", "aria-autocomplete", "aria-busy", "aria-checked", "aria-controls", "aria-describedby", "aria-disabled", "aria-readonly", "aria-dropeffect", "aria-expanded", "aria-flowto", "aria-grabbed", "aria-haspopup", "aria-hidden", "aria-disabled", "aria-invalid", "aria-label", "aria-labelledby", "aria-level", "aria-live", "aria-multiline", "aria-multiselectable", "aria-orientation", "aria-owns", "aria-posinset", "aria-pressed", "aria-readonly", "aria-relevant", "aria-required", "aria-selected", "aria-setsize", "aria-sort", "aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext", "role", "target"];
  const htmlTags$LWS = ["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "caption", "canvas", "center", "cite", "code", "col", "colgroup", "command", "datalist", "dd", "del", "details", "dfn", "dir", "div", "dl", "dt", "em", "fieldset", "figure", "figcaption", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "i", "iframe", "img", "input", "ins", "keygen", "kbd", "label", "legend", "li", "map", "mark", "menu", "meter", "nav", "ol", "optgroup", "option", "output", "p", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "small", "source", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"];
  const svgTags$LWS = ["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "audio", "canvas", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "video", "view", "vkern", "use"];
  const allTags$LWS = ArrayConcat$LWS(htmlTags$LWS, svgTags$LWS);
  const CUSTOM_ELEMENT_HANDLING$LWS = {
    attributeNameCheck: /.+/,
    allowCustomizedBuiltInElements: false,
    tagNameCheck: /^[a-z][-_.\w]*-[-.0-9_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u37D0\u37F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u10000-\uEFFFF]*$/
  };
  const NODE_ALL_IN_PLACE$LWS = {
    ADD_ATTR: shallowCloneArray$LWS(ariaAttributes$LWS),
    ALLOWED_TAGS: ArrayConcat$LWS(allTags$LWS, "#document-fragment"),
    CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS$1({}, CUSTOM_ELEMENT_HANDLING$LWS),
    IN_PLACE: true
  };
  const NODE_SVG$LWS = {
    ADD_ATTR: shallowCloneArray$LWS(ariaAttributes$LWS),
    ALLOWED_TAGS: shallowCloneArray$LWS(svgTags$LWS),
    CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS$1({}, CUSTOM_ELEMENT_HANDLING$LWS),
    RETURN_DOM_FRAGMENT: true,
    SANITIZE_DOM: false
  };
  const STRING_BLOB_HTML$LWS = {
    ADD_ATTR: shallowCloneArray$LWS(ariaAttributes$LWS),
    ALLOWED_TAGS: ReflectApply$LWS$1(ArrayProtoFilter$LWS$1, allTags$LWS, [(tag$LWS) => tag$LWS !== "iframe"]),
    CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS$1({}, CUSTOM_ELEMENT_HANDLING$LWS),
    SANITIZE_DOM: false
  };
  var CONFIG$LWS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    NODE_ALL_IN_PLACE: NODE_ALL_IN_PLACE$LWS,
    NODE_SVG: NODE_SVG$LWS,
    STRING_BLOB_HTML: STRING_BLOB_HTML$LWS
  });
  const instancesBySandboxKeyRegistry$LWS = {
    __proto__: null
  };
  const SANITIZE_ATTRIBUTES_LIST$LWS = toSafeArray$LWS$1(["href", "xlink:href"]);
  const SHARED_SVG_SANITIZER_KEY$LWS = "SHARED_SVG_SANITIZER_KEY";
  const htmlTemplate$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ["template"]);
  const queue$LWS = toSafeSet$LWS(new SetCtor$LWS$1());
  const urlReplacerRegExp$LWS = /[^a-z0-9]+/gi;
  function createSantizerHooksRegistry$LWS(sandboxKey$LWS) {
    return {
      __proto__: null,
      uponSanitizeAttribute: uponSanitizeAttribute$LWS,
      uponSanitizeElement(node$LWS, data$LWS, config$LWS) {
        var _config$CUSTOM_ELEMEN$LWS;
        const {
          tagName: tagName$LWS
        } = data$LWS;
        const tagNameCheck$LWS = config$LWS == null ? void 0 : (_config$CUSTOM_ELEMEN$LWS = config$LWS.CUSTOM_ELEMENT_HANDLING) == null ? void 0 : _config$CUSTOM_ELEMEN$LWS.tagNameCheck;
        if (tagNameCheck$LWS && ReflectApply$LWS$1(RegExpProtoTest$LWS$1, tagNameCheck$LWS, [tagName$LWS]) && !ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS])) {
          ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS, sandboxKey$LWS]);
        }
      }
    };
  }
  function createUrlContainer$LWS(url$LWS) {
    const container$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ["div"]);
    ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, container$LWS, ["style", "display:none"]);
    ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, container$LWS, ["id", url$LWS]);
    const body$LWS = ReflectApply$LWS$1(DocumentProtoBodyGetter$LWS$1, document, []);
    ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, body$LWS, [container$LWS]);
    return container$LWS;
  }
  function getSanitizerForConfig$LWS(sandboxKey$LWS, configName$LWS) {
    if (typeof sandboxKey$LWS !== "string") {
      throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
    }
    if (typeof configName$LWS !== "string") {
      throw new LockerSecurityError$LWS("Invalid config name.");
    }
    let sandboxConfiguredSanitizerInstances$LWS = instancesBySandboxKeyRegistry$LWS[sandboxKey$LWS];
    if (sandboxConfiguredSanitizerInstances$LWS === void 0) {
      sandboxConfiguredSanitizerInstances$LWS = instancesBySandboxKeyRegistry$LWS[sandboxKey$LWS] = {
        __proto__: null
      };
    }
    let configuredDOMPurifyInstance$LWS = sandboxConfiguredSanitizerInstances$LWS[configName$LWS];
    if (configuredDOMPurifyInstance$LWS === void 0) {
      const config$LWS = CONFIG$LWS[configName$LWS];
      configuredDOMPurifyInstance$LWS = purify();
      configuredDOMPurifyInstance$LWS.setConfig(config$LWS);
      const hooksRegistry$LWS = createSantizerHooksRegistry$LWS(sandboxKey$LWS);
      for (const hookName$LWS in hooksRegistry$LWS) {
        configuredDOMPurifyInstance$LWS.addHook(hookName$LWS, hooksRegistry$LWS[hookName$LWS]);
      }
      sandboxConfiguredSanitizerInstances$LWS[configName$LWS] = configuredDOMPurifyInstance$LWS;
    }
    return configuredDOMPurifyInstance$LWS;
  }
  function sanitizeSvgTextReturnDOM$LWS(dirty$LWS) {
    const svgSanitizer$LWS = getSanitizerForConfig$LWS(SHARED_SVG_SANITIZER_KEY$LWS, "NODE_SVG");
    return svgSanitizer$LWS.sanitize(dirty$LWS);
  }
  function sanitizeSvgHref$LWS(url$LWS) {
    const urlAsString$LWS = toString$LWS(url$LWS);
    if (ReflectApply$LWS$1(StringProtoStartsWith$LWS, urlAsString$LWS, ["#"])) {
      return url$LWS;
    }
    const normalizedHref$LWS = parseHref$LWS(urlAsString$LWS);
    if (URL_SCHEMES_LIST$LWS.includes(normalizedHref$LWS.protocol)) {
      const container$LWS = ReflectApply$LWS$1(DocumentProtoGetElementById$LWS, document, [normalizedHref$LWS.normalizedURL]);
      if (container$LWS && normalizedHref$LWS.normalizedFragment) {
        checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS);
      } else if (!container$LWS) {
        fetchAndSanitize$LWS(normalizedHref$LWS);
      }
      return normalizedHref$LWS.requestedFragment ? `#${normalizedHref$LWS.normalizedFragment}` : `#${normalizedHref$LWS.normalizedURL}`;
    }
    return url$LWS;
  }
  function updater$LWS(container$LWS, normalizedHref$LWS) {
    const {
      normalizedFragment: normalizedFragment$LWS,
      requestedFragment: requestedFragment$LWS
    } = normalizedHref$LWS;
    let el$LWS = ReflectApply$LWS$1(ElementProtoQuerySelector$LWS, container$LWS, [`#${normalizedFragment$LWS}`]);
    if (el$LWS === null) {
      try {
        el$LWS = ReflectApply$LWS$1(ElementProtoQuerySelector$LWS, container$LWS, [`#${requestedFragment$LWS}`]);
        ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, el$LWS, ["id", normalizedFragment$LWS]);
      } catch (_unused$LWS) {
      }
    }
  }
  function checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS) {
    if (queue$LWS.has(normalizedHref$LWS.normalizedURL)) {
      const interval$LWS = WindowSetInterval$LWS(() => {
        if (!queue$LWS.has(normalizedHref$LWS.normalizedURL)) {
          updater$LWS(container$LWS, normalizedHref$LWS);
          WindowClearInterval$LWS(interval$LWS);
        }
      }, 50);
    } else {
      updater$LWS(container$LWS, normalizedHref$LWS);
    }
  }
  function fetchAndSanitize$LWS(normalizedHref$LWS) {
    const container$LWS = createUrlContainer$LWS(normalizedHref$LWS.normalizedURL);
    queue$LWS.add(normalizedHref$LWS.normalizedURL);
    const xhr$LWS = new XhrCtor$LWS();
    ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, xhr$LWS, ["load", () => {
      const status$LWS = ReflectApply$LWS$1(XhrProtoStatusGetter$LWS, xhr$LWS, []);
      if (status$LWS === 200) {
        const responseText$LWS = ReflectApply$LWS$1(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
        const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(responseText$LWS);
        if (normalizedHref$LWS.requestedFragment) {
          const el$LWS = ReflectApply$LWS$1(DocumentFragmentProtoGetElementById$LWS, fragment$LWS, [normalizedHref$LWS.requestedFragment]);
          if (el$LWS) {
            ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, el$LWS, ["id", normalizedHref$LWS.normalizedFragment]);
          }
        }
        ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, container$LWS, [fragment$LWS]);
        queue$LWS.delete(normalizedHref$LWS.normalizedURL);
      }
    }]);
    ReflectApply$LWS$1(XhrProtoOpen$LWS, xhr$LWS, ["GET", normalizedHref$LWS.requestedURL]);
    ReflectApply$LWS$1(XhrProtoSend$LWS, xhr$LWS, []);
  }
  function parseHref$LWS(url$LWS) {
    ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
    const href$LWS = ReflectApply$LWS$1(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []);
    const protocol$LWS = ReflectApply$LWS$1(HTMLAnchorElementProtoProtocolGetter$LWS, normalizerAnchor$LWS, []);
    const {
      0: requestedURL$LWS,
      1: requestedFragment$LWS
    } = ReflectApply$LWS$1(StringProtoSplit$LWS, href$LWS, ["#"]);
    const loweredUrl$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, requestedURL$LWS, []);
    const normalizedURL$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, loweredUrl$LWS, [urlReplacerRegExp$LWS, ""]);
    const normalizedFragment$LWS = requestedFragment$LWS ? `${normalizedURL$LWS}_${ReflectApply$LWS$1(StringProtoReplace$LWS, requestedFragment$LWS, [urlReplacerRegExp$LWS, ""])}` : "";
    return {
      normalizedFragment: normalizedFragment$LWS,
      normalizedURL: normalizedURL$LWS,
      protocol: protocol$LWS,
      requestedFragment: requestedFragment$LWS,
      requestedURL: requestedURL$LWS
    };
  }
  function uponSanitizeAttribute$LWS(node$LWS, data$LWS, _config$LWS) {
    const {
      attrValue: attrValue$LWS,
      attrName: attrName$LWS
    } = data$LWS;
    if (attrValue$LWS && ReflectApply$LWS$1(StringProtoToUpperCase$LWS, ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, []), []) === "USE" && SANITIZE_ATTRIBUTES_LIST$LWS.includes(attrName$LWS)) {
      data$LWS.attrValue = sanitizeSvgHref$LWS(attrValue$LWS);
    }
    return data$LWS;
  }
  function blobSanitizer$LWS(sandboxKey$LWS) {
    if (typeof sandboxKey$LWS !== "string") {
      throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
    }
    return getSanitizerForConfig$LWS(sandboxKey$LWS, "STRING_BLOB_HTML");
  }
  function sanitize$LWS(dirty$LWS, sandboxKey$LWS) {
    if (typeof sandboxKey$LWS !== "string") {
      throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
    }
    ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, htmlTemplate$LWS, [dirty$LWS]);
    const content$LWS = ReflectApply$LWS$1(HTMLTemplateElementProtoContentGetter$LWS, htmlTemplate$LWS, []);
    const sanitizer$LWS = getSanitizerForConfig$LWS(sandboxKey$LWS, "NODE_ALL_IN_PLACE");
    sanitizer$LWS.sanitize(content$LWS);
    return ReflectApply$LWS$1(ElementProtoInnerHTMLGetter$LWS, htmlTemplate$LWS, []);
  }
  function sanitizeDocument$LWS(doc$LWS, sandboxKey$LWS) {
    const docEl$LWS = ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, doc$LWS, []);
    const content$LWS = ReflectApply$LWS$1(ElementProtoOuterHTMLGetter$LWS, docEl$LWS, []);
    const docImpl$LWS = ReflectApply$LWS$1(DocumentProtoImplementationGetter$LWS, doc$LWS, []);
    const newDoc$LWS = ReflectApply$LWS$1(DOMImplementationProtoCreateDocument$LWS, docImpl$LWS, [NAMESPACE_XHTML$LWS, "html"]);
    const newDocEl$LWS = ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, newDoc$LWS, []);
    ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, newDocEl$LWS, [sanitize$LWS(content$LWS, sandboxKey$LWS)]);
    return newDoc$LWS;
  }
  function createSvgContainer$LWS(ownerDoc$LWS) {
    return ReflectApply$LWS$1(DocumentProtoCreateElementNS$LWS, ownerDoc$LWS, [NAMESPACE_SVG$LWS, "svg"]);
  }
  function sanitizeSvgInnerHtml$LWS(stringOrSvg$LWS, dirty$LWS = "") {
    const ownerDoc$LWS = typeof stringOrSvg$LWS === "string" ? document : ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, stringOrSvg$LWS, []);
    let container$LWS;
    if (typeof stringOrSvg$LWS === "string") {
      dirty$LWS = stringOrSvg$LWS;
      container$LWS = createSvgContainer$LWS(ownerDoc$LWS);
    } else {
      const closestSvg$LWS = ReflectApply$LWS$1(ElementProtoClosest$LWS, stringOrSvg$LWS, ["svg"]);
      container$LWS = closestSvg$LWS ? ReflectApply$LWS$1(NodeProtoCloneNode$LWS, closestSvg$LWS, [false]) : createSvgContainer$LWS(ownerDoc$LWS);
    }
    const comment$LWS = ReflectApply$LWS$1(DocumentProtoCreateComment$LWS, ownerDoc$LWS, [""]);
    ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, container$LWS, [comment$LWS]);
    const outerHTML$LWS = ReflectApply$LWS$1(ElementProtoOuterHTMLGetter$LWS, container$LWS, []);
    const replacedOuterHTML$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, outerHTML$LWS, ["<!---->", dirty$LWS]);
    const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(replacedOuterHTML$LWS);
    const firstChild$LWS = ReflectApply$LWS$1(NodeProtoFirstChildGetter$LWS, fragment$LWS, []);
    return ReflectApply$LWS$1(ElementProtoInnerHTMLGetter$LWS, firstChild$LWS, []);
  }
  /*! version: 0.18.14 */
  /*!
   * Copyright (C) 2023 salesforce.com, inc.
   */
  const inflightRequests = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  async function getSourceText(resourceURL, targetElement) {
    abortInFlightRequest(targetElement);
    const controller = new AbortControllerCtor$LWS();
    const signal = ReflectApply$LWS$1(AbortControllerProtoSignalGetter$LWS, controller, []);
    inflightRequests.set(targetElement, controller);
    const response = await WindowFetch$LWS(resourceURL, {
      __proto__: null,
      method: "GET",
      credentials: "include",
      signal
    });
    inflightRequests.delete(targetElement);
    if (!ReflectApply$LWS$1(ResponseProtoOkGetter$LWS, response, [])) {
      throw new ErrorCtor$LWS$1("Request failed.");
    }
    const sourceText = await ReflectApply$LWS$1(ResponseProtoText$LWS, response, []);
    return sourceText;
  }
  function abortInFlightRequest(element) {
    const abortController = inflightRequests.get(element);
    if (abortController) {
      ReflectApply$LWS$1(AbortControllerProtoAbort$LWS, abortController, []);
    }
  }
  const EVALUATOR_PROPERTY_KEY = "$evaluator$";
  const BLOB_SCRIPT_SOURCE = `document.currentScript['${EVALUATOR_PROPERTY_KEY}']`;
  const SUPPORTS_TRUSTED_TYPES = typeof trustedTypes !== "undefined";
  function createTrustedTypesPolicy(name, options) {
    return trustedTypes.createPolicy(name, options);
  }
  function createFallbackPolicy(_name, options) {
    return options;
  }
  const createPolicy = SUPPORTS_TRUSTED_TYPES ? createTrustedTypesPolicy : createFallbackPolicy;
  const policyOptions$1 = {
    createHTML(value) {
      return value;
    },
    createScript(value) {
      return value;
    },
    createScriptURL(value) {
      return value;
    }
  };
  const trusted = createPolicy("trusted", policyOptions$1);
  const evaluatedScripts = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
  const scriptURLsCache = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const policyOptions = {
    createHTML(dirty, lwsKey, contentType) {
      if (dirty === null || dirty === void 0) {
        return "";
      }
      switch (contentType) {
        case 0:
          return sanitize$LWS(dirty, lwsKey);
        case 1:
          return "";
        case 2:
          return dirty;
        default:
          return "";
      }
    },
    createScript(_dirty, _evaluator) {
      return "";
    },
    createScriptURL(dirty, evaluator, targetElement) {
      const setURL = encloseSrcSetter(targetElement);
      dirty = `${dirty}`;
      if (evaluatedScripts.has(targetElement) || dirty === "" || dirty === "undefined" || dirty === "null") {
        setURL(trusted.createScriptURL(dirty));
        return dirty;
      }
      const targetElementIsConnected = ReflectApply$LWS$1(NodeProtoIsConnectedGetter$LWS, targetElement, []);
      const resolvedURL = resolveURL$LWS(dirty);
      if (targetElementIsConnected) {
        if (getURL(targetElement)) {
          evaluatedScripts.add(targetElement);
          setURL(trusted.createScriptURL(dirty));
          return dirty;
        }
        if (scriptURLsCache.has(targetElement)) {
          return "";
        }
      }
      const asyncRequest = getSourceText(resolvedURL, targetElement);
      scriptURLsCache.set(targetElement, resolvedURL);
      const safeURL = createSandboxURL();
      const onFulfill = (sourceText) => {
        ReflectDefineProperty$LWS$1(targetElement, EVALUATOR_PROPERTY_KEY, {
          __proto__: null,
          configurable: true,
          get: ReflectApply$LWS$1(FunctionProtoBind$LWS, () => {
            ReflectDeleteProperty$LWS$1(targetElement, EVALUATOR_PROPERTY_KEY);
            URLRevokeObjectURL$LWS(safeURL);
            const cachedURL = scriptURLsCache.get(targetElement);
            scriptURLsCache.delete(targetElement);
            evaluatedScripts.add(targetElement);
            setURL(trusted.createScriptURL(cachedURL));
            evaluator(sourceText);
          }, [targetElement]),
          set: void 0
        });
        setURL(trusted.createScriptURL(safeURL));
      };
      const onReject = (_error) => {
        URLRevokeObjectURL$LWS(safeURL);
        const cachedURL = scriptURLsCache.get(targetElement);
        scriptURLsCache.delete(targetElement);
        setURL(trusted.createScriptURL("blob:http://localhost/not-found"));
        const errorEventHandler = () => {
          setURL(trusted.createScriptURL(cachedURL));
          ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, targetElement, ["error", errorEventHandler]);
        };
        ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, targetElement, ["error", errorEventHandler]);
      };
      ReflectApply$LWS$1(PromiseProtoThen$LWS, asyncRequest, [onFulfill, onReject]);
      return "";
    }
  };
  const lwsInternalPolicy = createPolicy("lwsInternal", policyOptions);
  function createSandboxURL() {
    return URLCreateObjectURL$LWS(new BlobCtor$LWS([BLOB_SCRIPT_SOURCE], {
      __proto__: null,
      type: "text/javascript"
    }));
  }
  function getURL(targetElement) {
    const isHTMLScriptElement = targetElement instanceof HTMLScriptElementCtor$LWS;
    if (isHTMLScriptElement) {
      return ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, targetElement, ["src"]);
    }
    const hasHref = ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, targetElement, ["href"]);
    return hasHref ? ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, targetElement, ["href"]) : ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, targetElement, ["xlink:href"]);
  }
  function encloseSrcSetter(targetElement) {
    const namespaceURI = ReflectApply$LWS$1(ElementProtoNamespaceURIGetter$LWS, targetElement, []);
    const attributeNamespaceURI = namespaceURI === NAMESPACE_XHTML$LWS ? "" : NAMESPACE_XLINK$LWS;
    const attributeName = targetElement instanceof HTMLScriptElementCtor$LWS ? "src" : "href";
    return function(src) {
      ReflectApply$LWS$1(ElementProtoSetAttributeNS$LWS, targetElement, [attributeNamespaceURI, attributeName, src]);
    };
  }
  /*! version: 0.18.14 */
  /*!
   * Copyright (C) 2019 salesforce.com, inc.
   */
  const ERR_ILLEGAL_CONSTRUCTOR$LWS = "Illegal constructor.";
  const ERR_ILLEGAL_INVOCATION$LWS = "Illegal invocation.";
  const ERR_NO_NEW_OP_HTML_ELEMENT$LWS = "Failed to construct 'HTMLElement': Please use the 'new' operator, this DOM object constructor cannot be called as a function.";
  const LOCKER_ORIGINAL_HTML_ELEMENT_CTOR_SYMBOL$LWS = SymbolFor$LWS$1("@@lockerOriginalHTMLElementCtor");
  let currentRegistry$LWS;
  let currentUpgradingInstance$LWS;
  const definitionCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const originalHTMLElementCtorCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const globalRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const pivotCtorCache$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
  const sandboxRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  class VirtualRegistry$LWS {
    constructor(document$LWS) {
      this._awaitingUpgrade = toSafeMap$LWS$1(new MapCtor$LWS$1());
      this._definedCtors = toSafeSet$LWS(new SetCtor$LWS$1());
      this._definitionByElement = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
      this._definitionByTag = toSafeMap$LWS$1(new MapCtor$LWS$1());
      this._pendingRegistryByElement = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
      this._document = document$LWS;
      this._HTMLElement = originalHTMLElementCtorCache$LWS.get(document$LWS);
    }
    applyDefine(cer$LWS, args$LWS) {
      const {
        0: tagName$LWS,
        1: LocalCtor$LWS,
        2: options$LWS
      } = args$LWS;
      if (options$LWS && options$LWS.extends) {
        throw new DOMException("NotSupportedError: 'extends' key in customElements.define() options is not supported.");
      }
      if (this._definitionByTag.has(tagName$LWS)) {
        throw new DOMException(`Failed to execute 'define' on 'CustomElementRegistry': the name "${tagName$LWS}" has already been used with this registry.`);
      }
      if (this._definedCtors.has(LocalCtor$LWS)) {
        throw new DOMException("Failed to execute 'define' on 'CustomElementRegistry': this constructor has already been used with this registry.");
      }
      const definition$LWS = getDefinitionForConstructor$LWS(LocalCtor$LWS);
      let PivotCtor$LWS = pivotCtorCache$LWS.get(tagName$LWS);
      if (PivotCtor$LWS === void 0) {
        PivotCtor$LWS = createPivotingClass$LWS(this._document, this._HTMLElement, definition$LWS, tagName$LWS);
        ReflectApply$LWS$1(CustomElementRegistryProtoDefine$LWS, cer$LWS, [tagName$LWS, PivotCtor$LWS]);
      }
      definitionCache$LWS.set(LocalCtor$LWS, definition$LWS);
      pivotCtorCache$LWS.set(tagName$LWS, PivotCtor$LWS);
      this._definitionByTag.set(tagName$LWS, definition$LWS);
      this._definedCtors.add(LocalCtor$LWS);
      definition$LWS.PivotCtor = PivotCtor$LWS;
      const awaiting$LWS = this._awaitingUpgrade.get(tagName$LWS);
      if (awaiting$LWS) {
        awaiting$LWS.forEach((element$LWS) => {
          const originalDefinition$LWS = this._pendingRegistryByElement.get(element$LWS);
          if (originalDefinition$LWS) {
            this._pendingRegistryByElement.delete(element$LWS);
            this.upgrade(element$LWS, originalDefinition$LWS, definition$LWS);
          }
        });
      }
    }
    applyGet(cer$LWS, args$LWS) {
      const {
        0: tagName$LWS
      } = args$LWS;
      const definition$LWS = this._definitionByTag.get(tagName$LWS);
      return definition$LWS && definition$LWS.LocalCtor || ReflectApply$LWS$1(CustomElementRegistryProtoGet$LWS, cer$LWS, [tagName$LWS]);
    }
    applyWhenDefined(cer$LWS, args$LWS) {
      const {
        0: tagName$LWS
      } = args$LWS;
      const promise$LWS = ReflectApply$LWS$1(CustomElementRegistryProtoWhenDefined$LWS, cer$LWS, args$LWS);
      return new PromiseCtor$LWS((resolve$LWS, reject$LWS) => {
        ReflectApply$LWS$1(PromiseProtoThen$LWS, promise$LWS, [() => {
          const definition$LWS = this._definitionByTag.get(tagName$LWS);
          if (definition$LWS) {
            resolve$LWS(definition$LWS.LocalCtor);
          }
        }, reject$LWS]);
      });
    }
    getDefinition(instance$LWS) {
      return this._definitionByElement.get(instance$LWS);
    }
    newCtor(instance$LWS) {
      const pendingUpgrade$LWS = currentUpgradingInstance$LWS;
      if (pendingUpgrade$LWS) {
        currentUpgradingInstance$LWS = void 0;
        return pendingUpgrade$LWS;
      }
      const {
        constructor: LocalCtor$LWS
      } = instance$LWS;
      const definition$LWS = definitionCache$LWS.get(LocalCtor$LWS);
      if (definition$LWS === void 0 || typeof definition$LWS.PivotCtor !== "function") {
        let tagName$LWS;
        try {
          tagName$LWS = ReflectApply$LWS$1(ElementProtoTagNameGetter$LWS, instance$LWS, []);
        } catch (_unused$LWS) {
        }
        if (tagName$LWS) {
          return instance$LWS;
        }
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_CONSTRUCTOR$LWS);
      }
      return new definition$LWS.PivotCtor(this, definition$LWS);
    }
    scheduleConnectedCallback(instance$LWS, tagName$LWS) {
      let awaiting$LWS = this._awaitingUpgrade.get(tagName$LWS);
      if (awaiting$LWS === void 0) {
        awaiting$LWS = toSafeSet$LWS(new SetCtor$LWS$1());
        this._awaitingUpgrade.set(tagName$LWS, awaiting$LWS);
      }
      awaiting$LWS.add(instance$LWS);
    }
    scheduleDisconnectedCallback(instance$LWS, tagName$LWS) {
      const awaiting$LWS = this._awaitingUpgrade.get(tagName$LWS);
      if (awaiting$LWS) {
        awaiting$LWS.delete(instance$LWS);
      }
    }
    scheduleOrUpgrade(instance$LWS, tagName$LWS, originalDefinition$LWS) {
      const definition$LWS = this._definitionByTag.get(tagName$LWS);
      if (definition$LWS) {
        this.upgrade(instance$LWS, originalDefinition$LWS, definition$LWS);
      } else {
        this._pendingRegistryByElement.set(instance$LWS, originalDefinition$LWS);
        ReflectSetPrototypeOf$LWS$1(instance$LWS, this._HTMLElement.prototype);
      }
    }
    setDefinition(instance$LWS, pivotDefinition$LWS) {
      ReflectSetPrototypeOf$LWS$1(instance$LWS, pivotDefinition$LWS.LocalCtor.prototype);
      this._definitionByElement.set(instance$LWS, pivotDefinition$LWS);
    }
    upgrade(instance$LWS, originalDefinition$LWS, pivotDefinition$LWS) {
      const {
        LocalCtor: LocalCtor$LWS,
        connectedCallback: connectedCallback$LWS
      } = pivotDefinition$LWS;
      this.setDefinition(instance$LWS, pivotDefinition$LWS);
      if (pivotDefinition$LWS !== originalDefinition$LWS) {
        patchAttributes$LWS(instance$LWS, originalDefinition$LWS, pivotDefinition$LWS);
      }
      currentUpgradingInstance$LWS = instance$LWS;
      ReflectConstruct$LWS(LocalCtor$LWS, []);
      const tagName$LWS = ReflectApply$LWS$1(ElementProtoTagNameGetter$LWS, instance$LWS, []);
      const tagNameLowerCased$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, tagName$LWS, []);
      const awaiting$LWS = this._awaitingUpgrade.get(tagNameLowerCased$LWS);
      if (awaiting$LWS && awaiting$LWS.size) {
        triggerAttributeChangedCallbackDuringUpgrade$LWS(instance$LWS, originalDefinition$LWS);
        const needsConnectedCallback$LWS = awaiting$LWS.has(instance$LWS);
        if (needsConnectedCallback$LWS && ReflectApply$LWS$1(NodeProtoIsConnectedGetter$LWS, instance$LWS, [])) {
          if (connectedCallback$LWS) {
            ReflectApply$LWS$1(connectedCallback$LWS, instance$LWS, []);
          }
          awaiting$LWS.delete(instance$LWS);
          if (!awaiting$LWS.size) {
            this._awaitingUpgrade.delete(tagNameLowerCased$LWS);
          }
        }
      }
    }
  }
  function createDefinitionRecord$LWS(LocalCtor$LWS) {
    const {
      connectedCallback: connectedCallback$LWS,
      disconnectedCallback: disconnectedCallback$LWS,
      adoptedCallback: adoptedCallback$LWS,
      attributeChangedCallback: attributeChangedCallback$LWS
    } = LocalCtor$LWS.prototype;
    const observedAttributes$LWS = toSafeSet$LWS(new SetCtor$LWS$1(LocalCtor$LWS.observedAttributes || []));
    return {
      adoptedCallback: adoptedCallback$LWS,
      attributeChangedCallback: attributeChangedCallback$LWS,
      connectedCallback: connectedCallback$LWS,
      disconnectedCallback: disconnectedCallback$LWS,
      LocalCtor: LocalCtor$LWS,
      observedAttributes: observedAttributes$LWS,
      PivotCtor: void 0
    };
  }
  function createPivotingClass$LWS(document$LWS, CustomElementBaseClass$LWS, originalDefinition$LWS, tagName$LWS) {
    var _a$LWS;
    return _a$LWS = class PivotCtor$LWS extends CustomElementBaseClass$LWS {
      constructor(localRegistry$LWS, definition$LWS) {
        super();
        if (localRegistry$LWS && definition$LWS) {
          this.instanceRegistry = localRegistry$LWS;
          localRegistry$LWS.setDefinition(this, definition$LWS);
        } else {
          this.instanceRegistry = getNodeRegistry$LWS(document$LWS, this) || getCurrentRegistry$LWS() || getGlobalCustomElementRegistry$LWS(document$LWS);
          this.instanceRegistry.scheduleOrUpgrade(this, tagName$LWS, originalDefinition$LWS);
        }
      }
      connectedCallback() {
        const {
          instanceRegistry: instanceRegistry$LWS
        } = this;
        const definition$LWS = instanceRegistry$LWS.getDefinition(this);
        if (definition$LWS) {
          const {
            connectedCallback: connectedCallback$LWS
          } = definition$LWS;
          if (connectedCallback$LWS) {
            ReflectApply$LWS$1(connectedCallback$LWS, this, []);
          }
        } else {
          instanceRegistry$LWS.scheduleConnectedCallback(this, tagName$LWS);
        }
      }
      disconnectedCallback() {
        const {
          instanceRegistry: instanceRegistry$LWS
        } = this;
        const definition$LWS = instanceRegistry$LWS.getDefinition(this);
        if (definition$LWS) {
          const {
            disconnectedCallback: disconnectedCallback$LWS
          } = definition$LWS;
          if (disconnectedCallback$LWS) {
            ReflectApply$LWS$1(disconnectedCallback$LWS, this, []);
          }
        } else {
          instanceRegistry$LWS.scheduleDisconnectedCallback(this, tagName$LWS);
        }
      }
      adoptedCallback() {
        const definition$LWS = this.instanceRegistry.getDefinition(this);
        if (definition$LWS) {
          const {
            adoptedCallback: adoptedCallback$LWS
          } = definition$LWS;
          if (adoptedCallback$LWS) {
            ReflectApply$LWS$1(adoptedCallback$LWS, this, []);
          }
        }
      }
      attributeChangedCallback(name$LWS, oldValue$LWS, newValue$LWS) {
        const definition$LWS = this.instanceRegistry.getDefinition(this);
        const attributeChangedCallback$LWS = definition$LWS == null ? void 0 : definition$LWS.attributeChangedCallback;
        const observedAttributes$LWS = definition$LWS == null ? void 0 : definition$LWS.observedAttributes;
        if (typeof attributeChangedCallback$LWS === "function" && (originalDefinition$LWS === definition$LWS || observedAttributes$LWS != null && observedAttributes$LWS.has(name$LWS))) {
          ReflectApply$LWS$1(attributeChangedCallback$LWS, this, [name$LWS, oldValue$LWS, newValue$LWS]);
        }
      }
    }, _a$LWS.observedAttributes = [...originalDefinition$LWS.observedAttributes], _a$LWS;
  }
  function getCurrentRegistry$LWS() {
    const registry$LWS = currentRegistry$LWS;
    currentRegistry$LWS = void 0;
    return registry$LWS;
  }
  function getDefinitionForConstructor$LWS(LocalCtor$LWS) {
    const proto$LWS = typeof LocalCtor$LWS === "function" ? LocalCtor$LWS.prototype : void 0;
    if (!isObject$LWS$1(proto$LWS)) {
      throw new TypeErrorCtor$LWS$1("Invalid custom element constructor.");
    }
    let definition$LWS = definitionCache$LWS.get(LocalCtor$LWS);
    if (definition$LWS === void 0) {
      definition$LWS = createDefinitionRecord$LWS(LocalCtor$LWS);
      definitionCache$LWS.set(LocalCtor$LWS, definition$LWS);
    }
    return definition$LWS;
  }
  function getGlobalCustomElementRegistry$LWS(document$LWS) {
    let registry$LWS = globalRegistryCache$LWS.get(document$LWS);
    if (registry$LWS) {
      return registry$LWS;
    }
    registry$LWS = new VirtualRegistry$LWS(document$LWS);
    globalRegistryCache$LWS.set(document$LWS, registry$LWS);
    return registry$LWS;
  }
  function getNodeRegistry$LWS(document$LWS, node$LWS) {
    const key$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS]);
    if (key$LWS === null) {
      return void 0;
    }
    ReflectApply$LWS$1(ElementProtoRemoveAttribute$LWS, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS]);
    const ownerDoc$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, node$LWS, []);
    if (ownerDoc$LWS !== document$LWS) {
      return void 0;
    }
    const registries$LWS = sandboxRegistryCache$LWS.get(document$LWS);
    return registries$LWS ? registries$LWS.get(key$LWS) : void 0;
  }
  function getObservedAttributesList$LWS(baseDefinition$LWS, sourceDefinition$LWS) {
    return toSafeSet$LWS(new SetCtor$LWS$1([...sourceDefinition$LWS.observedAttributes].filter((attrName$LWS) => !baseDefinition$LWS.observedAttributes.has(attrName$LWS))));
  }
  function patchAttributes$LWS(instance$LWS, originalDefinition$LWS, pivotDefinition$LWS) {
    const {
      observedAttributes: observedAttributes$LWS,
      attributeChangedCallback: attributeChangedCallback$LWS
    } = pivotDefinition$LWS;
    if (observedAttributes$LWS.size === 0 || typeof attributeChangedCallback$LWS !== "function") {
      return;
    }
    const observedAttributesList$LWS = getObservedAttributesList$LWS(originalDefinition$LWS, pivotDefinition$LWS);
    if (!observedAttributesList$LWS.size) {
      return;
    }
    instance$LWS.removeAttribute = proxyMaskFunction$LWS(function removeAttribute$LWS(name$LWS) {
      const args$LWS = [name$LWS];
      if (observedAttributesList$LWS.has(name$LWS)) {
        const old$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, args$LWS);
        ReflectApply$LWS$1(ElementProtoRemoveAttribute$LWS, this, args$LWS);
        args$LWS[1] = old$LWS;
        args$LWS[2] = null;
        ReflectApply$LWS$1(attributeChangedCallback$LWS, this, args$LWS);
      } else {
        ReflectApply$LWS$1(ElementProtoRemoveAttribute$LWS, this, args$LWS);
      }
    }, ElementProtoRemoveAttribute$LWS);
    instance$LWS.setAttribute = proxyMaskFunction$LWS(function setAttribute$LWS(name$LWS, value$LWS) {
      const args$LWS = [name$LWS];
      const stringifiedValue$LWS = toString$LWS(value$LWS);
      const setAttributeArgs$LWS = [name$LWS, stringifiedValue$LWS];
      if (observedAttributesList$LWS.has(name$LWS)) {
        const old$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, args$LWS);
        ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, this, setAttributeArgs$LWS);
        args$LWS[1] = old$LWS;
        args$LWS[2] = stringifiedValue$LWS;
        ReflectApply$LWS$1(attributeChangedCallback$LWS, this, args$LWS);
      } else {
        ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, this, setAttributeArgs$LWS);
      }
    }, ElementProtoSetAttribute$LWS$1);
    instance$LWS.toggleAttribute = proxyMaskFunction$LWS(function toggleAttribute$LWS(name$LWS) {
      const args$LWS = [name$LWS];
      let returnValue$LWS;
      if (observedAttributesList$LWS.has(name$LWS)) {
        const hasAttribute$LWS = ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, this, args$LWS);
        const old$LWS = hasAttribute$LWS ? ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, args$LWS) : null;
        returnValue$LWS = ReflectApply$LWS$1(ElementProtoToggleAttribute$LWS, this, args$LWS);
        args$LWS[1] = old$LWS;
        if (hasAttribute$LWS) {
          args$LWS[2] = null;
        }
        ReflectApply$LWS$1(attributeChangedCallback$LWS, this, args$LWS);
      } else {
        returnValue$LWS = ReflectApply$LWS$1(ElementProtoToggleAttribute$LWS, this, args$LWS);
      }
      return returnValue$LWS;
    }, ElementProtoToggleAttribute$LWS);
  }
  function patchCustomElementRegistry$LWS(globalObject$LWS, registry$LWS) {
    const {
      CustomElementRegistry: {
        prototype: CustomElementRegistryProto$LWS2
      },
      customElements: customElements$LWS
    } = globalObject$LWS;
    CustomElementRegistryProto$LWS2.get = proxyMaskFunction$LWS(function get$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
      }
      return registry$LWS.applyGet(this, args$LWS);
    }, CustomElementRegistryProto$LWS2.get);
    CustomElementRegistryProto$LWS2.define = proxyMaskFunction$LWS(function define$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
      }
      return registry$LWS.applyDefine(this, args$LWS);
    }, CustomElementRegistryProto$LWS2.define);
    CustomElementRegistryProto$LWS2.whenDefined = proxyMaskFunction$LWS(function whenDefined$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        return PromiseReject$LWS(new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS));
      }
      return registry$LWS.applyWhenDefined(this, args$LWS);
    }, CustomElementRegistryProto$LWS2.whenDefined);
  }
  function patchHTMLElement$LWS(globalObject$LWS, registry$LWS) {
    let handshakeOriginalHTMLElementCtorFlag$LWS = false;
    const {
      HTMLElement: originalHTMLElementCtor$LWS
    } = globalObject$LWS;
    globalObject$LWS.HTMLElement = proxyMaskFunction$LWS(function HTMLElement$LWS() {
      if (new.target === void 0) {
        throw new TypeErrorCtor$LWS$1(ERR_NO_NEW_OP_HTML_ELEMENT$LWS);
      }
      if (new.target === HTMLElement$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_CONSTRUCTOR$LWS);
      }
      return registry$LWS.newCtor(this);
    }, originalHTMLElementCtor$LWS, {
      defineProperty(target$LWS, key$LWS, desc$LWS) {
        if (key$LWS === LOCKER_ORIGINAL_HTML_ELEMENT_CTOR_SYMBOL$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return ReflectDefineProperty$LWS$1(target$LWS, key$LWS, desc$LWS);
      },
      get(target$LWS, key$LWS, receiver$LWS, handshake$LWS = false) {
        handshakeOriginalHTMLElementCtorFlag$LWS && (handshakeOriginalHTMLElementCtorFlag$LWS = handshake$LWS);
        const isOriginalHTMLElementCtorSymbol$LWS = key$LWS === LOCKER_ORIGINAL_HTML_ELEMENT_CTOR_SYMBOL$LWS;
        if (handshakeOriginalHTMLElementCtorFlag$LWS) {
          if (isOriginalHTMLElementCtorSymbol$LWS) {
            return originalHTMLElementCtor$LWS;
          }
        }
        const result$LWS = ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
        if (result$LWS !== void 0 && isOriginalHTMLElementCtorSymbol$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return result$LWS;
      },
      getOwnPropertyDescriptor(target$LWS, key$LWS) {
        const result$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
        if (result$LWS && key$LWS === LOCKER_ORIGINAL_HTML_ELEMENT_CTOR_SYMBOL$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return result$LWS;
      },
      has(target$LWS, key$LWS) {
        const result$LWS = ReflectHas$LWS(target$LWS, key$LWS);
        const isOriginalHTMLElementCtorSymbol$LWS = key$LWS === LOCKER_ORIGINAL_HTML_ELEMENT_CTOR_SYMBOL$LWS;
        if (result$LWS) {
          handshakeOriginalHTMLElementCtorFlag$LWS = false;
          if (isOriginalHTMLElementCtorSymbol$LWS) {
            throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
          }
        } else {
          handshakeOriginalHTMLElementCtorFlag$LWS = isOriginalHTMLElementCtorSymbol$LWS;
        }
        return result$LWS;
      },
      set(target$LWS, key$LWS, value$LWS, receiver$LWS) {
        if (key$LWS === LOCKER_ORIGINAL_HTML_ELEMENT_CTOR_SYMBOL$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return ReflectSet$LWS(target$LWS, key$LWS, value$LWS, receiver$LWS);
      }
    });
  }
  function triggerAttributeChangedCallbackDuringUpgrade$LWS(instance$LWS, originalDefinition$LWS) {
    const {
      observedAttributes: observedAttributes$LWS
    } = originalDefinition$LWS;
    const attributeChangedCallback$LWS = observedAttributes$LWS.size ? originalDefinition$LWS.attributeChangedCallback : void 0;
    if (attributeChangedCallback$LWS) {
      observedAttributes$LWS.forEach((name$LWS) => {
        if (ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, instance$LWS, [name$LWS])) {
          const newValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, instance$LWS, [name$LWS]);
          ReflectApply$LWS$1(attributeChangedCallback$LWS, instance$LWS, [name$LWS, null, newValue$LWS]);
        }
      });
    }
  }
  function getOriginalHTMLElementCtor$LWS(patchedHTMLElementCtor$LWS) {
    return LOCKER_ORIGINAL_HTML_ELEMENT_CTOR_SYMBOL$LWS in patchedHTMLElementCtor$LWS ? void 0 : patchedHTMLElementCtor$LWS[LOCKER_ORIGINAL_HTML_ELEMENT_CTOR_SYMBOL$LWS];
  }
  function getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS) {
    let registries$LWS = sandboxRegistryCache$LWS.get(document$LWS);
    if (registries$LWS === void 0) {
      registries$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
      sandboxRegistryCache$LWS.set(document$LWS, registries$LWS);
    }
    let registry$LWS = registries$LWS.get(key$LWS);
    if (registry$LWS) {
      return registry$LWS;
    }
    registry$LWS = new VirtualRegistry$LWS(document$LWS);
    registries$LWS.set(key$LWS, registry$LWS);
    return registry$LWS;
  }
  function patchGlobalObject$LWS(document$LWS, globalObject$LWS) {
    let {
      HTMLElement: originalHTMLElementCtor$LWS
    } = globalObject$LWS;
    const {
      CustomElementRegistry: {
        prototype: {
          get: originalGet$LWS
        }
      }
    } = globalObject$LWS;
    const isHTMLElementCtorPatched$LWS = isProxyMaskedFunction$LWS(originalHTMLElementCtor$LWS);
    const isCustomElementRegistryPatched$LWS = isProxyMaskedFunction$LWS(originalGet$LWS);
    if (isHTMLElementCtorPatched$LWS) {
      originalHTMLElementCtor$LWS = getOriginalHTMLElementCtor$LWS(originalHTMLElementCtor$LWS);
      if (typeof originalHTMLElementCtor$LWS !== "function") {
        throw new TypeErrorCtor$LWS$1("Invalid HTMLElement constructor.");
      }
      originalHTMLElementCtorCache$LWS.set(document$LWS, originalHTMLElementCtor$LWS);
    } else {
      originalHTMLElementCtorCache$LWS.set(document$LWS, originalHTMLElementCtor$LWS);
    }
    const registry$LWS = !isHTMLElementCtorPatched$LWS || !isCustomElementRegistryPatched$LWS ? getGlobalCustomElementRegistry$LWS(document$LWS) : void 0;
    if (!isHTMLElementCtorPatched$LWS) {
      patchHTMLElement$LWS(globalObject$LWS, registry$LWS);
    }
    if (!isCustomElementRegistryPatched$LWS) {
      patchCustomElementRegistry$LWS(globalObject$LWS, registry$LWS);
    }
  }
  function setCustomElementsRegistry$LWS(document$LWS, key$LWS) {
    currentRegistry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
  }
  const attributeDistortionFactoriesCache$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
  const sandboxAttributeDistortionRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function finalizeAttributeDistortions$LWS(record$LWS) {
    const attributeFactories$LWS = attributeDistortionFactoriesCache$LWS.get(record$LWS);
    if (attributeFactories$LWS === void 0) {
      return;
    }
    attributeDistortionFactoriesCache$LWS.delete(record$LWS);
    const {
      document: document$LWS,
      key: key$LWS
    } = record$LWS;
    let sandboxAttributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistryCache$LWS.get(document$LWS);
    if (sandboxAttributeDistortionRegistry$LWS === void 0) {
      sandboxAttributeDistortionRegistry$LWS = {
        __proto__: null
      };
      sandboxAttributeDistortionRegistryCache$LWS.set(document$LWS, sandboxAttributeDistortionRegistry$LWS);
    }
    const attributeDistortionRegistry$LWS = {
      __proto__: null
    };
    sandboxAttributeDistortionRegistry$LWS[key$LWS] = attributeDistortionRegistry$LWS;
    for (let i$LWS = 0, {
      length: length$LWS2
    } = attributeFactories$LWS; i$LWS < length$LWS2; i$LWS += 1) {
      attributeFactories$LWS[i$LWS](attributeDistortionRegistry$LWS);
    }
  }
  function getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, attributeNamespace$LWS = NAMESPACE_DEFAULT$LWS) {
    const {
      document: document$LWS,
      key: key$LWS
    } = record$LWS;
    const sandboxAttributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistryCache$LWS.get(document$LWS);
    if (sandboxAttributeDistortionRegistry$LWS === void 0) {
      return void 0;
    }
    const attributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistry$LWS[key$LWS];
    if (attributeDistortionRegistry$LWS === void 0) {
      return void 0;
    }
    const elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[ReflectApply$LWS$1(StringProtoToLowerCase$LWS, attrName$LWS, [])];
    if (elementCtorMapByAttributeNamespaceRegistry$LWS === void 0) {
      return void 0;
    }
    const elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];
    if (elementCtorMap$LWS === void 0) {
      return void 0;
    }
    const mapIterator$LWS = elementCtorMap$LWS.entries();
    for (const {
      0: Ctor$LWS,
      1: distortion$LWS
    } of mapIterator$LWS) {
      if (element$LWS instanceof Ctor$LWS) {
        return distortion$LWS;
      }
    }
    return void 0;
  }
  function normalizeNamespace$LWS(ns$LWS) {
    return ns$LWS === null || ns$LWS === void 0 || ns$LWS === "" ? NAMESPACE_DEFAULT$LWS : ns$LWS;
  }
  function registerAttributeDistortion$LWS(record$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS) {
    let attributeFactories$LWS = attributeDistortionFactoriesCache$LWS.get(record$LWS);
    if (attributeFactories$LWS === void 0) {
      attributeFactories$LWS = [];
      attributeDistortionFactoriesCache$LWS.set(record$LWS, attributeFactories$LWS);
    }
    const loweredAttributeName$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, attributeName$LWS, []);
    attributeFactories$LWS[attributeFactories$LWS.length] = (attributeDistortionRegistry$LWS) => {
      let elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[loweredAttributeName$LWS];
      if (elementCtorMapByAttributeNamespaceRegistry$LWS === void 0) {
        elementCtorMapByAttributeNamespaceRegistry$LWS = {
          __proto__: null
        };
        attributeDistortionRegistry$LWS[loweredAttributeName$LWS] = elementCtorMapByAttributeNamespaceRegistry$LWS;
      }
      let elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];
      if (elementCtorMap$LWS === void 0) {
        elementCtorMap$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
        elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS] = elementCtorMap$LWS;
      }
      elementCtorMap$LWS.set(ElementCtor$LWS, distortion$LWS);
    };
  }
  function initDistortionAttrValueSetter$LWS({
    globalObject: {
      Attr: Attr$LWS
    }
  }) {
    const originalAttrValueSetter$LWS = ObjectLookupOwnSetter$LWS(Attr$LWS.prototype, "value");
    return function distortionAttrValueSetter$LWS(record$LWS) {
      return [originalAttrValueSetter$LWS, function value$LWS(val$LWS) {
        const ownerElement$LWS = ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, this, []);
        if (ownerElement$LWS) {
          const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, this, []);
          const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, this, []);
          const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerElement$LWS, attrName$LWS, normalizedNamespace$LWS);
          if (distortion$LWS) {
            ReflectApply$LWS$1(distortion$LWS, ownerElement$LWS, [val$LWS]);
            return;
          }
        }
        ReflectApply$LWS$1(originalAttrValueSetter$LWS, this, [val$LWS]);
      }];
    };
  }
  function initDistortionAuraUtilGlobalEval$LWS({
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: globalObject$LWS
  }) {
    var _globalObject$aura$LWS, _globalObject$aura$ut$LWS;
    const originalGlobalEval$LWS = (_globalObject$aura$LWS = globalObject$LWS.aura) == null ? void 0 : (_globalObject$aura$ut$LWS = _globalObject$aura$LWS.util) == null ? void 0 : _globalObject$aura$ut$LWS.globalEval;
    if (typeof originalGlobalEval$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionAuraUtilGlobalEval$LWS({
      sandboxEvaluator: sandboxEvaluator$LWS
    }) {
      return [originalGlobalEval$LWS, function globalEval$LWS(sourceText$LWS, descriptor$LWS, type$LWS) {
        let wrappedSourceText$LWS = `(function s(){return(${sourceText$LWS})})()`;
        if (typeof descriptor$LWS === "string") {
          const split$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, descriptor$LWS, ["://"]);
          const {
            length: length$LWS2
          } = split$LWS;
          const name$LWS = length$LWS2 ? split$LWS[split$LWS.length - 1] : "";
          wrappedSourceText$LWS += this.sourceComment + (type$LWS === "lib" ? `/libraries/${ReflectApply$LWS$1(StringProtoReplace$LWS, name$LWS, [".", "/"])}` : `/components/${ReflectApply$LWS$1(StringProtoReplace$LWS, name$LWS, [":", "/"])}.js`);
        }
        return sandboxEvaluator$LWS(transformSourceText$LWS(wrappedSourceText$LWS), UNCOMPILED_CONTEXT$LWS);
      }];
    };
  }
  function initDistortionCacheStorageDelete$LWS({
    globalObject: {
      CacheStorage: CacheStorage$LWS
    }
  }) {
    var _CacheStorage$prototy$LWS;
    const originalDelete$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy$LWS.delete;
    if (typeof originalDelete$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionCacheStorageDelete$LWS({
      key: key$LWS
    }) {
      return [originalDelete$LWS, function patchedDelete$LWS(...args$LWS) {
        if (args$LWS.length) {
          const {
            0: cacheName$LWS
          } = args$LWS;
          if (isConvertibleToString$LWS(cacheName$LWS)) {
            args$LWS[0] = prependNamespaceMarker$LWS(cacheName$LWS, key$LWS);
          }
        }
        return ReflectApply$LWS$1(originalDelete$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionCacheStorageHas$LWS({
    globalObject: {
      CacheStorage: CacheStorage$LWS
    }
  }) {
    var _CacheStorage$prototy2$LWS;
    const originalHas$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy2$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy2$LWS.has;
    if (typeof originalHas$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionCacheStorageHas$LWS({
      key: key$LWS
    }) {
      return [originalHas$LWS, function has$LWS(...args$LWS) {
        if (args$LWS.length) {
          const {
            0: cacheName$LWS
          } = args$LWS;
          if (isConvertibleToString$LWS(cacheName$LWS)) {
            args$LWS[0] = prependNamespaceMarker$LWS(cacheName$LWS, key$LWS);
          }
        }
        return ReflectApply$LWS$1(originalHas$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionCacheStorageKeys$LWS({
    globalObject: {
      CacheStorage: CacheStorage$LWS
    }
  }) {
    var _CacheStorage$prototy3$LWS;
    const originalKeys$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy3$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy3$LWS.keys;
    if (typeof originalKeys$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionCacheStorageKeys$LWS({
      key: key$LWS
    }) {
      return [originalKeys$LWS, function keys$LWS() {
        const keysResultPromise$LWS = ReflectApply$LWS$1(originalKeys$LWS, this, []);
        return ReflectApply$LWS$1(PromiseProtoThen$LWS, keysResultPromise$LWS, [(result$LWS) => {
          const sandboxedCacheNames$LWS = [];
          for (let i$LWS = 0, j$LWS = 0, {
            length: length$LWS2
          } = result$LWS; i$LWS < length$LWS2; i$LWS += 1) {
            const cacheName$LWS = result$LWS[i$LWS];
            if (startsWithNamespaceMarker$LWS(cacheName$LWS, key$LWS)) {
              sandboxedCacheNames$LWS[j$LWS++] = removeNamespaceMarker$LWS(cacheName$LWS, key$LWS);
            }
          }
          return sandboxedCacheNames$LWS;
        }]);
      }];
    };
  }
  function initDistortionCacheStorageMatch$LWS({
    globalObject: {
      CacheStorage: CacheStorage$LWS
    }
  }) {
    var _CacheStorage$prototy4$LWS;
    const originalMatch$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy4$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy4$LWS.match;
    if (typeof originalMatch$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionCacheStorageMatch$LWS({
      key: key$LWS
    }) {
      return [originalMatch$LWS, function match$LWS(...args$LWS) {
        const {
          length: length$LWS2
        } = args$LWS;
        if (!length$LWS2) {
          return ReflectApply$LWS$1(originalMatch$LWS, this, args$LWS);
        }
        const matchOptions$LWS = length$LWS2 >= 2 ? args$LWS[1] : void 0;
        if (isObjectLike$LWS(matchOptions$LWS) && "cacheName" in matchOptions$LWS) {
          const {
            cacheName: cacheName$LWS
          } = matchOptions$LWS;
          if (isConvertibleToString$LWS(cacheName$LWS)) {
            const clonedOptions$LWS = shallowCloneOptions$LWS(matchOptions$LWS);
            clonedOptions$LWS.cacheName = prependNamespaceMarker$LWS(cacheName$LWS, key$LWS);
            args$LWS[1] = clonedOptions$LWS;
            return ReflectApply$LWS$1(originalMatch$LWS, this, args$LWS);
          }
        }
        return PromiseReject$LWS(new LockerSecurityError$LWS("caches.match() expects 'options.cacheName' to be present."));
      }];
    };
  }
  function initDistortionCacheStorageOpen$LWS({
    globalObject: {
      CacheStorage: CacheStorage$LWS
    }
  }) {
    var _CacheStorage$prototy5$LWS;
    const originalOpen$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy5$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy5$LWS.open;
    if (typeof originalOpen$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionCacheStorageOpen$LWS({
      key: key$LWS
    }) {
      return [originalOpen$LWS, function open$LWS(...args$LWS) {
        if (args$LWS.length) {
          const {
            0: cacheName$LWS
          } = args$LWS;
          if (isConvertibleToString$LWS(cacheName$LWS)) {
            args$LWS[0] = prependNamespaceMarker$LWS(cacheName$LWS, key$LWS);
          }
        }
        return ReflectApply$LWS$1(originalOpen$LWS, this, args$LWS);
      }];
    };
  }
  const COOKIE_DELIMITER$LWS = "; ";
  function prefixCookieDetailsOrName$LWS(detailsOrName$LWS, namespace$LWS) {
    if (isObjectLike$LWS(detailsOrName$LWS)) {
      const clonedDetails$LWS = shallowCloneOptions$LWS(detailsOrName$LWS);
      clonedDetails$LWS.name = prependNamespaceMarker$LWS(clonedDetails$LWS.name, namespace$LWS);
      return clonedDetails$LWS;
    }
    return prependNamespaceMarker$LWS(detailsOrName$LWS, namespace$LWS);
  }
  function unprefixCookie$LWS(cookieEntry$LWS, namespace$LWS) {
    if (!startsWithNamespaceMarker$LWS(cookieEntry$LWS, namespace$LWS)) {
      return null;
    }
    const marker$LWS = getNamespaceMarker$LWS(namespace$LWS);
    const {
      length: markerLength$LWS
    } = marker$LWS;
    const pos$LWS = cookieEntry$LWS.length > markerLength$LWS && cookieEntry$LWS[markerLength$LWS] === "=" ? markerLength$LWS + 1 : markerLength$LWS;
    return ReflectApply$LWS$1(StringProtoSlice$LWS$1, cookieEntry$LWS, [pos$LWS]);
  }
  function initDistortionCookieStoreDelete$LWS({
    globalObject: {
      CookieStore: CookieStore$LWS
    }
  }) {
    var _CookieStore$prototyp$LWS;
    const originalDelete$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp$LWS.delete;
    if (typeof originalDelete$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionCookieStoreDelete$LWS({
      key: key$LWS
    }) {
      return [originalDelete$LWS, function deleteValue$LWS(...args$LWS) {
        const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : void 0;
        if (detailsOrName$LWS !== null && detailsOrName$LWS !== void 0) {
          args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
        }
        return ReflectApply$LWS$1(originalDelete$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionCookieStoreGet$LWS({
    globalObject: {
      CookieStore: CookieStore$LWS
    }
  }) {
    var _CookieStore$prototyp2$LWS;
    const originalGet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp2$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp2$LWS.get;
    if (typeof originalGet$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionCookieStoreGet$LWS({
      key: key$LWS
    }) {
      return [originalGet$LWS, function get$LWS(...args$LWS) {
        const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : void 0;
        if (detailsOrName$LWS !== null && detailsOrName$LWS !== void 0) {
          args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
        }
        const getResultPromise$LWS = ReflectApply$LWS$1(originalGet$LWS, this, args$LWS);
        return ReflectApply$LWS$1(PromiseProtoThen$LWS, getResultPromise$LWS, [(cookieListItem$LWS) => {
          if (cookieListItem$LWS) {
            const {
              name: name$LWS
            } = cookieListItem$LWS;
            if (startsWithNamespaceMarker$LWS(name$LWS, key$LWS)) {
              cookieListItem$LWS.name = removeNamespaceMarker$LWS(name$LWS, key$LWS);
              return cookieListItem$LWS;
            }
          }
          return null;
        }]);
      }];
    };
  }
  function initDistortionCookieStoreGetAll$LWS({
    globalObject: {
      CookieStore: CookieStore$LWS
    }
  }) {
    var _CookieStore$prototyp3$LWS;
    const originalGetAll$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp3$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp3$LWS.getAll;
    if (typeof originalGetAll$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionCookieStoreGetAll$LWS({
      key: key$LWS
    }) {
      return [originalGetAll$LWS, function getAll$LWS(...args$LWS) {
        const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : void 0;
        if (detailsOrName$LWS !== null && detailsOrName$LWS !== void 0) {
          args$LWS[0] = prefixCookieDetailsOrName$LWS(args$LWS[0], key$LWS);
        }
        const getAllResultPromise$LWS = ReflectApply$LWS$1(originalGetAll$LWS, this, args$LWS);
        return ReflectApply$LWS$1(PromiseProtoThen$LWS, getAllResultPromise$LWS, [(result$LWS) => {
          const sandboxedCookies$LWS = [];
          let sandboxedCookiesOffset$LWS = 0;
          for (let i$LWS = 0, {
            length: length$LWS2
          } = result$LWS; i$LWS < length$LWS2; i$LWS += 1) {
            const cookieListItem$LWS = result$LWS[i$LWS];
            if (cookieListItem$LWS) {
              const {
                name: name$LWS
              } = cookieListItem$LWS;
              if (startsWithNamespaceMarker$LWS(name$LWS, key$LWS)) {
                cookieListItem$LWS.name = removeNamespaceMarker$LWS(name$LWS, key$LWS);
                sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookieListItem$LWS;
              }
            }
          }
          return sandboxedCookies$LWS;
        }]);
      }];
    };
  }
  const restrictedEventTargetRegistryBySandboxKeyRegistry$LWS = {
    __proto__: null
  };
  function isEventTargetRestricted$LWS(record$LWS, eventTarget$LWS, eventName$LWS) {
    const {
      key: key$LWS
    } = record$LWS;
    const {
      [key$LWS]: restrictedEventTargetRegistry$LWS
    } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;
    if (restrictedEventTargetRegistry$LWS === void 0 || restrictedEventTargetRegistry$LWS[eventName$LWS] === void 0) {
      return false;
    }
    return restrictedEventTargetRegistry$LWS[eventName$LWS].has(eventTarget$LWS.constructor);
  }
  function registerEventTargetRestriction$LWS(record$LWS, EventTargetCtor$LWS, eventName$LWS) {
    if (isEventTargetRestricted$LWS(record$LWS, EventTargetCtor$LWS.prototype, eventName$LWS)) {
      return;
    }
    const {
      key: key$LWS
    } = record$LWS;
    const {
      [key$LWS]: restrictedEventTargetRegistry$LWS = {
        __proto__: null
      }
    } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;
    const {
      [eventName$LWS]: restrictedEventTargetCtors$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1())
    } = restrictedEventTargetRegistry$LWS;
    restrictedEventTargetCtors$LWS.add(EventTargetCtor$LWS);
    restrictedEventTargetRegistry$LWS[eventName$LWS] = restrictedEventTargetCtors$LWS;
    restrictedEventTargetRegistryBySandboxKeyRegistry$LWS[key$LWS] = restrictedEventTargetRegistry$LWS;
  }
  function createEventHandlerExceptionMessage$LWS(instanceOrProto$LWS, eventName$LWS) {
    let exceptionMessage$LWS = `Cannot set '${eventName$LWS}' event handler`;
    const safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(instanceOrProto$LWS.constructor, "name");
    if (safeDesc$LWS) {
      ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
      const {
        value: name$LWS
      } = safeDesc$LWS;
      if (typeof name$LWS === "string") {
        exceptionMessage$LWS += ` on ${name$LWS} object`;
      }
    }
    return `${exceptionMessage$LWS}.`;
  }
  function createEventListenerExceptionMessage$LWS(instanceOrProto$LWS, eventName$LWS) {
    let exceptionMessage$LWS = `Cannot add '${eventName$LWS}' event listener`;
    const safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(instanceOrProto$LWS.constructor, "name");
    if (safeDesc$LWS) {
      ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
      const {
        value: name$LWS
      } = safeDesc$LWS;
      if (typeof name$LWS === "string") {
        exceptionMessage$LWS += ` to ${name$LWS} object`;
      }
    }
    return `${exceptionMessage$LWS}.`;
  }
  function createEventDistortionFactory$LWS(eventHandlerTarget$LWS, eventListenerTarget$LWS, eventName$LWS) {
    const onEventHandlerName$LWS = `on${eventName$LWS}`;
    const originalEventHandlerSetter$LWS = ObjectLookupOwnSetter$LWS(eventHandlerTarget$LWS, onEventHandlerName$LWS);
    if (typeof originalEventHandlerSetter$LWS !== "function") {
      return noop$LWS$1;
    }
    const eventExceptionMessage$LWS = createEventHandlerExceptionMessage$LWS(eventHandlerTarget$LWS, onEventHandlerName$LWS);
    const distortionMapEntry$LWS = [originalEventHandlerSetter$LWS, function() {
      throw new LockerSecurityError$LWS(eventExceptionMessage$LWS);
    }];
    return function distortionEventHandler$LWS(record$LWS) {
      registerEventTargetRestriction$LWS(record$LWS, eventListenerTarget$LWS, eventName$LWS);
      return distortionMapEntry$LWS;
    };
  }
  function initDistortionCookieStoreOnChange$LWS({
    globalObject: {
      CookieStore: CookieStore$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(CookieStore$LWS == null ? void 0 : CookieStore$LWS.prototype, CookieStore$LWS, "change");
  }
  function initDistortionCookieStoreSet$LWS({
    globalObject: {
      CookieStore: CookieStore$LWS
    }
  }) {
    var _CookieStore$prototyp4$LWS;
    const originalSet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp4$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp4$LWS.set;
    if (typeof originalSet$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionCookieStoreSet$LWS({
      key: key$LWS
    }) {
      return [originalSet$LWS, function set$LWS(...args$LWS) {
        const {
          length: length$LWS2
        } = args$LWS;
        if (length$LWS2 > 1) {
          args$LWS[0] = prependNamespaceMarker$LWS(args$LWS[0], key$LWS);
        } else if (length$LWS2) {
          const {
            0: details$LWS
          } = args$LWS;
          if (isObjectLike$LWS(details$LWS)) {
            const clonedDetails$LWS = shallowCloneOptions$LWS(details$LWS);
            clonedDetails$LWS.name = prependNamespaceMarker$LWS(clonedDetails$LWS.name, key$LWS);
            args$LWS[0] = clonedDetails$LWS;
          }
        }
        return ReflectApply$LWS$1(originalSet$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionCSSStyleRuleStyleGetter$LWS({
    globalObject: {
      CSSStyleRule: CSSStyleRule$LWS
    }
  }) {
    const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS$1(CSSStyleRule$LWS.prototype, "style");
    const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
      return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalStyleGetter$LWS, this, []));
    }];
    return function distortionCSSStyleRuleStyleGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionCustomElementRegistryDefine$LWS({
    document: document$LWS,
    globalObject: {
      CustomElementRegistry: CustomElementRegistry$LWS,
      customElements: customElements$LWS
    }
  }) {
    var _CustomElementRegistr$LWS;
    const originalCustomElementsDefine$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr$LWS.define;
    if (typeof originalCustomElementsDefine$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionCustomElementRegistryDefine$LWS({
      key: key$LWS
    }) {
      const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
      return [originalCustomElementsDefine$LWS, function define$LWS(...args$LWS) {
        if (this !== customElements$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
        }
        return registry$LWS.applyDefine(this, args$LWS);
      }];
    };
  }
  function initDistortionCustomElementRegistryGet$LWS({
    document: document$LWS,
    globalObject: {
      CustomElementRegistry: CustomElementRegistry$LWS,
      customElements: customElements$LWS
    }
  }) {
    var _CustomElementRegistr2$LWS;
    const originalCustomElementsGet$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr2$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr2$LWS.get;
    if (typeof originalCustomElementsGet$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionCustomElementRegistryGet$LWS({
      key: key$LWS
    }) {
      const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
      return [originalCustomElementsGet$LWS, function get$LWS(...args$LWS) {
        if (this !== customElements$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
        }
        return registry$LWS.applyGet(this, args$LWS);
      }];
    };
  }
  function initDistortionCustomElementRegistryWhenDefined$LWS({
    document: document$LWS,
    globalObject: {
      CustomElementRegistry: CustomElementRegistry$LWS,
      customElements: customElements$LWS
    }
  }) {
    var _CustomElementRegistr3$LWS;
    const originalCustomElementsWhenDefined$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr3$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr3$LWS.whenDefined;
    if (typeof originalCustomElementsWhenDefined$LWS !== "function") {
      return noop$LWS$1;
    }
    return function distortionCustomElementRegistryWhenDefined$LWS({
      key: key$LWS
    }) {
      const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
      return [originalCustomElementsWhenDefined$LWS, function whenDefined$LWS(...args$LWS) {
        if (this !== customElements$LWS) {
          return PromiseReject$LWS(new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS));
        }
        return registry$LWS.applyWhenDefined(this, args$LWS);
      }];
    };
  }
  function initDistortionDocumentCookieGetter$LWS({
    globalObject: {
      Document: Document$LWS
    }
  }) {
    const originalCookieGetter$LWS = ObjectLookupOwnGetter$LWS$1(Document$LWS.prototype, "cookie");
    return function distortionDocumentCookieSetter$LWS({
      key: key$LWS
    }) {
      return [originalCookieGetter$LWS, function get$LWS() {
        const documentCookieValue$LWS = ReflectApply$LWS$1(DocumentProtoCookieGetter$LWS, this, []);
        const cookies$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, documentCookieValue$LWS, [COOKIE_DELIMITER$LWS]);
        const sandboxedCookies$LWS = [];
        let sandboxedCookiesOffset$LWS = 0;
        for (let i$LWS = 0, {
          length: length$LWS2
        } = cookies$LWS; i$LWS < length$LWS2; i$LWS += 1) {
          const cookie$LWS = unprefixCookie$LWS(cookies$LWS[i$LWS], key$LWS);
          if (cookie$LWS) {
            sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
          }
        }
        return ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, sandboxedCookies$LWS, [COOKIE_DELIMITER$LWS]);
      }];
    };
  }
  function initDistortionDocumentCookieSetter$LWS({
    globalObject: {
      Document: Document$LWS
    }
  }) {
    const originalCookieSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, "cookie");
    return function distortionDocumentCookieSetter$LWS({
      key: key$LWS
    }) {
      return [originalCookieSetter$LWS, function set$LWS(value$LWS) {
        const cookieEntries$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, value$LWS, [COOKIE_DELIMITER$LWS]);
        let {
          0: newCookieEntry$LWS
        } = cookieEntries$LWS;
        if (newCookieEntry$LWS.length && newCookieEntry$LWS[0] === "=") {
          newCookieEntry$LWS = ReflectApply$LWS$1(StringProtoSlice$LWS$1, newCookieEntry$LWS, [1]);
        }
        cookieEntries$LWS[0] = prependNamespaceMarker$LWS(newCookieEntry$LWS, key$LWS);
        const cookie$LWS = ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, cookieEntries$LWS, [COOKIE_DELIMITER$LWS]);
        ReflectApply$LWS$1(DocumentProtoCookieSetter$LWS, this, [cookie$LWS]);
      }];
    };
  }
  function initDistortionDocumentCreateElement$LWS({
    document: document$LWS,
    globalObject: {
      Document: {
        prototype: {
          createElement: originalDocumentCreateElement$LWS
        }
      }
    }
  }) {
    return function distortionDocumentCreateElement$LWS({
      key: key$LWS
    }) {
      return [originalDocumentCreateElement$LWS, function(...args$LWS) {
        const {
          0: tagName$LWS
        } = args$LWS;
        if (ReflectApply$LWS$1(StringProtoIncludes$LWS, tagName$LWS, ["-"])) {
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        }
        return ReflectApply$LWS$1(originalDocumentCreateElement$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionDocumentCreateElementNS$LWS({
    document: document$LWS,
    globalObject: {
      Document: {
        prototype: {
          createElementNS: originalDocumentCreateElementNS$LWS
        }
      }
    }
  }) {
    return function distortionDocumentCreateElementNS$LWS({
      key: key$LWS
    }) {
      return [originalDocumentCreateElementNS$LWS, function(...args$LWS) {
        const {
          1: tagName$LWS
        } = args$LWS;
        if (ReflectApply$LWS$1(StringProtoIncludes$LWS, tagName$LWS, ["-"])) {
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        }
        return ReflectApply$LWS$1(originalDocumentCreateElementNS$LWS, this, args$LWS);
      }];
    };
  }
  function domain$LWS() {
    throw new LockerSecurityError$LWS("Cannot set document.domain.");
  }
  function initDistortionDocumentDomainSetter$LWS({
    globalObject: {
      Document: Document$LWS
    }
  }) {
    const originalDomainSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, "domain");
    const distortionEntry$LWS = [originalDomainSetter$LWS, domain$LWS];
    return function distortionDocumentDomainSetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$m$LWS
  } = rootValidator$LWS;
  function initDistortionDocumentExecCommand$LWS({
    document: document$LWS,
    globalObject: {
      Document: {
        prototype: {
          execCommand: originalExecCommand$LWS
        }
      },
      HTMLElement: HTMLElement$LWS
    }
  }) {
    const originalActiveElement$LWS = ObjectLookupOwnGetter$LWS$1(Document.prototype, "activeElement");
    const originalIsContentEditable$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElement$LWS.prototype, "isContentEditable");
    return function distortionDocumentExecCommand$LWS({
      key: key$LWS,
      type: type$LWS
    }) {
      return [originalExecCommand$LWS, function execCommand$LWS(...args$LWS) {
        if (args$LWS.length > 2) {
          const {
            2: unsanitizedValue$LWS
          } = args$LWS;
          if (unsanitizedValue$LWS !== null && unsanitizedValue$LWS !== void 0) {
            const command$LWS = toString$LWS(args$LWS[0]);
            if (ReflectApply$LWS$1(StringProtoToLowerCase$LWS, command$LWS, []) === "inserthtml") {
              if (type$LWS === 0) {
                const activeElement$LWS = ReflectApply$LWS$1(originalActiveElement$LWS, this, []);
                if (isSharedElement$m$LWS(activeElement$LWS) && ReflectApply$LWS$1(originalIsContentEditable$LWS, activeElement$LWS, [])) {
                  throw new LockerSecurityError$LWS(`Cannot execute command '${command$LWS}' on ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, activeElement$LWS, [])}.`);
                }
              }
              setCustomElementsRegistry$LWS(document$LWS, key$LWS);
              args$LWS[0] = command$LWS;
              args$LWS[2] = lwsInternalPolicy.createHTML(unsanitizedValue$LWS, key$LWS, 0);
            }
          }
        }
        return ReflectApply$LWS$1(originalExecCommand$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionDocumentOnsecuritypolicyviolation$LWS({
    globalObject: {
      Document: {
        prototype: DocumentProto$LWS2
      },
      HTMLDocument: HTMLDocument$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(DocumentProto$LWS2, HTMLDocument$LWS, "securitypolicyviolation");
  }
  const noopenerRegExp$LWS = /(^|,)(\s*noopener\s*=\s*(?:yes|1)\s*)(,|$)/g;
  function sanitizeWindowOpenArguments$LWS(args$LWS) {
    const sanitizedArgs$LWS = shallowCloneArray$LWS(args$LWS);
    if (sanitizedArgs$LWS.length > 2) {
      const windowFeatures$LWS = toString$LWS(sanitizedArgs$LWS[2]);
      let loweredWindowFeatures$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, windowFeatures$LWS, []);
      if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, noopenerRegExp$LWS, [windowFeatures$LWS])) {
        loweredWindowFeatures$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, loweredWindowFeatures$LWS, [
          noopenerRegExp$LWS,
          (_match$LWS, leading$LWS, _feature$LWS, ending$LWS) => `${leading$LWS}noopener${ending$LWS}`
        ]);
      }
      sanitizedArgs$LWS[2] = loweredWindowFeatures$LWS;
    }
    return sanitizedArgs$LWS;
  }
  function initDistortionDocumentOpen$LWS({
    globalObject: {
      Document: {
        prototype: {
          open: originalDocumentOpen$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalDocumentOpen$LWS, function open$LWS(...args$LWS) {
      if (args$LWS.length >= 3) {
        const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
        return ReflectApply$LWS$1(originalDocumentOpen$LWS, this, sanitizedArgs$LWS);
      }
      return ReflectApply$LWS$1(originalDocumentOpen$LWS, this, args$LWS);
    }];
    return function distortionDocumentOpen$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$l$LWS
  } = rootValidator$LWS;
  function initDistortionDocumentReplaceChildren$LWS({
    globalObject: {
      Document: {
        prototype: {
          replaceChildren: originalReplaceChild$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalReplaceChild$LWS, function replaceChildren$LWS(...args$LWS) {
      if (isSharedElement$l$LWS(ReflectApply$LWS$1(DocumentProtoHeadGetter$LWS, this, []))) {
        throw new LockerSecurityError$LWS(`Cannot replace children of document.`);
      }
      return ReflectApply$LWS$1(originalReplaceChild$LWS, this, args$LWS);
    }];
    return function distortionDocumentReplaceChildren$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionDOMParserParseFromString$LWS({
    document: document$LWS,
    globalObject: {
      DOMParser: {
        prototype: {
          parseFromString: originalParseFromString$LWS
        }
      }
    }
  }) {
    return function distortionDOMParserParseFromString$LWS({
      key: key$LWS
    }) {
      return [originalParseFromString$LWS, function parseFromString$LWS(...args$LWS) {
        if (args$LWS.length >= 2) {
          const string$LWS = toString$LWS(args$LWS[0]);
          const mimeType$LWS = toString$LWS(args$LWS[1]);
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
          args$LWS[0] = mimeType$LWS === "image/svg+xml" ? sanitizeSvgInnerHtml$LWS(string$LWS) : mimeType$LWS === "application/xhtml+xml" || mimeType$LWS === "application/xml" || mimeType$LWS === "text/xml" ? lwsInternalPolicy.createHTML(string$LWS, key$LWS, 2) : lwsInternalPolicy.createHTML(string$LWS, key$LWS, 0);
        }
        return ReflectApply$LWS$1(originalParseFromString$LWS, this, args$LWS);
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$k$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$6$LWS
  } = rootValidator$LWS;
  function initDistortionElementAfter$LWS({
    globalObject: {
      Element: {
        prototype: {
          after: originalAfter$LWS
        }
      },
      Node: Node$LWS
    }
  }) {
    const distortionEntry$LWS = [originalAfter$LWS, function after$LWS(...args$LWS) {
      if (isSharedElement$k$LWS(this)) {
        for (let i$LWS = 0, {
          length: length$LWS2
        } = args$LWS; i$LWS < length$LWS2; i$LWS += 1) {
          const argValue$LWS = args$LWS[i$LWS];
          if (!isAllowedSharedElementChild$6$LWS(argValue$LWS)) {
            const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) : toString$LWS(argValue$LWS);
            throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} after ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
          }
        }
      }
      return ReflectApply$LWS$1(originalAfter$LWS, this, args$LWS);
    }];
    return function distortionElementAfter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$j$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$5$LWS
  } = rootValidator$LWS;
  function initDistortionElementAppend$LWS({
    globalObject: {
      Element: {
        prototype: {
          append: originalAppend$LWS
        }
      },
      Node: Node$LWS
    }
  }) {
    const distortionEntry$LWS = [originalAppend$LWS, function append$LWS(...args$LWS) {
      if (isSharedElement$j$LWS(this)) {
        for (let i$LWS = 0, {
          length: length$LWS2
        } = args$LWS; i$LWS < length$LWS2; i$LWS += 1) {
          const argValue$LWS = args$LWS[i$LWS];
          if (!isAllowedSharedElementChild$5$LWS(argValue$LWS)) {
            const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) : toString$LWS(argValue$LWS);
            throw new LockerSecurityError$LWS(`Cannot append ${nodeNameOrString$LWS} to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
          }
        }
      }
      return ReflectApply$LWS$1(originalAppend$LWS, this, args$LWS);
    }];
    return function distortionElementAppend$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionElementAttachShadow$LWS({
    globalObject: {
      Element: {
        prototype: {
          attachShadow: originalAttachShadow$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalAttachShadow$LWS, function attachShadow$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: originalShadowRootInit$LWS
        } = args$LWS;
        if (originalShadowRootInit$LWS !== null && originalShadowRootInit$LWS !== void 0) {
          const {
            mode: mode$LWS2
          } = originalShadowRootInit$LWS;
          if (mode$LWS2 !== "closed") {
            throw new LockerSecurityError$LWS("Shadow root mode cannot be 'open.'");
          }
          const shadowRootInit$LWS = ObjectAssign$LWS$1({}, originalShadowRootInit$LWS, {
            mode: mode$LWS2
          });
          const originalShadowRootInitProto$LWS = ReflectGetPrototypeOf$LWS$1(originalShadowRootInit$LWS);
          ReflectSetPrototypeOf$LWS$1(shadowRootInit$LWS, originalShadowRootInitProto$LWS);
          args$LWS[0] = shadowRootInit$LWS;
        }
      }
      return ReflectApply$LWS$1(originalAttachShadow$LWS, this, args$LWS);
    }];
    return function distortionElementAttachShadow$LWS() {
      return distortionEntry$LWS;
    };
  }
  const namedNodeMapToElementCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function pairElement$LWS(attrInstance$LWS, element$LWS) {
    namedNodeMapToElementCache$LWS.set(attrInstance$LWS, element$LWS);
  }
  function setNamedItemWithAttr$LWS(record$LWS, originalMethod$LWS, nodeNameMap$LWS, attr$LWS) {
    const element$LWS = namedNodeMapToElementCache$LWS.get(nodeNameMap$LWS);
    if (element$LWS) {
      const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, attr$LWS, []);
      const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, normalizedNamespace$LWS);
      if (distortion$LWS) {
        const attrValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, attr$LWS, []);
        return ReflectApply$LWS$1(distortion$LWS, element$LWS, [attrValue$LWS]);
      }
    }
    return ReflectApply$LWS$1(originalMethod$LWS, nodeNameMap$LWS, [attr$LWS]);
  }
  function initDistortionElementAttributesGetter$LWS({
    globalObject: {
      Element: Element$LWS
    }
  }) {
    const originalAttributesGetter$LWS = ObjectLookupOwnGetter$LWS$1(Element$LWS.prototype, "attributes");
    const distortionEntry$LWS = [originalAttributesGetter$LWS, function attributes$LWS() {
      const attrs$LWS = ReflectApply$LWS$1(originalAttributesGetter$LWS, this, []);
      pairElement$LWS(attrs$LWS, this);
      return attrs$LWS;
    }];
    return function distortionElementAttributesGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$i$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$4$LWS
  } = rootValidator$LWS;
  function initDistortionElementBefore$LWS({
    globalObject: {
      Element: {
        prototype: {
          before: originalBefore$LWS
        }
      },
      Node: Node$LWS
    }
  }) {
    const distortionEntry$LWS = [originalBefore$LWS, function before$LWS(...args$LWS) {
      if (isSharedElement$i$LWS(this)) {
        for (let i$LWS = 0, {
          length: length$LWS2
        } = args$LWS; i$LWS < length$LWS2; i$LWS += 1) {
          const argValue$LWS = args$LWS[i$LWS];
          if (!isAllowedSharedElementChild$4$LWS(argValue$LWS)) {
            const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) : toString$LWS(argValue$LWS);
            throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} before ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
          }
        }
      }
      return ReflectApply$LWS$1(originalBefore$LWS, this, args$LWS);
    }];
    return function distortionElementBefore$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$h$LWS
  } = rootValidator$LWS;
  function initDistortionElementInnerHTMLSetter$LWS({
    document: document$LWS,
    globalObject: {
      Element: Element$LWS,
      SVGElement: SVGElement$LWS,
      XMLDocument: XMLDocument$LWS
    }
  }) {
    const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, "innerHTML");
    return function distortionElementInnerHTMLSetter$LWS({
      key: key$LWS
    }) {
      return [originalInnerHTMLSetter$LWS, function innerHTML$LWS(value$LWS) {
        const isOwnerXMLDocument$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, this, []) instanceof XMLDocument$LWS;
        if (!isOwnerXMLDocument$LWS) {
          if (isSharedElement$h$LWS(this)) {
            throw new LockerSecurityError$LWS(`Cannot set innerHTML of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
          }
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
          value$LWS = this instanceof SVGElement$LWS ? sanitizeSvgInnerHtml$LWS(this, value$LWS) : sanitize$LWS(value$LWS, key$LWS);
        }
        ReflectApply$LWS$1(originalInnerHTMLSetter$LWS, this, [value$LWS]);
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$g$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$3$LWS
  } = rootValidator$LWS;
  function initDistortionElementInsertAdjacentElement$LWS({
    globalObject: {
      Element: {
        prototype: {
          insertAdjacentElement: originalInsertAdjacentElement$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalInsertAdjacentElement$LWS, function insertAdjacentElement$LWS(...args$LWS) {
      if (args$LWS.length > 1) {
        const {
          1: element$LWS
        } = args$LWS;
        if (isSharedElement$g$LWS(this) && !isAllowedSharedElementChild$3$LWS(element$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot insert ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, element$LWS, [])} adjacent to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
      return ReflectApply$LWS$1(originalInsertAdjacentElement$LWS, this, args$LWS);
    }];
    return function distortionElementInsertAdjacentElement$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$f$LWS
  } = rootValidator$LWS;
  function initDistortionElementInsertAdjacentHTML$LWS({
    document: document$LWS,
    globalObject: {
      Element: {
        prototype: {
          insertAdjacentHTML: originalInsertAdjacentHTML$LWS
        }
      }
    }
  }) {
    return function distortionElementInsertAdjacentHTML$LWS({
      key: key$LWS
    }) {
      return [originalInsertAdjacentHTML$LWS, function insertAdjacentHTML$LWS(...args$LWS) {
        if (isSharedElement$f$LWS(this)) {
          throw new LockerSecurityError$LWS(`Cannot insert adjacent HTML to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}`);
        }
        if (args$LWS.length > 1) {
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
          args$LWS[1] = lwsInternalPolicy.createHTML(args$LWS[1], key$LWS, 0);
        }
        ReflectApply$LWS$1(originalInsertAdjacentHTML$LWS, this, args$LWS);
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$e$LWS
  } = rootValidator$LWS;
  function initDistortionElementOuterHTMLSetter$LWS({
    document: document$LWS,
    globalObject: {
      Element: Element$LWS
    }
  }) {
    const originalOuterHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, "outerHTML");
    return function distortionElementOuterHTMLSetter$LWS({
      key: key$LWS
    }) {
      return [originalOuterHTMLSetter$LWS, function outerHTML$LWS(value$LWS) {
        if (isSharedElement$e$LWS(this)) {
          throw new LockerSecurityError$LWS(`Cannot set outerHTML of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        ReflectApply$LWS$1(originalOuterHTMLSetter$LWS, this, [lwsInternalPolicy.createHTML(value$LWS, key$LWS, 0)]);
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$d$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$2$LWS
  } = rootValidator$LWS;
  function initDistortionElementPrepend$LWS({
    globalObject: {
      Element: {
        prototype: {
          prepend: originalPrepend$LWS
        }
      },
      Node: Node$LWS
    }
  }) {
    const distortionEntry$LWS = [originalPrepend$LWS, function prepend$LWS(...args$LWS) {
      if (isSharedElement$d$LWS(this)) {
        for (let i$LWS = 0, {
          length: length$LWS2
        } = args$LWS; i$LWS < length$LWS2; i$LWS += 1) {
          const argValue$LWS = args$LWS[i$LWS];
          if (!isAllowedSharedElementChild$2$LWS(argValue$LWS)) {
            const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) : toString$LWS(argValue$LWS);
            throw new LockerSecurityError$LWS(`Cannot prepend ${nodeNameOrString$LWS} to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
          }
        }
      }
      return ReflectApply$LWS$1(originalPrepend$LWS, this, args$LWS);
    }];
    return function distortionElementPrepend$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$c$LWS
  } = rootValidator$LWS;
  function initDistortionElementRemove$LWS({
    globalObject: {
      Element: {
        prototype: {
          remove: originalRemove$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalRemove$LWS, function remove$LWS() {
      if (isSharedElement$c$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot remove ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
      ReflectApply$LWS$1(originalRemove$LWS, this, []);
    }];
    return function distortionElementRemove$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$b$LWS
  } = rootValidator$LWS;
  function initDistortionElementReplaceChildren$LWS({
    globalObject: {
      Element: {
        prototype: {
          replaceChildren: originalReplaceChildren$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalReplaceChildren$LWS, function replaceChildren$LWS(...args$LWS) {
      if (isSharedElement$b$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot replace children of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
      return ReflectApply$LWS$1(originalReplaceChildren$LWS, this, args$LWS);
    }];
    return function distortionElementReplaceChildren$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$a$LWS
  } = rootValidator$LWS;
  function initDistortionElementReplaceWith$LWS({
    globalObject: {
      Element: {
        prototype: {
          replaceWith: originalReplaceWith$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalReplaceWith$LWS, function replaceWith$LWS(...args$LWS) {
      if (isSharedElement$a$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot replace ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
      return ReflectApply$LWS$1(originalReplaceWith$LWS, this, args$LWS);
    }];
    return function distortionElementReplaceWith$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionElementSetAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      }
    }
  }) {
    return function distortionElementSetAttribute$LWS(record$LWS) {
      return [originalSetAttribute$LWS, function setAttribute$LWS(...args$LWS) {
        if (args$LWS.length > 1) {
          const attrName$LWS = toString$LWS(args$LWS[0]);
          const attrValue$LWS = toString$LWS(args$LWS[1]);
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS);
          if (distortion$LWS) {
            ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
            return;
          }
          args$LWS[0] = attrName$LWS;
          args$LWS[1] = attrValue$LWS;
        }
        ReflectApply$LWS$1(originalSetAttribute$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionElementSetAttributeNode$LWS({
    globalObject: {
      Attr: Attr$LWS,
      Element: {
        prototype: {
          setAttributeNode: originalSetAttributeNode$LWS
        }
      }
    }
  }) {
    return function distortionElementSetAttributeNode$LWS(record$LWS) {
      return [originalSetAttributeNode$LWS, function setAttributeNode$LWS(...args$LWS) {
        const attr$LWS = args$LWS.length ? args$LWS[0] : void 0;
        if (!(attr$LWS instanceof Attr$LWS)) {
          return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, args$LWS);
        }
        if (ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, attr$LWS, [])) {
          return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, args$LWS);
        }
        const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, attr$LWS, []);
        const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);
        if (distortion$LWS) {
          const oldAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNode$LWS, this, [attrName$LWS]);
          if (oldAttr$LWS) {
            ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [oldAttr$LWS]);
          }
          const attrValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, attr$LWS, []);
          ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
          const newAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNode$LWS, this, [attrName$LWS]);
          if (newAttr$LWS) {
            ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [newAttr$LWS]);
          }
          if (oldAttr$LWS) {
            ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, [oldAttr$LWS]);
          }
          if (newAttr$LWS) {
            const newValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, newAttr$LWS, []);
            ReflectApply$LWS$1(AttrProtoValueSetter$LWS, attr$LWS, [newValue$LWS]);
            return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, [attr$LWS]);
          }
          return void 0;
        }
        return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionElementSetAttributeNodeNS$LWS({
    globalObject: {
      Attr: Attr$LWS,
      Element: {
        prototype: {
          setAttributeNodeNS: originalSetAttributeNodeNS$LWS
        }
      }
    }
  }) {
    return function distortionElementSetAttributeNodeNS$LWS(record$LWS) {
      return [originalSetAttributeNodeNS$LWS, function setAttributeNodeNS$LWS(...args$LWS) {
        const attr$LWS = args$LWS.length ? args$LWS[0] : void 0;
        if (!(attr$LWS instanceof Attr$LWS)) {
          return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, args$LWS);
        }
        if (ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, attr$LWS, [])) {
          return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, args$LWS);
        }
        const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, attr$LWS, []);
        const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);
        if (distortion$LWS) {
          const oldAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNodeNS$LWS, this, [attrNamespace$LWS, attrName$LWS]);
          if (oldAttr$LWS) {
            ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [oldAttr$LWS]);
          }
          const attrValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, attr$LWS, []);
          ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
          const newAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNodeNS$LWS, this, [attrNamespace$LWS, attrName$LWS]);
          if (newAttr$LWS) {
            ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [newAttr$LWS]);
          }
          if (oldAttr$LWS) {
            ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, [oldAttr$LWS]);
          }
          if (newAttr$LWS) {
            const newValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, newAttr$LWS, []);
            ReflectApply$LWS$1(AttrProtoValueSetter$LWS, attr$LWS, [newValue$LWS]);
            return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
          }
          return null;
        }
        return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
      }];
    };
  }
  function initDistortionElementSetAttributeNS$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttributeNS: originalSetAttributeNS$LWS
        }
      }
    }
  }) {
    return function distortionElementSetAttributeNS$LWS(record$LWS) {
      return [originalSetAttributeNS$LWS, function setAttributeNS$LWS(...args$LWS) {
        if (args$LWS.length < 3) {
          ReflectApply$LWS$1(originalSetAttributeNS$LWS, this, args$LWS);
          return;
        }
        let {
          0: attrNamespace$LWS
        } = args$LWS;
        if (attrNamespace$LWS !== null && attrNamespace$LWS !== void 0) {
          attrNamespace$LWS = toString$LWS(attrNamespace$LWS);
        }
        const attrName$LWS = toString$LWS(args$LWS[1]);
        const attrValue$LWS = toString$LWS(args$LWS[2]);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);
        if (distortion$LWS) {
          ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
          return;
        }
        {
          args$LWS[0] = attrNamespace$LWS;
          args$LWS[1] = attrName$LWS;
          args$LWS[2] = attrValue$LWS;
          ReflectApply$LWS$1(originalSetAttributeNS$LWS, this, args$LWS);
        }
      }];
    };
  }
  function alwaysNull$LWS() {
    return null;
  }
  function initDistortionElementShadowRootGetter$LWS({
    globalObject: {
      Element: Element$LWS
    }
  }) {
    const originalShadowRootGetter$LWS = ObjectLookupOwnGetter$LWS$1(Element$LWS.prototype, "shadowRoot");
    const distortionEntry$LWS = [originalShadowRootGetter$LWS, alwaysNull$LWS];
    return function distortionElementShadowRootGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionElementToggleAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          hasAttribute: ElementProtoHasAttribute$LWS2,
          toggleAttribute: originalToggleAttribute$LWS
        }
      }
    }
  }) {
    return function distortionElementToggleAttribute$LWS(record$LWS) {
      return [originalToggleAttribute$LWS, function toggleAttribute$LWS(...args$LWS) {
        const {
          length: length$LWS2
        } = args$LWS;
        if (length$LWS2 > 0) {
          const attrName$LWS = toString$LWS(args$LWS[0]);
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS);
          if (distortion$LWS) {
            const distortionArgs$LWS = length$LWS2 > 1 ? [args$LWS[1]] : [];
            ReflectApply$LWS$1(distortion$LWS, this, distortionArgs$LWS);
            return ReflectApply$LWS$1(ElementProtoHasAttribute$LWS2, this, [attrName$LWS]);
          }
          args$LWS[0] = attrName$LWS;
        }
        return ReflectApply$LWS$1(originalToggleAttribute$LWS, this, args$LWS);
      }];
    };
  }
  function composedPath$LWS() {
    return createDistortedComposedPath$LWS(this);
  }
  function createDistortedComposedPath$LWS(event$LWS) {
    const currentTarget$LWS = ReflectApply$LWS$1(EventProtoCurrentTargetGetter$LWS, event$LWS, []);
    const {
      composedPath: originalComposedPath$LWS
    } = Event.prototype;
    const rawComposedPath$LWS = ReflectApply$LWS$1(originalComposedPath$LWS, event$LWS, []);
    const currentTargetIndex$LWS = ReflectApply$LWS$1(ArrayProtoIndexOf$LWS$1, rawComposedPath$LWS, [currentTarget$LWS]);
    let distortedComposedPath$LWS = rawComposedPath$LWS;
    for (let i$LWS = currentTargetIndex$LWS; i$LWS > -1; i$LWS -= 1) {
      const eventTarget$LWS = rawComposedPath$LWS[i$LWS];
      if (eventTarget$LWS instanceof ShadowRoot) {
        distortedComposedPath$LWS = ReflectApply$LWS$1(ArrayProtoSlice$LWS$1, rawComposedPath$LWS, [i$LWS + 1]);
        break;
      }
    }
    return distortedComposedPath$LWS;
  }
  function initDistortionEventComposedPath$LWS({
    globalObject: {
      Event: {
        prototype: {
          composedPath: originalComposedPath$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalComposedPath$LWS, composedPath$LWS];
    return function distortionEventComposedPath$LWS() {
      return distortionEntry$LWS;
    };
  }
  function path$LWS() {
    return createDistortedComposedPath$LWS(this);
  }
  function initDistortionEventPathGetter$LWS({
    globalObject: {
      Event: Event$LWS
    }
  }) {
    const originalPathGetter$LWS = ObjectLookupOwnGetter$LWS$1(Event$LWS.prototype, "path");
    if (typeof originalPathGetter$LWS !== "function") {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalPathGetter$LWS, path$LWS];
    return function distortionEventPathGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionEventTargetAddEventListener$LWS({
    globalObject: {
      EventTarget: {
        prototype: {
          addEventListener: originalAddEventListener$LWS
        }
      }
    }
  }) {
    return function distortionEventTargetAddEventListener$LWS(record$LWS) {
      function addEventListener$LWS(...args$LWS) {
        const {
          length: length$LWS2
        } = args$LWS;
        if (length$LWS2 > 1) {
          const eventName$LWS = toString$LWS(args$LWS[0]);
          if (isEventTargetRestricted$LWS(record$LWS, this, eventName$LWS)) {
            throw new LockerSecurityError$LWS(createEventListenerExceptionMessage$LWS(this, eventName$LWS));
          }
          args$LWS[0] = eventName$LWS;
        }
        return ReflectApply$LWS$1(originalAddEventListener$LWS, this, args$LWS);
      }
      return [originalAddEventListener$LWS, addEventListener$LWS];
    };
  }
  function initDistortionFunction$LWS({
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      Function: originalFunction$LWS
    }
  }) {
    return function distortionFunction$LWS({
      sandboxEvaluator: sandboxEvaluator$LWS
    }) {
      return [originalFunction$LWS, function Function$LWS(...args$LWS) {
        const {
          length: length$LWS2
        } = args$LWS;
        if (length$LWS2) {
          const lastIndex$LWS = length$LWS2 - 1;
          args$LWS[lastIndex$LWS] = transformSourceText$LWS(toString$LWS(args$LWS[lastIndex$LWS]));
        }
        const fn$LWS = sandboxEvaluator$LWS(`(...args) => Function(...args)`, UNCOMPILED_CONTEXT$LWS);
        return ReflectApply$LWS$1(fn$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionHistoryPushState$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      History: {
        prototype: {
          pushState: originalPushState$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalPushState$LWS, function pushState$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalPushState$LWS, this, args$LWS);
      } catch (error) {
        if (args$LWS.length && error instanceof DOMException$LWS) {
          const state$LWS = args$LWS[0];
          if (isObject$LWS$1(state$LWS)) {
            args$LWS[0] = partialStructuredClone$LWS(state$LWS);
            return ReflectApply$LWS$1(originalPushState$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionHistoryPushState$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionHistoryReplaceState$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      History: {
        prototype: {
          replaceState: originalReplaceState$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalReplaceState$LWS, function replaceState$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalReplaceState$LWS, this, args$LWS);
      } catch (error) {
        if (args$LWS.length && error instanceof DOMException$LWS) {
          const state$LWS = args$LWS[0];
          if (isObject$LWS$1(state$LWS)) {
            args$LWS[0] = partialStructuredClone$LWS(state$LWS);
            return ReflectApply$LWS$1(originalReplaceState$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionHistoryReplaceState$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionHTMLElementCtor$LWS({
    document: document$LWS,
    globalObject: {
      HTMLElement: originalHTMLElementCtor$LWS
    }
  }) {
    return function distortionHTMLElementCtor$LWS({
      key: key$LWS
    }) {
      let registry$LWS;
      return [originalHTMLElementCtor$LWS, function HTMLElement$LWS() {
        if (new.target === void 0) {
          throw new TypeErrorCtor$LWS$1(ERR_NO_NEW_OP_HTML_ELEMENT$LWS);
        }
        if (new.target === HTMLElement$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_CONSTRUCTOR$LWS);
        }
        if (registry$LWS === void 0) {
          registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
        }
        return registry$LWS.newCtor(this);
      }];
    };
  }
  function initDistortionHTMLElementDatasetGetter$LWS({
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  }) {
    const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElement$LWS.prototype, "dataset");
    const distortionEntry$LWS = [originalDatasetGetter$LWS, function dataset$LWS() {
      return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalDatasetGetter$LWS, this, []));
    }];
    return function distortionHTMLElementDatasetGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$9$LWS
  } = rootValidator$LWS;
  function initDistortionHTMLElementInnerTextSetter$LWS({
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  }) {
    const originalInnerTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, "innerText");
    if (typeof originalInnerTextSetter$LWS !== "function") {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalInnerTextSetter$LWS, function innerText$LWS(value$LWS) {
      if (isSharedElement$9$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot set innerText of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
      ReflectApply$LWS$1(originalInnerTextSetter$LWS, this, [value$LWS]);
    }];
    return function distortionHTMLElementInnerTextSetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$8$LWS
  } = rootValidator$LWS;
  function initDistortionHTMLElementOuterTextSetter$LWS({
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  }) {
    const originalOuterTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, "outerText");
    if (typeof originalOuterTextSetter$LWS !== "function") {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalOuterTextSetter$LWS, function outerText$LWS(value$LWS) {
      if (isSharedElement$8$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot set outerText of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
      ReflectApply$LWS$1(originalOuterTextSetter$LWS, this, [value$LWS]);
    }];
    return function distortionHTMLElementOuterTextSetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionHTMLElementStyleGetter$LWS({
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  }) {
    const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElement$LWS.prototype, "style");
    const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
      return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalStyleGetter$LWS, this, []));
    }];
    return function distortionHTMLElementStyleGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function src$LWS(value$LWS) {
    const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);
    if (!isValidURLScheme$LWS(urlString$LWS)) {
      throw new LockerSecurityError$LWS("HTMLIFrameElement.src supports http://, https:// schemes and relative urls.");
    }
    ReflectApply$LWS$1(HTMLIFrameElementProtoSrcSetter$LWS, this, [urlString$LWS]);
  }
  function initDistortionHTMLIFrameElementSrcSetter$LWS({
    globalObject: {
      HTMLIFrameElement: HTMLIFrameElement$LWS
    }
  }) {
    const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElement$LWS.prototype, "src");
    const distortionMapEntry$LWS = [originalSrcSetter$LWS, src$LWS];
    return function distortionHTMLIFrameElementSrcSetter$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, HTMLIFrameElement$LWS, "src", NAMESPACE_DEFAULT$LWS, src$LWS);
      return distortionMapEntry$LWS;
    };
  }
  const importRegExp$LWS = /import/i;
  const WARN_MESSAGE$LWS = 'HTMLLinkElement does not allow setting "rel" property to "import" value.';
  function isValidRelValue$LWS(value$LWS) {
    return typeof value$LWS !== "string" || !ReflectApply$LWS$1(RegExpProtoTest$LWS$1, importRegExp$LWS, [value$LWS]);
  }
  function initDistortionHTMLLinkElementRelSetter$LWS({
    globalObject: {
      HTMLLinkElement: HTMLLinkElement$LWS
    }
  }) {
    const originalRelSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, "rel");
    function rel$LWS(value$LWS) {
      const valueAsString$LWS = toString$LWS(value$LWS);
      if (isValidRelValue$LWS(valueAsString$LWS)) {
        ReflectApply$LWS$1(originalRelSetter$LWS, this, [valueAsString$LWS]);
        return;
      }
      consoleWarn$LWS(WARN_MESSAGE$LWS);
    }
    const distortionEntry$LWS = [originalRelSetter$LWS, rel$LWS];
    return function distortionHTMLLinkElementRelSetter$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, HTMLLinkElement$LWS, "rel", NAMESPACE_DEFAULT$LWS, rel$LWS);
      return distortionEntry$LWS;
    };
  }
  function initDistortionHTMLLinkElementRelListSetter$LWS({
    globalObject: {
      DOMTokenList: DOMTokenList$LWS,
      HTMLLinkElement: HTMLLinkElement$LWS
    }
  }) {
    const originalRelListSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, "relList");
    const distortionEntry$LWS = [originalRelListSetter$LWS, function relList$LWS(relListValue$LWS) {
      const string$LWS = relList$LWS instanceof DOMTokenList$LWS ? ReflectApply$LWS$1(DOMTokenListProtoValueGetter$LWS, relListValue$LWS, []) : toString$LWS(relListValue$LWS);
      if (isValidRelValue$LWS(string$LWS)) {
        ReflectApply$LWS$1(originalRelListSetter$LWS, this, [string$LWS]);
        return;
      }
      consoleWarn$LWS(WARN_MESSAGE$LWS);
    }];
    return function distortionHTMLLinkElementRelListSetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionHTMLObjectElementDataSetter$LWS({
    globalObject: {
      HTMLObjectElement: HTMLObjectElement$LWS
    }
  }) {
    const originalDataSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLObjectElement$LWS.prototype, "data");
    function data$LWS(value$LWS) {
      const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);
      if (!isValidURLScheme$LWS(urlString$LWS)) {
        throw new LockerSecurityError$LWS("HTMLObjectElement.data supports http://, https:// schemes and relative urls.");
      }
      const parsedURL$LWS = parseURL$LWS(urlString$LWS);
      if (!isValidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }
      ReflectApply$LWS$1(originalDataSetter$LWS, this, [urlString$LWS]);
    }
    const distortionEntry$LWS = [originalDataSetter$LWS, data$LWS];
    return function distortionHTMLObjectElementDataSetter$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, HTMLObjectElement$LWS, "data", NAMESPACE_DEFAULT$LWS, data$LWS);
      return distortionEntry$LWS;
    };
  }
  const descriptorCaches$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function createBlockedAttributeDistortionFactoryInitializer$LWS(Ctor$LWS, ctorName$LWS, attributeName$LWS) {
    return function initDistortionBlockedAttribute$LWS() {
      const enquotedAttributeName$LWS = enquote$LWS(attributeName$LWS);
      const distortionName$LWS = `blocked${capitalizeFirstChar$LWS(attributeName$LWS)}Attribute`;
      const {
        [distortionName$LWS]: distortion$LWS
      } = {
        [distortionName$LWS]: () => {
          throw new LockerSecurityError$LWS(`Attribute ${enquotedAttributeName$LWS} not allowed on ${ctorName$LWS}.`);
        }
      };
      return function distortionBlockedAttribute$LWS(record$LWS) {
        registerAttributeDistortion$LWS(record$LWS, Ctor$LWS, attributeName$LWS, NAMESPACE_DEFAULT$LWS, distortion$LWS);
      };
    };
  }
  function createGetThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
    const originalGet$LWS = ObjectLookupOwnGetter$LWS$1(proto$LWS, key$LWS);
    const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
    const distortionEntry$LWS = [
      originalGet$LWS,
      function get$LWS() {
        throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
      }
    ];
    function getThrowerDistortionFactory$LWS() {
      return distortionEntry$LWS;
    }
    return function getThrowerDistortionFactoryInitializer$LWS() {
      return getThrowerDistortionFactory$LWS;
    };
  }
  function createSetThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
    const originalSet$LWS = ObjectLookupOwnSetter$LWS(proto$LWS, key$LWS);
    const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
    const distortionEntry$LWS = [
      originalSet$LWS,
      function set$LWS() {
        throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
      }
    ];
    function setThrowerDistortionFactory$LWS() {
      return distortionEntry$LWS;
    }
    return function setThrowerDistortionFactoryInitializer$LWS() {
      return setThrowerDistortionFactory$LWS;
    };
  }
  function createValueThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
    const {
      [key$LWS]: originalValue$LWS
    } = proto$LWS;
    const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
    const distortionEntry$LWS = [
      originalValue$LWS,
      function value$LWS() {
        throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
      }
    ];
    function valueThrowerDistortionFactory$LWS() {
      return distortionEntry$LWS;
    }
    return function valueThrowerDistortionFactoryInitializer$LWS() {
      return valueThrowerDistortionFactory$LWS;
    };
  }
  function addBlockedAttributeDistortionFactoryInitializers$LWS(Ctor$LWS, ctorName$LWS, attributes$LWS, factoryInitializers$LWS) {
    let {
      length: factoryInitializersOffset$LWS
    } = factoryInitializers$LWS;
    for (let i$LWS = 0, {
      length: length$LWS2
    } = attributes$LWS; i$LWS < length$LWS2; i$LWS += 1) {
      factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createBlockedAttributeDistortionFactoryInitializer$LWS(Ctor$LWS, ctorName$LWS, attributes$LWS[i$LWS]);
    }
  }
  function addBlockedPropertyDistortionFactoryInitializers$LWS({
    document: document$LWS
  }, proto$LWS, properties$LWS, factoryInitializers$LWS) {
    let {
      length: factoryInitializersOffset$LWS
    } = factoryInitializers$LWS;
    let descsCache$LWS = descriptorCaches$LWS.get(document$LWS);
    if (descsCache$LWS === void 0) {
      descsCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
      descriptorCaches$LWS.set(document$LWS, descsCache$LWS);
    }
    let safeDescs$LWS = descsCache$LWS.get(proto$LWS);
    if (safeDescs$LWS === void 0) {
      safeDescs$LWS = {
        __proto__: null
      };
      descsCache$LWS.set(proto$LWS, safeDescs$LWS);
    }
    for (let i$LWS = 0, {
      length: length$LWS2
    } = properties$LWS; i$LWS < length$LWS2; i$LWS += 1) {
      const prop$LWS = properties$LWS[i$LWS];
      let safeDesc$LWS = safeDescs$LWS[prop$LWS];
      if (safeDesc$LWS === void 0) {
        var _ReflectGetOwnPropert$LWS;
        safeDesc$LWS = (_ReflectGetOwnPropert$LWS = ReflectGetOwnPropertyDescriptor$LWS(proto$LWS, prop$LWS)) != null ? _ReflectGetOwnPropert$LWS : null;
        if (safeDesc$LWS) {
          ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
        }
        safeDescs$LWS[prop$LWS] = safeDesc$LWS;
      }
      if (safeDesc$LWS) {
        const {
          value: value$LWS
        } = safeDesc$LWS;
        if ("get" in safeDesc$LWS || "set" in safeDesc$LWS) {
          const {
            get: getter$LWS,
            set: setter$LWS
          } = safeDesc$LWS;
          if (getter$LWS) {
            factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createGetThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
          }
          if (setter$LWS) {
            factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createSetThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
          }
        } else {
          if (typeof value$LWS === "function") {
            factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createValueThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
          }
        }
      }
    }
  }
  const scriptURLs$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function trackScriptURL$LWS(targetElement$LWS, url$LWS) {
    scriptURLs$LWS.set(targetElement$LWS, url$LWS);
  }
  function getScriptURL$LWS(targetElement$LWS) {
    return scriptURLs$LWS.get(targetElement$LWS);
  }
  function createScriptDistortion$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }, attributeName$LWS) {
    const distortionName$LWS = `script${capitalizeFirstChar$LWS(attributeName$LWS)}`;
    const {
      [distortionName$LWS]: distortion$LWS
    } = {
      [distortionName$LWS](url$LWS) {
        trackScriptURL$LWS(this, resolveURL$LWS(url$LWS));
        const targetElement$LWS = this;
        const evaluator$LWS = function evaluator$LWS2(sourceText$LWS) {
          const ownerDoc$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, targetElement$LWS, []);
          const defaultView$LWS = ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, ownerDoc$LWS, []);
          const context$LWS = {
            [UNCOMPILED_LOCATION_NAME$LWS]: defaultView$LWS.location,
            [UNCOMPILED_TOP_NAME$LWS]: defaultView$LWS.top
          };
          sourceText$LWS = transformSourceText$LWS(sourceText$LWS);
          return sandboxEvaluator$LWS(sourceText$LWS, context$LWS, defaultView$LWS, ownerDoc$LWS);
        };
        lwsInternalPolicy.createScriptURL(url$LWS, evaluator$LWS, targetElement$LWS);
      }
    };
    return distortion$LWS;
  }
  function initDistortionHTMLScriptElementSrcGetter$LWS({
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS
    }
  }) {
    const originalSrcGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLScriptElement$LWS.prototype, "src");
    const distortionEntry$LWS = [originalSrcGetter$LWS, function src$LWS2() {
      var _getScriptURL$LWS;
      return (_getScriptURL$LWS = getScriptURL$LWS(this)) != null ? _getScriptURL$LWS : ReflectApply$LWS$1(originalSrcGetter$LWS, this, []);
    }];
    return function distortionHTMLScriptElementSrcGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionHTMLScriptElementSrcSetter$LWS({
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS
    }
  }) {
    const {
      set: originalSrcSetter$LWS
    } = ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElement$LWS.prototype, "src");
    return function distortionHTMLScriptElementSrcSetter$LWS(record$LWS) {
      const src$LWS2 = createScriptDistortion$LWS(record$LWS, "src");
      registerAttributeDistortion$LWS(record$LWS, HTMLScriptElement$LWS, "src", NAMESPACE_DEFAULT$LWS, src$LWS2);
      return [originalSrcSetter$LWS, src$LWS2];
    };
  }
  function initDistortionIDBObjectStoreAdd$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      IDBObjectStore: {
        prototype: {
          add: originalAdd$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalAdd$LWS, function add$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalAdd$LWS, this, args$LWS);
      } catch (error) {
        if (args$LWS.length && error instanceof DOMException$LWS) {
          const value$LWS = args$LWS[0];
          if (isObject$LWS$1(value$LWS)) {
            args$LWS[0] = partialStructuredClone$LWS(value$LWS);
            return ReflectApply$LWS$1(originalAdd$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionIDBObjectStoreAdd$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionIDBObjectStorePut$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      IDBObjectStore: {
        prototype: {
          put: originalPut$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalPut$LWS, function put$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalPut$LWS, this, args$LWS);
      } catch (error) {
        if (args$LWS.length && error instanceof DOMException$LWS) {
          const value$LWS = args$LWS[0];
          if (isObject$LWS$1(value$LWS)) {
            args$LWS[0] = partialStructuredClone$LWS(value$LWS);
            return ReflectApply$LWS$1(originalPut$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionIDBObjectStorePut$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionJSONParse$LWS({
    globalObject: {
      JSON: {
        parse: originalParse$LWS
      }
    }
  }) {
    return function distortionJSONParse$LWS({
      trackAsFastTarget: trackAsFastTarget$LWS
    }) {
      return [originalParse$LWS, function parse$LWS(...args$LWS) {
        const {
          length: length$LWS2
        } = args$LWS;
        if (!length$LWS2) {
          return ReflectApply$LWS$1(originalParse$LWS, this, args$LWS);
        }
        const {
          0: text$LWS
        } = args$LWS;
        const originalReviver$LWS = length$LWS2 > 1 ? args$LWS[1] : void 0;
        const useReviver$LWS = typeof originalReviver$LWS === "function";
        return ReflectApply$LWS$1(originalParse$LWS, this, [
          text$LWS,
          function reviver$LWS(key$LWS, value$LWS) {
            if (typeof value$LWS === "object" && value$LWS !== null) {
              trackAsFastTarget$LWS(value$LWS);
              trackAsLiveTarget$LWS(value$LWS);
            }
            return useReviver$LWS ? ReflectApply$LWS$1(originalReviver$LWS, this, [key$LWS, value$LWS]) : value$LWS;
          }
        ]);
      }];
    };
  }
  function initDistortionMessagePortPostMessage$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      MessagePort: MessagePort$LWS
    }
  }) {
    const {
      postMessage: originalPostMessage$LWS
    } = MessagePort$LWS.prototype;
    const distortionEntry$LWS = [originalPostMessage$LWS, function postMessage$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
      } catch (error) {
        const {
          length: length$LWS2
        } = args$LWS;
        if (length$LWS2 && error instanceof DOMException$LWS) {
          const message$LWS = args$LWS[0];
          if (isObject$LWS$1(message$LWS)) {
            if (length$LWS2 > 1) {
              args$LWS = partialStructuredClone$LWS(args$LWS);
            } else {
              args$LWS[0] = partialStructuredClone$LWS(message$LWS);
            }
            return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionMessagePortPostMessage$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionNamedNodeMapSetNamedItem$LWS({
    globalObject: {
      Attr: Attr$LWS,
      NamedNodeMap: {
        prototype: {
          setNamedItem: originalSetNamedItem$LWS
        }
      }
    }
  }) {
    return function distortionNamedNodeMapSetNamedItem$LWS(record$LWS) {
      return [originalSetNamedItem$LWS, function setNamedItem$LWS(...args$LWS) {
        const attr$LWS = args$LWS.length ? args$LWS[0] : void 0;
        if (attr$LWS && attr$LWS instanceof Attr$LWS) {
          return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItem$LWS, this, attr$LWS);
        }
        return ReflectApply$LWS$1(originalSetNamedItem$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionNamedNodeMapSetNamedItemNS$LWS({
    globalObject: {
      Attr: Attr$LWS,
      NamedNodeMap: {
        prototype: {
          setNamedItemNS: originalSetNamedItemNS$LWS
        }
      }
    }
  }) {
    return function distortionNamedNodeMapSetNamedItemNS$LWS(record$LWS) {
      return [originalSetNamedItemNS$LWS, function setNamedItemNS$LWS(...args$LWS) {
        const attr$LWS = args$LWS.length ? args$LWS[0] : void 0;
        if (attr$LWS && attr$LWS instanceof Attr$LWS) {
          return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItemNS$LWS, this, attr$LWS);
        }
        return ReflectApply$LWS$1(originalSetNamedItemNS$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionNavigatorSendBeacon$LWS({
    globalObject: {
      Navigator: {
        prototype: {
          sendBeacon: originalSendBeacon$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalSendBeacon$LWS, function sendBeacon$LWS(...args$LWS) {
      if (args$LWS.length) {
        const parsedURL$LWS = parseURL$LWS(toString$LWS(args$LWS[0]));
        if (!isValidURL$LWS(parsedURL$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
        }
        args$LWS[0] = parsedURL$LWS.normalizedURL;
      }
      return ReflectApply$LWS$1(originalSendBeacon$LWS, this, args$LWS);
    }];
    return function distortionNavigatorSendBeacon$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionNavigatorServiceWorkerGetter$LWS({
    globalObject: {
      Navigator: Navigator$LWS
    }
  }) {
    const originalServiceWorkerGetter$LWS = ObjectLookupOwnGetter$LWS$1(Navigator$LWS.prototype, "serviceWorker");
    if (typeof originalServiceWorkerGetter$LWS !== "function") {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalServiceWorkerGetter$LWS, noop$LWS$1];
    return function distortionNavigatorServiceWorkerGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$7$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$1$LWS
  } = rootValidator$LWS;
  function initDistortionNodeInsertBefore$LWS({
    globalObject: {
      Node: {
        prototype: {
          insertBefore: originalInsertBefore$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalInsertBefore$LWS, function insertBefore$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: node$LWS
        } = args$LWS;
        if (isSharedElement$7$LWS(this) && !isAllowedSharedElementChild$1$LWS(node$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot insert child ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])} into ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])},`);
        }
      }
      return ReflectApply$LWS$1(originalInsertBefore$LWS, this, args$LWS);
    }];
    return function distortionNodeInsertBefore$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionNodeValueSetter$LWS({
    globalObject: {
      Attr: Attr$LWS,
      Node: Node$LWS
    }
  }) {
    const originalNodeValueSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, "nodeValue");
    return function distortionNodeValueSetter$LWS(record$LWS) {
      return [originalNodeValueSetter$LWS, function nodeValue$LWS(value$LWS) {
        if (this instanceof Attr$LWS) {
          const ownerEl$LWS = ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, this, []);
          if (ownerEl$LWS === null) {
            ReflectApply$LWS$1(originalNodeValueSetter$LWS, this, [value$LWS]);
            return;
          }
          const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, this, []);
          const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, this, []);
          const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS);
          if (distortion$LWS) {
            ReflectApply$LWS$1(distortion$LWS, ownerEl$LWS, [value$LWS]);
            return;
          }
        }
        ReflectApply$LWS$1(originalNodeValueSetter$LWS, this, [value$LWS]);
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$6$LWS
  } = rootValidator$LWS;
  function initDistortionNodeRemoveChild$LWS({
    globalObject: {
      Node: {
        prototype: {
          removeChild: originalRemoveChild$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalRemoveChild$LWS, function removeChild$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: child$LWS
        } = args$LWS;
        if (isSharedElement$6$LWS(child$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot remove ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, child$LWS, [])}.`);
        }
      }
      return ReflectApply$LWS$1(originalRemoveChild$LWS, this, args$LWS);
    }];
    return function distortionNodeRemoveChild$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$5$LWS
  } = rootValidator$LWS;
  function initDistortionNodeReplaceChild$LWS({
    globalObject: {
      Node: {
        prototype: {
          replaceChild: originalReplaceChild$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalReplaceChild$LWS, function replaceChild$LWS(...args$LWS) {
      const {
        length: length$LWS2
      } = args$LWS;
      if (length$LWS2 > 1) {
        const {
          1: child$LWS
        } = args$LWS;
        if (isSharedElement$5$LWS(child$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot replace ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, child$LWS, [])}.`);
        }
      }
      return ReflectApply$LWS$1(originalReplaceChild$LWS, this, args$LWS);
    }];
    return function distortionNodeReplaceChild$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionNodeTextContentGetter$LWS({
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS,
      Node: Node$LWS,
      SVGScriptElement: SVGScriptElement$LWS
    }
  }) {
    const originalTextContentGetter$LWS = ObjectLookupOwnGetter$LWS$1(Node$LWS.prototype, "textContent");
    const distortionEntry$LWS = [originalTextContentGetter$LWS, function textContent$LWS() {
      if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
        var _getOriginalScriptTex$LWS;
        return (_getOriginalScriptTex$LWS = getOriginalScriptTextContent$LWS(this)) != null ? _getOriginalScriptTex$LWS : ReflectApply$LWS$1(originalTextContentGetter$LWS, this, []);
      }
      return ReflectApply$LWS$1(originalTextContentGetter$LWS, this, []);
    }];
    return function distortionHTMLScriptElementSrcGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$4$LWS
  } = rootValidator$LWS;
  function initDistortionNodeTextContentSetter$LWS({
    globalObject: {
      Attr: Attr$LWS,
      Node: Node$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      SVGScriptElement: SVGScriptElement$LWS
    },
    root: {
      distortions: distortions$LWS
    }
  }) {
    const {
      get: originalTextContentGetter$LWS,
      set: originalTextContentSetter$LWS
    } = ReflectGetOwnPropertyDescriptor$LWS(Node$LWS.prototype, "textContent");
    let distortedTextContentGetter$LWS;
    return function distortionNodeTextContentSetter$LWS(record$LWS) {
      const {
        sandboxEvaluator: sandboxEvaluator$LWS
      } = record$LWS;
      return [originalTextContentSetter$LWS, function textContent$LWS(value$LWS) {
        const valueAsString$LWS = toString$LWS(value$LWS);
        if (this instanceof Attr$LWS) {
          const ownerEl$LWS = ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, this, []);
          if (ownerEl$LWS === null) {
            ReflectApply$LWS$1(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
            return;
          }
          const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, this, []);
          const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, this, []);
          const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS);
          if (distortion$LWS) {
            ReflectApply$LWS$1(distortion$LWS, ownerEl$LWS, [valueAsString$LWS]);
            return;
          }
        } else if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
          if (!isTextContentEvaluatorHookDefined$LWS(this)) {
            if (distortedTextContentGetter$LWS === void 0) {
              distortedTextContentGetter$LWS = distortions$LWS.get(originalTextContentGetter$LWS);
            }
            defineScriptAccessorProperty$LWS(this, "textContent", distortedTextContentGetter$LWS, originalTextContentSetter$LWS);
          }
          setOriginalScriptTextContent$LWS(this, valueAsString$LWS);
          if (!isScriptEvaluated$LWS(this)) {
            if (!isScriptURLEvaluatorHookDefined$LWS(this)) {
              defineScriptEvaluatorProperty$LWS(this, (context$LWS, defaultView$LWS, ownerDoc$LWS) => {
                deleteOriginalTextContent$LWS(this);
                ReflectDeleteProperty$LWS$1(this, "textContent");
                ReflectApply$LWS$1(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
                sandboxEvaluator$LWS(transformSourceText$LWS(valueAsString$LWS), context$LWS, defaultView$LWS, ownerDoc$LWS);
              });
              ReflectApply$LWS$1(originalTextContentSetter$LWS, this, [SCRIPT_HOOK_SOURCE_TEXT$LWS]);
            }
            return;
          }
        } else if (isSharedElement$4$LWS(this)) {
          throw new LockerSecurityError$LWS(`Cannot set textContent of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])} elements.`);
        }
        ReflectApply$LWS$1(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
      }];
    };
  }
  function initDistortionNotificationCtor$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      Notification: originalNotificationCtor$LWS
    }
  }) {
    if (typeof originalNotificationCtor$LWS !== "function") {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalNotificationCtor$LWS, function Notification$LWS(...args$LWS) {
      try {
        return ReflectConstruct$LWS(originalNotificationCtor$LWS, args$LWS);
      } catch (error) {
        if (args$LWS.length > 1 && error instanceof DOMException$LWS) {
          const providedOptions$LWS = args$LWS[1];
          if (isObjectLike$LWS(providedOptions$LWS)) {
            const {
              data: data$LWS
            } = providedOptions$LWS;
            if (isObject$LWS$1(data$LWS)) {
              args$LWS[1] = {
                __proto__: providedOptions$LWS,
                data: partialStructuredClone$LWS(data$LWS)
              };
              return ReflectConstruct$LWS(originalNotificationCtor$LWS, args$LWS);
            }
          }
        }
        throw error;
      }
    }];
    return function distortionNotificationCtor$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionRangeCreateContextualFragment$LWS({
    document: document$LWS,
    globalObject: {
      Range: {
        prototype: {
          createContextualFragment: originalCreateContextualFragment$LWS
        }
      }
    }
  }) {
    return function distortionRangeCreateContextualFragment$LWS({
      key: key$LWS
    }) {
      return [originalCreateContextualFragment$LWS, function createContextualFragment$LWS(...args$LWS) {
        if (args$LWS.length) {
          const {
            0: tagString$LWS
          } = args$LWS;
          if (tagString$LWS !== null && tagString$LWS !== void 0) {
            setCustomElementsRegistry$LWS(document$LWS, key$LWS);
            args$LWS[0] = lwsInternalPolicy.createHTML(tagString$LWS, key$LWS, 0);
          }
        }
        return ReflectApply$LWS$1(originalCreateContextualFragment$LWS, this, args$LWS);
      }];
    };
  }
  const {
    isSharedElement: isSharedElement$3$LWS
  } = rootValidator$LWS;
  function initDistortionRangeDeleteContents$LWS({
    globalObject: {
      AbstractRange: AbstractRange$LWS,
      Range: {
        prototype: {
          deleteContents: originalDeleteContents$LWS
        }
      }
    }
  }) {
    const {
      prototype: AbstractRangeProto$LWS
    } = AbstractRange$LWS != null ? AbstractRange$LWS : Range;
    const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, "endContainer");
    const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, "startContainer");
    const distortionEntry$LWS = [originalDeleteContents$LWS, function deleteContents$LWS(...args$LWS) {
      const containers$LWS = [ReflectApply$LWS$1(originalEndContainerGetter$LWS, this, []), ReflectApply$LWS$1(originalStartContainerGetter$LWS, this, [])];
      for (let i$LWS = 0, {
        length: length$LWS2
      } = containers$LWS; i$LWS < length$LWS2; i$LWS += 1) {
        const container$LWS = containers$LWS[i$LWS];
        if (isSharedElement$3$LWS(container$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot delete contents of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, container$LWS, [])}.`);
        }
      }
      return ReflectApply$LWS$1(originalDeleteContents$LWS, this, args$LWS);
    }];
    return function distortionRangeDeleteContents$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$2$LWS
  } = rootValidator$LWS;
  function initDistortionRangeExtractContents$LWS({
    globalObject: {
      AbstractRange: AbstractRange$LWS,
      Range: {
        prototype: {
          extractContents: originalExtractContents$LWS
        }
      }
    }
  }) {
    const {
      prototype: AbstractRangeProto$LWS
    } = AbstractRange$LWS != null ? AbstractRange$LWS : Range;
    const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, "endContainer");
    const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, "startContainer");
    const distortionEntry$LWS = [originalExtractContents$LWS, function extractContents$LWS(...args$LWS) {
      const containers$LWS = [ReflectApply$LWS$1(originalEndContainerGetter$LWS, this, []), ReflectApply$LWS$1(originalStartContainerGetter$LWS, this, [])];
      for (let i$LWS = 0, {
        length: length$LWS2
      } = containers$LWS; i$LWS < length$LWS2; i$LWS += 1) {
        const container$LWS = containers$LWS[i$LWS];
        if (isSharedElement$2$LWS(container$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot extract contents of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, container$LWS, [])}.`);
        }
      }
      return ReflectApply$LWS$1(originalExtractContents$LWS, this, args$LWS);
    }];
    return function distortionRangeExtractContents$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$1$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = rootValidator$LWS;
  function initDistortionRangeInsertNode$LWS({
    globalObject: {
      Range: {
        prototype: {
          insertNode: originalInsertNode$LWS
        }
      }
    }
  }) {
    const originalCommonAncestorContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(Range.prototype, "commonAncestorContainer");
    const distortionEntry$LWS = [originalInsertNode$LWS, function insertNode$LWS(...args$LWS) {
      if (args$LWS.length) {
        const commonAncestorContainer$LWS = ReflectApply$LWS$1(originalCommonAncestorContainerGetter$LWS, this, []);
        if (commonAncestorContainer$LWS && isSharedElement$1$LWS(commonAncestorContainer$LWS) && !isAllowedSharedElementChild$LWS(args$LWS[0])) {
          throw new LockerSecurityError$LWS(`Cannot insert a new child node of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, commonAncestorContainer$LWS, [])}.`);
        }
      }
      return ReflectApply$LWS$1(originalInsertNode$LWS, this, args$LWS);
    }];
    return function distortionRangeInsertNode$LWS() {
      return distortionEntry$LWS;
    };
  }
  const {
    isSharedElement: isSharedElement$LWS
  } = rootValidator$LWS;
  function createRangeProtoMethodDistortionFactoryInitializer$LWS(methodName$LWS) {
    return function initDistortionContentWindowGetter$LWS({
      globalObject: {
        Range: {
          prototype: {
            [methodName$LWS]: originalMethod$LWS
          }
        }
      }
    }) {
      const {
        [methodName$LWS]: distortion$LWS
      } = {
        [methodName$LWS](...args$LWS) {
          if (args$LWS.length) {
            const {
              0: node$LWS
            } = args$LWS;
            if (isSharedElement$LWS(node$LWS)) {
              throw new LockerSecurityError$LWS(`Cannot call ${methodName$LWS} with ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])}.`);
            }
          }
          return ReflectApply$LWS$1(originalMethod$LWS, this, args$LWS);
        }
      };
      const distortionEntry$LWS = [originalMethod$LWS, distortion$LWS];
      return function distortionContentWindowGetter$LWS() {
        return distortionEntry$LWS;
      };
    };
  }
  const initDistortionRangeSetEnd$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS("setEnd");
  const initDistortionRangeSelectNode$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS("selectNode");
  const initDistortionRangeSelectNodeContents$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS("selectNodeContents");
  const initDistortionRangeSetEndAfter$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS("setEndAfter");
  const initDistortionRangeSetEndBefore$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS("setEndBefore");
  const initDistortionRangeSetStart$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS("setStart");
  const initDistortionRangeSetStartAfter$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS("setStartAfter");
  const initDistortionRangeSetStartBefore$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS("setStartBefore");
  const initDistortionRangeSurroundContents$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS("surroundContents");
  function initDistortionServiceWorkerContainerProto$LWS({
    globalObject: {
      ServiceWorkerContainer: ServiceWorkerContainer$LWS
    }
  }) {
    if (typeof ServiceWorkerContainer$LWS !== "function") {
      return noop$LWS$1;
    }
    const {
      prototype: originalPrototype$LWS
    } = ServiceWorkerContainer$LWS;
    const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
    return function distortionServiceWorkerContainerProto$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionShadowRootInnerHTMLSetter$LWS({
    document: document$LWS,
    globalObject: {
      ShadowRoot: ShadowRoot$LWS
    }
  }) {
    const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(ShadowRoot$LWS.prototype, "innerHTML");
    return function distortionShadowRootInnerHTMLSetter$LWS({
      key: key$LWS
    }) {
      return [originalInnerHTMLSetter$LWS, function innerHTML$LWS(value$LWS) {
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        ReflectApply$LWS$1(originalInnerHTMLSetter$LWS, this, [lwsInternalPolicy.createHTML(value$LWS, key$LWS, 0)]);
      }];
    };
  }
  function mode$LWS() {
    return "closed";
  }
  function initDistortionShadowRootModeGetter$LWS({
    globalObject: {
      ShadowRoot: ShadowRoot$LWS
    }
  }) {
    const originalModeGetter$LWS = ObjectLookupOwnGetter$LWS$1(ShadowRoot$LWS.prototype, "mode");
    const distortionEntry$LWS = [originalModeGetter$LWS, mode$LWS];
    return function distortionShadowRootModeGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function SharedWorker$LWS(scriptURL$LWS) {
    throw new LockerSecurityError$LWS(`Cannot create SharedWorker with ${toSafeTemplateStringValue$LWS(scriptURL$LWS)}.`);
  }
  function initDistortionSharedWorkerCtor$LWS({
    globalObject: {
      SharedWorker: originalSharedWorkerCtor$LWS
    }
  }) {
    if (typeof originalSharedWorkerCtor$LWS !== "function") {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalSharedWorkerCtor$LWS, SharedWorker$LWS];
    return function distortionSharedWorkerCtor$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionSharedWorkerProto$LWS({
    globalObject: {
      SharedWorker: SharedWorker$LWS2
    }
  }) {
    if (typeof SharedWorker$LWS2 !== "function") {
      return noop$LWS$1;
    }
    const {
      prototype: originalPrototype$LWS
    } = SharedWorker$LWS2;
    const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
    return function distortionSharedWorkerProto$LWS() {
      return distortionEntry$LWS;
    };
  }
  function getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS) {
    const storageKeys$LWS = ObjectKeys$LWS$1(storage$LWS);
    const keys$LWS = [];
    let keysOffset$LWS = 0;
    for (let i$LWS = 0, {
      length: length$LWS2
    } = storageKeys$LWS; i$LWS < length$LWS2; i$LWS += 1) {
      const key$LWS = storageKeys$LWS[i$LWS];
      if (startsWithStorageNamespaceMarker$LWS(key$LWS, namespace$LWS)) {
        keys$LWS[keysOffset$LWS++] = key$LWS;
      }
    }
    return keys$LWS;
  }
  function processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, namespace$LWS) {
    const {
      length: length$LWS2
    } = storageKeysForNamespace$LWS;
    const keys$LWS = ArrayCtor$LWS$1(length$LWS2);
    for (let i$LWS = 0; i$LWS < length$LWS2; i$LWS += 1) {
      const key$LWS = storageKeysForNamespace$LWS[i$LWS];
      keys$LWS[i$LWS] = removeStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
    }
    return keys$LWS;
  }
  const storageToMetaMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function getStorageMetaOrThrowInvalidInvocation$LWS(storage$LWS) {
    const storageMeta$LWS = storageToMetaMap$LWS.get(storage$LWS);
    if (storageMeta$LWS === void 0) {
      throw new LockerSecurityError$LWS(ERR_ILLEGAL_INVOCATION$LWS);
    }
    return storageMeta$LWS;
  }
  function createStorageProxy$LWS(storageTarget$LWS) {
    const proxy$LWS = new ProxyCtor$LWS(storageTarget$LWS, {
      get(target$LWS, key$LWS, receiver$LWS) {
        if (typeof key$LWS === "symbol") {
          return ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
        }
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
        if (ObjectHasOwn$LWS$1(storage$LWS, markedKey$LWS)) {
          return ReflectGet$LWS(storage$LWS, markedKey$LWS);
        }
        const proto$LWS = ReflectGetPrototypeOf$LWS$1(target$LWS);
        return proto$LWS === null ? void 0 : ReflectGet$LWS(proto$LWS, key$LWS, receiver$LWS);
      },
      set(target$LWS, key$LWS, value$LWS) {
        if (typeof key$LWS === "symbol") {
          return ReflectSet$LWS(target$LWS, key$LWS, value$LWS);
        }
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
        ReflectApply$LWS$1(StorageProtoSetItem$LWS, storage$LWS, [markedKey$LWS, value$LWS]);
        return true;
      },
      defineProperty(target$LWS, key$LWS, unsafePartialDesc$LWS) {
        const safeDesc$LWS = unsafePartialDesc$LWS;
        ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
        if (typeof key$LWS === "symbol") {
          return ReflectDefineProperty$LWS$1(target$LWS, key$LWS, safeDesc$LWS);
        }
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
        return ReflectDefineProperty$LWS$1(storage$LWS, markedKey$LWS, safeDesc$LWS);
      },
      deleteProperty(target$LWS, key$LWS) {
        if (typeof key$LWS === "symbol") {
          return ReflectDeleteProperty$LWS$1(target$LWS, key$LWS);
        }
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
        return ReflectDeleteProperty$LWS$1(storage$LWS, markedKey$LWS);
      },
      getOwnPropertyDescriptor(target$LWS, key$LWS) {
        let safeDesc$LWS;
        if (typeof key$LWS === "symbol") {
          safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
        } else {
          const {
            namespace: namespace$LWS,
            storage: storage$LWS
          } = storageToMetaMap$LWS.get(proxy$LWS);
          const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
          safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(storage$LWS, markedKey$LWS);
        }
        if (safeDesc$LWS) {
          ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
        }
        return safeDesc$LWS;
      },
      ownKeys(target$LWS) {
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
        const storageKeys$LWS = processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, namespace$LWS);
        const localSymbolKeys$LWS = ObjectGetOwnPropertySymbols$LWS(target$LWS);
        return ArrayConcat$LWS(storageKeys$LWS, localSymbolKeys$LWS);
      },
      has(target$LWS, key$LWS) {
        if (typeof key$LWS === "symbol") {
          return ReflectHas$LWS(target$LWS, key$LWS);
        }
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
        if (ObjectHasOwn$LWS$1(storage$LWS, markedKey$LWS)) {
          return true;
        }
        const proto$LWS = ReflectGetPrototypeOf$LWS$1(target$LWS);
        if (proto$LWS === null) {
          return false;
        }
        return ReflectHas$LWS(proto$LWS, key$LWS);
      },
      preventExtensions(_target$LWS) {
        return false;
      }
    });
    return proxy$LWS;
  }
  class PatchedStorage$LWS {
    constructor() {
      throw new LockerSecurityError$LWS(ERR_ILLEGAL_CONSTRUCTOR$LWS);
    }
    get length() {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
      return storageKeysForNamespace$LWS.length;
    }
    key(...args$LWS) {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
      if (args$LWS.length) {
        const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
        const index$LWS = args$LWS[0];
        const storageKey$LWS = storageKeysForNamespace$LWS[index$LWS];
        const storageDefaultKey$LWS = storageKeysForNamespace$LWS[0];
        const resolvedKey$LWS = storageKey$LWS || storageDefaultKey$LWS;
        if (typeof resolvedKey$LWS !== "string") {
          return null;
        }
        return removeStorageNamespaceMarker$LWS(resolvedKey$LWS, namespace$LWS);
      }
      return ReflectApply$LWS$1(StorageProtoKey$LWS, storage$LWS, args$LWS);
    }
    getItem(...args$LWS) {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
      if (args$LWS.length) {
        args$LWS[0] = prependStorageNamespaceMarker$LWS(toString$LWS(args$LWS[0]), namespace$LWS);
      }
      return ReflectApply$LWS$1(StorageProtoGetItem$LWS, storage$LWS, args$LWS);
    }
    setItem(...args$LWS) {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
      if (args$LWS.length > 1) {
        args$LWS[0] = prependStorageNamespaceMarker$LWS(toString$LWS(args$LWS[0]), namespace$LWS);
        args$LWS[1] = toString$LWS(args$LWS[1]);
      }
      ReflectApply$LWS$1(StorageProtoSetItem$LWS, storage$LWS, args$LWS);
    }
    removeItem(...args$LWS) {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
      if (args$LWS.length) {
        args$LWS[0] = prependStorageNamespaceMarker$LWS(toString$LWS(args$LWS[0]), namespace$LWS);
      }
      ReflectApply$LWS$1(StorageProtoRemoveItem$LWS, storage$LWS, args$LWS);
    }
    clear() {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
      for (let i$LWS = 0, {
        length: length$LWS2
      } = storageKeysForNamespace$LWS; i$LWS < length$LWS2; i$LWS += 1) {
        const key$LWS = storageKeysForNamespace$LWS[i$LWS];
        ReflectApply$LWS$1(StorageProtoRemoveItem$LWS, storage$LWS, [key$LWS]);
      }
    }
  }
  function createStorage$LWS(storage$LWS, namespace$LWS) {
    const proxy$LWS = createStorageProxy$LWS({
      __proto__: PatchedStorage$LWS.prototype
    });
    trackAsLiveTarget$LWS(proxy$LWS);
    storageToMetaMap$LWS.set(proxy$LWS, {
      namespace: namespace$LWS,
      storage: storage$LWS
    });
    return proxy$LWS;
  }
  const {
    prototype: PatchedStorageProto$LWS
  } = PatchedStorage$LWS;
  const {
    clear: patchedStorageProtoClear$LWS,
    getItem: patchedStorageProtoGetItem$LWS,
    key: patchedStorageProtoKey$LWS,
    removeItem: patchedStorageProtoRemoveItem$LWS,
    setItem: patchedStorageProtoSetItem$LWS
  } = PatchedStorageProto$LWS;
  const patchedStorageProtoLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(PatchedStorageProto$LWS, "length");
  function createDistortionStorageFactoryInitializer$LWS(storageName$LWS) {
    return function initDistortionStorageFactory$LWS({
      globalObject: globalObject$LWS
    }) {
      let originalStorageObject$LWS;
      try {
        originalStorageObject$LWS = globalObject$LWS[storageName$LWS];
      } catch (_unused2$LWS) {
      }
      if (!isObject$LWS$1(originalStorageObject$LWS)) {
        return noop$LWS$1;
      }
      return function distortionStorageFactory$LWS({
        key: key$LWS
      }) {
        return [originalStorageObject$LWS, createStorage$LWS(originalStorageObject$LWS, key$LWS)];
      };
    };
  }
  function initDistortionStorageLength$LWS({
    globalObject: {
      Storage: Storage$LWS
    }
  }) {
    const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(Storage$LWS.prototype, "length");
    const distortionEntry$LWS = [originalLengthGetter$LWS, patchedStorageProtoLengthGetter$LWS];
    return function distortionStorageLength$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionStorageGetItem$LWS({
    globalObject: {
      Storage: {
        prototype: {
          getItem: originalStorageGetItem$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalStorageGetItem$LWS, patchedStorageProtoGetItem$LWS];
    return function distortionStorageSetItem$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionStorageSetItem$LWS({
    globalObject: {
      Storage: {
        prototype: {
          setItem: originalStorageSetItem$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalStorageSetItem$LWS, patchedStorageProtoSetItem$LWS];
    return function distortionStorageSetItem$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionStorageKey$LWS({
    globalObject: {
      Storage: {
        prototype: {
          key: originalStorageKey$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalStorageKey$LWS, patchedStorageProtoKey$LWS];
    return function distortionStorageKey$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionStorageRemoveItem$LWS({
    globalObject: {
      Storage: {
        prototype: {
          removeItem: originalStorageRemoveItem$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalStorageRemoveItem$LWS, patchedStorageProtoRemoveItem$LWS];
    return function distortionStorageRemoveItem$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionStorageClear$LWS({
    globalObject: {
      Storage: {
        prototype: {
          clear: originalStorageClear$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalStorageClear$LWS, patchedStorageProtoClear$LWS];
    return function distortionStorageClear$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionStorage$LWS({
    globalObject: {
      Storage: Storage$LWS
    }
  }) {
    const distortionEntry$LWS = [Storage$LWS, PatchedStorage$LWS];
    return function distortionStorage$LWS() {
      return distortionEntry$LWS;
    };
  }
  const initDistortionLocalStorage$LWS = createDistortionStorageFactoryInitializer$LWS("localStorage");
  const initDistortionSessionStorage$LWS = createDistortionStorageFactoryInitializer$LWS("sessionStorage");
  function initDistortionSVGAnimateElementAttributeNameAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  }) {
    return function distortionSVGAnimateElementAttributeNameAttribute$LWS(record$LWS) {
      function distortAttribute$LWS(el$LWS, attrName$LWS) {
        if (ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS])) {
          const originalAttributeValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]);
          if (originalAttributeValue$LWS) {
            const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS);
            if (distortion$LWS) {
              ReflectApply$LWS$1(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
            }
          }
        }
      }
      registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, "attributeName", NAMESPACE_DEFAULT$LWS, function attributeName$LWS(value$LWS) {
        ReflectApply$LWS$1(originalSetAttribute$LWS, this, ["attributeName", value$LWS]);
        if (value$LWS === "href") {
          distortAttribute$LWS(this, "from");
          distortAttribute$LWS(this, "to");
          distortAttribute$LWS(this, "values");
        }
      });
    };
  }
  function initDistortionSVGAnimateElementFromAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  }) {
    function from$LWS(value$LWS) {
      if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ["attributeName"]) === "href") {
        value$LWS = sanitizeSvgHref$LWS(value$LWS);
      }
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, ["from", value$LWS]);
    }
    return function distortionSVGAnimateElementFromAttribute$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, "from", NAMESPACE_DEFAULT$LWS, from$LWS);
    };
  }
  function initDistortionSVGAnimateElementToAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  }) {
    function to$LWS(value$LWS) {
      if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ["attributeName"]) === "href") {
        value$LWS = sanitizeSvgHref$LWS(value$LWS);
      }
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, ["to", value$LWS]);
    }
    return function distortionSVGAnimateElementToAttribute$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, "to", NAMESPACE_DEFAULT$LWS, to$LWS);
    };
  }
  function initDistortionSVGAnimateElementValuesAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  }) {
    function values$LWS(value$LWS) {
      let returnValues$LWS = value$LWS;
      if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ["attributeName"]) === "href") {
        const valuesSplit$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, value$LWS, [";"]);
        const {
          length: length$LWS2
        } = valuesSplit$LWS;
        for (let i$LWS = 0; i$LWS < length$LWS2; i$LWS += 1) {
          valuesSplit$LWS[i$LWS] = sanitizeSvgHref$LWS(valuesSplit$LWS[i$LWS]);
        }
        returnValues$LWS = ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, valuesSplit$LWS, [";"]);
      }
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, ["values", returnValues$LWS]);
    }
    return function distortionSVGAnimateElementValuesAttribute$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, "values", NAMESPACE_DEFAULT$LWS, values$LWS);
    };
  }
  function initDistortionSVGElementDatasetGetter$LWS({
    globalObject: {
      SVGElement: SVGElement$LWS
    }
  }) {
    const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS$1(SVGElement$LWS.prototype, "dataset");
    const distortionEntry$LWS = [originalDatasetGetter$LWS, function dataset$LWS() {
      return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalDatasetGetter$LWS, this, []));
    }];
    return function distortionSVGElementDatasetGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionSVGElementStyleGetter$LWS({
    globalObject: {
      SVGElement: SVGElement$LWS
    }
  }) {
    const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS$1(SVGElement$LWS.prototype, "style");
    const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
      return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalStyleGetter$LWS, this, []));
    }];
    return function distortionSVGElementStyleGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionSVGScriptElementHrefGetter$LWS({
    globalObject: {
      SVGScriptElement: SVGScriptElement$LWS
    }
  }) {
    const originalHrefGetter$LWS = ObjectLookupOwnGetter$LWS$1(SVGScriptElement$LWS.prototype, "href");
    const distortionEntry$LWS = [originalHrefGetter$LWS, function href$LWS() {
      var _getScriptURL2$LWS;
      return (_getScriptURL2$LWS = getScriptURL$LWS(this)) != null ? _getScriptURL2$LWS : ReflectApply$LWS$1(originalHrefGetter$LWS, this, []);
    }];
    return function distortionSVGScriptElementHrefGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionSVGScriptElementHrefSetter$LWS({
    globalObject: {
      SVGScriptElement: SVGScriptElement$LWS
    }
  }) {
    return function distortionSVGScriptElementHrefSetter$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, "href", NAMESPACE_XLINK$LWS, createScriptDistortion$LWS(record$LWS, "href"));
      registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, "xlink:href", NAMESPACE_XLINK$LWS, createScriptDistortion$LWS(record$LWS, "xlink:href"));
    };
  }
  function initDistortionSVGSetElementAttributeNameAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGSetElement: SVGSetElement$LWS
    }
  }) {
    return function distortionSVGSetElementAttributeNameAttribute$LWS(record$LWS) {
      function distortAttribute$LWS(el$LWS, attrName$LWS) {
        if (ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS])) {
          const originalAttributeValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]);
          if (originalAttributeValue$LWS) {
            const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS);
            if (distortion$LWS) {
              ReflectApply$LWS$1(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
            }
          }
        }
      }
      function attributeName$LWS(value$LWS) {
        ReflectApply$LWS$1(originalSetAttribute$LWS, this, ["attributeName", value$LWS]);
        if (value$LWS === "href") {
          distortAttribute$LWS(this, "to");
        }
      }
      registerAttributeDistortion$LWS(record$LWS, SVGSetElement$LWS, "attributeName", NAMESPACE_DEFAULT$LWS, attributeName$LWS);
    };
  }
  function initDistortionSVGSetElementToAttribute$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS
        }
      },
      SVGSetElement: SVGSetElement$LWS
    }
  }) {
    function to$LWS(value$LWS) {
      if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ["attributeName"]) === "href") {
        value$LWS = sanitizeSvgHref$LWS(value$LWS);
      }
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, ["to", value$LWS]);
    }
    return function distortionSVGSetElementToAttribute$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, SVGSetElement$LWS, "to", NAMESPACE_DEFAULT$LWS, to$LWS);
    };
  }
  function createDistortionHrefAttributeFactoryInitializer$LWS(attributeName$LWS) {
    return function distortionHrefAttributeFactoryInitializer$LWS({
      globalObject: {
        Element: {
          prototype: {
            setAttribute: originalSetAttribute$LWS,
            setAttributeNS: originalSetAttributeNS$LWS
          }
        },
        SVGUseElement: SVGUseElement$LWS
      }
    }) {
      function xlinkNamespaceDistortion$LWS(value$LWS) {
        const returnValue$LWS = value$LWS === null || value$LWS === void 0 || value$LWS === "" ? value$LWS : sanitizeSvgHref$LWS(value$LWS);
        ReflectApply$LWS$1(originalSetAttributeNS$LWS, this, [NAMESPACE_XLINK$LWS, attributeName$LWS, returnValue$LWS]);
      }
      return function distortionHrefAttributeFactory$LWS(record$LWS) {
        registerAttributeDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, NAMESPACE_XLINK$LWS, xlinkNamespaceDistortion$LWS);
        if (attributeName$LWS === "href") {
          const defaultNamespaceDistortion$LWS = function defaultNamespaceDistortion$LWS2(value$LWS) {
            const returnValue$LWS = value$LWS === null || value$LWS === void 0 || value$LWS === "" ? value$LWS : sanitizeSvgHref$LWS(value$LWS);
            ReflectApply$LWS$1(originalSetAttribute$LWS, this, [attributeName$LWS, returnValue$LWS]);
          };
          registerAttributeDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, NAMESPACE_DEFAULT$LWS, defaultNamespaceDistortion$LWS);
        }
      };
    };
  }
  const initDistortionSVGUseElementHrefAttribute$LWS = createDistortionHrefAttributeFactoryInitializer$LWS("href");
  const initDistortionSVGUseElementXlinkHrefAttribute$LWS = createDistortionHrefAttributeFactoryInitializer$LWS("xlink:href");
  function initDistortionTrustedTypePolicyFactoryCreatePolicy$LWS({
    globalObject: {
      TrustedTypePolicyFactory: TrustedTypePolicyFactory$LWS
    }
  }) {
    var _TrustedTypePolicyFac$LWS;
    const originalCreatePolicy$LWS = TrustedTypePolicyFactory$LWS == null ? void 0 : (_TrustedTypePolicyFac$LWS = TrustedTypePolicyFactory$LWS.prototype) == null ? void 0 : _TrustedTypePolicyFac$LWS.createPolicy;
    if (typeof originalCreatePolicy$LWS !== "function") {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalCreatePolicy$LWS, function createPolicy$LWS(...args$LWS) {
      const name$LWS = args$LWS.length ? args$LWS[0] : void 0;
      if (name$LWS === "default") {
        throw new LockerSecurityError$LWS(`Cannot create TrustedTypePolicy with '${name$LWS}' policy name.`);
      }
      return ReflectApply$LWS$1(originalCreatePolicy$LWS, this, args$LWS);
    }];
    return function distortionTrustedTypePolicyFactoryCreatePolicy$LWS() {
      return distortionEntry$LWS;
    };
  }
  const HTML_MIME_TYPES_LIST$LWS = toSafeArray$LWS$1(["text/html", "image/svg+xml", "text/xml"]);
  function initDistortionURLCreateObjectURL$LWS({
    document: document$LWS,
    globalObject: globalObject$LWS,
    globalObject: {
      MediaSource: MediaSource$LWS,
      URL: {
        createObjectURL: originalCreateObjectURL$LWS
      }
    }
  }) {
    const {
      isEqualDomString: isEqualDomString$LWS
    } = getValidator$LWS(document$LWS, globalObject$LWS);
    return function distortionURLCreateObjectURL$LWS({
      key: key$LWS
    }) {
      const sanitizer$LWS = blobSanitizer$LWS(key$LWS);
      return [originalCreateObjectURL$LWS, function createObjectURL$LWS(blobObject$LWS) {
        let outURL$LWS = ReflectApply$LWS$1(originalCreateObjectURL$LWS, this, [blobObject$LWS]);
        if (MediaSource$LWS && blobObject$LWS instanceof MediaSource$LWS) {
          return outURL$LWS;
        }
        const blobType$LWS = ReflectApply$LWS$1(BlobProtoTypeGetter$LWS, blobObject$LWS, []);
        if (blobType$LWS === "") {
          const plainTextBlob$LWS = ReflectApply$LWS$1(BlobProtoSlice$LWS, blobObject$LWS, [0, void 0, "text/plain"]);
          return ReflectApply$LWS$1(originalCreateObjectURL$LWS, this, [plainTextBlob$LWS]);
        }
        const loweredBlobType$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, blobType$LWS, []);
        if (HTML_MIME_TYPES_LIST$LWS.includes(loweredBlobType$LWS)) {
          const blobSize$LWS = ReflectApply$LWS$1(BlobProtoSizeGetter$LWS, blobObject$LWS, []);
          const normalizedBlob$LWS = ReflectApply$LWS$1(BlobProtoSlice$LWS, blobObject$LWS, [0, blobSize$LWS, `${loweredBlobType$LWS};charset=utf-8`]);
          URLRevokeObjectURL$LWS(outURL$LWS);
          outURL$LWS = ReflectApply$LWS$1(originalCreateObjectURL$LWS, this, [normalizedBlob$LWS]);
          const xhr$LWS = new XhrCtor$LWS();
          ReflectApply$LWS$1(XhrProtoOpen$LWS, xhr$LWS, ["GET", outURL$LWS, false]);
          ReflectApply$LWS$1(XhrProtoSend$LWS, xhr$LWS, []);
          const responseText$LWS = ReflectApply$LWS$1(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
          const sanitized$LWS = sanitizer$LWS.sanitize(responseText$LWS);
          if (!isEqualDomString$LWS(responseText$LWS, sanitized$LWS)) {
            URLRevokeObjectURL$LWS(outURL$LWS);
            throw new LockerSecurityError$LWS(`Cannot 'createObjectURL' using a unsecure ${toSafeTemplateStringValue$LWS(blobObject$LWS)}.`);
          }
          return outURL$LWS;
        }
        if (isMIMETypeAllowed$LWS(loweredBlobType$LWS)) {
          return outURL$LWS;
        }
        URLRevokeObjectURL$LWS(outURL$LWS);
        throw new LockerSecurityError$LWS("Unsupported MIME type.");
      }];
    };
  }
  function initDistortionWindowFetch$LWS({
    globalObject: {
      fetch: originalFetch$LWS
    }
  }) {
    const distortionEntry$LWS = [originalFetch$LWS, function fetch$LWS(...args$LWS) {
      let {
        0: url$LWS
      } = args$LWS;
      if (url$LWS !== null && url$LWS !== void 0) {
        let parsedURL$LWS;
        if (url$LWS instanceof Request) {
          parsedURL$LWS = parseURL$LWS(ReflectApply$LWS$1(RequestProtoURLGetter$LWS, url$LWS, []));
        } else {
          parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));
          url$LWS = parsedURL$LWS.normalizedURL;
          args$LWS[0] = url$LWS;
        }
        if (!isValidURL$LWS(parsedURL$LWS)) {
          const {
            normalizedURL: normalizedURL$LWS
          } = parsedURL$LWS;
          return PromiseReject$LWS(new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${toSafeTemplateStringValue$LWS(normalizedURL$LWS)}`));
        }
      }
      return ReflectApply$LWS$1(originalFetch$LWS, this, args$LWS);
    }];
    return function distortionWindowFetch$LWS() {
      return distortionEntry$LWS;
    };
  }
  class BaseFrameHandler$LWS {
    defineProperty(_target$LWS, _key$LWS, _descriptor$LWS) {
      return true;
    }
    deleteProperty(_target$LWS, _key$LWS) {
      return true;
    }
    getOwnPropertyDescriptor(_target$LWS, _key$LWS) {
      return void 0;
    }
    isExtensible(_target$LWS) {
      return true;
    }
    ownKeys(_target$LWS) {
      return [];
    }
    preventExtensions(_target$LWS) {
      return true;
    }
    set(_target$LWS, _key$LWS, _value$LWS, _receiver$LWS) {
      return true;
    }
    setPrototypeOf(_target$LWS) {
      return false;
    }
  }
  ReflectSetPrototypeOf$LWS$1(BaseFrameHandler$LWS.prototype, null);
  class ShadowFramesPrototypeHandler$LWS extends BaseFrameHandler$LWS {
  }
  function initDistortionWindowFramesGetter$LWS({
    globalObject: globalObject$LWS
  }) {
    const originalWindowFramesGetter$LWS = ObjectLookupOwnGetter$LWS$1(globalObject$LWS, "frames");
    if (typeof originalWindowFramesGetter$LWS !== "function") {
      return noop$LWS$1;
    }
    const createFramesProxy$LWS = () => {
      const WindowPrototype$LWS = ReflectGetPrototypeOf$LWS$1(globalObject$LWS);
      const WindowProperties$LWS = ReflectGetPrototypeOf$LWS$1(WindowPrototype$LWS);
      const framesLengthGetter$LWS = ReflectApply$LWS$1(FunctionProtoBind$LWS, WindowLengthGetter$LWS, [globalObject$LWS]);
      const framesLengthSetter$LWS = ReflectApply$LWS$1(FunctionProtoBind$LWS, noop$LWS$1, []);
      const getFrameByIndexKey$LWS = (key$LWS) => {
        const possibleIndex$LWS = typeof key$LWS === "string" ? +key$LWS : -1;
        if (possibleIndex$LWS > -1 && NumberIsInteger$LWS$1(possibleIndex$LWS) && possibleIndex$LWS < ReflectApply$LWS$1(WindowLengthGetter$LWS, globalObject$LWS, [])) {
          const value$LWS = ObjectLookupOwnValue$LWS(globalObject$LWS, key$LWS);
          if (isWindow$LWS(value$LWS)) {
            return value$LWS;
          }
        }
        return void 0;
      };
      const getFrameByNameKey$LWS = (key$LWS) => {
        if (typeof key$LWS === "string" && !ObjectHasOwn$LWS$1(globalObject$LWS, key$LWS) && !ObjectHasOwn$LWS$1(WindowPrototype$LWS, key$LWS)) {
          const value$LWS = ObjectLookupOwnValue$LWS(WindowProperties$LWS, key$LWS);
          if (isWindow$LWS(value$LWS)) {
            return value$LWS;
          }
        }
        return void 0;
      };
      const getValueByKey$LWS = (key$LWS) => key$LWS === "length" ? ReflectApply$LWS$1(WindowLengthGetter$LWS, globalObject$LWS, []) : getFrameByIndexKey$LWS(key$LWS);
      class ShadowFrameHandler$LWS extends BaseFrameHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          const value$LWS = getValueByKey$LWS(key$LWS);
          return value$LWS === void 0 ? ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) : value$LWS;
        }
        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          if (key$LWS === "length") {
            return {
              __proto__: null,
              configurable: true,
              enumerable: true,
              get: framesLengthGetter$LWS,
              set: framesLengthSetter$LWS
            };
          }
          const value$LWS = getFrameByIndexKey$LWS(key$LWS);
          if (value$LWS) {
            return {
              __proto__: null,
              configurable: true,
              enumerable: true,
              value: value$LWS,
              writable: false
            };
          }
          return void 0;
        }
        has(target$LWS, key$LWS) {
          return ReflectHas$LWS(target$LWS, key$LWS) || getValueByKey$LWS(key$LWS) !== void 0;
        }
        ownKeys() {
          const {
            length: length$LWS2
          } = globalObject$LWS;
          const keys$LWS = ArrayCtor$LWS$1(length$LWS2 + 1);
          for (let i$LWS = 0; i$LWS < length$LWS2; i$LWS += 1) {
            keys$LWS[i$LWS] = `${i$LWS}`;
          }
          keys$LWS[length$LWS2] = "length";
          return keys$LWS;
        }
      }
      class ShadowWindowPropertiesHandler$LWS extends ShadowFramesPrototypeHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          const value$LWS = getFrameByNameKey$LWS(key$LWS);
          return value$LWS === void 0 ? ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) : value$LWS;
        }
        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          const value$LWS = getFrameByNameKey$LWS(key$LWS);
          if (value$LWS === void 0) {
            return value$LWS;
          }
          return {
            __proto__: null,
            configurable: true,
            enumerable: true,
            value: value$LWS,
            writable: false
          };
        }
        has(target$LWS, key$LWS) {
          return ReflectHas$LWS(target$LWS, key$LWS) || getFrameByNameKey$LWS(key$LWS) !== void 0;
        }
        ownKeys() {
          const keys$LWS = [];
          let keysOffset$LWS = 0;
          const unsafeDescs$LWS = ObjectGetOwnPropertyDescriptors$LWS(WindowProperties$LWS);
          ReflectSetPrototypeOf$LWS$1(unsafeDescs$LWS, null);
          for (const key$LWS in unsafeDescs$LWS) {
            if (typeof key$LWS === "string") {
              const unsafeDesc$LWS = unsafeDescs$LWS[key$LWS];
              if (ObjectHasOwn$LWS$1(unsafeDesc$LWS, "value") && isWindow$LWS(unsafeDesc$LWS.value)) {
                keys$LWS[keysOffset$LWS++] = key$LWS;
              }
            }
          }
          return keys$LWS;
        }
      }
      const shadowFrames$LWS = {};
      const shadowFramesPrototype$LWS = {};
      const shadowWindowProperties$LWS = {};
      const shadowFramesHandler$LWS = new ShadowFrameHandler$LWS();
      const shadowFramesPrototypeHandler$LWS = new ShadowFramesPrototypeHandler$LWS();
      const shadowWindowPropertiesHandler$LWS = new ShadowWindowPropertiesHandler$LWS();
      const framesPrototypeProxy$LWS = new ProxyCtor$LWS(shadowFramesPrototype$LWS, shadowFramesPrototypeHandler$LWS);
      const windowPropertiesProxy$LWS = new ProxyCtor$LWS(shadowWindowProperties$LWS, shadowWindowPropertiesHandler$LWS);
      ReflectSetPrototypeOf$LWS$1(shadowFrames$LWS, framesPrototypeProxy$LWS);
      ReflectSetPrototypeOf$LWS$1(shadowFramesPrototype$LWS, windowPropertiesProxy$LWS);
      return new ProxyCtor$LWS(shadowFrames$LWS, shadowFramesHandler$LWS);
    };
    let framesProxy$LWS;
    const distortionEntry$LWS = [
      originalWindowFramesGetter$LWS,
      function frames$LWS() {
        if (framesProxy$LWS === void 0) {
          framesProxy$LWS = createFramesProxy$LWS();
        }
        return framesProxy$LWS;
      }
    ];
    return function distortionWindowFramesGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionWindowGetComputedStyle$LWS({
    globalObject: {
      getComputedStyle: originalGetComputedStyle$LWS
    }
  }) {
    const distortionEntry$LWS = [originalGetComputedStyle$LWS, function getComputedStyle$LWS(...args$LWS) {
      return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalGetComputedStyle$LWS, this, args$LWS));
    }];
    return function distortionWindowGetComputedStyle$LWS() {
      return distortionEntry$LWS;
    };
  }
  function length$LWS() {
    return 0;
  }
  function initDistortionWindowLengthGetter$LWS({
    globalObject: globalObject$LWS
  }) {
    const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(globalObject$LWS, "length");
    if (typeof originalLengthGetter$LWS !== "function") {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalLengthGetter$LWS, length$LWS];
    return function distortionWindowLengthGetter$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionWindowOnsecuritypolicyviolation$LWS({
    globalObject: globalObject$LWS,
    globalObject: {
      Window: Window$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, "securitypolicyviolation");
  }
  function initDistortionWindowOnstorage$LWS({
    globalObject: globalObject$LWS,
    globalObject: {
      Window: Window$LWS
    }
  }) {
    return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, "storage");
  }
  function initDistortionWindowOpen$LWS({
    globalObject: {
      open: originalWindowOpen$LWS
    }
  }) {
    const distortionEntry$LWS = [originalWindowOpen$LWS, function open$LWS(...args$LWS) {
      const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
      return ReflectApply$LWS$1(originalWindowOpen$LWS, this, sanitizedArgs$LWS);
    }];
    return function distortionWindowOpen$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionWindowPostMessage$LWS({
    globalObject: {
      postMessage: originalPostMessage$LWS
    }
  }) {
    const distortionEntry$LWS = [originalPostMessage$LWS, function postMessage$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
      } catch (error) {
        const {
          length: length$LWS2
        } = args$LWS;
        if (length$LWS2) {
          const message$LWS = args$LWS[0];
          if (isObject$LWS$1(message$LWS)) {
            const providedOptions$LWS = length$LWS2 > 1 ? args$LWS[1] : void 0;
            if (isObjectLike$LWS(providedOptions$LWS)) {
              const {
                transfer: transfer$LWS
              } = providedOptions$LWS;
              args$LWS[1] = {
                __proto__: providedOptions$LWS,
                transfer: transfer$LWS
              };
              args$LWS = partialStructuredClone$LWS(args$LWS);
            } else {
              args$LWS[0] = partialStructuredClone$LWS(message$LWS);
            }
            return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionWindowPostMessage$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionWindowSetInterval$LWS({
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      setInterval: originalSetInterval$LWS
    }
  }) {
    return function distortionWndowSetInterval$LWS({
      sandboxEvaluator: sandboxEvaluator$LWS
    }) {
      return [originalSetInterval$LWS, function setInterval$LWS(...args$LWS) {
        if (args$LWS.length) {
          const {
            0: callback$LWS
          } = args$LWS;
          if (callback$LWS !== null && callback$LWS !== void 0 && typeof callback$LWS !== "function") {
            const sourceText$LWS = toString$LWS(callback$LWS);
            let transformedSourceText$LWS;
            args$LWS[0] = () => {
              if (transformedSourceText$LWS === void 0) {
                transformedSourceText$LWS = transformSourceText$LWS(sourceText$LWS);
              }
              sandboxEvaluator$LWS(transformedSourceText$LWS, UNCOMPILED_CONTEXT$LWS);
            };
          }
        }
        return ReflectApply$LWS$1(originalSetInterval$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionWindowSetTimeout$LWS({
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      setTimeout: originalSetTimeout$LWS
    }
  }) {
    return function distortionWindowSetTimeout$LWS({
      sandboxEvaluator: sandboxEvaluator$LWS
    }) {
      return [originalSetTimeout$LWS, function setTimeout$LWS(...args$LWS) {
        if (args$LWS.length) {
          const {
            0: callback$LWS
          } = args$LWS;
          if (callback$LWS !== null && callback$LWS !== void 0 && typeof callback$LWS !== "function") {
            const sourceText$LWS = toString$LWS(callback$LWS);
            args$LWS[0] = () => {
              sandboxEvaluator$LWS(transformSourceText$LWS(sourceText$LWS), UNCOMPILED_CONTEXT$LWS);
            };
          }
        }
        return ReflectApply$LWS$1(originalSetTimeout$LWS, this, args$LWS);
      }];
    };
  }
  function initDistortionWindowStructuredClone$LWS({
    globalObject: {
      DOMException: DOMException$LWS,
      structuredClone: originalStructuredClone$LWS
    }
  }) {
    if (typeof originalStructuredClone$LWS !== "function") {
      return noop$LWS$1;
    }
    const distortionEntry$LWS = [originalStructuredClone$LWS, function structuredClone$LWS(...args$LWS) {
      try {
        return ReflectApply$LWS$1(originalStructuredClone$LWS, this, args$LWS);
      } catch (error) {
        const {
          length: length$LWS2
        } = args$LWS;
        if (length$LWS2 && error instanceof DOMException$LWS) {
          const message$LWS = args$LWS[0];
          if (isObject$LWS$1(message$LWS)) {
            const providedOptions$LWS = length$LWS2 > 1 ? args$LWS[1] : void 0;
            if (isObjectLike$LWS(providedOptions$LWS)) {
              const {
                transfer: transfer$LWS
              } = providedOptions$LWS;
              args$LWS[1] = {
                __proto__: providedOptions$LWS,
                transfer: transfer$LWS
              };
              args$LWS = partialStructuredClone$LWS(args$LWS);
            } else {
              args$LWS[0] = partialStructuredClone$LWS(message$LWS);
            }
            return ReflectApply$LWS$1(originalStructuredClone$LWS, this, args$LWS);
          }
        }
        throw error;
      }
    }];
    return function distortionWindowStructuredClone$LWS() {
      return distortionEntry$LWS;
    };
  }
  function Worker$LWS(scriptURL$LWS) {
    throw new LockerSecurityError$LWS(`Cannot create Worker with ${toSafeTemplateStringValue$LWS(scriptURL$LWS)}.`);
  }
  function initDistortionWorkerCtor$LWS({
    globalObject: {
      Worker: originalWorkerCtor$LWS
    }
  }) {
    const distortionEntry$LWS = [originalWorkerCtor$LWS, Worker$LWS];
    return function distortionWorkerCtor$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionWorkerProto$LWS({
    globalObject: {
      Worker: {
        prototype: originalPrototype$LWS
      }
    }
  }) {
    const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
    return function distortionWorkerProto$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionXMLHttpRequestOpen$LWS({
    globalObject: {
      XMLHttpRequest: {
        prototype: {
          open: originalOpen$LWS
        }
      }
    }
  }) {
    const distortionEntry$LWS = [originalOpen$LWS, function open$LWS(...args$LWS) {
      const url$LWS = args$LWS.length > 1 ? args$LWS[1] : void 0;
      if (url$LWS !== null && url$LWS !== void 0) {
        const parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));
        if (!isValidURL$LWS(parsedURL$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
        }
        args$LWS[1] = parsedURL$LWS.normalizedURL;
      }
      ReflectApply$LWS$1(originalOpen$LWS, this, args$LWS);
    }];
    return function distortionXMLHttpRequestOpen$LWS() {
      return distortionEntry$LWS;
    };
  }
  function initDistortionXMLHttpRequestResponseGetter$LWS({
    document: document$LWS,
    globalObject: {
      Document: Document$LWS,
      XMLHttpRequest: XMLHttpRequest$LWS
    }
  }) {
    const originalResponseGetter$LWS = ObjectLookupOwnGetter$LWS$1(XMLHttpRequest$LWS.prototype, "response");
    return function distortionXMLHttpRequestResponseGetter$LWS({
      key: key$LWS
    }) {
      return [originalResponseGetter$LWS, function response$LWS() {
        const rawResponse$LWS = ReflectApply$LWS$1(originalResponseGetter$LWS, this, []);
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        return rawResponse$LWS instanceof Document$LWS ? sanitizeDocument$LWS(rawResponse$LWS, key$LWS) : rawResponse$LWS;
      }];
    };
  }
  function initDistortionXMLHttpRequestResponseXMLGetter$LWS({
    document: document$LWS,
    globalObject: {
      XMLHttpRequest: XMLHttpRequest$LWS
    }
  }) {
    const originalResponseXMLGetter$LWS = ObjectLookupOwnGetter$LWS$1(XMLHttpRequest$LWS.prototype, "responseXML");
    return function distortionXMLHttpRequestResponseXMLGetter$LWS({
      key: key$LWS
    }) {
      return [originalResponseXMLGetter$LWS, function responseXML$LWS() {
        const rawResponseXML$LWS = ReflectApply$LWS$1(originalResponseXMLGetter$LWS, this, []);
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        return sanitizeDocument$LWS(rawResponseXML$LWS, key$LWS);
      }];
    };
  }
  const internalDistortionFactoryInitializers$LWS = [
    initDistortionCSSStyleRuleStyleGetter$LWS,
    initDistortionDocumentDomainSetter$LWS,
    initDistortionDocumentOnsecuritypolicyviolation$LWS,
    initDistortionDocumentOpen$LWS,
    initDistortionElementAttachShadow$LWS,
    initDistortionElementAttributesGetter$LWS,
    initDistortionElementRemove$LWS,
    initDistortionElementReplaceChildren$LWS,
    initDistortionElementReplaceWith$LWS,
    initDistortionFunction$LWS,
    initDistortionHistoryPushState$LWS,
    initDistortionHistoryReplaceState$LWS,
    initDistortionHTMLElementDatasetGetter$LWS,
    initDistortionHTMLElementInnerTextSetter$LWS,
    initDistortionHTMLElementOuterTextSetter$LWS,
    initDistortionHTMLElementStyleGetter$LWS,
    initDistortionHTMLIFrameElementSrcSetter$LWS,
    initDistortionHTMLLinkElementRelSetter$LWS,
    initDistortionHTMLLinkElementRelListSetter$LWS,
    initDistortionHTMLObjectElementDataSetter$LWS,
    initDistortionHTMLScriptElementSrcGetter$LWS,
    initDistortionIDBObjectStoreAdd$LWS,
    initDistortionIDBObjectStorePut$LWS,
    initDistortionMessagePortPostMessage$LWS,
    initDistortionNavigatorSendBeacon$LWS,
    initDistortionNavigatorServiceWorkerGetter$LWS,
    initDistortionNodeRemoveChild$LWS,
    initDistortionNodeReplaceChild$LWS,
    initDistortionNotificationCtor$LWS,
    initDistortionRangeDeleteContents$LWS,
    initDistortionRangeExtractContents$LWS,
    initDistortionRangeInsertNode$LWS,
    initDistortionRangeSelectNode$LWS,
    initDistortionRangeSelectNodeContents$LWS,
    initDistortionRangeSetEnd$LWS,
    initDistortionRangeSetEndAfter$LWS,
    initDistortionRangeSetEndBefore$LWS,
    initDistortionRangeSetStart$LWS,
    initDistortionRangeSetStartAfter$LWS,
    initDistortionRangeSetStartBefore$LWS,
    initDistortionRangeSurroundContents$LWS,
    initDistortionServiceWorkerContainerProto$LWS,
    initDistortionShadowRootModeGetter$LWS,
    initDistortionSharedWorkerCtor$LWS,
    initDistortionSharedWorkerProto$LWS,
    initDistortionStorage$LWS,
    initDistortionStorageClear$LWS,
    initDistortionStorageGetItem$LWS,
    initDistortionStorageKey$LWS,
    initDistortionStorageLength$LWS,
    initDistortionStorageRemoveItem$LWS,
    initDistortionStorageSetItem$LWS,
    initDistortionSVGAnimateElementFromAttribute$LWS,
    initDistortionSVGAnimateElementToAttribute$LWS,
    initDistortionSVGAnimateElementValuesAttribute$LWS,
    initDistortionSVGElementDatasetGetter$LWS,
    initDistortionSVGElementStyleGetter$LWS,
    initDistortionSVGSetElementToAttribute$LWS,
    initDistortionSVGUseElementHrefAttribute$LWS,
    initDistortionSVGUseElementXlinkHrefAttribute$LWS,
    initDistortionTrustedTypePolicyFactoryCreatePolicy$LWS,
    initDistortionWindowFetch$LWS,
    initDistortionWindowFramesGetter$LWS,
    initDistortionWindowGetComputedStyle$LWS,
    initDistortionWindowLengthGetter$LWS,
    initDistortionWindowOnsecuritypolicyviolation$LWS,
    initDistortionWindowOnstorage$LWS,
    initDistortionWindowOpen$LWS,
    initDistortionWindowPostMessage$LWS,
    initDistortionWindowStructuredClone$LWS,
    initDistortionWorkerCtor$LWS,
    initDistortionWorkerProto$LWS,
    initDistortionXMLHttpRequestOpen$LWS
  ];
  const internalKeyedDistortionFactoryInitializers$LWS = [
    initDistortionAttrValueSetter$LWS,
    initDistortionAuraUtilGlobalEval$LWS,
    initDistortionCacheStorageDelete$LWS,
    initDistortionCacheStorageHas$LWS,
    initDistortionCacheStorageKeys$LWS,
    initDistortionCacheStorageMatch$LWS,
    initDistortionCacheStorageOpen$LWS,
    initDistortionCookieStoreDelete$LWS,
    initDistortionCookieStoreGet$LWS,
    initDistortionCookieStoreGetAll$LWS,
    initDistortionCookieStoreOnChange$LWS,
    initDistortionCookieStoreSet$LWS,
    initDistortionDocumentCookieGetter$LWS,
    initDistortionDocumentCookieSetter$LWS,
    initDistortionDocumentCreateElement$LWS,
    initDistortionDocumentCreateElementNS$LWS,
    initDistortionDocumentExecCommand$LWS,
    initDistortionDocumentReplaceChildren$LWS,
    initDistortionDOMParserParseFromString$LWS,
    initDistortionCustomElementRegistryDefine$LWS,
    initDistortionCustomElementRegistryGet$LWS,
    initDistortionCustomElementRegistryWhenDefined$LWS,
    initDistortionElementInnerHTMLSetter$LWS,
    initDistortionElementInsertAdjacentHTML$LWS,
    initDistortionElementOuterHTMLSetter$LWS,
    initDistortionElementSetAttribute$LWS,
    initDistortionElementSetAttributeNode$LWS,
    initDistortionElementSetAttributeNodeNS$LWS,
    initDistortionElementSetAttributeNS$LWS,
    initDistortionElementToggleAttribute$LWS,
    initDistortionEventComposedPath$LWS,
    initDistortionEventPathGetter$LWS,
    initDistortionEventTargetAddEventListener$LWS,
    initDistortionHTMLElementCtor$LWS,
    initDistortionHTMLScriptElementSrcSetter$LWS,
    initDistortionJSONParse$LWS,
    initDistortionNamedNodeMapSetNamedItem$LWS,
    initDistortionNamedNodeMapSetNamedItemNS$LWS,
    initDistortionNodeValueSetter$LWS,
    initDistortionNodeTextContentGetter$LWS,
    initDistortionNodeTextContentSetter$LWS,
    initDistortionRangeCreateContextualFragment$LWS,
    initDistortionShadowRootInnerHTMLSetter$LWS,
    initDistortionLocalStorage$LWS,
    initDistortionSessionStorage$LWS,
    initDistortionSVGAnimateElementAttributeNameAttribute$LWS,
    initDistortionSVGScriptElementHrefGetter$LWS,
    initDistortionSVGScriptElementHrefSetter$LWS,
    initDistortionSVGSetElementAttributeNameAttribute$LWS,
    initDistortionURLCreateObjectURL$LWS,
    initDistortionWindowSetInterval$LWS,
    initDistortionWindowSetTimeout$LWS,
    initDistortionXMLHttpRequestResponseGetter$LWS,
    initDistortionXMLHttpRequestResponseXMLGetter$LWS
  ];
  const externalDistortionFactoryInitializers$LWS = ArrayConcat$LWS(internalDistortionFactoryInitializers$LWS, [
    initDistortionElementAfter$LWS,
    initDistortionElementAppend$LWS,
    initDistortionElementBefore$LWS,
    initDistortionElementInsertAdjacentElement$LWS,
    initDistortionElementPrepend$LWS,
    initDistortionElementShadowRootGetter$LWS,
    initDistortionNodeInsertBefore$LWS
  ]);
  const externalKeyedDistortionFactoryInitializers$LWS = internalKeyedDistortionFactoryInitializers$LWS;
  const DocumentBlockedProperties$LWS = ["createProcessingInstruction", "exitFullscreen", "fullscreen", "fullscreenElement", "fullscreenEnabled", "mozCancelFullScreen", "mozFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "onfullscreenchange", "onfullscreenerror", "onmozfullscreenchange", "onmozfullscreenerror", "onrejectionhandled", "onunhandledrejection", "releaseCapture", "releaseEvents", "webkitFullScreenKeyboardInputAllowed", "write", "writeln"];
  const ElementBlockedProperties$LWS = ["mozRequestFullScreen", "onfullscreenchange", "onfullscreenerror", "requestFullscreen", "webkitRequestFullScreen", "webkitRequestFullscreen"];
  function initDistortionEval$LWS({
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      eval: originalEval$LWS
    }
  }) {
    return function distortionEval$LWS({
      sandboxEvaluator: sandboxEvaluator$LWS
    }) {
      return [originalEval$LWS, (sourceText$LWS) => sandboxEvaluator$LWS(transformSourceText$LWS(toString$LWS(sourceText$LWS)), UNCOMPILED_CONTEXT$LWS)];
    };
  }
  const HTMLElementBlockedAttributes$LWS = ["nonce"];
  const HTMLElementBlockedProperties$LWS = ["nonce", "onrejectionhandled", "onunhandledrejection"];
  const HTMLEmbedElementBlockedProperties$LWS = ["getSVGDocument"];
  const HTMLIFrameElementBlockedAttributes$LWS = ["allowpaymentrequest", "referrerpolicy", "srcdoc"];
  const HTMLIFrameElementBlockedProperties$LWS = ["allowPaymentRequest", "csp", "featurePolicy", "getSVGDocument", "referrerPolicy", "srcdoc"];
  const HTMLObjectElementBlockedProperties$LWS = ["getSVGDocument"];
  const HTMLScriptElementBlockedAttributes$LWS = ["nonce"];
  const HTMLScriptElementBlockedProperties$LWS = ["nonce"];
  const SVGElementBlockedAttributes$LWS = ["nonce"];
  const SVGElementBlockedProperties$LWS = ["nonce"];
  const XSLTProcessorBlockedProperties$LWS = ["transformToDocument", "transformToFragment"];
  const distortionFactoriesCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const evalDistortionFactoryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const opaqueWindowPostMessageDistortionFactoryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const SUPPORTS_DISTORTIONS_WEAK_MAP$LWS = !IS_WEBKIT_BROWSER$LWS;
  function createDistortionEntries$LWS(_record$LWS, factories$LWS) {
    const entries$LWS = [];
    for (let _i$LWS = 0, {
      length: _length$LWS
    } = factories$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      const factory$LWS = factories$LWS[_i$LWS];
      const entry$LWS = factory$LWS(_record$LWS);
      if (entry$LWS) {
        const {
          0: _originalValue$LWS,
          1: distortedValue$LWS
        } = entry$LWS;
        if (typeof _originalValue$LWS === "function") {
          entries$LWS[entries$LWS.length] = [_originalValue$LWS, proxyMaskFunctionDistortion$LWS(_record$LWS, factory$LWS, distortedValue$LWS, _originalValue$LWS)];
        } else {
          if (typeof _originalValue$LWS === "object" && _originalValue$LWS !== null) {
            entries$LWS[entries$LWS.length] = entry$LWS;
          }
        }
      }
    }
    return entries$LWS;
  }
  function createDistortionMap$LWS(entries$LWS) {
    return SUPPORTS_DISTORTIONS_WEAK_MAP$LWS ? toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1(entries$LWS)) : toSafeMap$LWS$1(new MapCtor$LWS$1(entries$LWS));
  }
  function getDistortionFactories$LWS(_record$LWS) {
    const {
      document: _document$LWS,
      globalObject: _globalObject$LWS,
      type: _type$LWS
    } = _record$LWS;
    let factories$LWS = distortionFactoriesCache$LWS.get(_document$LWS);
    if (factories$LWS) {
      return factories$LWS;
    }
    const {
      Document: _Document$LWS,
      Element: _Element$LWS,
      HTMLElement: _HTMLElement$LWS,
      HTMLIFrameElement: _HTMLIFrameElement$LWS,
      HTMLScriptElement: _HTMLScriptElement$LWS,
      SVGElement: _SVGElement$LWS,
      XSLTProcessor: XSLTProcessor$LWS
    } = _globalObject$LWS;
    const initializers$LWS = _type$LWS === 1 ? ArrayConcat$LWS(internalDistortionFactoryInitializers$LWS, internalKeyedDistortionFactoryInitializers$LWS) : ArrayConcat$LWS(externalDistortionFactoryInitializers$LWS, externalKeyedDistortionFactoryInitializers$LWS);
    addBlockedAttributeDistortionFactoryInitializers$LWS(_HTMLElement$LWS, "HTMLElement", HTMLElementBlockedAttributes$LWS, initializers$LWS);
    addBlockedAttributeDistortionFactoryInitializers$LWS(_HTMLIFrameElement$LWS, "HTMLIFrameElement", HTMLIFrameElementBlockedAttributes$LWS, initializers$LWS);
    addBlockedAttributeDistortionFactoryInitializers$LWS(_HTMLScriptElement$LWS, "HTMLScriptElement", HTMLScriptElementBlockedAttributes$LWS, initializers$LWS);
    addBlockedAttributeDistortionFactoryInitializers$LWS(_SVGElement$LWS, "SVGElement", SVGElementBlockedAttributes$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _Document$LWS.prototype, DocumentBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _Element$LWS.prototype, ElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _HTMLElement$LWS.prototype, HTMLElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _HTMLIFrameElement$LWS.prototype, HTMLIFrameElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, HTMLEmbedElement.prototype, HTMLEmbedElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, HTMLObjectElement.prototype, HTMLObjectElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _HTMLScriptElement$LWS.prototype, HTMLScriptElementBlockedProperties$LWS, initializers$LWS);
    addBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, _SVGElement$LWS.prototype, SVGElementBlockedProperties$LWS, initializers$LWS);
    if (typeof XSLTProcessor$LWS === "function") {
      addBlockedPropertyDistortionFactoryInitializers$LWS(_record$LWS, XSLTProcessor$LWS.prototype, XSLTProcessorBlockedProperties$LWS, initializers$LWS);
    }
    patchGlobalObject$LWS(_document$LWS, _globalObject$LWS);
    factories$LWS = initializers$LWS;
    for (let _i$LWS = 0, {
      length: _length$LWS
    } = factories$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      factories$LWS[_i$LWS] = initializers$LWS[_i$LWS](_record$LWS);
    }
    factories$LWS[factories$LWS.length] = finalizeAttributeDistortions$LWS;
    distortionFactoriesCache$LWS.set(_document$LWS, factories$LWS);
    return factories$LWS;
  }
  function getEvalDistortionFactory$LWS(_record$LWS) {
    const {
      document: _document$LWS
    } = _record$LWS;
    let evalDistortionFactory$LWS = evalDistortionFactoryCache$LWS.get(_document$LWS);
    if (evalDistortionFactory$LWS) {
      return evalDistortionFactory$LWS;
    }
    evalDistortionFactory$LWS = initDistortionEval$LWS(_record$LWS);
    evalDistortionFactoryCache$LWS.set(_document$LWS, evalDistortionFactory$LWS);
    return evalDistortionFactory$LWS;
  }
  function getOpaqueWindowPostMessageDistortionFactory$LWS(_record$LWS) {
    const {
      globalObject: _globalObject$LWS
    } = _record$LWS;
    let opaqueWindowPostMessageDistortionFactory$LWS = opaqueWindowPostMessageDistortionFactoryCache$LWS.get(_globalObject$LWS);
    if (opaqueWindowPostMessageDistortionFactory$LWS) {
      return opaqueWindowPostMessageDistortionFactory$LWS;
    }
    opaqueWindowPostMessageDistortionFactory$LWS = initDistortionWindowPostMessage$LWS(_record$LWS);
    opaqueWindowPostMessageDistortionFactoryCache$LWS.set(_globalObject$LWS, opaqueWindowPostMessageDistortionFactory$LWS);
    return opaqueWindowPostMessageDistortionFactory$LWS;
  }
  function proxyMaskFunctionDistortion$LWS({
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
    instrumentation: instrumentation$LWS,
    key: sandboxKey$LWS
  }, distortionFactory$LWS, distortionFunc$LWS, maskFunc$LWS) {
    let activityName$LWS;
    let startActivity$LWS;
    if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
      ({
        startActivity: startActivity$LWS
      } = instrumentation$LWS);
      const {
        name: factoryName$LWS
      } = distortionFactory$LWS;
      activityName$LWS = factoryName$LWS ? ReflectApply$LWS$1(StringProtoReplace$LWS, factoryName$LWS, [LOCKER_IDENTIFIER_MARKER$LWS, ""]) : "<unknown>";
    }
    return proxyMaskFunction$LWS(distortionFunc$LWS, maskFunc$LWS, {
      apply: function(__target$LWS, thisArg$LWS, _args$LWS) {
        let activity$LWS;
        if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS, BASIC_INSTRUMENTATION_DATA$LWS);
        }
        try {
          return ReflectApply$LWS$1(__target$LWS, thisArg$LWS, _args$LWS);
        } catch (error) {
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error({
              sandboxKey: sandboxKey$LWS,
              error
            });
          }
          throw error;
        } finally {
          if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
        }
      },
      construct: function(__target$LWS, _args$LWS, newTarget$LWS) {
        let activity$LWS;
        if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS(activityName$LWS, BASIC_INSTRUMENTATION_DATA$LWS);
        }
        try {
          return ReflectConstruct$LWS(__target$LWS, _args$LWS, newTarget$LWS);
        } catch (error) {
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error({
              sandboxKey: sandboxKey$LWS,
              error
            });
          }
          throw error;
        } finally {
          if (LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
        }
      }
    });
  }
  let lockerEvalContextValue$LWS;
  let lockerEvalHelpersValue$LWS;
  function clearEvalContext$LWS() {
    const evalContext$LWS = lockerEvalContextValue$LWS;
    lockerEvalContextValue$LWS = void 0;
    return evalContext$LWS;
  }
  function clearEvalHelpers$LWS() {
    const evalHelpers$LWS = lockerEvalHelpersValue$LWS;
    lockerEvalHelpersValue$LWS = void 0;
    return evalHelpers$LWS;
  }
  function setEvalContext$LWS(evalContext$LWS) {
    lockerEvalContextValue$LWS = evalContext$LWS;
  }
  function setEvalHelpers$LWS(evalHelpers$LWS) {
    lockerEvalHelpersValue$LWS = evalHelpers$LWS;
  }
  const CORE_SANDBOX_KEY$LWS = "lws-core-sandbox";
  const DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS = {
    [SANDBOX_EVAL_CONTEXT_NAME$LWS]: {
      __proto__: null,
      get() {
        return clearEvalContext$LWS();
      }
    },
    [SANDBOX_EVAL_HELPERS_NAME$LWS]: {
      __proto__: null,
      get() {
        return clearEvalHelpers$LWS();
      }
    }
  };
  const EMPTY_DISTORTIONS_MAP$LWS = createDistortionMap$LWS();
  const EMPTY_OBJECT$LWS = {};
  const ROOT_UNCOMPILED_CONTEXT$LWS = {
    [UNCOMPILED_LOCATION_NAME$LWS]: rootWindowLocation$LWS,
    [UNCOMPILED_TOP_NAME$LWS]: topWindow$LWS
  };
  const {
    apply: ReflectApply$LWS,
    defineProperty: ReflectDefineProperty$LWS,
    deleteProperty: ReflectDeleteProperty$LWS,
    getPrototypeOf: ReflectGetPrototypeOf$LWS,
    ownKeys: ReflectOwnKeys$LWS,
    setPrototypeOf: ReflectSetPrototypeOf$LWS
  } = Reflect;
  const ObjectCtor$LWS = Object;
  const {
    assign: ObjectAssign$LWS,
    freeze: ObjectFreeze$LWS,
    keys: ObjectKeys$LWS,
    prototype: ObjectProto$LWS
  } = ObjectCtor$LWS;
  const {
    hasOwn: OriginalObjectHasOwn$LWS
  } = ObjectCtor$LWS;
  const {
    __lookupGetter__: ObjectProtoLookupGetter$LWS,
    __lookupSetter__: ObjectProtoLookupSetter$LWS,
    hasOwnProperty: ObjectProtoHasOwnProperty$LWS
  } = ObjectProto$LWS;
  const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === "function" ? OriginalObjectHasOwn$LWS : function ObjectHasOwn$LWS2(object$LWS, __key$LWS) {
    return ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [__key$LWS]);
  };
  const {
    toString: ObjectProtoToString$LWS
  } = ObjectProto$LWS;
  function isObject$LWS(__value$LWS) {
    return typeof __value$LWS === "object" && __value$LWS !== null;
  }
  function ObjectLookupOwnGetter$LWS(object$LWS, __key$LWS) {
    return object$LWS === null || object$LWS === void 0 || !ObjectHasOwn$LWS(object$LWS, __key$LWS) ? void 0 : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, object$LWS, [__key$LWS]);
  }
  const SymbolCtor$LWS = Symbol;
  const {
    for: SymbolFor$LWS,
    iterator: SymbolIterator$LWS,
    toStringTag: SymbolToStringTag$LWS,
    unscopables: SymbolUnscopables$LWS
  } = SymbolCtor$LWS;
  const ArrayCtor$LWS = Array;
  const {
    prototype: ArrayProto$LWS
  } = ArrayCtor$LWS;
  const {
    at: ArrayProtoAt$LWS,
    concat: ArrayProtoConcat$LWS,
    copyWithin: ArrayProtoCopyWithin$LWS,
    entries: ArrayProtoEntries$LWS,
    every: ArrayProtoEvery$LWS,
    fill: ArrayProtoFill$LWS,
    findIndex: ArrayProtoFindIndex$LWS,
    flat: ArrayProtoFlat$LWS,
    flatMap: ArrayProtoFlatMap$LWS,
    forEach: ArrayProtoForEach$LWS,
    indexOf: ArrayProtoIndexOf$LWS,
    join: ArrayProtoJoin$LWS,
    keys: ArrayProtoKeys$LWS,
    lastIndexOf: ArrayProtoLastIndexOf$LWS,
    map: ArrayProtoMap$LWS,
    pop: ArrayProtoPop$LWS,
    reduce: ArrayProtoReduce$LWS,
    reduceRight: ArrayProtoReduceRight$LWS,
    reverse: ArrayProtoReverse$LWS,
    slice: ArrayProtoSlice$LWS,
    some: ArrayProtoSome$LWS,
    splice: ArrayProtoSplice$LWS,
    toLocaleString: ArrayProtoToLocaleString$LWS,
    toString: ArrayProtoToString$LWS,
    values: ArrayProtoValues$LWS,
    [SymbolIterator$LWS]: ArrayProtoSymbolIterator$LWS
  } = ArrayProto$LWS;
  const ArrayUnscopables$LWS = ObjectFreeze$LWS(ObjectAssign$LWS({
    __proto__: null
  }, ArrayProto$LWS[SymbolUnscopables$LWS]));
  const {
    filter: ArrayProtoFilter$LWS,
    find: ArrayProtoFind$LWS,
    includes: ArrayProtoIncludes$LWS,
    shift: ArrayProtoShift$LWS,
    sort: ArrayProtoSort$LWS,
    unshift: ArrayProtoUnshift$LWS
  } = ArrayProto$LWS;
  const {
    push: ArrayProtoPush$LWS
  } = ArrayProto$LWS;
  const {
    isArray: ArrayIsArray$LWS
  } = ArrayCtor$LWS;
  function toSafeArray$LWS(array$LWS) {
    ReflectSetPrototypeOf$LWS(array$LWS, null);
    array$LWS.at = ArrayProtoAt$LWS;
    array$LWS.concat = ArrayProtoConcat$LWS;
    array$LWS.copyWithin = ArrayProtoCopyWithin$LWS;
    array$LWS.entries = ArrayProtoEntries$LWS;
    array$LWS.every = ArrayProtoEvery$LWS;
    array$LWS.fill = ArrayProtoFill$LWS;
    array$LWS.filter = ArrayProtoFilter$LWS;
    array$LWS.find = ArrayProtoFind$LWS;
    array$LWS.findIndex = ArrayProtoFindIndex$LWS;
    array$LWS.flat = ArrayProtoFlat$LWS;
    array$LWS.flatMap = ArrayProtoFlatMap$LWS;
    array$LWS.forEach = ArrayProtoForEach$LWS;
    array$LWS.includes = ArrayProtoIncludes$LWS;
    array$LWS.indexOf = ArrayProtoIndexOf$LWS;
    array$LWS.join = ArrayProtoJoin$LWS;
    array$LWS.keys = ArrayProtoKeys$LWS;
    array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS;
    array$LWS.map = ArrayProtoMap$LWS;
    array$LWS.pop = ArrayProtoPop$LWS;
    array$LWS.push = ArrayProtoPush$LWS;
    array$LWS.reduce = ArrayProtoReduce$LWS;
    array$LWS.reduceRight = ArrayProtoReduceRight$LWS;
    array$LWS.reverse = ArrayProtoReverse$LWS;
    array$LWS.shift = ArrayProtoShift$LWS;
    array$LWS.slice = ArrayProtoSlice$LWS;
    array$LWS.some = ArrayProtoSome$LWS;
    array$LWS.sort = ArrayProtoSort$LWS;
    array$LWS.splice = ArrayProtoSplice$LWS;
    array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS;
    array$LWS.toString = ArrayProtoToString$LWS;
    array$LWS.unshift = ArrayProtoUnshift$LWS;
    array$LWS.values = ArrayProtoValues$LWS;
    array$LWS[SymbolIterator$LWS] = ArrayProtoSymbolIterator$LWS;
    array$LWS[SymbolUnscopables$LWS] = ArrayUnscopables$LWS;
    ReflectSetPrototypeOf$LWS(array$LWS, ArrayProto$LWS);
    return array$LWS;
  }
  ObjectLookupOwnGetter$LWS(ArrayBuffer.prototype, "byteLength");
  const LOCKER_UNMINIFIED_FLAG$LWS = `${function LOCKER_UNMINIFIED_FLAG$LWS2() {
    return LOCKER_UNMINIFIED_FLAG$LWS2.name;
  }()}`.includes("LOCKER_UNMINIFIED_FLAG");
  const CHAR_ELLIPSIS$LWS = "\u2026";
  const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = SymbolFor$LWS("@@lockerNearMembraneSerializedValue");
  const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = SymbolFor$LWS("@@lockerNearMembrane");
  SymbolFor$LWS("@@lockerLiveValue");
  const TO_STRING_BRAND_BIG_INT$LWS = "[object BigInt]";
  const TO_STRING_BRAND_BOOLEAN$LWS = "[object Boolean]";
  const TO_STRING_BRAND_NUMBER$LWS = "[object Number]";
  const TO_STRING_BRAND_STRING$LWS = "[object String]";
  const TO_STRING_BRAND_SYMBOL$LWS = "[object Symbol]";
  const MapCtor$LWS = Map;
  const {
    prototype: MapProto$LWS
  } = MapCtor$LWS;
  const {
    clear: MapProtoClear$LWS,
    delete: MapProtoDelete$LWS,
    forEach: MapProtoForEach$LWS,
    get: MapProtoGet$LWS,
    has: MapProtoHas$LWS,
    keys: MapProtoKeys$LWS,
    values: MapProtoValues$LWS,
    [SymbolIterator$LWS]: MapProtoSymbolIterator$LWS,
    [SymbolToStringTag$LWS]: MapProtoSymbolToStringTag$LWS
  } = MapProto$LWS;
  const {
    entries: MapProtoEntries$LWS,
    set: MapProtoSet$LWS
  } = MapProto$LWS;
  const MapProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(MapProto$LWS, "size");
  function toSafeMap$LWS(map$LWS) {
    ReflectSetPrototypeOf$LWS(map$LWS, null);
    map$LWS.clear = MapProtoClear$LWS;
    map$LWS.delete = MapProtoDelete$LWS;
    map$LWS.entries = MapProtoEntries$LWS;
    map$LWS.forEach = MapProtoForEach$LWS;
    map$LWS.get = MapProtoGet$LWS;
    map$LWS.has = MapProtoHas$LWS;
    map$LWS.keys = MapProtoKeys$LWS;
    map$LWS.set = MapProtoSet$LWS;
    ReflectDefineProperty$LWS(map$LWS, "size", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get: MapProtoSizeGetter$LWS,
      set: void 0
    });
    map$LWS.values = MapProtoValues$LWS;
    map$LWS[SymbolIterator$LWS] = MapProtoSymbolIterator$LWS;
    map$LWS[SymbolToStringTag$LWS] = MapProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS(map$LWS, MapProto$LWS);
    return map$LWS;
  }
  const NumberCtor$LWS = Number;
  const {
    isFinite: NumberIsFinite$LWS,
    isInteger: NumberIsInteger$LWS
  } = NumberCtor$LWS;
  const RegExpCtor$LWS = RegExp;
  const {
    prototype: RegExpProto$LWS
  } = RegExpCtor$LWS;
  const {
    test: RegExpProtoTest$LWS
  } = RegExpProto$LWS;
  ObjectLookupOwnGetter$LWS(RegExpProto$LWS, "source");
  const SetCtor$LWS = Set;
  const {
    prototype: SetProto$LWS
  } = SetCtor$LWS;
  ObjectLookupOwnGetter$LWS(SetProto$LWS, "size");
  const StringCtor$LWS = String;
  const {
    prototype: StringProto$LWS
  } = StringCtor$LWS;
  const {
    slice: StringProtoSlice$LWS,
    valueOf: StringProtoValueOf$LWS
  } = StringProto$LWS;
  const WeakMapCtor$LWS = WeakMap;
  const {
    prototype: WeakMapProto$LWS
  } = WeakMapCtor$LWS;
  const {
    has: WeakMapProtoHas$LWS
  } = WeakMapProto$LWS;
  const {
    delete: WeakMapProtoDelete$LWS,
    get: WeakMapProtoGet$LWS,
    set: WeakMapProtoSet$LWS,
    [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
  } = WeakMapProto$LWS;
  function toSafeWeakMap$LWS(weakMap$LWS) {
    ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
    weakMap$LWS.delete = WeakMapProtoDelete$LWS;
    weakMap$LWS.get = WeakMapProtoGet$LWS;
    weakMap$LWS.has = WeakMapProtoHas$LWS;
    weakMap$LWS.set = WeakMapProtoSet$LWS;
    weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
    return weakMap$LWS;
  }
  const WeakSetCtor$LWS = WeakSet;
  const {
    prototype: WeakSetProto$LWS
  } = WeakSetCtor$LWS;
  const {
    has: WeakSetProtoHas$LWS
  } = WeakSetProto$LWS;
  const {
    add: WeakSetProtoAdd$LWS,
    delete: WeakSetProtoDelete$LWS,
    [SymbolToStringTag$LWS]: WeakSetProtoSymbolToStringTag$LWS
  } = WeakSetProto$LWS;
  function toSafeWeakSet$LWS(weakSet$LWS) {
    ReflectSetPrototypeOf$LWS(weakSet$LWS, null);
    weakSet$LWS.add = WeakSetProtoAdd$LWS;
    weakSet$LWS.delete = WeakSetProtoDelete$LWS;
    weakSet$LWS.has = WeakSetProtoHas$LWS;
    weakSet$LWS[SymbolToStringTag$LWS] = WeakSetProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS(weakSet$LWS, WeakSetProto$LWS);
    return weakSet$LWS;
  }
  const {
    stringify: JSONStringify$LWS
  } = JSON;
  function getNearMembraneProxySerializedValue$LWS(object$LWS) {
    if (typeof object$LWS === "object" && object$LWS !== null || typeof object$LWS === "function") {
      return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS in object$LWS ? void 0 : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS];
    }
    return void 0;
  }
  function isNearMembraneProxy$LWS(__value$LWS) {
    if (typeof __value$LWS === "object" && __value$LWS !== null || typeof __value$LWS === "function") {
      return !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS in __value$LWS) && __value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS] === true;
    }
    return false;
  }
  toSafeMap$LWS(new MapCtor$LWS());
  const ErrorCtor$LWS = Error;
  const TypeErrorCtor$LWS = TypeError;
  function noop$LWS() {
  }
  const {
    min: MathMin$LWS
  } = Math;
  const rootWindow$LWS = window;
  const {
    navigator: navigator$LWS,
    navigator: {
      userAgentData: userAgentData$LWS
    }
  } = rootWindow$LWS;
  const brands$LWS = userAgentData$LWS == null ? void 0 : userAgentData$LWS.brands;
  const chromiumUserAgentRegExp$LWS = / (?:Headless)?Chrome\/\d+/;
  let userAgent$LWS;
  function getUserAgent$LWS() {
    if (userAgent$LWS === void 0) {
      userAgent$LWS = navigator$LWS.userAgent;
    }
    return userAgent$LWS;
  }
  const IS_CHROMIUM_BROWSER$LWS = ArrayIsArray$LWS(brands$LWS) && brands$LWS.length ? ReflectApply$LWS(ArrayProtoFind$LWS, brands$LWS, [
    (item$LWS) => (item$LWS == null ? void 0 : item$LWS.brand) === "Chromium"
  ]) !== void 0 : ReflectApply$LWS(RegExpProtoTest$LWS, chromiumUserAgentRegExp$LWS, [getUserAgent$LWS()]);
  const IS_OLD_CHROMIUM_BROWSER$LWS = IS_CHROMIUM_BROWSER$LWS && userAgentData$LWS === void 0;
  const {
    prototype: _DocumentProto$LWS
  } = Document;
  const {
    close: DocumentProtoClose$LWS,
    createElement: DocumentProtoCreateElement$LWS,
    open: DocumentProtoOpen$LWS
  } = _DocumentProto$LWS;
  const DocumentProtoBodyGetter$LWS = ObjectLookupOwnGetter$LWS(_DocumentProto$LWS, "body");
  const DOMExceptionCtor$LWS = DOMException;
  ObjectLookupOwnGetter$LWS(DOMExceptionCtor$LWS.prototype, "code");
  const {
    remove: ElementProtoRemove$LWS,
    setAttribute: ElementProtoSetAttribute$LWS
  } = Element.prototype;
  const HTMLElementProtoStyleGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement.prototype, "style");
  const HTMLIFrameElementProtoContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElement.prototype, "contentWindow");
  const {
    prototype: NodeProto$LWS
  } = Node;
  const {
    appendChild: NodeProtoAppendChild$LWS
  } = NodeProto$LWS;
  const NodeProtoLastChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, "lastChild");
  if (LOCKER_UNMINIFIED_FLAG$LWS) {
    let lockerDebugModeSymbolFlag$LWS = true;
    const LOCKER_DEBUG_MODE_SYMBOL$LWS = SymbolFor$LWS("@@lockerDebugMode");
    const MAX_ARRAY_DISPLAY$LWS = 100;
    const MAX_OBJECT_DISPLAY$LWS = 5;
    const MAX_STRING_DISPLAY$LWS = 100;
    const MID_STRING_DISPLAY$LWS = MAX_STRING_DISPLAY$LWS / 2;
    const headerCSSText$LWS = "display: inline-block; margin-bottom: 3px; margin-left: -3px; word-break: break-all; word-wrap: wrap;";
    const bodyItemStyleObject$LWS = {
      style: "margin-left:11px; margin-bottom: 3px;"
    };
    const bodyStyleObject$LWS = {
      style: "display: inline-block; margin-left:12px; word-break: break-all; word-wrap: wrap;"
    };
    const keyEnumerableStringStyleObject$LWS = {
      style: "color: #9d288c; font-weight: bold"
    };
    const keyNonEnumerableOrSymbolStyleObject$LWS = {
      style: "color: #b17ab0"
    };
    const primitiveBlueColorStyleObject$LWS = {
      style: "color: #16239f"
    };
    const primitiveGreenColorStyleObject$LWS = {
      style: "color: #236d25"
    };
    const primitiveGreyColorStyleObject$LWS = {
      style: "color: #606367"
    };
    const primitiveOrangeColorStyleObject$LWS = {
      style: "color: #b82619"
    };
    const formatValue$LWS = function formatValue$LWS2(__value$LWS) {
      if (__value$LWS === null || __value$LWS === void 0) {
        return ["span", primitiveGreyColorStyleObject$LWS, `${__value$LWS}`];
      }
      if (typeof __value$LWS === "boolean") {
        return ["span", primitiveBlueColorStyleObject$LWS, __value$LWS];
      }
      if (typeof __value$LWS === "number") {
        return NumberIsFinite$LWS(__value$LWS) ? ["span", primitiveBlueColorStyleObject$LWS, __value$LWS] : ["span", primitiveBlueColorStyleObject$LWS, `${__value$LWS >= 0 ? "" : "-"}Infinity`];
      }
      if (typeof __value$LWS === "string") {
        let _string$LWS = __value$LWS;
        const {
          length: _length$LWS
        } = _string$LWS;
        if (_length$LWS > MAX_STRING_DISPLAY$LWS) {
          const firstChunk$LWS = ReflectApply$LWS(StringProtoSlice$LWS, _string$LWS, [0, MID_STRING_DISPLAY$LWS]);
          const lastChunk$LWS = ReflectApply$LWS(StringProtoSlice$LWS, _string$LWS, [_length$LWS - MID_STRING_DISPLAY$LWS - 1, _length$LWS]);
          _string$LWS = firstChunk$LWS + CHAR_ELLIPSIS$LWS + lastChunk$LWS;
        }
        return ["span", primitiveOrangeColorStyleObject$LWS, JSONStringify$LWS(_string$LWS)];
      }
      if (ArrayIsArray$LWS(__value$LWS)) {
        return ["span", {}, `Array(${__value$LWS.length})`];
      }
      if (isObject$LWS(__value$LWS)) {
        return ["span", {}, `{${CHAR_ELLIPSIS$LWS}}`];
      }
      return ["span", primitiveOrangeColorStyleObject$LWS, StringCtor$LWS(__value$LWS)];
    };
    const formatHeader$LWS = function formatHeader$LWS2(object$LWS, config$LWS) {
      const isChildElement$LWS = config$LWS == null ? void 0 : config$LWS.isChildElement;
      const formattedHeader$LWS = [];
      let formattedHeaderOffset$LWS = 0;
      if (isChildElement$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", keyEnumerableStringStyleObject$LWS, config$LWS.childKey];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", {}, ": "];
      }
      const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, object$LWS, []);
      let _keys$LWS = ObjectKeys$LWS(object$LWS);
      if (brand$LWS === TO_STRING_BRAND_SYMBOL$LWS) {
        if (!ReflectApply$LWS(ArrayProtoIncludes$LWS, _keys$LWS, ["description"])) {
          ReflectApply$LWS(ArrayProtoUnshift$LWS, _keys$LWS, ["description"]);
        }
      } else if (brand$LWS === TO_STRING_BRAND_STRING$LWS) {
        const {
          length: _length$LWS
        } = object$LWS;
        _keys$LWS = ReflectApply$LWS(ArrayProtoFilter$LWS, _keys$LWS, [(__key$LWS) => {
          const _possibleIndex$LWS = typeof __key$LWS === "string" ? +__key$LWS : -1;
          return _possibleIndex$LWS < 0 || _possibleIndex$LWS >= _length$LWS || !NumberIsInteger$LWS(_possibleIndex$LWS);
        }]);
      }
      const {
        length: keysLength$LWS
      } = _keys$LWS;
      if (ArrayIsArray$LWS(object$LWS)) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", isChildElement$LWS ? primitiveGreyColorStyleObject$LWS : {}, `(${object$LWS.length}) [`];
        for (let _i$LWS = 0, _length$LWS = MathMin$LWS(keysLength$LWS, MAX_ARRAY_DISPLAY$LWS); _i$LWS < _length$LWS; _i$LWS += 1) {
          const __key$LWS = _keys$LWS[_i$LWS];
          const __value$LWS = object$LWS[__key$LWS];
          formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", {}, _i$LWS ? ", " : ""];
          formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(__value$LWS);
        }
        if (keysLength$LWS > MAX_ARRAY_DISPLAY$LWS) {
          formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", null, ["span", {}, `, ${CHAR_ELLIPSIS$LWS}`]];
        }
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", {}, "]"];
        return formattedHeader$LWS;
      }
      let boxedHeaderEntry$LWS;
      let headerOpening$LWS = "{";
      switch (brand$LWS) {
        case TO_STRING_BRAND_BIG_INT$LWS:
        case TO_STRING_BRAND_BOOLEAN$LWS:
        case TO_STRING_BRAND_NUMBER$LWS:
        case TO_STRING_BRAND_STRING$LWS:
        case TO_STRING_BRAND_SYMBOL$LWS: {
          let colorStyleObject$LWS = primitiveBlueColorStyleObject$LWS;
          if (brand$LWS === TO_STRING_BRAND_BIG_INT$LWS) {
            colorStyleObject$LWS = primitiveGreenColorStyleObject$LWS;
          } else if (brand$LWS === TO_STRING_BRAND_SYMBOL$LWS) {
            colorStyleObject$LWS = primitiveOrangeColorStyleObject$LWS;
          }
          headerOpening$LWS = `${ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1])} {`;
          boxedHeaderEntry$LWS = ["span", colorStyleObject$LWS, `${StringCtor$LWS(getNearMembraneProxySerializedValue$LWS(object$LWS))}`];
          break;
        }
      }
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", {}, headerOpening$LWS];
      if (boxedHeaderEntry$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = boxedHeaderEntry$LWS;
        if (keysLength$LWS) {
          formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", {}, ", "];
        }
      }
      for (let _i$LWS = 0, _length$LWS = MathMin$LWS(keysLength$LWS, MAX_OBJECT_DISPLAY$LWS); _i$LWS < _length$LWS; _i$LWS += 1) {
        const __key$LWS = _keys$LWS[_i$LWS];
        const __value$LWS = object$LWS[__key$LWS];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", {}, _i$LWS ? ", " : ""];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", primitiveGreyColorStyleObject$LWS, __key$LWS];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", {}, ": "];
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(__value$LWS);
      }
      if (keysLength$LWS > MAX_OBJECT_DISPLAY$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", null, ["span", {}, `, ${CHAR_ELLIPSIS$LWS}`]];
      }
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ["span", {}, "}"];
      return formattedHeader$LWS;
    };
    const formatBody$LWS = function formatBody$LWS2(object$LWS) {
      const _keys$LWS = ObjectKeys$LWS(object$LWS);
      const ownKeys$LWS = ReflectOwnKeys$LWS(object$LWS);
      if (!ArrayIsArray$LWS(object$LWS)) {
        ReflectApply$LWS(ArrayProtoSort$LWS, ownKeys$LWS, []);
      }
      const formattedBody$LWS = [];
      let formattedBodyOffset$LWS = 0;
      for (let _i$LWS = 0, {
        length: _length$LWS
      } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
        const ownKey$LWS = ownKeys$LWS[_i$LWS];
        const __value$LWS = object$LWS[ownKey$LWS];
        if (isObject$LWS(__value$LWS)) {
          formattedBody$LWS[formattedBodyOffset$LWS++] = ["div", {}, ["object", {
            object: __value$LWS,
            config: {
              childKey: StringCtor$LWS(ownKey$LWS),
              isChildElement: true
            }
          }]];
        } else {
          let currentKeyStyle$LWS = keyEnumerableStringStyleObject$LWS;
          if (typeof ownKey$LWS === "symbol" || !ReflectApply$LWS(ArrayProtoIncludes$LWS, _keys$LWS, [ownKey$LWS])) {
            currentKeyStyle$LWS = keyNonEnumerableOrSymbolStyleObject$LWS;
          }
          formattedBody$LWS[formattedBodyOffset$LWS++] = ["div", bodyItemStyleObject$LWS, ["span", currentKeyStyle$LWS, StringCtor$LWS(ownKey$LWS)], ["span", {}, ": "], formatValue$LWS(__value$LWS)];
        }
      }
      return formattedBody$LWS;
    };
    let {
      devtoolsFormatters: devtoolsFormatters$LWS
    } = rootWindow$LWS;
    if (!ArrayIsArray$LWS(devtoolsFormatters$LWS)) {
      devtoolsFormatters$LWS = [];
      ReflectDefineProperty$LWS(rootWindow$LWS, "devtoolsFormatters", {
        __proto__: null,
        configurable: true,
        value: devtoolsFormatters$LWS,
        writable: true
      });
    }
    devtoolsFormatters$LWS[devtoolsFormatters$LWS.length] = {
      header(object$LWS, config$LWS) {
        if (lockerDebugModeSymbolFlag$LWS) {
          lockerDebugModeSymbolFlag$LWS = false;
          ReflectDefineProperty$LWS(rootWindow$LWS, LOCKER_DEBUG_MODE_SYMBOL$LWS, {
            __proto__: null,
            configurable: true,
            value: true,
            writable: true
          });
        }
        if (!isNearMembraneProxy$LWS(object$LWS)) {
          return null;
        }
        const headerDiv$LWS = ["div", {
          style: `${headerCSSText$LWS}${config$LWS != null && config$LWS.isChildElement ? "" : "font-style: italic;"}`
        }];
        ReflectApply$LWS(ArrayProtoPush$LWS, headerDiv$LWS, formatHeader$LWS(object$LWS, config$LWS));
        return ["div", {}, headerDiv$LWS];
      },
      hasBody() {
        return true;
      },
      body(object$LWS) {
        const bodyDiv$LWS = ["div", bodyStyleObject$LWS];
        ReflectApply$LWS(ArrayProtoPush$LWS, bodyDiv$LWS, formatBody$LWS(object$LWS));
        return bodyDiv$LWS;
      }
    };
  }
  const proxyTargetToLazyPropertyDescriptorStateMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
  function createMembraneMarshall$LWS(_globalObject$LWS) {
    var _ref$LWS, _ref2$LWS, _ReflectApply$LWS, _globalThisRef$BigInt$LWS, _globalThisRef$BigUin$LWS;
    const ArrayCtor$LWS2 = Array;
    const ArrayBufferCtor$LWS2 = ArrayBuffer;
    const ErrorCtor$LWS2 = Error;
    const NumberCtor$LWS2 = Number;
    const ObjectCtor$LWS2 = Object;
    const ProxyCtor$LWS2 = Proxy;
    const ReflectRef$LWS = Reflect;
    const RegExpCtor$LWS2 = RegExp;
    const StringCtor$LWS2 = String;
    const SymbolCtor$LWS2 = Symbol;
    const TypeErrorCtor$LWS2 = TypeError;
    const WeakMapCtor$LWS2 = WeakMap;
    const WeakSetCtor$LWS2 = WeakSet;
    const {
      for: SymbolFor$LWS2,
      toStringTag: SymbolToStringTag$LWS2
    } = SymbolCtor$LWS2;
    const {
      apply: ReflectApply$LWS2,
      construct: ReflectConstruct$LWS2,
      defineProperty: ReflectDefineProperty$LWS2,
      deleteProperty: ReflectDeleteProperty$LWS2,
      get: ReflectGet$LWS2,
      getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS2,
      getPrototypeOf: ReflectGetPrototypeOf$LWS2,
      has: ReflectHas$LWS2,
      isExtensible: ReflectIsExtensible$LWS2,
      ownKeys: ReflectOwnKeys$LWS2,
      preventExtensions: ReflectPreventExtensions$LWS2,
      set: ReflectSet$LWS2,
      setPrototypeOf: ReflectSetPrototypeOf$LWS2
    } = ReflectRef$LWS;
    const {
      assign: ObjectAssign$LWS2,
      defineProperties: ObjectDefineProperties$LWS2,
      freeze: ObjectFreeze$LWS2,
      getOwnPropertyDescriptor: ObjectGetOwnPropertyDescriptor$LWS,
      getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS2,
      isFrozen: ObjectIsFrozen$LWS,
      isSealed: ObjectIsSealed$LWS,
      keys: ObjectKeys$LWS2,
      prototype: ObjectProto$LWS2,
      seal: ObjectSeal$LWS
    } = ObjectCtor$LWS2;
    const {
      hasOwnProperty: ObjectProtoHasOwnProperty$LWS2,
      propertyIsEnumerable: ObjectProtoPropertyIsEnumerable$LWS,
      toString: ObjectProtoToString$LWS2
    } = ObjectProto$LWS2;
    const {
      hasOwn: OriginalObjectHasOwn$LWS2
    } = ObjectCtor$LWS2;
    const {
      __defineGetter__: ObjectProtoDefineGetter$LWS,
      __defineSetter__: ObjectProtoDefineSetter$LWS,
      __lookupGetter__: ObjectProtoLookupGetter$LWS2,
      __lookupSetter__: ObjectProtoLookupSetter$LWS2
    } = ObjectProto$LWS2;
    const ObjectHasOwn$LWS2 = typeof OriginalObjectHasOwn$LWS2 === "function" ? OriginalObjectHasOwn$LWS2 : (object$LWS, __key$LWS) => ReflectApply$LWS2(ObjectProtoHasOwnProperty$LWS2, object$LWS, [__key$LWS]);
    const globalThisRef$LWS = (_ref$LWS = (_ref2$LWS = _globalObject$LWS != null ? _globalObject$LWS : typeof globalThis !== "undefined" ? globalThis : void 0) != null ? _ref2$LWS : typeof self !== "undefined" ? self : void 0) != null ? _ref$LWS : (ReflectDefineProperty$LWS2(ObjectProto$LWS2, "globalThis", {
      __proto__: null,
      configurable: true,
      get() {
        ReflectDeleteProperty$LWS2(ObjectProto$LWS2, "globalThis");
        return this != null ? this : self;
      }
    }), globalThis);
    const IS_IN_SHADOW_REALM$LWS = typeof _globalObject$LWS !== "object" || _globalObject$LWS === null;
    const IS_NOT_IN_SHADOW_REALM$LWS = !IS_IN_SHADOW_REALM$LWS;
    const LOCKER_DEBUG_MODE_SYMBOL$LWS = IS_NOT_IN_SHADOW_REALM$LWS ? SymbolFor$LWS2("@@lockerDebugMode") : void 0;
    const LOCKER_IDENTIFIER_MARKER$LWS2 = "$LWS";
    const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS2 = IS_NOT_IN_SHADOW_REALM$LWS ? SymbolFor$LWS2("@@lockerNearMembraneSerializedValue") : void 0;
    const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS2 = IS_NOT_IN_SHADOW_REALM$LWS ? SymbolFor$LWS2("@@lockerNearMembrane") : void 0;
    const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2 = SymbolFor$LWS2("@@lockerNearMembraneUndefinedValue");
    const LOCKER_STACK_TRACE_LIMIT$LWS = 20;
    const LOCKER_UNMINIFIED_FLAG$LWS2 = `${function LOCKER_UNMINIFIED_FLAG$LWS3() {
      return LOCKER_UNMINIFIED_FLAG$LWS3.name;
    }()}`.includes("LOCKER_UNMINIFIED_FLAG");
    const LOCKER_DEBUGGABLE_FLAG$LWS = LOCKER_UNMINIFIED_FLAG$LWS2 && IS_NOT_IN_SHADOW_REALM$LWS;
    const ERR_ILLEGAL_PROPERTY_ACCESS$LWS2 = "Illegal property access.";
    const FLAGS_REG_EXP$LWS = IS_IN_SHADOW_REALM$LWS ? /\w*$/ : void 0;
    let MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS;
    const SUPPORTS_BIG_INT$LWS2 = typeof BigInt === "function";
    const {
      isArray: isArrayOrThrowForRevoked$LWS
    } = ArrayCtor$LWS2;
    const {
      includes: ArrayProtoIncludes$LWS2,
      indexOf: ArrayProtoIndexOf$LWS2,
      slice: ArrayProtoSlice$LWS2
    } = ArrayCtor$LWS2.prototype;
    const {
      isView: ArrayBufferIsView$LWS2
    } = ArrayBufferCtor$LWS2;
    const BigIntProtoValueOf$LWS2 = SUPPORTS_BIG_INT$LWS2 ? BigInt.prototype.valueOf : void 0;
    const {
      valueOf: BooleanProtoValueOf$LWS2
    } = Boolean.prototype;
    const {
      toString: ErrorProtoToString$LWS
    } = ErrorCtor$LWS2.prototype;
    const {
      bind: FunctionProtoBind$LWS2,
      toString: FunctionProtoToString$LWS2
    } = Function.prototype;
    const {
      stringify: JSONStringify$LWS2
    } = JSON;
    const {
      isInteger: NumberIsInteger$LWS2
    } = NumberCtor$LWS2;
    const {
      valueOf: NumberProtoValueOf$LWS2
    } = NumberCtor$LWS2.prototype;
    const {
      revocable: ProxyRevocable$LWS2
    } = ProxyCtor$LWS2;
    const {
      prototype: RegExpProto$LWS2
    } = RegExpCtor$LWS2;
    const {
      exec: RegExpProtoExec$LWS2,
      test: RegExpProtoTest$LWS2,
      toString: RegExProtoToString$LWS
    } = RegExpProto$LWS2;
    const RegExpProtoFlagsGetter$LWS = IS_IN_SHADOW_REALM$LWS ? (_ReflectApply$LWS = ReflectApply$LWS2(ObjectProtoLookupGetter$LWS2, RegExpProto$LWS2, ["flags"])) != null ? _ReflectApply$LWS : function flags$LWS() {
      const _string$LWS = ReflectApply$LWS2(RegExProtoToString$LWS, this, []);
      return ReflectApply$LWS2(RegExpProtoExec$LWS2, FLAGS_REG_EXP$LWS, [_string$LWS])[0];
    } : void 0;
    const RegExpProtoSourceGetter$LWS2 = ReflectApply$LWS2(ObjectProtoLookupGetter$LWS2, RegExpProto$LWS2, ["source"]);
    const {
      replace: StringProtoReplace$LWS2,
      slice: StringProtoSlice$LWS2,
      valueOf: StringProtoValueOf$LWS2
    } = StringCtor$LWS2.prototype;
    const {
      toString: SymbolProtoToString$LWS2,
      valueOf: SymbolProtoValueOf$LWS2
    } = SymbolCtor$LWS2.prototype;
    const BigInt64ArrayProto$LWS = (_globalThisRef$BigInt$LWS = globalThisRef$LWS.BigInt64Array) == null ? void 0 : _globalThisRef$BigInt$LWS.prototype;
    const BigUint64ArrayProto$LWS = (_globalThisRef$BigUin$LWS = globalThisRef$LWS.BigUint64Array) == null ? void 0 : _globalThisRef$BigUin$LWS.prototype;
    const {
      prototype: Float32ArrayProto$LWS
    } = Float32Array;
    const {
      prototype: Float64ArrayProto$LWS
    } = Float64Array;
    const {
      prototype: Int8ArrayProto$LWS
    } = Int8Array;
    const {
      prototype: Int16ArrayProto$LWS
    } = Int16Array;
    const {
      prototype: Int32ArrayProto$LWS
    } = Int32Array;
    const {
      prototype: Uint8ArrayProto$LWS
    } = Uint8Array;
    const {
      prototype: Uint16ArrayProto$LWS
    } = Uint16Array;
    const {
      prototype: Uint32ArrayProto$LWS
    } = Uint32Array;
    const TypedArrayProto$LWS = Uint8ArrayProto$LWS.__proto__;
    const TypedArrayProtoLengthGetter$LWS = ReflectApply$LWS2(ObjectProtoLookupGetter$LWS2, TypedArrayProto$LWS, ["length"]);
    const {
      prototype: WeakMapProto$LWS2
    } = WeakMapCtor$LWS2;
    const {
      delete: WeakMapProtoDelete$LWS2,
      has: WeakMapProtoHas$LWS2,
      set: WeakMapProtoSet$LWS2,
      [SymbolToStringTag$LWS2]: WeakMapProtoSymbolToStringTag$LWS2
    } = WeakMapProto$LWS2;
    const {
      prototype: WeakSetProto$LWS2
    } = WeakSetCtor$LWS2;
    const {
      add: WeakSetProtoAdd$LWS2,
      has: WeakSetProtoHas$LWS2,
      delete: WeakSetProtoDelete$LWS2,
      [SymbolToStringTag$LWS2]: WeakSetProtoSymbolToStringTag$LWS2
    } = WeakSetProto$LWS2;
    const consoleObject$LWS = IS_NOT_IN_SHADOW_REALM$LWS && typeof console === "object" && console !== null ? console : void 0;
    const consoleInfo$LWS = consoleObject$LWS == null ? void 0 : consoleObject$LWS.info;
    const localEval$LWS = IS_IN_SHADOW_REALM$LWS ? eval : void 0;
    let installedErrorPrepareStackTraceFlag$LWS = false;
    let installedPropertyDescriptorMethodWrappersFlag$LWS = false;
    function alwaysFalse$LWS() {
      return false;
    }
    const installErrorPrepareStackTrace$LWS = LOCKER_UNMINIFIED_FLAG$LWS2 ? () => {
      if (installedErrorPrepareStackTraceFlag$LWS) {
        return;
      }
      installedErrorPrepareStackTraceFlag$LWS = true;
      const CallSite$LWS = (() => {
        try {
          var _callSites$$LWS;
          ErrorCtor$LWS2.prepareStackTrace = (_error$LWS, callSites2) => callSites2;
          const callSites = new ErrorCtor$LWS2().stack;
          ReflectDeleteProperty$LWS2(ErrorCtor$LWS2, "prepareStackTrace");
          return isArrayOrThrowForRevoked$LWS(callSites) && callSites.length > 0 ? (_callSites$$LWS = callSites[0]) == null ? void 0 : _callSites$$LWS.constructor : void 0;
        } catch (__unused$LWS) {
        }
        return void 0;
      })();
      if (typeof CallSite$LWS !== "function") {
        return;
      }
      const {
        getEvalOrigin: CallSiteProtoGetEvalOrigin$LWS,
        getFunctionName: CallSiteProtoGetFunctionName$LWS,
        toString: CallSiteProtoToString$LWS
      } = CallSite$LWS.prototype;
      const lockerFunctionNameMarkerRegExp$LWS = new RegExpCtor$LWS2(`${ReflectApply$LWS2(StringProtoReplace$LWS2, LOCKER_IDENTIFIER_MARKER$LWS2, [/[\\^$.*+?()[\]{}|]/g, "\\$&"])}(?=\\.|$)`);
      const formatStackTrace = function formatStackTrace2(error, callSites) {
        let stackTrace$LWS = "";
        try {
          stackTrace$LWS = ReflectApply$LWS2(ErrorProtoToString$LWS, error, []);
        } catch (__unused2$LWS) {
          stackTrace$LWS = "<error>";
        }
        let consecutive$LWS = false;
        for (let _i$LWS = 0, {
          length: _length$LWS
        } = callSites; _i$LWS < _length$LWS; _i$LWS += 1) {
          const callSite$LWS = callSites[_i$LWS];
          const funcName$LWS = ReflectApply$LWS2(CallSiteProtoGetFunctionName$LWS, callSite$LWS, []);
          let isMarked$LWS = false;
          if (typeof funcName$LWS === "string" && funcName$LWS !== "eval" && ReflectApply$LWS2(RegExpProtoTest$LWS2, lockerFunctionNameMarkerRegExp$LWS, [funcName$LWS])) {
            isMarked$LWS = true;
          }
          if (!isMarked$LWS) {
            const evalOrigin$LWS = ReflectApply$LWS2(CallSiteProtoGetEvalOrigin$LWS, callSite$LWS, []);
            if (typeof evalOrigin$LWS === "string" && ReflectApply$LWS2(RegExpProtoTest$LWS2, lockerFunctionNameMarkerRegExp$LWS, [evalOrigin$LWS])) {
              isMarked$LWS = true;
            }
          }
          if (isMarked$LWS) {
            if (!consecutive$LWS) {
              consecutive$LWS = true;
              stackTrace$LWS += "\n    at LWS";
            }
            continue;
          } else {
            consecutive$LWS = false;
          }
          try {
            stackTrace$LWS += `
    at ${ReflectApply$LWS2(CallSiteProtoToString$LWS, callSite$LWS, [])}`;
          } catch (_unused3$LWS) {
          }
        }
        return stackTrace$LWS;
      };
      try {
        ErrorCtor$LWS2.prepareStackTrace = function prepareStackTrace(error, callSites) {
          return formatStackTrace(error, callSites);
        };
      } catch (_unused4$LWS) {
      }
      try {
        const {
          stackTraceLimit: stackTraceLimit$LWS
        } = ErrorCtor$LWS2;
        if (typeof stackTraceLimit$LWS !== "number" || stackTraceLimit$LWS < LOCKER_STACK_TRACE_LIMIT$LWS) {
          ErrorCtor$LWS2.stackTraceLimit = LOCKER_STACK_TRACE_LIMIT$LWS;
        }
      } catch (_unused5$LWS) {
      }
    } : noop$LWS2;
    function noop$LWS2() {
    }
    const serializeBigIntObject$LWS = IS_IN_SHADOW_REALM$LWS ? (bigIntObject$LWS) => ReflectApply$LWS2(BigIntProtoValueOf$LWS2, bigIntObject$LWS, []) : noop$LWS2;
    const serializeBooleanObject$LWS = IS_IN_SHADOW_REALM$LWS ? (booleanObject$LWS) => ReflectApply$LWS2(BooleanProtoValueOf$LWS2, booleanObject$LWS, []) : noop$LWS2;
    const serializeNumberObject$LWS = IS_IN_SHADOW_REALM$LWS ? (numberObject$LWS) => ReflectApply$LWS2(NumberProtoValueOf$LWS2, numberObject$LWS, []) : noop$LWS2;
    const serializeRegExp$LWS = IS_IN_SHADOW_REALM$LWS ? (__value$LWS) => {
      if (__value$LWS !== RegExpProto$LWS2) {
        const source$LWS = ReflectApply$LWS2(RegExpProtoSourceGetter$LWS2, __value$LWS, []);
        return JSONStringify$LWS2({
          __proto__: null,
          flags: ReflectApply$LWS2(RegExpProtoFlagsGetter$LWS, __value$LWS, []),
          source: source$LWS
        });
      }
      return void 0;
    } : noop$LWS2;
    const serializeStringObject$LWS = IS_IN_SHADOW_REALM$LWS ? (stringObject$LWS) => ReflectApply$LWS2(StringProtoValueOf$LWS2, stringObject$LWS, []) : noop$LWS2;
    const serializeSymbolObject$LWS = IS_IN_SHADOW_REALM$LWS ? (symbolObject$LWS) => ReflectApply$LWS2(SymbolProtoValueOf$LWS2, symbolObject$LWS, []) : noop$LWS2;
    const serializeTargetByBrand$LWS = IS_IN_SHADOW_REALM$LWS ? (__target$LWS) => {
      const brand$LWS = ReflectApply$LWS2(ObjectProtoToString$LWS2, __target$LWS, []);
      switch (brand$LWS) {
        case "[object Boolean]":
          return serializeBooleanObject$LWS(__target$LWS);
        case "[object Number]":
          return serializeNumberObject$LWS(__target$LWS);
        case "[object RegExp]":
          return serializeRegExp$LWS(__target$LWS);
        case "[object String]":
          return serializeStringObject$LWS(__target$LWS);
        case "[object Object]":
          try {
            return serializeSymbolObject$LWS(__target$LWS);
          } catch (_unused6$LWS) {
          }
          if (SUPPORTS_BIG_INT$LWS2) {
            try {
              return serializeBigIntObject$LWS(__target$LWS);
            } catch (_unused7$LWS) {
            }
          }
        default:
          return void 0;
      }
    } : noop$LWS2;
    const serializeTargetByTrialAndError$LWS = IS_IN_SHADOW_REALM$LWS ? (__target$LWS) => {
      try {
        return serializeSymbolObject$LWS(__target$LWS);
      } catch (_unused8$LWS) {
      }
      if (SUPPORTS_BIG_INT$LWS2) {
        try {
          return serializeBigIntObject$LWS(__target$LWS);
        } catch (_unused9$LWS) {
        }
      }
      try {
        return serializeBooleanObject$LWS(__target$LWS);
      } catch (_unused10$LWS) {
      }
      try {
        return serializeNumberObject$LWS(__target$LWS);
      } catch (_unused11$LWS) {
      }
      try {
        return serializeRegExp$LWS(__target$LWS);
      } catch (_unused12$LWS) {
      }
      try {
        return serializeStringObject$LWS(__target$LWS);
      } catch (_unused13$LWS) {
      }
      return void 0;
    } : noop$LWS2;
    function toSafeTemplateStringValue$LWS2(__value$LWS) {
      if (typeof __value$LWS === "string") {
        return __value$LWS;
      }
      try {
        if (typeof __value$LWS === "object" && __value$LWS !== null) {
          const _result$LWS = ReflectApply$LWS2(ObjectProtoToString$LWS2, __value$LWS, []);
          return _result$LWS === "[object Symbol]" ? ReflectApply$LWS2(SymbolProtoToString$LWS2, __value$LWS, []) : _result$LWS;
        }
        if (typeof __value$LWS === "function") {
          return ReflectApply$LWS2(FunctionProtoToString$LWS2, __value$LWS, []);
        }
        return StringCtor$LWS2(__value$LWS);
      } catch (_unused14$LWS) {
      }
      return "[Object Unknown]";
    }
    function toSafeWeakMap$LWS2(weakMap$LWS) {
      ReflectSetPrototypeOf$LWS2(weakMap$LWS, null);
      weakMap$LWS.delete = WeakMapProtoDelete$LWS2;
      weakMap$LWS.has = WeakMapProtoHas$LWS2;
      weakMap$LWS.set = WeakMapProtoSet$LWS2;
      weakMap$LWS[SymbolToStringTag$LWS2] = WeakMapProtoSymbolToStringTag$LWS2;
      ReflectSetPrototypeOf$LWS2(weakMap$LWS, WeakMapProto$LWS2);
      return weakMap$LWS;
    }
    function toSafeWeakSet$LWS2(weakSet$LWS) {
      ReflectSetPrototypeOf$LWS2(weakSet$LWS, null);
      weakSet$LWS.add = WeakSetProtoAdd$LWS2;
      weakSet$LWS.delete = WeakSetProtoDelete$LWS2;
      weakSet$LWS.has = WeakSetProtoHas$LWS2;
      weakSet$LWS[SymbolToStringTag$LWS2] = WeakSetProtoSymbolToStringTag$LWS2;
      ReflectSetPrototypeOf$LWS2(weakSet$LWS, WeakSetProto$LWS2);
      return weakSet$LWS;
    }
    return function createHooksCallback$LWS(color$LWS, foreignCallableHooksCallback$LWS, _options$LWS) {
      if (IS_IN_SHADOW_REALM$LWS) {
        _options$LWS = void 0;
      }
      const {
        distortionCallback: distortionCallback$LWS,
        instrumentation: instrumentation$LWS,
        liveTargetCallback: liveTargetCallback$LWS,
        revokedProxyCallback: revokedProxyCallback$LWS2
      } = ObjectAssign$LWS2({
        __proto__: null
      }, _options$LWS);
      const LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS = IS_NOT_IN_SHADOW_REALM$LWS && typeof instrumentation$LWS === "object" && instrumentation$LWS !== null;
      const applyTrapNameRegistry$LWS = {
        __proto__: null,
        0: void 0,
        1: void 0,
        2: void 0,
        3: void 0,
        4: void 0,
        n: void 0
      };
      const constructTrapNameRegistry$LWS = {
        __proto__: null,
        0: void 0,
        1: void 0,
        2: void 0,
        3: void 0,
        4: void 0,
        n: void 0
      };
      const lazyPropertyDescriptorStateCache$LWS = toSafeWeakMap$LWS2(new WeakMapCtor$LWS2());
      const proxyPointerCache$LWS = toSafeWeakMap$LWS2(new WeakMapCtor$LWS2());
      const startActivity$LWS = LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS.startActivity : void 0;
      let foreignCallablePushErrorTarget$LWS;
      let foreignCallablePushTarget$LWS;
      let foreignCallableApply$LWS;
      let foreignCallableConstruct$LWS;
      let foreignCallableDefineProperty$LWS;
      let foreignCallableDeleteProperty$LWS;
      let foreignCallableGet$LWS;
      let foreignCallableGetOwnPropertyDescriptor$LWS;
      let foreignCallableGetPrototypeOf$LWS;
      let foreignCallableHas$LWS;
      let foreignCallableIsExtensible$LWS;
      let foreignCallableOwnKeys$LWS;
      let foreignCallablePreventExtensions$LWS;
      let foreignCallableSet$LWS;
      let foreignCallableSetPrototypeOf$LWS;
      let foreignCallableDebugInfo$LWS;
      let foreignCallableGetPropertyValue$LWS;
      let foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS;
      let foreignCallableGetTargetIntegrityTraits$LWS;
      let foreignCallableGetToStringTagOfTarget$LWS;
      let foreignCallableInstallErrorPrepareStackTrace$LWS;
      let foreignCallableIsTargetLive$LWS;
      let foreignCallableIsTargetRevoked$LWS;
      let foreignCallableSerializeTarget$LWS;
      let foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS;
      let foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS;
      let foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS;
      let foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS;
      let fastForeignTargetPointers$LWS;
      let foreignPointerBigInt64ArrayProto$LWS;
      let foreignPointerBigUint64ArrayProto$LWS;
      let foreignPointerFloat32ArrayProto$LWS;
      let foreignPointerFloat64ArrayProto$LWS;
      let foreignPointerInt8ArrayProto$LWS;
      let foreignPointerInt16ArrayProto$LWS;
      let foreignPointerInt32ArrayProto$LWS;
      let foreignPointerObjectProto$LWS;
      let foreignPointerTypedArrayProto$LWS;
      let foreignPointerUint8ArrayProto$LWS;
      let foreignPointerUint16ArrayProto$LWS;
      let foreignPointerUint32ArrayProto$LWS;
      let selectedTarget$LWS;
      let lastProxyTrapCalled$LWS = 0;
      let handshakePropertyFlag$LWS = false;
      let useFastForeignTargetPath$LWS = IS_IN_SHADOW_REALM$LWS;
      let useFastForeignTargetPathForTypedArrays$LWS = IS_IN_SHADOW_REALM$LWS;
      const activateLazyOwnPropertyDefinition$LWS = IS_IN_SHADOW_REALM$LWS ? (__target$LWS, __key$LWS, _state$LWS) => {
        _state$LWS[__key$LWS] = false;
        const foreignTargetPointer$LWS = getTransferablePointer$LWS(__target$LWS);
        let _safeDesc$LWS;
        try {
          foreignCallableGetOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, __key$LWS, (__key$LWS2, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
            _safeDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
          });
        } catch (error) {
          var _selectedTarget$LWS;
          const errorToThrow$LWS = (_selectedTarget$LWS = selectedTarget$LWS) != null ? _selectedTarget$LWS : error;
          selectedTarget$LWS = void 0;
          throw errorToThrow$LWS;
        }
        if (_safeDesc$LWS) {
          ReflectDefineProperty$LWS2(__target$LWS, __key$LWS, _safeDesc$LWS);
        } else {
          ReflectDeleteProperty$LWS2(__target$LWS, __key$LWS);
        }
      } : noop$LWS2;
      let checkDebugMode$LWS = LOCKER_DEBUGGABLE_FLAG$LWS ? () => {
        try {
          if (ObjectHasOwn$LWS2(globalThisRef$LWS, LOCKER_DEBUG_MODE_SYMBOL$LWS)) {
            checkDebugMode$LWS = () => true;
            installErrorPrepareStackTrace$LWS();
            foreignCallableInstallErrorPrepareStackTrace$LWS();
          }
        } catch (_unused15$LWS) {
          checkDebugMode$LWS = alwaysFalse$LWS;
        }
        return false;
      } : alwaysFalse$LWS;
      const clearFastForeignTargetPointers$LWS = IS_IN_SHADOW_REALM$LWS ? () => {
        fastForeignTargetPointers$LWS = toSafeWeakSet$LWS2(new WeakSetCtor$LWS2());
      } : noop$LWS2;
      function copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS) {
        let activity$LWS;
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS("copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget");
        }
        let protoPointerOrNull$LWS;
        try {
          protoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS(foreignTargetPointer$LWS, (...descriptorTuples$LWS) => {
            const descriptors$LWS = {};
            for (let _i$LWS = 0, {
              length: _length$LWS
            } = descriptorTuples$LWS; _i$LWS < _length$LWS; _i$LWS += 7) {
              const __key$LWS = descriptorTuples$LWS[_i$LWS];
              descriptors$LWS[__key$LWS] = createDescriptorFromMeta$LWS(descriptorTuples$LWS[_i$LWS + 1], descriptorTuples$LWS[_i$LWS + 2], descriptorTuples$LWS[_i$LWS + 3], descriptorTuples$LWS[_i$LWS + 4], descriptorTuples$LWS[_i$LWS + 5], descriptorTuples$LWS[_i$LWS + 6]);
            }
            ObjectDefineProperties$LWS2(shadowTarget$LWS, descriptors$LWS);
          });
        } catch (error) {
          var _selectedTarget2$LWS;
          const errorToThrow$LWS = (_selectedTarget2$LWS = selectedTarget$LWS) != null ? _selectedTarget2$LWS : error;
          selectedTarget$LWS = void 0;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }
          throw errorToThrow$LWS;
        }
        let _proto$LWS;
        if (typeof protoPointerOrNull$LWS === "function") {
          protoPointerOrNull$LWS();
          _proto$LWS = selectedTarget$LWS;
          selectedTarget$LWS = void 0;
        } else {
          _proto$LWS = null;
        }
        ReflectSetPrototypeOf$LWS2(shadowTarget$LWS, _proto$LWS);
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }
      }
      function createApplyOrConstructTrapForZeroOrMoreArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1;
        const activityName$LWS = `Reflect.${isApplyTrap$LWS ? "apply" : "construct"}()`;
        const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrap$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: _length$LWS
          } = _args$LWS;
          if (_length$LWS !== 0) {
            var _arityToApplyOrConstr$LWS;
            return this[(_arityToApplyOrConstr$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
          }
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS(activityName$LWS);
          }
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let pointerOrPrimitive$LWS;
          try {
            pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, typeof thisArgOrNewTarget$LWS === "object" && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === "function" ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : typeof thisArgOrNewTarget$LWS === "undefined" ? void 0 : thisArgOrNewTarget$LWS);
          } catch (error) {
            var _selectedTarget3$LWS;
            const errorToThrow$LWS = (_selectedTarget3$LWS = selectedTarget$LWS) != null ? _selectedTarget3$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          let _result$LWS;
          if (typeof pointerOrPrimitive$LWS === "function") {
            pointerOrPrimitive$LWS();
            _result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _result$LWS = pointerOrPrimitive$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return _result$LWS;
        };
      }
      function createApplyOrConstructTrapForOneOrMoreArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1;
        const activityName$LWS = `Reflect.${isApplyTrap$LWS ? "apply" : "construct"}(1)`;
        const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrapForOneOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: _length$LWS
          } = _args$LWS;
          if (_length$LWS !== 1) {
            var _arityToApplyOrConstr2$LWS;
            return this[(_arityToApplyOrConstr2$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr2$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
          }
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS(activityName$LWS);
          }
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let pointerOrPrimitive$LWS;
          try {
            const {
              0: arg0$LWS
            } = _args$LWS;
            pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, typeof thisArgOrNewTarget$LWS === "object" && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === "function" ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : typeof thisArgOrNewTarget$LWS === "undefined" ? void 0 : thisArgOrNewTarget$LWS, typeof arg0$LWS === "object" && arg0$LWS !== null || typeof arg0$LWS === "function" ? getTransferablePointer$LWS(arg0$LWS) : typeof arg0$LWS === "undefined" ? void 0 : arg0$LWS);
          } catch (error) {
            var _selectedTarget4$LWS;
            const errorToThrow$LWS = (_selectedTarget4$LWS = selectedTarget$LWS) != null ? _selectedTarget4$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          let _result$LWS;
          if (typeof pointerOrPrimitive$LWS === "function") {
            pointerOrPrimitive$LWS();
            _result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _result$LWS = pointerOrPrimitive$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return _result$LWS;
        };
      }
      function createApplyOrConstructTrapForTwoOrMoreArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1;
        const activityName$LWS = `Reflect.${isApplyTrap$LWS ? "apply" : "construct"}(2)`;
        const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrapForTwoOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: _length$LWS
          } = _args$LWS;
          if (_length$LWS !== 2) {
            var _arityToApplyOrConstr3$LWS;
            return this[(_arityToApplyOrConstr3$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr3$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
          }
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS(activityName$LWS);
          }
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let pointerOrPrimitive$LWS;
          try {
            const {
              0: arg0$LWS,
              1: arg1$LWS
            } = _args$LWS;
            pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, typeof thisArgOrNewTarget$LWS === "object" && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === "function" ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : typeof thisArgOrNewTarget$LWS === "undefined" ? void 0 : thisArgOrNewTarget$LWS, typeof arg0$LWS === "object" && arg0$LWS !== null || typeof arg0$LWS === "function" ? getTransferablePointer$LWS(arg0$LWS) : typeof arg0$LWS === "undefined" ? void 0 : arg0$LWS, typeof arg1$LWS === "object" && arg1$LWS !== null || typeof arg1$LWS === "function" ? getTransferablePointer$LWS(arg1$LWS) : typeof arg1$LWS === "undefined" ? void 0 : arg1$LWS);
          } catch (error) {
            var _selectedTarget5$LWS;
            const errorToThrow$LWS = (_selectedTarget5$LWS = selectedTarget$LWS) != null ? _selectedTarget5$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          let _result$LWS;
          if (typeof pointerOrPrimitive$LWS === "function") {
            pointerOrPrimitive$LWS();
            _result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _result$LWS = pointerOrPrimitive$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return _result$LWS;
        };
      }
      function createApplyOrConstructTrapForThreeOrMoreArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1;
        const activityName$LWS = `Reflect.${isApplyTrap$LWS ? "apply" : "construct"}(3)`;
        const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrapForTwoOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: _length$LWS
          } = _args$LWS;
          if (_length$LWS !== 3) {
            var _arityToApplyOrConstr4$LWS;
            return this[(_arityToApplyOrConstr4$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr4$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
          }
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS(activityName$LWS);
          }
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let pointerOrPrimitive$LWS;
          try {
            const {
              0: arg0$LWS,
              1: arg1$LWS,
              2: arg2$LWS
            } = _args$LWS;
            pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, typeof thisArgOrNewTarget$LWS === "object" && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === "function" ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : typeof thisArgOrNewTarget$LWS === "undefined" ? void 0 : thisArgOrNewTarget$LWS, typeof arg0$LWS === "object" && arg0$LWS !== null || typeof arg0$LWS === "function" ? getTransferablePointer$LWS(arg0$LWS) : typeof arg0$LWS === "undefined" ? void 0 : arg0$LWS, typeof arg1$LWS === "object" && arg1$LWS !== null || typeof arg1$LWS === "function" ? getTransferablePointer$LWS(arg1$LWS) : typeof arg1$LWS === "undefined" ? void 0 : arg1$LWS, typeof arg2$LWS === "object" && arg2$LWS !== null || typeof arg2$LWS === "function" ? getTransferablePointer$LWS(arg2$LWS) : typeof arg2$LWS === "undefined" ? void 0 : arg2$LWS);
          } catch (error) {
            var _selectedTarget6$LWS;
            const errorToThrow$LWS = (_selectedTarget6$LWS = selectedTarget$LWS) != null ? _selectedTarget6$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          let _result$LWS;
          if (typeof pointerOrPrimitive$LWS === "function") {
            pointerOrPrimitive$LWS();
            _result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _result$LWS = pointerOrPrimitive$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return _result$LWS;
        };
      }
      function createApplyOrConstructTrapForFourOrMoreArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1;
        const activityName$LWS = `Reflect.${isApplyTrap$LWS ? "apply" : "construct"}(4)`;
        const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrapForTwoOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: _length$LWS
          } = _args$LWS;
          if (_length$LWS !== 4) {
            var _arityToApplyOrConstr5$LWS;
            return this[(_arityToApplyOrConstr5$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr5$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
          }
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS(activityName$LWS);
          }
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let pointerOrPrimitive$LWS;
          try {
            const {
              0: arg0$LWS,
              1: arg1$LWS,
              2: arg2$LWS,
              3: arg3$LWS
            } = _args$LWS;
            pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, typeof thisArgOrNewTarget$LWS === "object" && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === "function" ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : typeof thisArgOrNewTarget$LWS === "undefined" ? void 0 : thisArgOrNewTarget$LWS, typeof arg0$LWS === "object" && arg0$LWS !== null || typeof arg0$LWS === "function" ? getTransferablePointer$LWS(arg0$LWS) : typeof arg0$LWS === "undefined" ? void 0 : arg0$LWS, typeof arg1$LWS === "object" && arg1$LWS !== null || typeof arg1$LWS === "function" ? getTransferablePointer$LWS(arg1$LWS) : typeof arg1$LWS === "undefined" ? void 0 : arg1$LWS, typeof arg2$LWS === "object" && arg2$LWS !== null || typeof arg2$LWS === "function" ? getTransferablePointer$LWS(arg2$LWS) : typeof arg2$LWS === "undefined" ? void 0 : arg2$LWS, typeof arg3$LWS === "object" && arg3$LWS !== null || typeof arg3$LWS === "function" ? getTransferablePointer$LWS(arg3$LWS) : typeof arg3$LWS === "undefined" ? void 0 : arg3$LWS);
          } catch (error) {
            var _selectedTarget7$LWS;
            const errorToThrow$LWS = (_selectedTarget7$LWS = selectedTarget$LWS) != null ? _selectedTarget7$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          let _result$LWS;
          if (typeof pointerOrPrimitive$LWS === "function") {
            pointerOrPrimitive$LWS();
            _result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _result$LWS = pointerOrPrimitive$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return _result$LWS;
        };
      }
      function createApplyOrConstructTrapForFiveOrMoreArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1;
        const activityName$LWS = `Reflect.${isApplyTrap$LWS ? "apply" : "construct"}(5)`;
        const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrapForTwoOrMoreArgs$LWS(shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: _length$LWS
          } = _args$LWS;
          if (_length$LWS !== 5) {
            var _arityToApplyOrConstr6$LWS;
            return this[(_arityToApplyOrConstr6$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[_length$LWS]) != null ? _arityToApplyOrConstr6$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
          }
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS(activityName$LWS);
          }
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let pointerOrPrimitive$LWS;
          try {
            const {
              0: arg0$LWS,
              1: arg1$LWS,
              2: arg2$LWS,
              3: arg3$LWS,
              4: arg4$LWS
            } = _args$LWS;
            pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS, typeof thisArgOrNewTarget$LWS === "object" && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === "function" ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : typeof thisArgOrNewTarget$LWS === "undefined" ? void 0 : thisArgOrNewTarget$LWS, typeof arg0$LWS === "object" && arg0$LWS !== null || typeof arg0$LWS === "function" ? getTransferablePointer$LWS(arg0$LWS) : typeof arg0$LWS === "undefined" ? void 0 : arg0$LWS, typeof arg1$LWS === "object" && arg1$LWS !== null || typeof arg1$LWS === "function" ? getTransferablePointer$LWS(arg1$LWS) : typeof arg1$LWS === "undefined" ? void 0 : arg1$LWS, typeof arg2$LWS === "object" && arg2$LWS !== null || typeof arg2$LWS === "function" ? getTransferablePointer$LWS(arg2$LWS) : typeof arg2$LWS === "undefined" ? void 0 : arg2$LWS, typeof arg3$LWS === "object" && arg3$LWS !== null || typeof arg3$LWS === "function" ? getTransferablePointer$LWS(arg3$LWS) : typeof arg3$LWS === "undefined" ? void 0 : arg3$LWS, typeof arg4$LWS === "object" && arg4$LWS !== null || typeof arg4$LWS === "function" ? getTransferablePointer$LWS(arg4$LWS) : typeof arg4$LWS === "undefined" ? void 0 : arg4$LWS);
          } catch (error) {
            var _selectedTarget8$LWS;
            const errorToThrow$LWS = (_selectedTarget8$LWS = selectedTarget$LWS) != null ? _selectedTarget8$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          let _result$LWS;
          if (typeof pointerOrPrimitive$LWS === "function") {
            pointerOrPrimitive$LWS();
            _result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _result$LWS = pointerOrPrimitive$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return _result$LWS;
        };
      }
      function createApplyOrConstructTrapForAnyNumberOfArgs$LWS(proxyTrapEnum$LWS) {
        const isApplyTrap$LWS = proxyTrapEnum$LWS & 1;
        const nativeMethodName$LWS = isApplyTrap$LWS ? "apply" : "construct";
        const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
        return function applyOrConstructTrapForAnyNumberOfArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
          lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const _args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
          const {
            length: _length$LWS
          } = _args$LWS;
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS(`Reflect.${nativeMethodName$LWS}(${_length$LWS})`);
          }
          const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
          let combinedOffset$LWS = 2;
          const combinedArgs$LWS = new ArrayCtor$LWS2(_length$LWS + combinedOffset$LWS);
          combinedArgs$LWS[0] = foreignTargetPointer$LWS;
          let pointerOrPrimitive$LWS;
          try {
            combinedArgs$LWS[1] = typeof thisArgOrNewTarget$LWS === "object" && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === "function" ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) : typeof thisArgOrNewTarget$LWS === "undefined" ? void 0 : thisArgOrNewTarget$LWS;
            for (let _i$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1) {
              const arg$LWS = _args$LWS[_i$LWS];
              combinedArgs$LWS[combinedOffset$LWS++] = typeof arg$LWS === "object" && arg$LWS !== null || typeof arg$LWS === "function" ? getTransferablePointer$LWS(arg$LWS) : typeof arg$LWS === "undefined" ? void 0 : arg$LWS;
            }
            pointerOrPrimitive$LWS = ReflectApply$LWS2(foreignCallableApplyOrConstruct$LWS, void 0, combinedArgs$LWS);
          } catch (error) {
            var _selectedTarget9$LWS;
            const errorToThrow$LWS = (_selectedTarget9$LWS = selectedTarget$LWS) != null ? _selectedTarget9$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          let _result$LWS;
          if (typeof pointerOrPrimitive$LWS === "function") {
            pointerOrPrimitive$LWS();
            _result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _result$LWS = pointerOrPrimitive$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return _result$LWS;
        };
      }
      function createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointerOrPrimitive$LWS, getterPointerOrPrimitive$LWS, setterPointerOrPrimitive$LWS) {
        const _safeDesc$LWS = {
          __proto__: null
        };
        if (configurable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
          _safeDesc$LWS.configurable = configurable$LWS;
        }
        if (enumerable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
          _safeDesc$LWS.enumerable = enumerable$LWS;
        }
        if (writable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
          _safeDesc$LWS.writable = writable$LWS;
        }
        if (getterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
          if (typeof getterPointerOrPrimitive$LWS === "function") {
            getterPointerOrPrimitive$LWS();
            _safeDesc$LWS.get = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _safeDesc$LWS.get = void 0;
          }
        }
        if (setterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
          if (typeof setterPointerOrPrimitive$LWS === "function") {
            setterPointerOrPrimitive$LWS();
            _safeDesc$LWS.set = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _safeDesc$LWS.set = void 0;
          }
        }
        if (valuePointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
          if (typeof valuePointerOrPrimitive$LWS === "function") {
            valuePointerOrPrimitive$LWS();
            _safeDesc$LWS.value = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _safeDesc$LWS.value = valuePointerOrPrimitive$LWS;
          }
        }
        return _safeDesc$LWS;
      }
      function createPointer$LWS(originalTarget$LWS) {
        const pointer$LWS = () => {
          selectedTarget$LWS = originalTarget$LWS;
        };
        return pointer$LWS;
      }
      const disableFastForeignTargetPointers$LWS = IS_IN_SHADOW_REALM$LWS ? () => {
        useFastForeignTargetPath$LWS = false;
        useFastForeignTargetPathForTypedArrays$LWS = false;
        clearFastForeignTargetPointers$LWS();
      } : noop$LWS2;
      const getLazyPropertyDescriptorStateByTarget$LWS = IS_IN_SHADOW_REALM$LWS ? (__target$LWS) => {
        let _state$LWS = lazyPropertyDescriptorStateCache$LWS.get(__target$LWS);
        if (_state$LWS === void 0) {
          const statePointerOrUndefined$LWS = foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS(getTransferablePointer$LWS(__target$LWS));
          if (typeof statePointerOrUndefined$LWS === "function") {
            statePointerOrUndefined$LWS();
            _state$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
            if (_state$LWS) {
              lazyPropertyDescriptorStateCache$LWS.set(__target$LWS, _state$LWS);
            }
          }
        }
        return _state$LWS;
      } : noop$LWS2;
      const isForeignPointerOfObjectProto$LWS = IS_IN_SHADOW_REALM$LWS ? (foreignTargetPointer$LWS) => foreignTargetPointer$LWS === (foreignPointerObjectProto$LWS === void 0 ? foreignPointerObjectProto$LWS = getTransferablePointer$LWS(ObjectProto$LWS2) : foreignPointerObjectProto$LWS) : alwaysFalse$LWS;
      const isForeignPointerOfTypedArrayProto$LWS = IS_IN_SHADOW_REALM$LWS ? (foreignTargetPointer$LWS) => foreignTargetPointer$LWS === (foreignPointerFloat32ArrayProto$LWS === void 0 ? foreignPointerFloat32ArrayProto$LWS = getTransferablePointer$LWS(Float32ArrayProto$LWS) : foreignPointerFloat32ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerFloat64ArrayProto$LWS === void 0 ? foreignPointerFloat64ArrayProto$LWS = getTransferablePointer$LWS(Float64ArrayProto$LWS) : foreignPointerFloat64ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerInt8ArrayProto$LWS === void 0 ? foreignPointerInt8ArrayProto$LWS = getTransferablePointer$LWS(Int8ArrayProto$LWS) : foreignPointerInt8ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerInt16ArrayProto$LWS === void 0 ? foreignPointerInt16ArrayProto$LWS = getTransferablePointer$LWS(Int16ArrayProto$LWS) : foreignPointerInt16ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerInt32ArrayProto$LWS === void 0 ? foreignPointerInt32ArrayProto$LWS = getTransferablePointer$LWS(Int32ArrayProto$LWS) : foreignPointerInt32ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerUint8ArrayProto$LWS === void 0 ? foreignPointerUint8ArrayProto$LWS = getTransferablePointer$LWS(Uint8ArrayProto$LWS) : foreignPointerUint8ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerUint16ArrayProto$LWS === void 0 ? foreignPointerUint16ArrayProto$LWS = getTransferablePointer$LWS(Uint16ArrayProto$LWS) : foreignPointerUint16ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerUint32ArrayProto$LWS === void 0 ? foreignPointerUint32ArrayProto$LWS = getTransferablePointer$LWS(Uint32ArrayProto$LWS) : foreignPointerUint32ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerTypedArrayProto$LWS === void 0 ? foreignPointerTypedArrayProto$LWS = getTransferablePointer$LWS(TypedArrayProto$LWS) : foreignPointerTypedArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerBigInt64ArrayProto$LWS === void 0 ? foreignPointerBigInt64ArrayProto$LWS = BigInt64ArrayProto$LWS ? getTransferablePointer$LWS(BigInt64ArrayProto$LWS) : noop$LWS2 : foreignPointerBigInt64ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerBigUint64ArrayProto$LWS === void 0 ? foreignPointerBigUint64ArrayProto$LWS = BigUint64ArrayProto$LWS ? getTransferablePointer$LWS(BigUint64ArrayProto$LWS) : noop$LWS2 : foreignPointerBigUint64ArrayProto$LWS) : alwaysFalse$LWS;
      function getTransferablePointer$LWS(originalTarget$LWS, foreignCallablePusher$LWS = foreignCallablePushTarget$LWS) {
        let proxyPointer$LWS = proxyPointerCache$LWS.get(originalTarget$LWS);
        if (proxyPointer$LWS) {
          return proxyPointer$LWS;
        }
        let targetFunctionArity$LWS = 0;
        let targetFunctionName$LWS = "";
        let targetTypedArrayLength$LWS = 0;
        if (revokedProxyCallback$LWS2 && revokedProxyCallback$LWS2(originalTarget$LWS)) {
          proxyPointer$LWS = foreignCallablePusher$LWS(createPointer$LWS(originalTarget$LWS), 64, targetFunctionArity$LWS, targetFunctionName$LWS, targetTypedArrayLength$LWS);
          proxyPointerCache$LWS.set(originalTarget$LWS, proxyPointer$LWS);
          return proxyPointer$LWS;
        }
        let distortionTarget$LWS;
        let targetTraits$LWS = 16;
        if (distortionCallback$LWS) {
          distortionTarget$LWS = distortionCallback$LWS(originalTarget$LWS);
          if (distortionTarget$LWS !== originalTarget$LWS && typeof distortionTarget$LWS !== typeof originalTarget$LWS) {
            throw new TypeErrorCtor$LWS2(`Invalid distortion ${toSafeTemplateStringValue$LWS2(originalTarget$LWS)}.`);
          }
        } else {
          distortionTarget$LWS = originalTarget$LWS;
        }
        let isPossiblyRevoked$LWS = true;
        if (typeof distortionTarget$LWS === "function") {
          isPossiblyRevoked$LWS = false;
          targetFunctionArity$LWS = 0;
          targetTraits$LWS = 4;
          try {
            if (!("prototype" in distortionTarget$LWS)) {
              targetTraits$LWS |= 8;
            }
            const safeLengthDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS2(originalTarget$LWS, "length");
            if (safeLengthDesc$LWS) {
              ReflectSetPrototypeOf$LWS2(safeLengthDesc$LWS, null);
              const {
                value: safeLengthDescValue$LWS
              } = safeLengthDesc$LWS;
              if (typeof safeLengthDescValue$LWS === "number") {
                targetFunctionArity$LWS = safeLengthDescValue$LWS;
              }
            }
            const safeNameDesc$LWS = false ? ReflectGetOwnPropertyDescriptor$LWS2(originalTarget$LWS, "name") : void 0;
            if (safeNameDesc$LWS)
              ;
          } catch (_unused16$LWS) {
            isPossiblyRevoked$LWS = true;
          }
        } else if (ArrayBufferIsView$LWS2(distortionTarget$LWS)) {
          isPossiblyRevoked$LWS = false;
          targetTraits$LWS = 2;
          try {
            targetTypedArrayLength$LWS = ReflectApply$LWS2(TypedArrayProtoLengthGetter$LWS, distortionTarget$LWS, []);
            targetTraits$LWS |= 32;
          } catch (_unused17$LWS) {
            isPossiblyRevoked$LWS = true;
          }
        }
        if (isPossiblyRevoked$LWS) {
          try {
            if (isArrayOrThrowForRevoked$LWS(distortionTarget$LWS)) {
              targetTraits$LWS = 1;
            }
          } catch (_unused18$LWS) {
            targetTraits$LWS = 64;
          }
        }
        proxyPointer$LWS = foreignCallablePusher$LWS(createPointer$LWS(distortionTarget$LWS), targetTraits$LWS, targetFunctionArity$LWS, targetFunctionName$LWS, targetTypedArrayLength$LWS);
        proxyPointerCache$LWS.set(originalTarget$LWS, proxyPointer$LWS);
        return proxyPointer$LWS;
      }
      const installPropertyDescriptorMethodWrappers$LWS = IS_IN_SHADOW_REALM$LWS ? (unforgeableGlobalThisKeys$LWS) => {
        if (installedPropertyDescriptorMethodWrappersFlag$LWS) {
          return;
        }
        installedPropertyDescriptorMethodWrappersFlag$LWS = true;
        const shouldFixChromeBug$LWS = isArrayOrThrowForRevoked$LWS(unforgeableGlobalThisKeys$LWS) && unforgeableGlobalThisKeys$LWS.length > 0;
        const keyToGlobalThisGetterRegistry$LWS = shouldFixChromeBug$LWS ? {
          __proto__: null
        } : void 0;
        const getFixedDescriptor$LWS = shouldFixChromeBug$LWS ? (__target$LWS, __key$LWS) => ReflectApply$LWS2(ArrayProtoIncludes$LWS2, unforgeableGlobalThisKeys$LWS, [__key$LWS]) ? {
          configurable: false,
          enumerable: ReflectApply$LWS2(ObjectProtoPropertyIsEnumerable$LWS, __target$LWS, [__key$LWS]),
          get: getUnforgeableGlobalThisGetter$LWS(__key$LWS),
          set: void 0
        } : ReflectGetOwnPropertyDescriptor$LWS2(__target$LWS, __key$LWS) : void 0;
        const getUnforgeableGlobalThisGetter$LWS = shouldFixChromeBug$LWS ? (__key$LWS) => {
          let globalThisGetter$LWS = keyToGlobalThisGetterRegistry$LWS[__key$LWS];
          if (globalThisGetter$LWS === void 0) {
            globalThisGetter$LWS = ReflectApply$LWS2(FunctionProtoBind$LWS2, unboundGlobalThisGetter$LWS, []);
            keyToGlobalThisGetterRegistry$LWS[__key$LWS] = globalThisGetter$LWS;
          }
          return globalThisGetter$LWS;
        } : void 0;
        const lookupFixedGetter$LWS = shouldFixChromeBug$LWS ? (__target$LWS, __key$LWS) => ReflectApply$LWS2(ArrayProtoIncludes$LWS2, unforgeableGlobalThisKeys$LWS, [__key$LWS]) ? getUnforgeableGlobalThisGetter$LWS(__key$LWS) : ReflectApply$LWS2(ObjectProtoLookupGetter$LWS2, __target$LWS, [__key$LWS]) : void 0;
        const lookupFixedSetter$LWS = shouldFixChromeBug$LWS ? (__target$LWS, __key$LWS) => ReflectApply$LWS2(ArrayProtoIncludes$LWS2, unforgeableGlobalThisKeys$LWS, [__key$LWS]) ? void 0 : ReflectApply$LWS2(ObjectProtoLookupSetter$LWS2, __target$LWS, [__key$LWS]) : void 0;
        const unboundGlobalThisGetter$LWS = shouldFixChromeBug$LWS ? () => globalThisRef$LWS : void 0;
        const wrapDefineAccessOrProperty$LWS = (originalFunc$LWS) => {
          const {
            length: originalFuncLength$LWS
          } = originalFunc$LWS;
          const useThisArgAsTarget$LWS = originalFuncLength$LWS === 2;
          return new ProxyCtor$LWS2(originalFunc$LWS, {
            apply(_originalFunc$LWS, thisArg$LWS, _args$LWS) {
              if (_args$LWS.length >= originalFuncLength$LWS) {
                const __target$LWS = useThisArgAsTarget$LWS ? thisArg$LWS : _args$LWS[0];
                if (typeof __target$LWS === "object" && __target$LWS !== null || typeof __target$LWS === "function") {
                  const __key$LWS = useThisArgAsTarget$LWS ? _args$LWS[0] : _args$LWS[1];
                  const _state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(__target$LWS);
                  if (_state$LWS != null && _state$LWS[__key$LWS]) {
                    __target$LWS[__key$LWS];
                  }
                }
              }
              return ReflectApply$LWS2(originalFunc$LWS, thisArg$LWS, _args$LWS);
            }
          });
        };
        const wrapLookupAccessor$LWS = (originalFunc$LWS, lookupFixedAccessor$LWS) => new ProxyCtor$LWS2(originalFunc$LWS, {
          apply(_originalFunc$LWS, thisArg$LWS, _args$LWS) {
            if (_args$LWS.length && (typeof thisArg$LWS === "object" && thisArg$LWS !== null || typeof thisArg$LWS === "function")) {
              const {
                0: __key$LWS
              } = _args$LWS;
              const _state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(thisArg$LWS);
              if (_state$LWS != null && _state$LWS[__key$LWS]) {
                thisArg$LWS[__key$LWS];
              }
              if (shouldFixChromeBug$LWS && thisArg$LWS === globalThisRef$LWS) {
                return lookupFixedAccessor$LWS(thisArg$LWS, __key$LWS);
              }
            }
            return ReflectApply$LWS2(originalFunc$LWS, thisArg$LWS, _args$LWS);
          }
        });
        const wrapGetOwnPropertyDescriptor$LWS = (originalFunc$LWS) => new ProxyCtor$LWS2(originalFunc$LWS, {
          apply(_originalFunc$LWS, thisArg$LWS, _args$LWS) {
            if (_args$LWS.length > 1) {
              const {
                0: __target$LWS,
                1: __key$LWS
              } = _args$LWS;
              if (typeof __target$LWS === "object" && __target$LWS !== null || typeof __target$LWS === "function") {
                const _state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(__target$LWS);
                if (_state$LWS != null && _state$LWS[__key$LWS]) {
                  __target$LWS[__key$LWS];
                }
                if (shouldFixChromeBug$LWS && __target$LWS === globalThisRef$LWS) {
                  return getFixedDescriptor$LWS(__target$LWS, __key$LWS);
                }
              }
            }
            return ReflectApply$LWS2(originalFunc$LWS, thisArg$LWS, _args$LWS);
          }
        });
        const wrapGetOwnPropertyDescriptors$LWS = (originalFunc$LWS) => new ProxyCtor$LWS2(originalFunc$LWS, {
          apply(_originalFunc$LWS, thisArg$LWS, _args$LWS) {
            const __target$LWS = _args$LWS.length ? _args$LWS[0] : void 0;
            if (!(typeof __target$LWS === "object" && __target$LWS !== null || typeof __target$LWS === "function")) {
              return ReflectApply$LWS2(originalFunc$LWS, thisArg$LWS, _args$LWS);
            }
            const _state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(__target$LWS);
            const isFixingChromeBug$LWS = __target$LWS === globalThisRef$LWS && shouldFixChromeBug$LWS;
            const _unsafeDescs$LWS = isFixingChromeBug$LWS ? {} : ReflectApply$LWS2(originalFunc$LWS, thisArg$LWS, _args$LWS);
            if (!isFixingChromeBug$LWS && _state$LWS === void 0) {
              return _unsafeDescs$LWS;
            }
            const ownKeys$LWS = ReflectOwnKeys$LWS2(isFixingChromeBug$LWS ? __target$LWS : _unsafeDescs$LWS);
            for (let _i$LWS = 0, {
              length: _length$LWS
            } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
              const ownKey$LWS = ownKeys$LWS[_i$LWS];
              const isLazyProp$LWS = !!(_state$LWS != null && _state$LWS[ownKey$LWS]);
              if (isLazyProp$LWS) {
                __target$LWS[ownKey$LWS];
              }
              if (isLazyProp$LWS || isFixingChromeBug$LWS) {
                const _unsafeDesc$LWS = isFixingChromeBug$LWS ? getFixedDescriptor$LWS(__target$LWS, ownKey$LWS) : ReflectGetOwnPropertyDescriptor$LWS2(__target$LWS, ownKey$LWS);
                if (_unsafeDesc$LWS) {
                  _unsafeDescs$LWS[ownKey$LWS] = _unsafeDesc$LWS;
                } else if (!isFixingChromeBug$LWS) {
                  ReflectDeleteProperty$LWS2(_unsafeDescs$LWS, ownKey$LWS);
                }
              }
            }
            return _unsafeDescs$LWS;
          }
        });
        try {
          ReflectRef$LWS.defineProperty = wrapDefineAccessOrProperty$LWS(ReflectDefineProperty$LWS2);
        } catch (_unused19$LWS) {
        }
        try {
          ReflectRef$LWS.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor$LWS(ReflectGetOwnPropertyDescriptor$LWS2);
        } catch (_unused20$LWS) {
        }
        try {
          ObjectCtor$LWS2.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor$LWS(ObjectGetOwnPropertyDescriptor$LWS);
        } catch (_unused21$LWS) {
        }
        try {
          ObjectCtor$LWS2.getOwnPropertyDescriptors = wrapGetOwnPropertyDescriptors$LWS(ObjectGetOwnPropertyDescriptors$LWS2);
        } catch (_unused22$LWS) {
        }
        try {
          ObjectProto$LWS2.__defineGetter__ = wrapDefineAccessOrProperty$LWS(ObjectProtoDefineGetter$LWS);
        } catch (_unused23$LWS) {
        }
        try {
          ObjectProto$LWS2.__defineSetter__ = wrapDefineAccessOrProperty$LWS(ObjectProtoDefineSetter$LWS);
        } catch (_unused24$LWS) {
        }
        try {
          ObjectProto$LWS2.__lookupGetter__ = wrapLookupAccessor$LWS(ObjectProtoLookupGetter$LWS2, lookupFixedGetter$LWS);
        } catch (_unused25$LWS) {
        }
        try {
          ObjectProto$LWS2.__lookupSetter__ = wrapLookupAccessor$LWS(ObjectProtoLookupSetter$LWS2, lookupFixedSetter$LWS);
        } catch (_unused26$LWS) {
        }
      } : noop$LWS2;
      function lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS) {
        let activity$LWS;
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS("lookupForeignDescriptor");
        }
        let protoPointerOrNull$LWS;
        let _safeDesc$LWS;
        try {
          protoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, __key$LWS, (__key$LWS2, configurable$LWS, enumerable$LWS, writable$LWS, valuePointerOrPrimitive$LWS, getterPointerOrPrimitive$LWS, setterPointerOrPrimitive$LWS) => {
            _safeDesc$LWS = {
              __proto__: null,
              foreign: true
            };
            if (configurable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
              _safeDesc$LWS.configurable = configurable$LWS;
            }
            if (enumerable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
              _safeDesc$LWS.enumerable = enumerable$LWS;
            }
            if (writable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
              _safeDesc$LWS.writable = writable$LWS;
            }
            if (getterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
              if (typeof getterPointerOrPrimitive$LWS === "function") {
                getterPointerOrPrimitive$LWS();
                _safeDesc$LWS.get = selectedTarget$LWS;
                selectedTarget$LWS = void 0;
              } else {
                _safeDesc$LWS.get = void 0;
              }
            }
            if (setterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
              if (typeof setterPointerOrPrimitive$LWS === "function") {
                setterPointerOrPrimitive$LWS();
                _safeDesc$LWS.set = selectedTarget$LWS;
                selectedTarget$LWS = void 0;
              } else {
                _safeDesc$LWS.set = void 0;
              }
            }
            if (valuePointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
              if (typeof valuePointerOrPrimitive$LWS === "function") {
                valuePointerOrPrimitive$LWS();
                _safeDesc$LWS.value = selectedTarget$LWS;
                selectedTarget$LWS = void 0;
              } else {
                _safeDesc$LWS.value = valuePointerOrPrimitive$LWS;
              }
            }
            if (configurable$LWS === false) {
              ReflectDefineProperty$LWS2(shadowTarget$LWS, __key$LWS2, _safeDesc$LWS);
            }
          });
        } catch (error) {
          var _selectedTarget10$LWS;
          const errorToThrow$LWS = (_selectedTarget10$LWS = selectedTarget$LWS) != null ? _selectedTarget10$LWS : error;
          selectedTarget$LWS = void 0;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }
          throw errorToThrow$LWS;
        }
        if (_safeDesc$LWS === void 0) {
          let currentObject$LWS;
          if (typeof protoPointerOrNull$LWS === "function") {
            protoPointerOrNull$LWS();
            currentObject$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            currentObject$LWS = null;
          }
          while (currentObject$LWS) {
            _safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS2(currentObject$LWS, __key$LWS);
            if (_safeDesc$LWS) {
              ReflectSetPrototypeOf$LWS2(_safeDesc$LWS, null);
              break;
            }
            currentObject$LWS = ReflectGetPrototypeOf$LWS2(currentObject$LWS);
          }
          if (_safeDesc$LWS) {
            var _ref3$LWS;
            const {
              get: _getter$LWS,
              set: _setter$LWS,
              value: localValue$LWS
            } = _safeDesc$LWS;
            const possibleProxy$LWS = (_ref3$LWS = _getter$LWS != null ? _getter$LWS : _setter$LWS) != null ? _ref3$LWS : localValue$LWS;
            _safeDesc$LWS.foreign = (typeof possibleProxy$LWS === "object" && possibleProxy$LWS !== null || typeof possibleProxy$LWS === "function") && proxyPointerCache$LWS.get(possibleProxy$LWS) !== void 0;
          }
        }
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }
        return _safeDesc$LWS;
      }
      function passthruForeignTraversedSet$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS) {
        const _safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS);
        if (_safeDesc$LWS) {
          if ("get" in _safeDesc$LWS || "set" in _safeDesc$LWS) {
            const {
              set: _setter$LWS
            } = _safeDesc$LWS;
            if (_setter$LWS) {
              if (_safeDesc$LWS.foreign) {
                foreignCallableApply$LWS(getTransferablePointer$LWS(_setter$LWS), typeof __receiver$LWS === "object" && __receiver$LWS !== null || typeof __receiver$LWS === "function" ? getTransferablePointer$LWS(__receiver$LWS) : typeof __receiver$LWS === "undefined" ? void 0 : __receiver$LWS, typeof __value$LWS === "object" && __value$LWS !== null || typeof __value$LWS === "function" ? getTransferablePointer$LWS(__value$LWS) : typeof __value$LWS === "undefined" ? void 0 : __value$LWS);
              } else {
                ReflectApply$LWS2(_setter$LWS, __receiver$LWS, [__value$LWS]);
              }
              return true;
            }
            return false;
          }
          if (_safeDesc$LWS.writable === false) {
            return false;
          }
        }
        if (!(typeof __receiver$LWS === "object" && __receiver$LWS !== null || typeof __receiver$LWS === "function")) {
          return false;
        }
        const safeReceiverDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS2(__receiver$LWS, __key$LWS);
        if (safeReceiverDesc$LWS) {
          ReflectSetPrototypeOf$LWS2(safeReceiverDesc$LWS, null);
          if ("get" in safeReceiverDesc$LWS || "set" in safeReceiverDesc$LWS || safeReceiverDesc$LWS.writable === false) {
            return false;
          }
          ReflectDefineProperty$LWS2(__receiver$LWS, __key$LWS, {
            __proto__: null,
            value: __value$LWS
          });
          return true;
        }
        return ReflectDefineProperty$LWS2(__receiver$LWS, __key$LWS, {
          __proto__: null,
          configurable: true,
          enumerable: true,
          value: __value$LWS,
          writable: true
        });
      }
      function pushErrorAcrossBoundary$LWS(error) {
        if (LOCKER_DEBUGGABLE_FLAG$LWS) {
          checkDebugMode$LWS();
        }
        if (typeof error === "object" && error !== null || typeof error === "function") {
          const foreignErrorPointer$LWS = getTransferablePointer$LWS(error, foreignCallablePushErrorTarget$LWS);
          foreignErrorPointer$LWS();
        }
        return error;
      }
      function pushTarget$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) {
        const {
          proxy: _proxy$LWS
        } = new BoundaryProxyHandler$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS);
        proxyPointerCache$LWS.set(_proxy$LWS, foreignTargetPointer$LWS);
        return createPointer$LWS(_proxy$LWS);
      }
      const setLazyPropertyDescriptorStateByTarget$LWS = IS_IN_SHADOW_REALM$LWS ? (__target$LWS, _state$LWS) => {
        lazyPropertyDescriptorStateCache$LWS.set(__target$LWS, _state$LWS);
        foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS(getTransferablePointer$LWS(__target$LWS), getTransferablePointer$LWS(_state$LWS));
      } : noop$LWS2;
      class BoundaryProxyHandler$LWS {
        constructor(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) {
          this.makeProxyLive = IS_IN_SHADOW_REALM$LWS ? function() {
            this.deleteProperty = BoundaryProxyHandler$LWS.passthruDeletePropertyTrap;
            this.defineProperty = BoundaryProxyHandler$LWS.passthruDefinePropertyTrap;
            this.preventExtensions = BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap;
            this.set = BoundaryProxyHandler$LWS.passthruSetTrap;
            this.setPrototypeOf = BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap;
          } : noop$LWS2;
          this.makeProxyStatic = IS_IN_SHADOW_REALM$LWS ? function() {
            this.defineProperty = BoundaryProxyHandler$LWS.staticDefinePropertyTrap;
            this.deleteProperty = BoundaryProxyHandler$LWS.staticDeletePropertyTrap;
            this.get = BoundaryProxyHandler$LWS.staticGetTrap;
            this.getOwnPropertyDescriptor = BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap;
            this.getPrototypeOf = BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap;
            this.has = BoundaryProxyHandler$LWS.staticHasTrap;
            this.isExtensible = BoundaryProxyHandler$LWS.staticIsExtensibleTrap;
            this.ownKeys = BoundaryProxyHandler$LWS.staticOwnKeysTrap;
            this.preventExtensions = BoundaryProxyHandler$LWS.staticPreventExtensionsTrap;
            this.set = BoundaryProxyHandler$LWS.staticSetTrap;
            this.setPrototypeOf = BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap;
            const {
              foreignTargetPointer: foreignTargetPointer$LWS2,
              foreignTargetTraits: foreignTargetTraits$LWS2,
              shadowTarget: shadowTarget$LWS2
            } = this;
            if (useFastForeignTargetPath$LWS) {
              fastForeignTargetPointers$LWS.delete(foreignTargetPointer$LWS2);
            }
            const targetIntegrityTraits$LWS = foreignCallableGetTargetIntegrityTraits$LWS(foreignTargetPointer$LWS2);
            if (targetIntegrityTraits$LWS & 8) {
              this.revoke();
              return;
            }
            try {
              copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS2, shadowTarget$LWS2);
            } catch (_unused27$LWS) {
              if (foreignCallableIsTargetRevoked$LWS(foreignTargetPointer$LWS2)) {
                this.revoke();
                return;
              }
            }
            if (foreignTargetTraits$LWS2 & 16 && !(SymbolToStringTag$LWS2 in shadowTarget$LWS2)) {
              let toStringTag$LWS = "Object";
              try {
                toStringTag$LWS = foreignCallableGetToStringTagOfTarget$LWS(foreignTargetPointer$LWS2);
              } catch (_unused28$LWS) {
              }
              this.staticToStringTag = toStringTag$LWS;
            }
            if (targetIntegrityTraits$LWS & 4) {
              ObjectFreeze$LWS2(shadowTarget$LWS2);
            } else {
              if (targetIntegrityTraits$LWS & 2) {
                ObjectSeal$LWS(shadowTarget$LWS2);
              } else if (targetIntegrityTraits$LWS & 1) {
                ReflectPreventExtensions$LWS2(shadowTarget$LWS2);
              }
              if (LOCKER_UNMINIFIED_FLAG$LWS2) {
                foreignCallableDebugInfo$LWS("Mutations on the membrane of an object originating outside of the sandbox will not be reflected on the object itself:", foreignTargetPointer$LWS2);
              }
            }
          } : noop$LWS2;
          let shadowTarget$LWS;
          const isForeignTargetArray$LWS = foreignTargetTraits$LWS & 1;
          const isForeignTargetFunction$LWS = foreignTargetTraits$LWS & 4;
          if (isForeignTargetFunction$LWS) {
            shadowTarget$LWS = foreignTargetTraits$LWS & 8 ? () => {
            } : function() {
            };
          } else if (isForeignTargetArray$LWS) {
            shadowTarget$LWS = [];
          } else {
            shadowTarget$LWS = {};
          }
          const {
            proxy: _proxy$LWS,
            revoke: revoke$LWS
          } = ProxyRevocable$LWS2(shadowTarget$LWS, this);
          this.foreignTargetPointer = foreignTargetPointer$LWS;
          this.foreignTargetTraits = foreignTargetTraits$LWS;
          this.foreignTargetTypedArrayLength = foreignTargetTypedArrayLength$LWS;
          this.nonConfigurableDescriptorCallback = (__key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
            ReflectDefineProperty$LWS2(this.shadowTarget, __key$LWS, createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS));
          };
          this.proxy = _proxy$LWS;
          this.revoke = revoke$LWS;
          this.serialize = noop$LWS2;
          this.shadowTarget = shadowTarget$LWS;
          this.staticToStringTag = "Object";
          if (isForeignTargetFunction$LWS) {
            var _applyTrapNameRegistr$LWS, _constructTrapNameReg$LWS;
            this.apply = this[(_applyTrapNameRegistr$LWS = applyTrapNameRegistry$LWS[foreignTargetFunctionArity$LWS]) != null ? _applyTrapNameRegistr$LWS : applyTrapNameRegistry$LWS.n];
            this.construct = this[(_constructTrapNameReg$LWS = constructTrapNameRegistry$LWS[foreignTargetFunctionArity$LWS]) != null ? _constructTrapNameReg$LWS : constructTrapNameRegistry$LWS.n];
          }
          this.defineProperty = BoundaryProxyHandler$LWS.defaultDefinePropertyTrap;
          this.deleteProperty = BoundaryProxyHandler$LWS.defaultDeletePropertyTrap;
          this.isExtensible = BoundaryProxyHandler$LWS.defaultIsExtensibleTrap;
          this.getOwnPropertyDescriptor = BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap;
          this.getPrototypeOf = BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap;
          this.get = foreignTargetTraits$LWS & 32 ? BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray : BoundaryProxyHandler$LWS.defaultGetTrap;
          this.has = BoundaryProxyHandler$LWS.defaultHasTrap;
          this.ownKeys = BoundaryProxyHandler$LWS.defaultOwnKeysTrap;
          this.preventExtensions = BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap;
          this.setPrototypeOf = BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap;
          this.set = BoundaryProxyHandler$LWS.defaultSetTrap;
          if (foreignTargetTraits$LWS & 64) {
            this.revoke();
          } else if (IS_IN_SHADOW_REALM$LWS) {
            if (isForeignTargetArray$LWS || foreignTargetTraits$LWS & 2) {
              this.makeProxyLive();
            }
          } else {
            if (foreignTargetTraits$LWS & 16) {
              let cachedSerializedValue$LWS = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2;
              this.serialize = () => {
                if (cachedSerializedValue$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) {
                  cachedSerializedValue$LWS = foreignCallableSerializeTarget$LWS(this.foreignTargetPointer);
                }
                return cachedSerializedValue$LWS;
              };
            }
          }
        }
        static passthruDefinePropertyTrap(_shadowTarget$LWS, __key$LWS, _unsafePartialDesc$LWS) {
          lastProxyTrapCalled$LWS = 4;
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS("Reflect.defineProperty");
          }
          const {
            foreignTargetPointer: foreignTargetPointer$LWS,
            nonConfigurableDescriptorCallback: nonConfigurableDescriptorCallback$LWS
          } = this;
          const safePartialDesc$LWS = _unsafePartialDesc$LWS;
          ReflectSetPrototypeOf$LWS2(safePartialDesc$LWS, null);
          const {
            get: _getter$LWS,
            set: _setter$LWS,
            value: __value$LWS
          } = safePartialDesc$LWS;
          const valuePointerOrPrimitive$LWS = "value" in safePartialDesc$LWS ? typeof __value$LWS === "object" && __value$LWS !== null || typeof __value$LWS === "function" ? getTransferablePointer$LWS(__value$LWS) : typeof __value$LWS === "undefined" ? void 0 : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2;
          const getterPointerOrUndefinedSymbol$LWS = "get" in safePartialDesc$LWS ? typeof _getter$LWS === "function" ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2;
          const setterPointerOrUndefinedSymbol$LWS = "set" in safePartialDesc$LWS ? typeof _setter$LWS === "function" ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2;
          let _result$LWS = false;
          try {
            _result$LWS = foreignCallableDefineProperty$LWS(foreignTargetPointer$LWS, __key$LWS, "configurable" in safePartialDesc$LWS ? !!safePartialDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "enumerable" in safePartialDesc$LWS ? !!safePartialDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "writable" in safePartialDesc$LWS ? !!safePartialDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, valuePointerOrPrimitive$LWS, getterPointerOrUndefinedSymbol$LWS, setterPointerOrUndefinedSymbol$LWS, nonConfigurableDescriptorCallback$LWS);
          } catch (error) {
            var _selectedTarget11$LWS;
            const errorToThrow$LWS = (_selectedTarget11$LWS = selectedTarget$LWS) != null ? _selectedTarget11$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          if (useFastForeignTargetPath$LWS && _result$LWS && (typeof getterPointerOrUndefinedSymbol$LWS === "function" || typeof setterPointerOrUndefinedSymbol$LWS === "function")) {
            fastForeignTargetPointers$LWS.delete(foreignTargetPointer$LWS);
          }
          return _result$LWS;
        }
        static passthruDeletePropertyTrap(_shadowTarget$LWS, __key$LWS) {
          lastProxyTrapCalled$LWS = 8;
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS("Reflect.deleteProperty");
          }
          let _result$LWS = false;
          try {
            _result$LWS = foreignCallableDeleteProperty$LWS(this.foreignTargetPointer, __key$LWS);
          } catch (error) {
            var _selectedTarget12$LWS;
            const errorToThrow$LWS = (_selectedTarget12$LWS = selectedTarget$LWS) != null ? _selectedTarget12$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return _result$LWS;
        }
        static passthruGetPrototypeOfTrap(_shadowTarget$LWS) {
          lastProxyTrapCalled$LWS = 64;
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS("Reflect.getPrototypeOf");
          }
          let protoPointerOrNull$LWS;
          try {
            protoPointerOrNull$LWS = foreignCallableGetPrototypeOf$LWS(this.foreignTargetPointer);
          } catch (error) {
            var _selectedTarget13$LWS;
            const errorToThrow$LWS = (_selectedTarget13$LWS = selectedTarget$LWS) != null ? _selectedTarget13$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          let _proto$LWS;
          if (typeof protoPointerOrNull$LWS === "function") {
            protoPointerOrNull$LWS();
            _proto$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _proto$LWS = null;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return _proto$LWS;
        }
        static passthruIsExtensibleTrap(_shadowTarget$LWS) {
          lastProxyTrapCalled$LWS = 256;
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS("Reflect.isExtensible");
          }
          const {
            shadowTarget: shadowTarget$LWS
          } = this;
          let _result$LWS = false;
          if (ReflectIsExtensible$LWS2(shadowTarget$LWS)) {
            const {
              foreignTargetPointer: foreignTargetPointer$LWS
            } = this;
            try {
              _result$LWS = foreignCallableIsExtensible$LWS(foreignTargetPointer$LWS);
            } catch (error) {
              var _selectedTarget14$LWS;
              const errorToThrow$LWS = (_selectedTarget14$LWS = selectedTarget$LWS) != null ? _selectedTarget14$LWS : error;
              selectedTarget$LWS = void 0;
              if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
                activity$LWS.error(errorToThrow$LWS);
              }
              throw errorToThrow$LWS;
            }
            if (!_result$LWS) {
              copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
              ReflectPreventExtensions$LWS2(shadowTarget$LWS);
            }
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return _result$LWS;
        }
        static passthruOwnKeysTrap(_shadowTarget$LWS) {
          lastProxyTrapCalled$LWS = 512;
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS("Reflect.ownKeys");
          }
          let ownKeys$LWS;
          try {
            foreignCallableOwnKeys$LWS(this.foreignTargetPointer, (..._args$LWS) => {
              ownKeys$LWS = _args$LWS;
            });
          } catch (error) {
            var _selectedTarget15$LWS;
            const errorToThrow$LWS = (_selectedTarget15$LWS = selectedTarget$LWS) != null ? _selectedTarget15$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return ownKeys$LWS || [];
        }
        static passthruGetOwnPropertyDescriptorTrap(_shadowTarget$LWS, __key$LWS) {
          lastProxyTrapCalled$LWS = 32;
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS("Reflect.getOwnPropertyDescriptor");
          }
          const {
            foreignTargetPointer: foreignTargetPointer$LWS,
            shadowTarget: shadowTarget$LWS
          } = this;
          let _safeDesc$LWS;
          try {
            foreignCallableGetOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, __key$LWS, (__key$LWS2, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
              _safeDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
              if (_safeDesc$LWS.configurable === false) {
                ReflectDefineProperty$LWS2(shadowTarget$LWS, __key$LWS2, _safeDesc$LWS);
              }
            });
          } catch (error) {
            var _selectedTarget16$LWS;
            const errorToThrow$LWS = (_selectedTarget16$LWS = selectedTarget$LWS) != null ? _selectedTarget16$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          if (IS_NOT_IN_SHADOW_REALM$LWS && _safeDesc$LWS && (__key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS2 || __key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS2)) {
            throw new TypeErrorCtor$LWS2(ERR_ILLEGAL_PROPERTY_ACCESS$LWS2);
          }
          return _safeDesc$LWS;
        }
        static passthruPreventExtensionsTrap(_shadowTarget$LWS) {
          lastProxyTrapCalled$LWS = 1024;
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS("Reflect.preventExtensions");
          }
          const {
            foreignTargetPointer: foreignTargetPointer$LWS,
            shadowTarget: shadowTarget$LWS
          } = this;
          let _result$LWS = true;
          if (ReflectIsExtensible$LWS2(shadowTarget$LWS)) {
            let resultEnum$LWS = 0;
            try {
              resultEnum$LWS = foreignCallablePreventExtensions$LWS(foreignTargetPointer$LWS);
            } catch (error) {
              var _selectedTarget17$LWS;
              const errorToThrow$LWS = (_selectedTarget17$LWS = selectedTarget$LWS) != null ? _selectedTarget17$LWS : error;
              selectedTarget$LWS = void 0;
              if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
                activity$LWS.error(errorToThrow$LWS);
              }
              throw errorToThrow$LWS;
            }
            if (!(resultEnum$LWS & 1)) {
              copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
              ReflectPreventExtensions$LWS2(shadowTarget$LWS);
            }
            _result$LWS = !(resultEnum$LWS & 2);
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return _result$LWS;
        }
        static passthruSetPrototypeOfTrap(_shadowTarget$LWS, _proto$LWS) {
          lastProxyTrapCalled$LWS = 4096;
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS("Reflect.setPrototypeOf");
          }
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          const transferableProto$LWS = _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
          let _result$LWS = false;
          try {
            _result$LWS = foreignCallableSetPrototypeOf$LWS(foreignTargetPointer$LWS, transferableProto$LWS);
          } catch (error) {
            var _selectedTarget18$LWS;
            const errorToThrow$LWS = (_selectedTarget18$LWS = selectedTarget$LWS) != null ? _selectedTarget18$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          if (useFastForeignTargetPath$LWS && _result$LWS) {
            fastForeignTargetPointers$LWS.delete(foreignTargetPointer$LWS);
          }
          return _result$LWS;
        }
        static passthruSetTrap(_shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS) {
          lastProxyTrapCalled$LWS = 2048;
          const {
            foreignTargetPointer: foreignTargetPointer$LWS,
            proxy: _proxy$LWS,
            shadowTarget: shadowTarget$LWS
          } = this;
          if (typeof __value$LWS === "undefined") {
            __value$LWS = void 0;
          }
          if (typeof __receiver$LWS === "undefined") {
            __receiver$LWS = _proxy$LWS;
          }
          if (IS_NOT_IN_SHADOW_REALM$LWS && (__key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS2 || __key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS2)) {
            throw new TypeErrorCtor$LWS2(ERR_ILLEGAL_PROPERTY_ACCESS$LWS2);
          }
          const isFastPath$LWS = _proxy$LWS === __receiver$LWS;
          let activity$LWS;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS = startActivity$LWS(isFastPath$LWS ? "Reflect.set" : "passthruForeignTraversedSet");
          }
          let _result$LWS = false;
          try {
            _result$LWS = isFastPath$LWS ? foreignCallableSet$LWS(foreignTargetPointer$LWS, __key$LWS, typeof __value$LWS === "object" && __value$LWS !== null || typeof __value$LWS === "function" ? getTransferablePointer$LWS(__value$LWS) : __value$LWS, LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2) : passthruForeignTraversedSet$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS);
          } catch (error) {
            var _selectedTarget19$LWS;
            const errorToThrow$LWS = (_selectedTarget19$LWS = selectedTarget$LWS) != null ? _selectedTarget19$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.stop();
          }
          return _result$LWS;
        }
      }
      BoundaryProxyHandler$LWS.hybridGetTrap = IS_IN_SHADOW_REALM$LWS ? function(_shadowTarget$LWS, __key$LWS, __receiver$LWS) {
        let activity$LWS;
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS("hybridGetTrap");
        }
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTraits: foreignTargetTraits$LWS,
          proxy: _proxy$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        let _safeDesc$LWS;
        let _result$LWS;
        if (useFastForeignTargetPath$LWS && fastForeignTargetPointers$LWS.has(foreignTargetPointer$LWS)) {
          let pointerOrPrimitive$LWS;
          try {
            pointerOrPrimitive$LWS = foreignCallableGetPropertyValue$LWS(foreignTargetPointer$LWS, __key$LWS);
          } catch (error) {
            var _selectedTarget20$LWS;
            const errorToThrow$LWS = (_selectedTarget20$LWS = selectedTarget$LWS) != null ? _selectedTarget20$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          if (typeof pointerOrPrimitive$LWS === "function") {
            pointerOrPrimitive$LWS();
            _result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _result$LWS = pointerOrPrimitive$LWS;
          }
        } else {
          _safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS);
          if (_safeDesc$LWS) {
            const {
              get: _getter$LWS,
              value: localValue$LWS
            } = _safeDesc$LWS;
            if (_getter$LWS) {
              if (_safeDesc$LWS.foreign) {
                const foreignGetterPointer$LWS = getTransferablePointer$LWS(_getter$LWS);
                const transferableReceiver$LWS = _proxy$LWS === __receiver$LWS ? foreignTargetPointer$LWS : typeof __receiver$LWS === "object" && __receiver$LWS !== null || typeof __receiver$LWS === "function" ? getTransferablePointer$LWS(__receiver$LWS) : __receiver$LWS;
                let pointerOrPrimitive$LWS;
                try {
                  pointerOrPrimitive$LWS = foreignCallableApply$LWS(foreignGetterPointer$LWS, transferableReceiver$LWS);
                } catch (error) {
                  var _selectedTarget21$LWS;
                  const errorToThrow$LWS = (_selectedTarget21$LWS = selectedTarget$LWS) != null ? _selectedTarget21$LWS : error;
                  selectedTarget$LWS = void 0;
                  if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
                    activity$LWS.error(errorToThrow$LWS);
                  }
                  throw errorToThrow$LWS;
                }
                if (typeof pointerOrPrimitive$LWS === "function") {
                  pointerOrPrimitive$LWS();
                  _result$LWS = selectedTarget$LWS;
                  selectedTarget$LWS = void 0;
                } else {
                  _result$LWS = pointerOrPrimitive$LWS;
                }
              } else {
                _result$LWS = ReflectApply$LWS2(_getter$LWS, __receiver$LWS, []);
              }
            } else {
              _result$LWS = localValue$LWS;
            }
          } else {
            const transferableReceiver$LWS = _proxy$LWS === __receiver$LWS ? foreignTargetPointer$LWS : typeof __receiver$LWS === "object" && __receiver$LWS !== null || typeof __receiver$LWS === "function" ? getTransferablePointer$LWS(__receiver$LWS) : __receiver$LWS;
            let pointerOrPrimitive$LWS;
            try {
              pointerOrPrimitive$LWS = foreignCallableGet$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, __key$LWS, transferableReceiver$LWS);
            } catch (error) {
              var _selectedTarget22$LWS;
              const errorToThrow$LWS = (_selectedTarget22$LWS = selectedTarget$LWS) != null ? _selectedTarget22$LWS : error;
              selectedTarget$LWS = void 0;
              if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
                activity$LWS.error(errorToThrow$LWS);
              }
              throw errorToThrow$LWS;
            }
            if (typeof pointerOrPrimitive$LWS === "function") {
              pointerOrPrimitive$LWS();
              _result$LWS = selectedTarget$LWS;
              selectedTarget$LWS = void 0;
            } else {
              _result$LWS = pointerOrPrimitive$LWS;
            }
          }
        }
        if (_safeDesc$LWS === void 0 && _result$LWS === void 0 && __key$LWS === SymbolToStringTag$LWS2 && foreignTargetTraits$LWS & 16) {
          let toStringTag$LWS;
          try {
            toStringTag$LWS = foreignCallableGetToStringTagOfTarget$LWS(foreignTargetPointer$LWS);
          } catch (error) {
            var _selectedTarget23$LWS;
            const errorToThrow$LWS = (_selectedTarget23$LWS = selectedTarget$LWS) != null ? _selectedTarget23$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          if (toStringTag$LWS !== "Object") {
            _result$LWS = toStringTag$LWS;
          }
        }
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }
        return _result$LWS;
      } : noop$LWS2;
      BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray = IS_IN_SHADOW_REALM$LWS ? function(_shadowTarget$LWS, __key$LWS, __receiver$LWS) {
        let activity$LWS;
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS("hybridGetTrapForTypedArray");
        }
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTypedArrayLength: foreignTargetTypedArrayLength$LWS,
          proxy: _proxy$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        let useFastPath$LWS = useFastForeignTargetPathForTypedArrays$LWS;
        if (!useFastPath$LWS && typeof __key$LWS === "string") {
          const _possibleIndex$LWS = +__key$LWS;
          useFastPath$LWS = _possibleIndex$LWS > -1 && _possibleIndex$LWS < foreignTargetTypedArrayLength$LWS && NumberIsInteger$LWS2(_possibleIndex$LWS);
        }
        let _result$LWS;
        if (useFastPath$LWS) {
          let pointerOrPrimitive$LWS;
          try {
            pointerOrPrimitive$LWS = foreignCallableGetPropertyValue$LWS(foreignTargetPointer$LWS, __key$LWS);
          } catch (error) {
            var _selectedTarget24$LWS;
            const errorToThrow$LWS = (_selectedTarget24$LWS = selectedTarget$LWS) != null ? _selectedTarget24$LWS : error;
            selectedTarget$LWS = void 0;
            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
              activity$LWS.error(errorToThrow$LWS);
            }
            throw errorToThrow$LWS;
          }
          if (typeof pointerOrPrimitive$LWS === "function") {
            pointerOrPrimitive$LWS();
            _result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            _result$LWS = pointerOrPrimitive$LWS;
          }
        } else {
          const _safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, __key$LWS);
          if (_safeDesc$LWS) {
            const {
              get: _getter$LWS,
              value: localValue$LWS
            } = _safeDesc$LWS;
            if (_getter$LWS) {
              if (_safeDesc$LWS.foreign) {
                const foreignGetterPointer$LWS = getTransferablePointer$LWS(_getter$LWS);
                const transferableReceiver$LWS = _proxy$LWS === __receiver$LWS ? foreignTargetPointer$LWS : typeof __receiver$LWS === "object" && __receiver$LWS !== null || typeof __receiver$LWS === "function" ? getTransferablePointer$LWS(__receiver$LWS) : __receiver$LWS;
                let pointerOrPrimitive$LWS;
                try {
                  pointerOrPrimitive$LWS = foreignCallableApply$LWS(foreignGetterPointer$LWS, transferableReceiver$LWS);
                } catch (error) {
                  var _selectedTarget25$LWS;
                  const errorToThrow$LWS = (_selectedTarget25$LWS = selectedTarget$LWS) != null ? _selectedTarget25$LWS : error;
                  selectedTarget$LWS = void 0;
                  if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
                    activity$LWS.error(errorToThrow$LWS);
                  }
                  throw errorToThrow$LWS;
                }
                if (typeof pointerOrPrimitive$LWS === "function") {
                  pointerOrPrimitive$LWS();
                  _result$LWS = selectedTarget$LWS;
                  selectedTarget$LWS = void 0;
                } else {
                  _result$LWS = pointerOrPrimitive$LWS;
                }
              } else {
                _result$LWS = ReflectApply$LWS2(_getter$LWS, __receiver$LWS, []);
              }
            } else {
              _result$LWS = localValue$LWS;
            }
          }
        }
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }
        return _result$LWS;
      } : noop$LWS2;
      BoundaryProxyHandler$LWS.hybridHasTrap = IS_IN_SHADOW_REALM$LWS ? function(_shadowTarget$LWS, __key$LWS) {
        let activity$LWS;
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS("hybridHasTrap");
        }
        let trueOrProtoPointerOrNull$LWS;
        try {
          trueOrProtoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS(this.foreignTargetPointer, __key$LWS);
        } catch (error) {
          var _selectedTarget26$LWS;
          const errorToThrow$LWS = (_selectedTarget26$LWS = selectedTarget$LWS) != null ? _selectedTarget26$LWS : error;
          selectedTarget$LWS = void 0;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }
          throw errorToThrow$LWS;
        }
        let _result$LWS = false;
        if (trueOrProtoPointerOrNull$LWS === true) {
          _result$LWS = true;
        } else {
          let currentObject$LWS;
          if (typeof trueOrProtoPointerOrNull$LWS === "function") {
            trueOrProtoPointerOrNull$LWS();
            currentObject$LWS = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          } else {
            currentObject$LWS = null;
          }
          while (currentObject$LWS) {
            if (ObjectHasOwn$LWS2(currentObject$LWS, __key$LWS)) {
              _result$LWS = true;
              break;
            }
            currentObject$LWS = ReflectGetPrototypeOf$LWS2(currentObject$LWS);
          }
        }
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }
        return _result$LWS;
      } : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.passthruGetTrap = IS_NOT_IN_SHADOW_REALM$LWS ? function(_shadowTarget$LWS, __key$LWS, __receiver$LWS) {
        handshakePropertyFlag$LWS && (handshakePropertyFlag$LWS = lastProxyTrapCalled$LWS === 128);
        lastProxyTrapCalled$LWS = 16;
        const isNearMembraneSymbol$LWS = __key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS2;
        const isNearMembraneSerializedValueSymbol$LWS = __key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS2;
        if (handshakePropertyFlag$LWS) {
          if (isNearMembraneSymbol$LWS) {
            return true;
          }
          if (isNearMembraneSerializedValueSymbol$LWS) {
            return this.serialize();
          }
        }
        let activity$LWS;
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS("Reflect.get");
        }
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTraits: foreignTargetTraits$LWS,
          proxy: _proxy$LWS
        } = this;
        if (typeof __receiver$LWS === "undefined") {
          __receiver$LWS = _proxy$LWS;
        }
        const transferableReceiver$LWS = _proxy$LWS === __receiver$LWS ? LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2 : typeof __receiver$LWS === "object" && __receiver$LWS !== null || typeof __receiver$LWS === "function" ? getTransferablePointer$LWS(__receiver$LWS) : __receiver$LWS;
        let pointerOrPrimitive$LWS;
        try {
          pointerOrPrimitive$LWS = foreignCallableGet$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, __key$LWS, transferableReceiver$LWS);
        } catch (error) {
          var _selectedTarget27$LWS;
          const errorToThrow$LWS = (_selectedTarget27$LWS = selectedTarget$LWS) != null ? _selectedTarget27$LWS : error;
          selectedTarget$LWS = void 0;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }
          throw errorToThrow$LWS;
        }
        let _result$LWS;
        if (typeof pointerOrPrimitive$LWS === "function") {
          pointerOrPrimitive$LWS();
          _result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = void 0;
        } else {
          _result$LWS = pointerOrPrimitive$LWS;
        }
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }
        if (_result$LWS !== void 0 && (isNearMembraneSymbol$LWS || isNearMembraneSerializedValueSymbol$LWS)) {
          throw new TypeErrorCtor$LWS2(ERR_ILLEGAL_PROPERTY_ACCESS$LWS2);
        }
        return _result$LWS;
      } : noop$LWS2;
      BoundaryProxyHandler$LWS.passthruHasTrap = IS_NOT_IN_SHADOW_REALM$LWS ? function(_shadowTarget$LWS, __key$LWS) {
        lastProxyTrapCalled$LWS = 128;
        let activity$LWS;
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS = startActivity$LWS("Reflect.has");
        }
        let _result$LWS;
        try {
          _result$LWS = foreignCallableHas$LWS(this.foreignTargetPointer, __key$LWS);
        } catch (error) {
          var _selectedTarget28$LWS;
          const errorToThrow$LWS = (_selectedTarget28$LWS = selectedTarget$LWS) != null ? _selectedTarget28$LWS : error;
          selectedTarget$LWS = void 0;
          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
            activity$LWS.error(errorToThrow$LWS);
          }
          throw errorToThrow$LWS;
        }
        const isNearMembraneSymbol$LWS = __key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS2;
        const isNearMembraneSerializedValueSymbol$LWS = __key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS2;
        if (_result$LWS) {
          handshakePropertyFlag$LWS = false;
          if (isNearMembraneSymbol$LWS || isNearMembraneSerializedValueSymbol$LWS) {
            throw new TypeErrorCtor$LWS2(ERR_ILLEGAL_PROPERTY_ACCESS$LWS2);
          }
        } else {
          handshakePropertyFlag$LWS = isNearMembraneSymbol$LWS || isNearMembraneSerializedValueSymbol$LWS;
        }
        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
          activity$LWS.stop();
        }
        return _result$LWS;
      } : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.pendingDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? function(shadowTarget$LWS, __key$LWS, _unsafePartialDesc$LWS) {
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTraits: foreignTargetTraits$LWS
        } = this;
        if (foreignCallableIsTargetLive$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS)) {
          this.makeProxyLive();
        } else {
          if (useFastForeignTargetPath$LWS) {
            if (isForeignPointerOfObjectProto$LWS(foreignTargetPointer$LWS)) {
              disableFastForeignTargetPointers$LWS();
            } else if (isForeignPointerOfTypedArrayProto$LWS(foreignTargetPointer$LWS)) {
              useFastForeignTargetPathForTypedArrays$LWS = false;
            }
          }
          this.makeProxyStatic();
        }
        return this.defineProperty(shadowTarget$LWS, __key$LWS, _unsafePartialDesc$LWS);
      } : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.pendingDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? function(shadowTarget$LWS, __key$LWS) {
        if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
          this.makeProxyLive();
        } else {
          this.makeProxyStatic();
        }
        return this.deleteProperty(shadowTarget$LWS, __key$LWS);
      } : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? function(shadowTarget$LWS) {
        if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
          this.makeProxyLive();
        } else {
          this.makeProxyStatic();
        }
        return this.preventExtensions(shadowTarget$LWS);
      } : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? function(shadowTarget$LWS, _proto$LWS) {
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTraits: foreignTargetTraits$LWS
        } = this;
        if (foreignCallableIsTargetLive$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS)) {
          this.makeProxyLive();
        } else {
          if (useFastForeignTargetPath$LWS) {
            if (isForeignPointerOfObjectProto$LWS(foreignTargetPointer$LWS)) {
              disableFastForeignTargetPointers$LWS();
            } else if (isForeignPointerOfTypedArrayProto$LWS(foreignTargetPointer$LWS)) {
              useFastForeignTargetPathForTypedArrays$LWS = false;
            }
          }
          this.makeProxyStatic();
        }
        return this.setPrototypeOf(shadowTarget$LWS, _proto$LWS);
      } : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.pendingSetTrap = IS_IN_SHADOW_REALM$LWS ? function(shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS) {
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          foreignTargetTraits: foreignTargetTraits$LWS
        } = this;
        if (foreignCallableIsTargetLive$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS)) {
          this.makeProxyLive();
        } else {
          if (useFastForeignTargetPath$LWS) {
            if (isForeignPointerOfObjectProto$LWS(foreignTargetPointer$LWS)) {
              disableFastForeignTargetPointers$LWS();
            } else if (isForeignPointerOfTypedArrayProto$LWS(foreignTargetPointer$LWS)) {
              useFastForeignTargetPathForTypedArrays$LWS = false;
            }
          }
          this.makeProxyStatic();
        }
        return this.set(shadowTarget$LWS, __key$LWS, __value$LWS, __receiver$LWS);
      } : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? ReflectDefineProperty$LWS2 : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? ReflectDeleteProperty$LWS2 : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap = IS_IN_SHADOW_REALM$LWS ? ReflectGetOwnPropertyDescriptor$LWS2 : noop$LWS2;
      BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? ReflectGetPrototypeOf$LWS2 : () => null;
      BoundaryProxyHandler$LWS.staticGetTrap = IS_IN_SHADOW_REALM$LWS ? function(shadowTarget$LWS, __key$LWS, __receiver$LWS) {
        const {
          foreignTargetTraits: foreignTargetTraits$LWS,
          staticToStringTag: staticToStringTag$LWS
        } = this;
        const _result$LWS = ReflectGet$LWS2(shadowTarget$LWS, __key$LWS, __receiver$LWS);
        if (_result$LWS === void 0 && __key$LWS === SymbolToStringTag$LWS2 && foreignTargetTraits$LWS & 16 && staticToStringTag$LWS !== "Object" && !(__key$LWS in shadowTarget$LWS)) {
          return staticToStringTag$LWS;
        }
        return _result$LWS;
      } : noop$LWS2;
      BoundaryProxyHandler$LWS.staticHasTrap = IS_IN_SHADOW_REALM$LWS ? ReflectHas$LWS2 : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticIsExtensibleTrap = IS_IN_SHADOW_REALM$LWS ? ReflectIsExtensible$LWS2 : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticOwnKeysTrap = IS_IN_SHADOW_REALM$LWS ? ReflectOwnKeys$LWS2 : () => [];
      BoundaryProxyHandler$LWS.staticPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? ReflectPreventExtensions$LWS2 : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? ReflectSetPrototypeOf$LWS2 : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.staticSetTrap = IS_IN_SHADOW_REALM$LWS ? ReflectSet$LWS2 : alwaysFalse$LWS;
      BoundaryProxyHandler$LWS.defaultDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingDefinePropertyTrap : BoundaryProxyHandler$LWS.passthruDefinePropertyTrap;
      BoundaryProxyHandler$LWS.defaultDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingDeletePropertyTrap : BoundaryProxyHandler$LWS.passthruDeletePropertyTrap;
      BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap = BoundaryProxyHandler$LWS.passthruGetOwnPropertyDescriptorTrap;
      BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap = BoundaryProxyHandler$LWS.passthruGetPrototypeOfTrap;
      BoundaryProxyHandler$LWS.defaultGetTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.hybridGetTrap : BoundaryProxyHandler$LWS.passthruGetTrap;
      BoundaryProxyHandler$LWS.defaultHasTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.hybridHasTrap : BoundaryProxyHandler$LWS.passthruHasTrap;
      BoundaryProxyHandler$LWS.defaultIsExtensibleTrap = BoundaryProxyHandler$LWS.passthruIsExtensibleTrap;
      BoundaryProxyHandler$LWS.defaultOwnKeysTrap = BoundaryProxyHandler$LWS.passthruOwnKeysTrap;
      BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap : BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap;
      BoundaryProxyHandler$LWS.defaultSetTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingSetTrap : BoundaryProxyHandler$LWS.passthruSetTrap;
      BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap : BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap;
      if (IS_IN_SHADOW_REALM$LWS) {
        clearFastForeignTargetPointers$LWS();
      }
      foreignCallableHooksCallback$LWS(createPointer$LWS(globalThisRef$LWS), IS_NOT_IN_SHADOW_REALM$LWS ? () => {
        const _result$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        return _result$LWS;
      } : noop$LWS2, (__value$LWS) => {
        if (typeof __value$LWS === "object" && __value$LWS !== null || typeof __value$LWS === "function") {
          return getTransferablePointer$LWS(__value$LWS);
        }
        return typeof __value$LWS === "undefined" ? void 0 : __value$LWS;
      }, (targetPointer$LWS, __key$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        const __value$LWS = __target$LWS == null ? void 0 : __target$LWS[__key$LWS];
        return createPointer$LWS(typeof __value$LWS === "undefined" ? void 0 : __value$LWS);
      }, IS_IN_SHADOW_REALM$LWS ? (_sourceText$LWS) => {
        let _result$LWS;
        try {
          _result$LWS = localEval$LWS(_sourceText$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        return typeof _result$LWS === "object" && _result$LWS !== null || typeof _result$LWS === "function" ? getTransferablePointer$LWS(_result$LWS) : _result$LWS;
      } : noop$LWS2, (targetPointer$LWS, newPointer$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        if (typeof __target$LWS === "object" && __target$LWS !== null || typeof __target$LWS === "function") {
          proxyPointerCache$LWS.set(__target$LWS, newPointer$LWS);
        }
      }, LOCKER_DEBUGGABLE_FLAG$LWS ? (foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) => {
        const pointer$LWS = pushTarget$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS);
        const pointerWrapper$LWS = () => {
          checkDebugMode$LWS();
          return pointer$LWS();
        };
        return pointerWrapper$LWS;
      } : pushTarget$LWS, pushTarget$LWS, (targetPointer$LWS, thisArgPointerOrUndefined$LWS, ..._args$LWS) => {
        targetPointer$LWS();
        const func$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let thisArg$LWS;
        if (typeof thisArgPointerOrUndefined$LWS === "function") {
          thisArgPointerOrUndefined$LWS();
          thisArg$LWS = selectedTarget$LWS;
          selectedTarget$LWS = void 0;
        }
        for (let _i$LWS = 0, {
          length: _length$LWS
        } = _args$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
          const pointerOrPrimitive$LWS = _args$LWS[_i$LWS];
          if (typeof pointerOrPrimitive$LWS === "function") {
            pointerOrPrimitive$LWS();
            _args$LWS[_i$LWS] = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          }
        }
        let _result$LWS;
        try {
          _result$LWS = ReflectApply$LWS2(func$LWS, thisArg$LWS, _args$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        return typeof _result$LWS === "object" && _result$LWS !== null || typeof _result$LWS === "function" ? getTransferablePointer$LWS(_result$LWS) : typeof _result$LWS === "undefined" ? void 0 : _result$LWS;
      }, (targetPointer$LWS, newTargetPointerOrUndefined$LWS, ..._args$LWS) => {
        targetPointer$LWS();
        const constructor$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let newTarget$LWS;
        if (typeof newTargetPointerOrUndefined$LWS === "function") {
          newTargetPointerOrUndefined$LWS();
          newTarget$LWS = selectedTarget$LWS;
          selectedTarget$LWS = void 0;
        }
        for (let _i$LWS = 0, {
          length: _length$LWS
        } = _args$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
          const pointerOrPrimitive$LWS = _args$LWS[_i$LWS];
          if (typeof pointerOrPrimitive$LWS === "function") {
            pointerOrPrimitive$LWS();
            _args$LWS[_i$LWS] = selectedTarget$LWS;
            selectedTarget$LWS = void 0;
          }
        }
        let _result$LWS;
        try {
          _result$LWS = ReflectConstruct$LWS2(constructor$LWS, _args$LWS, newTarget$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        return typeof _result$LWS === "object" && _result$LWS !== null || typeof _result$LWS === "function" ? getTransferablePointer$LWS(_result$LWS) : typeof _result$LWS === "undefined" ? void 0 : _result$LWS;
      }, (targetPointer$LWS, __key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS, foreignCallableNonConfigurableDescriptorCallback$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        const safePartialDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
        let _result$LWS = false;
        try {
          _result$LWS = ReflectDefineProperty$LWS2(__target$LWS, __key$LWS, safePartialDesc$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (_result$LWS && configurable$LWS === false) {
          let _safeDesc$LWS;
          try {
            _safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS2(__target$LWS, __key$LWS);
          } catch (error) {
            throw pushErrorAcrossBoundary$LWS(error);
          }
          if (_safeDesc$LWS) {
            ReflectSetPrototypeOf$LWS2(_safeDesc$LWS, null);
            if (_safeDesc$LWS.configurable === false) {
              const {
                get: _getter$LWS,
                set: _setter$LWS,
                value: __value$LWS
              } = _safeDesc$LWS;
              foreignCallableNonConfigurableDescriptorCallback$LWS(__key$LWS, false, "enumerable" in _safeDesc$LWS ? _safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "writable" in _safeDesc$LWS ? _safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "value" in _safeDesc$LWS ? typeof __value$LWS === "object" && __value$LWS !== null || typeof __value$LWS === "function" ? getTransferablePointer$LWS(__value$LWS) : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "get" in _safeDesc$LWS ? typeof _getter$LWS === "function" ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "set" in _safeDesc$LWS ? typeof _setter$LWS === "function" ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2);
            }
          }
        }
        return _result$LWS;
      }, (targetPointer$LWS, __key$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        try {
          return ReflectDeleteProperty$LWS2(__target$LWS, __key$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      }, (targetPointer$LWS, targetTraits$LWS, __key$LWS, receiverPointerOrPrimitive$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let __receiver$LWS;
        if (typeof receiverPointerOrPrimitive$LWS === "function") {
          receiverPointerOrPrimitive$LWS();
          __receiver$LWS = selectedTarget$LWS;
          selectedTarget$LWS = void 0;
        } else {
          __receiver$LWS = receiverPointerOrPrimitive$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2 ? __target$LWS : receiverPointerOrPrimitive$LWS;
        }
        let _result$LWS;
        try {
          _result$LWS = ReflectGet$LWS2(__target$LWS, __key$LWS, __receiver$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (typeof _result$LWS === "object" && _result$LWS !== null || typeof _result$LWS === "function") {
          return getTransferablePointer$LWS(_result$LWS);
        }
        if (_result$LWS === void 0 && __key$LWS === SymbolToStringTag$LWS2 && targetTraits$LWS & 16) {
          try {
            if (!(__key$LWS in __target$LWS)) {
              const brand$LWS = ReflectApply$LWS2(ObjectProtoToString$LWS2, __target$LWS, []);
              if (brand$LWS !== "[object Object]") {
                _result$LWS = ReflectApply$LWS2(StringProtoSlice$LWS2, brand$LWS, [8, -1]);
              }
            }
          } catch (error) {
            throw pushErrorAcrossBoundary$LWS(error);
          }
        }
        return typeof _result$LWS === "undefined" ? void 0 : _result$LWS;
      }, (targetPointer$LWS, __key$LWS, foreignCallableDescriptorCallback$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let _safeDesc$LWS;
        try {
          _safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS2(__target$LWS, __key$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (_safeDesc$LWS) {
          ReflectSetPrototypeOf$LWS2(_safeDesc$LWS, null);
          const {
            get: _getter$LWS,
            set: _setter$LWS,
            value: __value$LWS
          } = _safeDesc$LWS;
          foreignCallableDescriptorCallback$LWS(__key$LWS, "configurable" in _safeDesc$LWS ? _safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "enumerable" in _safeDesc$LWS ? _safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "writable" in _safeDesc$LWS ? _safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "value" in _safeDesc$LWS ? typeof __value$LWS === "object" && __value$LWS !== null || typeof __value$LWS === "function" ? getTransferablePointer$LWS(__value$LWS) : typeof __value$LWS === "undefined" ? void 0 : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "get" in _safeDesc$LWS ? typeof _getter$LWS === "function" ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "set" in _safeDesc$LWS ? typeof _setter$LWS === "function" ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2);
        }
      }, (targetPointer$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let _proto$LWS;
        try {
          _proto$LWS = ReflectGetPrototypeOf$LWS2(__target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (typeof _proto$LWS === "undefined") {
          return null;
        }
        return _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
      }, (targetPointer$LWS, __key$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        try {
          return __key$LWS in __target$LWS;
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      }, (targetPointer$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        try {
          return ReflectIsExtensible$LWS2(__target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      }, (targetPointer$LWS, foreignCallableKeysCallback$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let ownKeys$LWS;
        try {
          ownKeys$LWS = ReflectOwnKeys$LWS2(__target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        ReflectApply$LWS2(foreignCallableKeysCallback$LWS, void 0, ownKeys$LWS);
      }, (targetPointer$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let _result$LWS = 2;
        try {
          if (ReflectPreventExtensions$LWS2(__target$LWS)) {
            _result$LWS = 4;
          } else if (ReflectIsExtensible$LWS2(__target$LWS)) {
            _result$LWS |= 1;
          }
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        return _result$LWS;
      }, (targetPointer$LWS, __key$LWS, valuePointerOrPrimitive$LWS, receiverPointerOrPrimitive$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let __value$LWS;
        if (typeof valuePointerOrPrimitive$LWS === "function") {
          valuePointerOrPrimitive$LWS();
          __value$LWS = selectedTarget$LWS;
          selectedTarget$LWS = void 0;
        } else {
          __value$LWS = valuePointerOrPrimitive$LWS;
        }
        let __receiver$LWS;
        if (typeof receiverPointerOrPrimitive$LWS === "function") {
          receiverPointerOrPrimitive$LWS();
          __receiver$LWS = selectedTarget$LWS;
          selectedTarget$LWS = void 0;
        } else {
          __receiver$LWS = receiverPointerOrPrimitive$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2 ? __target$LWS : receiverPointerOrPrimitive$LWS;
        }
        try {
          return ReflectSet$LWS2(__target$LWS, __key$LWS, __value$LWS, __receiver$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      }, (targetPointer$LWS, protoPointerOrNull$LWS = null) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let _proto$LWS;
        if (typeof protoPointerOrNull$LWS === "function") {
          protoPointerOrNull$LWS();
          _proto$LWS = selectedTarget$LWS;
          selectedTarget$LWS = void 0;
        } else {
          _proto$LWS = null;
        }
        try {
          return ReflectSetPrototypeOf$LWS2(__target$LWS, _proto$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      }, LOCKER_DEBUGGABLE_FLAG$LWS ? (..._args$LWS) => {
        if (checkDebugMode$LWS()) {
          for (let _i$LWS = 0, {
            length: _length$LWS
          } = _args$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
            const pointerOrPrimitive$LWS = _args$LWS[_i$LWS];
            if (typeof pointerOrPrimitive$LWS === "function") {
              pointerOrPrimitive$LWS();
              _args$LWS[_i$LWS] = selectedTarget$LWS;
              selectedTarget$LWS = void 0;
            }
          }
          try {
            ReflectApply$LWS2(consoleInfo$LWS, consoleObject$LWS, _args$LWS);
          } catch (_unused29$LWS) {
          }
        }
      } : noop$LWS2, IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, ...descriptorTuples$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        for (let _i$LWS = 0, {
          length: _length$LWS
        } = descriptorTuples$LWS; _i$LWS < _length$LWS; _i$LWS += 7) {
          ReflectDefineProperty$LWS2(__target$LWS, descriptorTuples$LWS[_i$LWS], createDescriptorFromMeta$LWS(descriptorTuples$LWS[_i$LWS + 1], descriptorTuples$LWS[_i$LWS + 2], descriptorTuples$LWS[_i$LWS + 3], descriptorTuples$LWS[_i$LWS + 4], descriptorTuples$LWS[_i$LWS + 5], descriptorTuples$LWS[_i$LWS + 6]));
        }
      } : noop$LWS2, IS_NOT_IN_SHADOW_REALM$LWS ? (targetPointer$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        const _state$LWS = proxyTargetToLazyPropertyDescriptorStateMap$LWS.get(__target$LWS);
        return _state$LWS ? getTransferablePointer$LWS(_state$LWS) : _state$LWS;
      } : noop$LWS2, IS_NOT_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, __key$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let __value$LWS;
        try {
          __value$LWS = __target$LWS[__key$LWS];
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        return typeof __value$LWS === "object" && __value$LWS !== null || typeof __value$LWS === "function" ? getTransferablePointer$LWS(__value$LWS) : __value$LWS;
      } : noop$LWS2, IS_NOT_IN_SHADOW_REALM$LWS ? (targetPointer$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        try {
          if (!ReflectIsExtensible$LWS2(__target$LWS)) {
            if (ObjectIsFrozen$LWS(__target$LWS)) {
              return 4 & 2 & 1;
            }
            if (ObjectIsSealed$LWS(__target$LWS)) {
              return 2 & 1;
            }
            return 1;
          }
        } catch (_unused30$LWS) {
          try {
            isArrayOrThrowForRevoked$LWS(__target$LWS);
          } catch (_unused31$LWS) {
            return 8;
          }
        }
        return 0;
      } : () => 0, (targetPointer$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        try {
          const brand$LWS = ReflectApply$LWS2(ObjectProtoToString$LWS2, __target$LWS, []);
          return brand$LWS === "[object Object]" ? "Object" : ReflectApply$LWS2(StringProtoSlice$LWS2, brand$LWS, [8, -1]);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      }, installErrorPrepareStackTrace$LWS, IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, ...ownKeysAndUnforgeableGlobalThisKeys$LWS) => {
        const sliceIndex$LWS = ReflectApply$LWS2(ArrayProtoIndexOf$LWS2, ownKeysAndUnforgeableGlobalThisKeys$LWS, [LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2]);
        let ownKeys$LWS;
        let unforgeableGlobalThisKeys$LWS;
        if (sliceIndex$LWS === -1) {
          ownKeys$LWS = ownKeysAndUnforgeableGlobalThisKeys$LWS;
        } else {
          ownKeys$LWS = ReflectApply$LWS2(ArrayProtoSlice$LWS2, ownKeysAndUnforgeableGlobalThisKeys$LWS, [0, sliceIndex$LWS]);
          unforgeableGlobalThisKeys$LWS = ReflectApply$LWS2(ArrayProtoSlice$LWS2, ownKeysAndUnforgeableGlobalThisKeys$LWS, [sliceIndex$LWS + 1]);
        }
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let _state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(__target$LWS);
        if (_state$LWS === void 0) {
          _state$LWS = {
            __proto__: null
          };
          setLazyPropertyDescriptorStateByTarget$LWS(__target$LWS, _state$LWS);
        }
        for (let _i$LWS = 0, {
          length: _length$LWS
        } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
          const ownKey$LWS = ownKeys$LWS[_i$LWS];
          _state$LWS[ownKey$LWS] = true;
          ReflectDefineProperty$LWS2(__target$LWS, ownKey$LWS, {
            __proto__: null,
            configurable: true,
            get() {
              activateLazyOwnPropertyDefinition$LWS(__target$LWS, ownKey$LWS, _state$LWS);
              return __target$LWS[ownKey$LWS];
            },
            set(__value$LWS) {
              activateLazyOwnPropertyDefinition$LWS(__target$LWS, ownKey$LWS, _state$LWS);
              ReflectSet$LWS2(__target$LWS, ownKey$LWS, __value$LWS);
            }
          });
        }
        installPropertyDescriptorMethodWrappers$LWS(unforgeableGlobalThisKeys$LWS);
      } : noop$LWS2, IS_NOT_IN_SHADOW_REALM$LWS && liveTargetCallback$LWS ? (targetPointer$LWS, targetTraits$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        if (__target$LWS !== ObjectProto$LWS2 && __target$LWS !== RegExpProto$LWS2) {
          try {
            return liveTargetCallback$LWS(__target$LWS, targetTraits$LWS);
          } catch (_unused32$LWS) {
          }
        }
        return false;
      } : alwaysFalse$LWS, IS_NOT_IN_SHADOW_REALM$LWS ? (targetPointer$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        try {
          isArrayOrThrowForRevoked$LWS(__target$LWS);
          return false;
        } catch (_unused33$LWS) {
        }
        return true;
      } : alwaysFalse$LWS, IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        try {
          return SymbolToStringTag$LWS2 in __target$LWS ? serializeTargetByTrialAndError$LWS(__target$LWS) : serializeTargetByBrand$LWS(__target$LWS);
        } catch (_unused34$LWS) {
        }
        return void 0;
      } : noop$LWS2, IS_NOT_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, statePointer$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        statePointer$LWS();
        const _state$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        proxyTargetToLazyPropertyDescriptorStateMap$LWS.set(__target$LWS, _state$LWS);
      } : noop$LWS2, IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        if (useFastForeignTargetPath$LWS) {
          fastForeignTargetPointers$LWS.add(getTransferablePointer$LWS(__target$LWS));
        }
      } : noop$LWS2, (targetPointer$LWS, foreignCallableDescriptorsCallback$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let _unsafeDescs$LWS;
        try {
          _unsafeDescs$LWS = ObjectGetOwnPropertyDescriptors$LWS2(__target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        const ownKeys$LWS = ReflectOwnKeys$LWS2(_unsafeDescs$LWS);
        const {
          length: _length$LWS
        } = ownKeys$LWS;
        const descriptorTuples$LWS = new ArrayCtor$LWS2(_length$LWS * 7);
        for (let _i$LWS = 0, _j$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1, _j$LWS += 7) {
          const ownKey$LWS = ownKeys$LWS[_i$LWS];
          const _safeDesc$LWS = _unsafeDescs$LWS[ownKey$LWS];
          ReflectSetPrototypeOf$LWS2(_safeDesc$LWS, null);
          const {
            get: _getter$LWS,
            set: _setter$LWS,
            value: __value$LWS
          } = _safeDesc$LWS;
          descriptorTuples$LWS[_j$LWS] = ownKey$LWS;
          descriptorTuples$LWS[_j$LWS + 1] = "configurable" in _safeDesc$LWS ? _safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2;
          descriptorTuples$LWS[_j$LWS + 2] = "enumerable" in _safeDesc$LWS ? _safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2;
          descriptorTuples$LWS[_j$LWS + 3] = "writable" in _safeDesc$LWS ? _safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2;
          descriptorTuples$LWS[_j$LWS + 4] = "value" in _safeDesc$LWS ? typeof __value$LWS === "object" && __value$LWS !== null || typeof __value$LWS === "function" ? getTransferablePointer$LWS(__value$LWS) : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2;
          descriptorTuples$LWS[_j$LWS + 5] = "get" in _safeDesc$LWS ? typeof _getter$LWS === "function" ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2;
          descriptorTuples$LWS[_j$LWS + 6] = "set" in _safeDesc$LWS ? typeof _setter$LWS === "function" ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2;
        }
        ReflectApply$LWS2(foreignCallableDescriptorsCallback$LWS, void 0, descriptorTuples$LWS);
        let _proto$LWS;
        try {
          _proto$LWS = ReflectGetPrototypeOf$LWS2(__target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (typeof _proto$LWS === "undefined") {
          return null;
        }
        return _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
      }, (targetPointer$LWS, __key$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let _proto$LWS;
        try {
          if (ObjectHasOwn$LWS2(__target$LWS, __key$LWS)) {
            return true;
          }
          _proto$LWS = ReflectGetPrototypeOf$LWS2(__target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (typeof _proto$LWS === "undefined") {
          return null;
        }
        return _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
      }, (targetPointer$LWS, __key$LWS, foreignCallableDescriptorCallback$LWS) => {
        targetPointer$LWS();
        const __target$LWS = selectedTarget$LWS;
        selectedTarget$LWS = void 0;
        let _safeDesc$LWS;
        try {
          _safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS2(__target$LWS, __key$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (_safeDesc$LWS) {
          ReflectSetPrototypeOf$LWS2(_safeDesc$LWS, null);
          const {
            get: _getter$LWS,
            set: _setter$LWS,
            value: __value$LWS
          } = _safeDesc$LWS;
          foreignCallableDescriptorCallback$LWS(__key$LWS, "configurable" in _safeDesc$LWS ? _safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "enumerable" in _safeDesc$LWS ? _safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "writable" in _safeDesc$LWS ? _safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "value" in _safeDesc$LWS ? typeof __value$LWS === "object" && __value$LWS !== null || typeof __value$LWS === "function" ? getTransferablePointer$LWS(__value$LWS) : typeof __value$LWS === "undefined" ? void 0 : __value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "get" in _safeDesc$LWS ? typeof _getter$LWS === "function" ? getTransferablePointer$LWS(_getter$LWS) : _getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2, "set" in _safeDesc$LWS ? typeof _setter$LWS === "function" ? getTransferablePointer$LWS(_setter$LWS) : _setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS2);
          return void 0;
        }
        let _proto$LWS;
        try {
          _proto$LWS = ReflectGetPrototypeOf$LWS2(__target$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (typeof _proto$LWS === "undefined") {
          return null;
        }
        return _proto$LWS ? getTransferablePointer$LWS(_proto$LWS) : _proto$LWS;
      });
      let foreignCallablesHooked$LWS = false;
      return (...hooks$LWS) => {
        if (foreignCallablesHooked$LWS) {
          return;
        }
        foreignCallablesHooked$LWS = true;
        ({
          6: foreignCallablePushErrorTarget$LWS,
          7: foreignCallablePushTarget$LWS,
          8: foreignCallableApply$LWS,
          9: foreignCallableConstruct$LWS,
          10: foreignCallableDefineProperty$LWS,
          11: foreignCallableDeleteProperty$LWS,
          12: foreignCallableGet$LWS,
          13: foreignCallableGetOwnPropertyDescriptor$LWS,
          14: foreignCallableGetPrototypeOf$LWS,
          15: foreignCallableHas$LWS,
          16: foreignCallableIsExtensible$LWS,
          17: foreignCallableOwnKeys$LWS,
          18: foreignCallablePreventExtensions$LWS,
          19: foreignCallableSet$LWS,
          20: foreignCallableSetPrototypeOf$LWS,
          21: foreignCallableDebugInfo$LWS,
          23: foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS,
          24: foreignCallableGetPropertyValue$LWS,
          25: foreignCallableGetTargetIntegrityTraits$LWS,
          26: foreignCallableGetToStringTagOfTarget$LWS,
          27: foreignCallableInstallErrorPrepareStackTrace$LWS,
          29: foreignCallableIsTargetLive$LWS,
          30: foreignCallableIsTargetRevoked$LWS,
          31: foreignCallableSerializeTarget$LWS,
          32: foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS,
          34: foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
          35: foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
          36: foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
        } = hooks$LWS);
        const applyTrapForZeroOrMoreArgs$LWS = createApplyOrConstructTrapForZeroOrMoreArgs$LWS(1);
        const applyTrapForOneOrMoreArgs$LWS = createApplyOrConstructTrapForOneOrMoreArgs$LWS(1);
        const applyTrapForTwoOrMoreArgs$LWS = createApplyOrConstructTrapForTwoOrMoreArgs$LWS(1);
        const applyTrapForThreeOrMoreArgs$LWS = createApplyOrConstructTrapForThreeOrMoreArgs$LWS(1);
        const applyTrapForFourOrMoreArgs$LWS = createApplyOrConstructTrapForFourOrMoreArgs$LWS(1);
        const applyTrapForFiveOrMoreArgs$LWS = createApplyOrConstructTrapForFiveOrMoreArgs$LWS(1);
        const applyTrapForAnyNumberOfArgs$LWS = createApplyOrConstructTrapForAnyNumberOfArgs$LWS(1);
        const constructTrapForZeroOrMoreArgs$LWS = createApplyOrConstructTrapForZeroOrMoreArgs$LWS(2);
        const constructTrapForOneOrMoreArgs$LWS = createApplyOrConstructTrapForOneOrMoreArgs$LWS(2);
        const constructTrapForTwoOrMoreArgs$LWS = createApplyOrConstructTrapForTwoOrMoreArgs$LWS(2);
        const constructTrapForThreeOrMoreArgs$LWS = createApplyOrConstructTrapForThreeOrMoreArgs$LWS(2);
        const constructTrapForFourOrMoreArgs$LWS = createApplyOrConstructTrapForFourOrMoreArgs$LWS(2);
        const constructTrapForFiveOrMoreArgs$LWS = createApplyOrConstructTrapForFiveOrMoreArgs$LWS(2);
        const constructTrapForAnyNumberOfArgs$LWS = createApplyOrConstructTrapForAnyNumberOfArgs$LWS(2);
        if (MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS === void 0) {
          MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS = ObjectKeys$LWS2({
            applyTrapForZeroOrMoreArgs: applyTrapForZeroOrMoreArgs$LWS,
            applyTrapForOneOrMoreArgs: applyTrapForOneOrMoreArgs$LWS,
            applyTrapForTwoOrMoreArgs: applyTrapForTwoOrMoreArgs$LWS,
            applyTrapForThreeOrMoreArgs: applyTrapForThreeOrMoreArgs$LWS,
            applyTrapForFourOrMoreArgs: applyTrapForFourOrMoreArgs$LWS,
            applyTrapForFiveOrMoreArgs: applyTrapForFiveOrMoreArgs$LWS,
            applyTrapForAnyNumberOfArgs: applyTrapForAnyNumberOfArgs$LWS,
            constructTrapForZeroOrMoreArgs: constructTrapForZeroOrMoreArgs$LWS,
            constructTrapForOneOrMoreArgs: constructTrapForOneOrMoreArgs$LWS,
            constructTrapForTwoOrMoreArgs: constructTrapForTwoOrMoreArgs$LWS,
            constructTrapForThreeOrMoreArgs: constructTrapForThreeOrMoreArgs$LWS,
            constructTrapForFourOrMoreArgs: constructTrapForFourOrMoreArgs$LWS,
            constructTrapForFiveOrMoreArgs: constructTrapForFiveOrMoreArgs$LWS,
            constructTrapForAnyNumberOfArgs: constructTrapForAnyNumberOfArgs$LWS
          });
        }
        applyTrapNameRegistry$LWS[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[0];
        applyTrapNameRegistry$LWS[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[1];
        applyTrapNameRegistry$LWS[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[2];
        applyTrapNameRegistry$LWS[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[3];
        applyTrapNameRegistry$LWS[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[4];
        applyTrapNameRegistry$LWS[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[5];
        applyTrapNameRegistry$LWS.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[6];
        constructTrapNameRegistry$LWS[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[7];
        constructTrapNameRegistry$LWS[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[8];
        constructTrapNameRegistry$LWS[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[9];
        constructTrapNameRegistry$LWS[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[10];
        constructTrapNameRegistry$LWS[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[11];
        constructTrapNameRegistry$LWS[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[12];
        constructTrapNameRegistry$LWS.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[13];
        const {
          prototype: BoundaryProxyHandlerProto$LWS
        } = BoundaryProxyHandler$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[0]] = applyTrapForZeroOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[1]] = applyTrapForOneOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[2]] = applyTrapForTwoOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[3]] = applyTrapForThreeOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[4]] = applyTrapForFourOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[5]] = applyTrapForFiveOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS.n] = applyTrapForAnyNumberOfArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[0]] = constructTrapForZeroOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[1]] = constructTrapForOneOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[2]] = constructTrapForTwoOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[3]] = constructTrapForThreeOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[4]] = constructTrapForFourOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[5]] = constructTrapForFiveOrMoreArgs$LWS;
        BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS.n] = constructTrapForAnyNumberOfArgs$LWS;
        ReflectSetPrototypeOf$LWS2(BoundaryProxyHandlerProto$LWS, null);
      };
    };
  }
  const createMembraneMarshallSourceInStrictMode$LWS = `
'use strict';
(${createMembraneMarshall$LWS})`;
  function createBlueConnector$LWS(_globalObject$LWS) {
    if (typeof _globalObject$LWS !== "object" || _globalObject$LWS === null) {
      throw new TypeErrorCtor$LWS("Missing globalObject.");
    }
    return createMembraneMarshall$LWS(_globalObject$LWS);
  }
  function createRedConnector$LWS(_evaluator$LWS) {
    if (typeof _evaluator$LWS !== "function") {
      throw new TypeErrorCtor$LWS("Missing evaluator function.");
    }
    return _evaluator$LWS(createMembraneMarshallSourceInStrictMode$LWS)();
  }
  const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS = SymbolFor$LWS("@@lockerNearMembraneUndefinedValue");
  class VirtualEnvironment$LWS {
    constructor(_options$LWS) {
      if (_options$LWS === void 0) {
        throw new ErrorCtor$LWS("Missing required VirtualEnvironment options.");
      }
      const {
        blueConnector: blueConnector$LWS,
        redConnector: redConnector$LWS,
        distortionCallback: distortionCallback$LWS,
        instrumentation: instrumentation$LWS,
        liveTargetCallback: liveTargetCallback$LWS,
        revokedProxyCallback: revokedProxyCallback$LWS2,
        signSourceCallback: signSourceCallback$LWS
      } = ObjectAssign$LWS({
        __proto__: null
      }, _options$LWS);
      let blueHooks$LWS;
      const blueConnect$LWS = blueConnector$LWS("blue", (...hooks$LWS) => {
        blueHooks$LWS = hooks$LWS;
      }, {
        distortionCallback: distortionCallback$LWS,
        instrumentation: instrumentation$LWS,
        liveTargetCallback: liveTargetCallback$LWS,
        revokedProxyCallback: revokedProxyCallback$LWS2
      });
      const {
        0: blueGlobalThisPointer$LWS,
        1: blueGetSelectedTarget$LWS,
        2: blueGetTransferableValue$LWS,
        3: blueCallableGetPropertyValuePointer$LWS,
        5: blueCallableLinkPointers$LWS,
        6: blueCallablePushErrorTarget$LWS,
        7: blueCallablePushTarget$LWS,
        8: blueCallableApply$LWS,
        9: blueCallableConstruct$LWS,
        10: blueCallableDefineProperty$LWS,
        11: blueCallableDeleteProperty$LWS,
        12: blueCallableGet$LWS,
        13: blueCallableGetOwnPropertyDescriptor$LWS,
        14: blueCallableGetPrototypeOf$LWS,
        15: blueCallableHas$LWS,
        16: blueCallableIsExtensible$LWS,
        17: blueCallableOwnKeys$LWS,
        18: blueCallablePreventExtensions$LWS,
        19: blueCallableSet$LWS,
        20: blueCallableSetPrototypeOf$LWS,
        23: blueCallableGetLazyPropertyDescriptorStateByTarget$LWS,
        24: blueCallableGetPropertyValue$LWS,
        25: blueCallableGetTargetIntegrityTraits$LWS,
        26: blueCallableGetToStringTagOfTarget$LWS,
        27: blueCallableInstallErrorPrepareStackTrace$LWS,
        29: blueCallableIsTargetLive$LWS,
        32: blueCallableSetLazyPropertyDescriptorStateByTarget$LWS,
        34: blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
        35: blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
        36: blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
      } = blueHooks$LWS;
      let redHooks$LWS;
      const redConnect$LWS = redConnector$LWS("red", (...hooks$LWS) => {
        redHooks$LWS = hooks$LWS;
      });
      const {
        0: redGlobalThisPointer$LWS,
        3: redCallableGetPropertyValuePointer$LWS,
        4: redCallableEvaluate$LWS,
        5: redCallableLinkPointers$LWS,
        6: redCallablePushErrorTarget$LWS,
        7: redCallablePushTarget$LWS,
        8: redCallableApply$LWS,
        9: redCallableConstruct$LWS,
        10: redCallableDefineProperty$LWS,
        11: redCallableDeleteProperty$LWS,
        12: redCallableGet$LWS,
        13: redCallableGetOwnPropertyDescriptor$LWS,
        14: redCallableGetPrototypeOf$LWS,
        15: redCallableHas$LWS,
        16: redCallableIsExtensible$LWS,
        17: redCallableOwnKeys$LWS,
        18: redCallablePreventExtensions$LWS,
        19: redCallableSet$LWS,
        20: redCallableSetPrototypeOf$LWS,
        21: redCallableDebugInfo$LWS,
        22: redCallableDefineProperties$LWS,
        23: redCallableGetLazyPropertyDescriptorStateByTarget$LWS,
        25: redCallableGetTargetIntegrityTraits$LWS,
        26: redCallableGetToStringTagOfTarget$LWS,
        27: redCallableInstallErrorPrepareStackTrace$LWS,
        28: redCallableInstallLazyPropertyDescriptors$LWS,
        30: redCallableIsTargetRevoked$LWS,
        31: redCallableSerializeTarget$LWS,
        32: redCallableSetLazyPropertyDescriptorStateByTarget$LWS,
        33: redCallableTrackAsFastTarget$LWS,
        34: redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
        35: redCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
        36: redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
      } = redHooks$LWS;
      blueConnect$LWS(noop$LWS, noop$LWS, noop$LWS, noop$LWS, noop$LWS, noop$LWS, redCallablePushErrorTarget$LWS, redCallablePushTarget$LWS, redCallableApply$LWS, redCallableConstruct$LWS, redCallableDefineProperty$LWS, redCallableDeleteProperty$LWS, redCallableGet$LWS, redCallableGetOwnPropertyDescriptor$LWS, redCallableGetPrototypeOf$LWS, redCallableHas$LWS, redCallableIsExtensible$LWS, redCallableOwnKeys$LWS, redCallablePreventExtensions$LWS, redCallableSet$LWS, redCallableSetPrototypeOf$LWS, redCallableDebugInfo$LWS, noop$LWS, redCallableGetLazyPropertyDescriptorStateByTarget$LWS, noop$LWS, redCallableGetTargetIntegrityTraits$LWS, redCallableGetToStringTagOfTarget$LWS, redCallableInstallErrorPrepareStackTrace$LWS, noop$LWS, noop$LWS, redCallableIsTargetRevoked$LWS, redCallableSerializeTarget$LWS, redCallableSetLazyPropertyDescriptorStateByTarget$LWS, redCallableTrackAsFastTarget$LWS, redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS, redCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS, redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS);
      redConnect$LWS(noop$LWS, noop$LWS, noop$LWS, noop$LWS, noop$LWS, noop$LWS, blueCallablePushErrorTarget$LWS, blueCallablePushTarget$LWS, blueCallableApply$LWS, blueCallableConstruct$LWS, blueCallableDefineProperty$LWS, blueCallableDeleteProperty$LWS, blueCallableGet$LWS, blueCallableGetOwnPropertyDescriptor$LWS, blueCallableGetPrototypeOf$LWS, blueCallableHas$LWS, blueCallableIsExtensible$LWS, blueCallableOwnKeys$LWS, blueCallablePreventExtensions$LWS, blueCallableSet$LWS, blueCallableSetPrototypeOf$LWS, noop$LWS, noop$LWS, blueCallableGetLazyPropertyDescriptorStateByTarget$LWS, blueCallableGetPropertyValue$LWS, blueCallableGetTargetIntegrityTraits$LWS, blueCallableGetToStringTagOfTarget$LWS, blueCallableInstallErrorPrepareStackTrace$LWS, noop$LWS, blueCallableIsTargetLive$LWS, noop$LWS, noop$LWS, blueCallableSetLazyPropertyDescriptorStateByTarget$LWS, noop$LWS, blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS, blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS, blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS);
      this.blueGlobalThisPointer = blueGlobalThisPointer$LWS;
      this.blueGetSelectedTarget = blueGetSelectedTarget$LWS;
      this.blueGetTransferableValue = blueGetTransferableValue$LWS;
      this.blueCallableGetPropertyValuePointer = blueCallableGetPropertyValuePointer$LWS;
      this.blueCallableLinkPointers = blueCallableLinkPointers$LWS;
      this.redGlobalThisPointer = () => redGlobalThisPointer$LWS();
      this.redCallableGetPropertyValuePointer = (targetPointer$LWS, __key$LWS) => redCallableGetPropertyValuePointer$LWS(targetPointer$LWS, __key$LWS);
      this.redCallableEvaluate = signSourceCallback$LWS ? (_sourceText$LWS) => redCallableEvaluate$LWS(signSourceCallback$LWS(_sourceText$LWS)) : (_sourceText$LWS) => redCallableEvaluate$LWS(_sourceText$LWS);
      this.redCallableLinkPointers = (targetPointer$LWS, foreignTargetPointer$LWS) => redCallableLinkPointers$LWS(targetPointer$LWS, foreignTargetPointer$LWS);
      this.redCallableSetPrototypeOf = (targetPointer$LWS, protoPointerOrNull$LWS) => redCallableSetPrototypeOf$LWS(targetPointer$LWS, protoPointerOrNull$LWS);
      this.redCallableDefineProperties = (targetPointer$LWS, ...descriptorTuples$LWS) => {
        const {
          length: _length$LWS
        } = descriptorTuples$LWS;
        const _args$LWS = new ArrayCtor$LWS(_length$LWS + 1);
        _args$LWS[0] = targetPointer$LWS;
        for (let _i$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1) {
          _args$LWS[_i$LWS + 1] = descriptorTuples$LWS[_i$LWS];
        }
        ReflectApply$LWS(redCallableDefineProperties$LWS, void 0, _args$LWS);
      };
      this.redCallableInstallLazyPropertyDescriptors = (targetPointer$LWS, ...ownKeysAndUnforgeableGlobalThisKeys$LWS) => {
        const {
          length: _length$LWS
        } = ownKeysAndUnforgeableGlobalThisKeys$LWS;
        const _args$LWS = new ArrayCtor$LWS(_length$LWS + 1);
        _args$LWS[0] = targetPointer$LWS;
        for (let _i$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1) {
          _args$LWS[_i$LWS + 1] = ownKeysAndUnforgeableGlobalThisKeys$LWS[_i$LWS];
        }
        ReflectApply$LWS(redCallableInstallLazyPropertyDescriptors$LWS, void 0, _args$LWS);
      };
      this.redCallableTrackAsFastTarget = (targetPointer$LWS) => redCallableTrackAsFastTarget$LWS(targetPointer$LWS);
    }
    evaluate(_sourceText$LWS) {
      try {
        const bluePointerOrPrimitiveValue$LWS = this.redCallableEvaluate(_sourceText$LWS);
        if (typeof bluePointerOrPrimitiveValue$LWS === "function") {
          bluePointerOrPrimitiveValue$LWS();
          return this.blueGetSelectedTarget();
        }
        return bluePointerOrPrimitiveValue$LWS;
      } catch (error) {
        var _this$blueGetSelected$LWS;
        throw (_this$blueGetSelected$LWS = this.blueGetSelectedTarget()) != null ? _this$blueGetSelected$LWS : error;
      }
    }
    lazyRemapProperties(__target$LWS, ownKeys$LWS, unforgeableGlobalThisKeys$LWS) {
      if (typeof __target$LWS === "object" && __target$LWS !== null || typeof __target$LWS === "function") {
        const _args$LWS = [this.blueGetTransferableValue(__target$LWS)];
        ReflectApply$LWS(ArrayProtoPush$LWS, _args$LWS, ownKeys$LWS);
        if (unforgeableGlobalThisKeys$LWS != null && unforgeableGlobalThisKeys$LWS.length) {
          _args$LWS[_args$LWS.length] = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          ReflectApply$LWS(ArrayProtoPush$LWS, _args$LWS, unforgeableGlobalThisKeys$LWS);
        }
        ReflectApply$LWS(this.redCallableInstallLazyPropertyDescriptors, void 0, _args$LWS);
      }
    }
    link(..._keys$LWS) {
      let bluePointer$LWS = this.blueGlobalThisPointer;
      let redPointer$LWS = this.redGlobalThisPointer;
      for (let _i$LWS = 0, {
        length: _length$LWS
      } = _keys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
        const __key$LWS = _keys$LWS[_i$LWS];
        bluePointer$LWS = this.blueCallableGetPropertyValuePointer(bluePointer$LWS, __key$LWS);
        redPointer$LWS = this.redCallableGetPropertyValuePointer(redPointer$LWS, __key$LWS);
        this.redCallableLinkPointers(redPointer$LWS, bluePointer$LWS);
        this.blueCallableLinkPointers(bluePointer$LWS, redPointer$LWS);
      }
    }
    remapProperties(__target$LWS, unsafeBlueDescs$LWS) {
      if (typeof __target$LWS === "object" && __target$LWS !== null || typeof __target$LWS === "function") {
        const targetPointer$LWS = this.blueGetTransferableValue(__target$LWS);
        const ownKeys$LWS = ReflectOwnKeys$LWS(unsafeBlueDescs$LWS);
        const {
          length: _length$LWS
        } = ownKeys$LWS;
        const _args$LWS = new ArrayCtor$LWS(1 + _length$LWS * 7);
        _args$LWS[0] = targetPointer$LWS;
        for (let _i$LWS = 0, _j$LWS = 1; _i$LWS < _length$LWS; _i$LWS += 1, _j$LWS += 7) {
          const ownKey$LWS = ownKeys$LWS[_i$LWS];
          const unsafeBlueDesc$LWS = unsafeBlueDescs$LWS[ownKey$LWS];
          const safeBlueDesc$LWS = ObjectAssign$LWS({
            __proto__: null
          }, unsafeBlueDesc$LWS);
          _args$LWS[_j$LWS] = ownKey$LWS;
          _args$LWS[_j$LWS + 1] = "configurable" in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          _args$LWS[_j$LWS + 2] = "enumerable" in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          _args$LWS[_j$LWS + 3] = "writable" in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          _args$LWS[_j$LWS + 4] = "value" in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.value) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          _args$LWS[_j$LWS + 5] = "get" in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.get) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
          _args$LWS[_j$LWS + 6] = "set" in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.set) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        }
        ReflectApply$LWS(this.redCallableDefineProperties, this, _args$LWS);
      }
    }
    remapProto(__target$LWS, _proto$LWS) {
      if (typeof __target$LWS === "object" && __target$LWS !== null || typeof __target$LWS === "function") {
        const foreignTargetPointer$LWS = this.blueGetTransferableValue(__target$LWS);
        const transferableProto$LWS = _proto$LWS ? this.blueGetTransferableValue(_proto$LWS) : _proto$LWS;
        this.redCallableSetPrototypeOf(foreignTargetPointer$LWS, transferableProto$LWS);
      }
    }
    trackAsFastTarget(__target$LWS) {
      if (typeof __target$LWS === "object" && __target$LWS !== null || typeof __target$LWS === "function") {
        this.redCallableTrackAsFastTarget(this.blueGetTransferableValue(__target$LWS));
      }
    }
  }
  const ESGlobalKeys$LWS = [
    "globalThis",
    "Infinity",
    "NaN",
    "undefined",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "BigInt",
    "Boolean",
    "FinalizationRegistry",
    "Number",
    "RegExp",
    "String",
    "Symbol",
    "WeakRef",
    "Math",
    "Reflect",
    "escape",
    "unescape"
  ];
  const ReflectiveIntrinsicObjectNames$LWS = ["AggregateError", "Array", "Error", "EvalError", "Function", "Object", "Proxy", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "eval", "globalThis"];
  const ESGlobalsAndReflectiveIntrinsicObjectNames$LWS = toSafeArray$LWS([...ESGlobalKeys$LWS, ...ReflectiveIntrinsicObjectNames$LWS]);
  function assignFilteredGlobalDescriptorsFromPropertyDescriptorMap$LWS(descs$LWS, source$LWS) {
    const ownKeys$LWS = ReflectOwnKeys$LWS(source$LWS);
    for (let _i$LWS = 0, {
      length: _length$LWS
    } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      const ownKey$LWS = ownKeys$LWS[_i$LWS];
      if (!ESGlobalsAndReflectiveIntrinsicObjectNames$LWS.includes(ownKey$LWS)) {
        const _unsafeDesc$LWS = source$LWS[ownKey$LWS];
        if (_unsafeDesc$LWS) {
          descs$LWS[ownKey$LWS] = ObjectAssign$LWS({
            __proto__: null
          }, _unsafeDesc$LWS);
        }
      }
    }
    return descs$LWS;
  }
  function getFilteredGlobalOwnKeys$LWS(source$LWS) {
    const _result$LWS = [];
    let resultOffset$LWS = 0;
    const ownKeys$LWS = ReflectOwnKeys$LWS(source$LWS);
    for (let _i$LWS = 0, {
      length: _length$LWS
    } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      const ownKey$LWS = ownKeys$LWS[_i$LWS];
      if (!ESGlobalsAndReflectiveIntrinsicObjectNames$LWS.includes(ownKey$LWS)) {
        _result$LWS[resultOffset$LWS++] = ownKey$LWS;
      }
    }
    return _result$LWS;
  }
  function linkIntrinsics$LWS(env$LWS, _globalObject$LWS) {
    for (let _i$LWS = 0, {
      length: _length$LWS
    } = ReflectiveIntrinsicObjectNames$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      const globalName$LWS = ReflectiveIntrinsicObjectNames$LWS[_i$LWS];
      const reflectiveValue$LWS = _globalObject$LWS[globalName$LWS];
      if (reflectiveValue$LWS) {
        if (reflectiveValue$LWS.prototype) {
          env$LWS.link(globalName$LWS, "prototype");
        } else {
          env$LWS.link(globalName$LWS);
        }
      }
    }
  }
  const blueDocumentToRecordMap$LWS = toSafeWeakMap$LWS(new WeakMap());
  const unforgeablePoisonedWindowKeys$LWS = IS_CHROMIUM_BROWSER$LWS ? ["window"] : void 0;
  function getCachedGlobalObjectReferences$LWS(_globalObject$LWS) {
    const {
      window: window$LWS
    } = _globalObject$LWS;
    let _record$LWS;
    let _document$LWS;
    try {
      ({
        document: _document$LWS
      } = _globalObject$LWS);
      _record$LWS = blueDocumentToRecordMap$LWS.get(_document$LWS);
    } catch (__unused$LWS) {
      return void 0;
    }
    if (_record$LWS) {
      return _record$LWS;
    }
    const WindowProto$LWS = ReflectGetPrototypeOf$LWS(window$LWS);
    const WindowPropertiesProto$LWS = ReflectGetPrototypeOf$LWS(WindowProto$LWS);
    const EventTargetProto$LWS = ReflectGetPrototypeOf$LWS(WindowPropertiesProto$LWS);
    _record$LWS = {
      document: _document$LWS,
      DocumentProto: ReflectGetPrototypeOf$LWS(_document$LWS),
      window: window$LWS,
      WindowProto: ReflectGetPrototypeOf$LWS(window$LWS),
      WindowPropertiesProto: ReflectGetPrototypeOf$LWS(WindowProto$LWS),
      EventTargetProto: EventTargetProto$LWS,
      EventTargetProtoOwnKeys: ReflectOwnKeys$LWS(EventTargetProto$LWS)
    };
    blueDocumentToRecordMap$LWS.set(_document$LWS, _record$LWS);
    return _record$LWS;
  }
  function filterWindowKeys$LWS(_keys$LWS) {
    const _result$LWS = [];
    let resultOffset$LWS = 0;
    for (let _i$LWS = 0, {
      length: _length$LWS
    } = _keys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      const __key$LWS = _keys$LWS[_i$LWS];
      if (__key$LWS !== "document" && __key$LWS !== "location " && __key$LWS !== "top" && __key$LWS !== "window" && __key$LWS !== "chrome") {
        _result$LWS[resultOffset$LWS++] = __key$LWS;
      }
    }
    return _result$LWS;
  }
  function removeWindowDescriptors$LWS(_unsafeDescs$LWS) {
    ReflectDeleteProperty$LWS(_unsafeDescs$LWS, "document");
    ReflectDeleteProperty$LWS(_unsafeDescs$LWS, "location");
    ReflectDeleteProperty$LWS(_unsafeDescs$LWS, "top");
    ReflectDeleteProperty$LWS(_unsafeDescs$LWS, "window");
    ReflectDeleteProperty$LWS(_unsafeDescs$LWS, "chrome");
    return _unsafeDescs$LWS;
  }
  getCachedGlobalObjectReferences$LWS(rootWindow$LWS);
  const IFRAME_SANDBOX_ATTRIBUTE_VALUE$LWS = "allow-same-origin allow-scripts";
  const aliveIframes$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());
  const blueCreateHooksCallbackCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
  let defaultGlobalOwnKeys$LWS = null;
  function createDetachableIframe$LWS(doc$LWS) {
    var _ReflectApply$LWS;
    const iframe$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, doc$LWS, ["iframe"]);
    const parent$LWS = (_ReflectApply$LWS = ReflectApply$LWS(DocumentProtoBodyGetter$LWS, doc$LWS, [])) != null ? _ReflectApply$LWS : ReflectApply$LWS(NodeProtoLastChildGetter$LWS, doc$LWS, []);
    const _style$LWS = ReflectApply$LWS(HTMLElementProtoStyleGetter$LWS, iframe$LWS, []);
    _style$LWS.display = "none";
    ReflectApply$LWS(ElementProtoSetAttribute$LWS, iframe$LWS, ["sandbox", IFRAME_SANDBOX_ATTRIBUTE_VALUE$LWS]);
    ReflectApply$LWS(NodeProtoAppendChild$LWS, parent$LWS, [iframe$LWS]);
    return iframe$LWS;
  }
  function createIframeVirtualEnvironment$LWS(_globalObject$LWS, _providedOptions$LWS) {
    if (typeof _globalObject$LWS !== "object" || _globalObject$LWS === null) {
      throw new TypeErrorCtor$LWS("Missing global object virtualization target.");
    }
    const blueRefs$LWS = getCachedGlobalObjectReferences$LWS(_globalObject$LWS);
    if (typeof blueRefs$LWS !== "object" || blueRefs$LWS === null) {
      throw new TypeErrorCtor$LWS("Invalid virtualization target.");
    }
    const {
      distortionCallback: distortionCallback$LWS,
      endowments: endowments$LWS,
      globalObjectShape: globalObjectShape$LWS,
      instrumentation: instrumentation$LWS,
      keepAlive: keepAlive$LWS = true,
      liveTargetCallback: liveTargetCallback$LWS,
      signSourceCallback: signSourceCallback$LWS
    } = ObjectAssign$LWS({
      __proto__: null
    }, _providedOptions$LWS);
    const iframe$LWS = createDetachableIframe$LWS(blueRefs$LWS.document);
    const redWindow$LWS = ReflectApply$LWS(HTMLIFrameElementProtoContentWindowGetter$LWS, iframe$LWS, []);
    const shouldUseDefaultGlobalOwnKeys$LWS = typeof globalObjectShape$LWS !== "object" || globalObjectShape$LWS === null;
    if (shouldUseDefaultGlobalOwnKeys$LWS && defaultGlobalOwnKeys$LWS === null) {
      defaultGlobalOwnKeys$LWS = filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(redWindow$LWS));
    }
    let blueConnector$LWS = blueCreateHooksCallbackCache$LWS.get(blueRefs$LWS.document);
    if (blueConnector$LWS === void 0) {
      blueConnector$LWS = createBlueConnector$LWS(_globalObject$LWS);
      blueCreateHooksCallbackCache$LWS.set(blueRefs$LWS.document, blueConnector$LWS);
    }
    const {
      eval: redIndirectEval$LWS
    } = redWindow$LWS;
    const env$LWS = new VirtualEnvironment$LWS({
      blueConnector: blueConnector$LWS,
      redConnector: createRedConnector$LWS(signSourceCallback$LWS ? (_sourceText$LWS) => redIndirectEval$LWS(signSourceCallback$LWS(_sourceText$LWS)) : redIndirectEval$LWS),
      distortionCallback: distortionCallback$LWS,
      instrumentation: instrumentation$LWS,
      liveTargetCallback: liveTargetCallback$LWS,
      revokedProxyCallback: keepAlive$LWS ? revokedProxyCallback$LWS : void 0,
      signSourceCallback: signSourceCallback$LWS
    });
    linkIntrinsics$LWS(env$LWS, _globalObject$LWS);
    if (typeof globalThis === "undefined") {
      env$LWS.link("window", "document");
    } else {
      env$LWS.link("document");
    }
    env$LWS.link("__proto__", "__proto__", "__proto__");
    env$LWS.remapProto(blueRefs$LWS.document, blueRefs$LWS.DocumentProto);
    env$LWS.lazyRemapProperties(blueRefs$LWS.window, shouldUseDefaultGlobalOwnKeys$LWS ? defaultGlobalOwnKeys$LWS : filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(globalObjectShape$LWS)), keepAlive$LWS ? void 0 : unforgeablePoisonedWindowKeys$LWS);
    if (endowments$LWS) {
      const filteredEndowments$LWS = {};
      assignFilteredGlobalDescriptorsFromPropertyDescriptorMap$LWS(filteredEndowments$LWS, endowments$LWS);
      removeWindowDescriptors$LWS(filteredEndowments$LWS);
      env$LWS.remapProperties(blueRefs$LWS.window, filteredEndowments$LWS);
    }
    env$LWS.lazyRemapProperties(blueRefs$LWS.EventTargetProto, blueRefs$LWS.EventTargetProtoOwnKeys);
    if (keepAlive$LWS) {
      aliveIframes$LWS.add(iframe$LWS);
      const {
        document: redDocument$LWS
      } = redWindow$LWS;
      ReflectApply$LWS(DocumentProtoOpen$LWS, redDocument$LWS, []);
      ReflectApply$LWS(DocumentProtoClose$LWS, redDocument$LWS, []);
    } else {
      if (IS_OLD_CHROMIUM_BROWSER$LWS) {
        redIndirectEval$LWS("window");
      }
      ReflectApply$LWS(ElementProtoRemove$LWS, iframe$LWS, []);
    }
    return env$LWS;
  }
  function revokedProxyCallback$LWS(__value$LWS) {
    return aliveIframes$LWS.has(__value$LWS);
  }
  function createResourceLoadError$LWS(_url$LWS) {
    return new LockerSecurityError$LWS(`platformResourceLoader error loading ${enquote$LWS(_url$LWS)}.`);
  }
  const EMPTY_EVAL_HELPERS$LWS = {
    asyncToGen: noop$LWS$1,
    makeRedResyncImports: noop$LWS$1,
    forAwaitOf: noop$LWS$1,
    genToAsync: noop$LWS$1,
    loadScript: noop$LWS$1,
    loadStyle: noop$LWS$1,
    makeRedGet: noop$LWS$1,
    makeRedSyncImports: noop$LWS$1,
    namespace: noop$LWS$1,
    spreadable: noop$LWS$1,
    super: noop$LWS$1
  };
  const EVAL_HELPERS_SOURCE_TEXT$LWS = `'use strict';
        ${SANDBOX_EVAL_CONTEXT_NAME$LWS}(${function redHelpersFactory$LWS(baseGenToAsync$LWS, forAwaitOf$LWS, loadScript$LWS, loadStyle$LWS) {
    const ArrayCtor$LWS2 = Array;
    const {
      iterator: SymbolIterator$LWS2
    } = Symbol;
    const {
      [SymbolIterator$LWS2]: ArrayProtoIterator$LWS
    } = ArrayCtor$LWS2.prototype;
    const GeneratorProto$LWS = function* () {
    }.constructor.prototype.prototype;
    const {
      next: GeneratorProtoNext$LWS,
      throw: GeneratorProtoThrow$LWS
    } = GeneratorProto$LWS;
    const {
      defineProperties: ObjectDefineProperties$LWS2,
      freeze: ObjectFreeze$LWS2
    } = Object;
    const {
      apply: ReflectApply$LWS2,
      get: ReflectGet$LWS2,
      getPrototypeOf: ReflectGetPrototypeOf$LWS2,
      setPrototypeOf: ReflectSetPrototypeOf$LWS2
    } = Reflect;
    function genToAsync$LWS(func$LWS, thisArg$LWS) {
      let gen$LWS;
      const wrapGenMethod$LWS = (genMethod$LWS) => (__value$LWS) => {
        if (gen$LWS === void 0) {
          gen$LWS = ReflectApply$LWS2(func$LWS, thisArg$LWS, []);
        }
        return ReflectApply$LWS2(genMethod$LWS, gen$LWS, [__value$LWS]);
      };
      return baseGenToAsync$LWS(wrapGenMethod$LWS(GeneratorProtoNext$LWS), wrapGenMethod$LWS(GeneratorProtoThrow$LWS));
    }
    function makeRedGet$LWS(...bindings$LWS) {
      const {
        length: _length$LWS
      } = bindings$LWS;
      const redGet$LWS = ArrayCtor$LWS2(_length$LWS);
      const descriptors$LWS = {};
      for (let _i$LWS = 0; _i$LWS < _length$LWS; _i$LWS += 1) {
        descriptors$LWS[_i$LWS] = {
          __proto__: null,
          get: bindings$LWS[_i$LWS]
        };
      }
      ObjectDefineProperties$LWS2(redGet$LWS, descriptors$LWS);
      return redGet$LWS;
    }
    function makeRedSyncImports$LWS(bindings$LWS) {
      return function(..._args$LWS) {
        for (let _i$LWS = 0, {
          length: _length$LWS
        } = bindings$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
          try {
            bindings$LWS[_i$LWS];
          } catch (_unused35$LWS) {
          }
        }
        return spreadable$LWS(_args$LWS);
      };
    }
    function _namespace$LWS(object$LWS) {
      return ObjectFreeze$LWS2(object$LWS);
    }
    function spreadable$LWS(array$LWS) {
      ReflectSetPrototypeOf$LWS2(array$LWS, null);
      array$LWS[SymbolIterator$LWS2] = ArrayProtoIterator$LWS;
      return array$LWS;
    }
    function superApplyOrGet$LWS(__target$LWS, __key$LWS, thisArgOrReceiver$LWS, _args$LWS) {
      const superProto$LWS = ReflectGetPrototypeOf$LWS2(__target$LWS);
      if (superProto$LWS === null) {
        return void 0;
      }
      return _args$LWS ? ReflectApply$LWS2(superProto$LWS[__key$LWS], thisArgOrReceiver$LWS, _args$LWS) : ReflectGet$LWS2(superProto$LWS, __key$LWS, thisArgOrReceiver$LWS);
    }
    return {
      asyncToGen: genToAsync$LWS,
      makeRedResyncImports: makeRedSyncImports$LWS,
      forAwaitOf: forAwaitOf$LWS,
      genToAsync: genToAsync$LWS,
      loadScript: loadScript$LWS,
      loadStyle: loadStyle$LWS,
      makeRedGet: makeRedGet$LWS,
      makeRedSyncImports: makeRedSyncImports$LWS,
      namespace: _namespace$LWS,
      spreadable: spreadable$LWS,
      super: superApplyOrGet$LWS
    };
  }})`;
  function createEvalHelpersFactoryArgs$LWS(_record$LWS) {
    const {
      document: _document$LWS,
      document: {
        head: head$LWS
      },
      distortions: _distortions$LWS,
      globalObject: {
        HTMLScriptElement: {
          prototype: HTMLScriptElementProto$LWS2
        }
      },
      root: root$LWS
    } = _record$LWS;
    const isRootRecord$LWS = _record$LWS === root$LWS;
    const forOfStateCache$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
    const resourcePromiseCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
    const resourceStatusCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
    const scriptSrcGetterDistortion$LWS = _distortions$LWS.get(isRootRecord$LWS ? HTMLScriptElementProtoSrcGetter$LWS : ObjectLookupOwnGetter$LWS$1(HTMLScriptElementProto$LWS2, "src"));
    const scriptSrcSetterDistortion$LWS = _distortions$LWS.get(isRootRecord$LWS ? HTMLScriptElementProtoSrcSetter$LWS : ObjectLookupOwnSetter$LWS(HTMLScriptElementProto$LWS2, "src"));
    function genStep$LWS(_resolve$LWS, _reject$LWS, next$LWS, thrower$LWS, genMethodWrapper$LWS, arg$LWS) {
      let info$LWS;
      let __value$LWS;
      try {
        info$LWS = genMethodWrapper$LWS(arg$LWS);
        __value$LWS = info$LWS.value;
      } catch (error) {
        _reject$LWS(error);
        return;
      }
      if (info$LWS.done) {
        _resolve$LWS(__value$LWS);
      } else {
        ReflectApply$LWS$1(PromiseProtoThen$LWS, PromiseResolve$LWS(__value$LWS), [next$LWS, thrower$LWS]);
      }
    }
    function loadPromise$LWS(_element$LWS, urlAsString$LWS) {
      const _promise$LWS = new PromiseCtor$LWS((_resolve$LWS, _reject$LWS) => {
        function onerror$LWS(_event$LWS) {
          ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, _element$LWS, ["error", onerror$LWS]);
          ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, _element$LWS, ["load", onload$LWS]);
          ReflectApply$LWS$1(EventProtoStopPropagation$LWS, _event$LWS, []);
          resourceStatusCache$LWS.set(_element$LWS, 1);
          _reject$LWS(createResourceLoadError$LWS(urlAsString$LWS));
        }
        function onload$LWS() {
          ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, _element$LWS, ["error", onerror$LWS]);
          ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, _element$LWS, ["load", onload$LWS]);
          resourceStatusCache$LWS.set(_element$LWS, 3);
          _resolve$LWS(void 0);
        }
        ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, _element$LWS, ["error", onerror$LWS]);
        ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, _element$LWS, ["load", onload$LWS]);
      });
      resourceStatusCache$LWS.set(_element$LWS, 2);
      resourcePromiseCache$LWS.set(_element$LWS, _promise$LWS);
      ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, head$LWS, [_element$LWS]);
      return _promise$LWS;
    }
    return [
      function baseGenToAsync$LWS(genNextWrapper$LWS, genThrowWrapper$LWS) {
        return new PromiseCtor$LWS((_resolve$LWS, _reject$LWS) => {
          function next$LWS(__value$LWS) {
            genStep$LWS(_resolve$LWS, _reject$LWS, next$LWS, thrower$LWS, genNextWrapper$LWS, __value$LWS);
          }
          function thrower$LWS(error) {
            genStep$LWS(_resolve$LWS, _reject$LWS, next$LWS, thrower$LWS, genThrowWrapper$LWS, error);
          }
          next$LWS(void 0);
        });
      },
      function forAwaitOf$LWS(_index$LWS, stage$LWS, object$LWS) {
        if (stage$LWS === 0) {
          let sync$LWS = false;
          let {
            [SymbolAsyncIterator$LWS]: iterator$LWS
          } = object$LWS;
          if (iterator$LWS === null || iterator$LWS === void 0) {
            sync$LWS = true;
            ({
              [SymbolIterator$LWS$1]: iterator$LWS
            } = object$LWS);
          }
          if (typeof iterator$LWS !== "function") {
            throw new TypeErrorCtor$LWS$1("Object is not iterable.");
          }
          forOfStateCache$LWS.set(_index$LWS, {
            iterable: ReflectApply$LWS$1(iterator$LWS, object$LWS, []),
            step: void 0,
            sync: sync$LWS
          });
          return void 0;
        }
        const _state$LWS = forOfStateCache$LWS.get(_index$LWS);
        if (stage$LWS === 1) {
          const _result$LWS = _state$LWS.iterable.next();
          return _state$LWS.sync ? new PromiseCtor$LWS((_resolve$LWS) => {
            _state$LWS.step = _result$LWS;
            _resolve$LWS();
          }) : ReflectApply$LWS$1(PromiseProtoThen$LWS, _result$LWS, [(step$LWS) => {
            _state$LWS.step = step$LWS;
          }]);
        }
        if (stage$LWS === 2) {
          return _state$LWS.step.value;
        }
        if (stage$LWS === 3) {
          const done$LWS = !!_state$LWS.step.done;
          if (done$LWS) {
            forOfStateCache$LWS.delete(_index$LWS);
          }
          return done$LWS;
        }
        return void 0;
      },
      function loadScript$LWS(_thisArg$LWS, _url$LWS) {
        const urlAsString$LWS = toString$LWS(_url$LWS);
        const resolvedURL$LWS = resolveURL$LWS(urlAsString$LWS);
        const scripts$LWS = ReflectApply$LWS$1(ElementProtoQuerySelectorAll$LWS, head$LWS, ["script"]);
        for (let _i$LWS = 0, {
          length: _length$LWS
        } = scripts$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
          const script$LWS2 = scripts$LWS[_i$LWS];
          if (ReflectApply$LWS$1(scriptSrcGetterDistortion$LWS, script$LWS2, []) === resolvedURL$LWS) {
            var _resourceStatusCache$$LWS;
            const status$LWS = (_resourceStatusCache$$LWS = resourceStatusCache$LWS.get(script$LWS2)) != null ? _resourceStatusCache$$LWS : 0;
            if (status$LWS === 3) {
              return PromiseResolve$LWS(void 0);
            }
            if (status$LWS === 1) {
              return PromiseReject$LWS(createResourceLoadError$LWS(urlAsString$LWS));
            }
            if (status$LWS === 2) {
              return resourcePromiseCache$LWS.get(script$LWS2);
            }
          }
        }
        const script$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, _document$LWS, ["script"]);
        script$LWS.type = "text/javascript";
        ReflectApply$LWS$1(scriptSrcSetterDistortion$LWS, script$LWS, [urlAsString$LWS]);
        return loadPromise$LWS(script$LWS, urlAsString$LWS);
      },
      function loadStyle$LWS(_thisArg$LWS, _url$LWS) {
        const urlAsString$LWS = toString$LWS(_url$LWS);
        let link$LWS = ReflectApply$LWS$1(ElementProtoQuerySelector$LWS, head$LWS, [`link[href=${enquote$LWS(urlAsString$LWS)}]`]);
        if (link$LWS) {
          var _resourceStatusCache$2$LWS;
          const status$LWS = (_resourceStatusCache$2$LWS = resourceStatusCache$LWS.get(link$LWS)) != null ? _resourceStatusCache$2$LWS : 0;
          if (status$LWS === 0 || status$LWS === 3) {
            return PromiseResolve$LWS(void 0);
          }
          if (status$LWS === 1) {
            return PromiseReject$LWS(createResourceLoadError$LWS(urlAsString$LWS));
          }
          const _promise$LWS = status$LWS === 2 ? resourcePromiseCache$LWS.get(link$LWS) : void 0;
          return _promise$LWS != null ? _promise$LWS : PromiseResolve$LWS(void 0);
        }
        link$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, _document$LWS, ["link"]);
        link$LWS.type = "text/css";
        link$LWS.rel = "stylesheet";
        link$LWS.href = urlAsString$LWS;
        return loadPromise$LWS(link$LWS, urlAsString$LWS);
      }
    ];
  }
  function toSourceText$LWS(__value$LWS, sourceType$LWS) {
    let _sourceText$LWS = typeof __value$LWS === "function" ? extractFunctionBodySource$LWS(__value$LWS) : toString$LWS(__value$LWS);
    _sourceText$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, _sourceText$LWS, [
      /\/\/# sandbox(?=MappingURL=.*?\s*$)/,
      "//# source"
    ]);
    return sourceType$LWS === 1 && indexOfPragma$LWS(_sourceText$LWS, "use strict") === -1 ? `'use strict';${_sourceText$LWS}` : _sourceText$LWS;
  }
  const rootSandboxRegistry$LWS = {
    __proto__: null
  };
  const documentSandboxRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1([[rootDocument$LWS, rootSandboxRegistry$LWS]]));
  const opaqueWindowSandboxRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  function getOpaqueSandboxRegistry$LWS(_globalObject$LWS) {
    let sandboxRegistry$LWS = opaqueWindowSandboxRegistryCache$LWS.get(_globalObject$LWS);
    if (sandboxRegistry$LWS === void 0) {
      sandboxRegistry$LWS = {
        __proto__: null
      };
      opaqueWindowSandboxRegistryCache$LWS.set(_globalObject$LWS, sandboxRegistry$LWS);
    }
    return sandboxRegistry$LWS;
  }
  function getSandboxRegistry$LWS(_document$LWS) {
    let sandboxRegistry$LWS = documentSandboxRegistryCache$LWS.get(_document$LWS);
    if (sandboxRegistry$LWS === void 0) {
      sandboxRegistry$LWS = {
        __proto__: null
      };
      documentSandboxRegistryCache$LWS.set(_document$LWS, sandboxRegistry$LWS);
    }
    return sandboxRegistry$LWS;
  }
  const IFRAME_KEEP_ALIVE_FLAG$LWS = LOCKER_UNMINIFIED_FLAG$LWS$1 && true;
  const rootDistortionMapSeedEntries$LWS = [[rootDocument$LWS, rootDocument$LWS], [rootWindowLocation$LWS, rootWindowLocation$LWS], [rootWindow$LWS$1, rootWindow$LWS$1]];
  const rendererFactoryToRendererCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const seenGlobalObjects$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
  function createGetVirtualEnvironment$LWS(_record$LWS) {
    let virtualEnvironment$LWS;
    return () => {
      if (virtualEnvironment$LWS === void 0) {
        virtualEnvironment$LWS = createVirtualEnvironment$LWS(_record$LWS);
      }
      return virtualEnvironment$LWS;
    };
  }
  function createTrackAsFastTarget$LWS(getVirtualEnvironment$LWS) {
    let virtualEnvironment$LWS;
    return (__target$LWS) => {
      if (virtualEnvironment$LWS === void 0) {
        virtualEnvironment$LWS = getVirtualEnvironment$LWS();
      }
      virtualEnvironment$LWS.trackAsFastTarget(__target$LWS);
    };
  }
  function createVirtualEnvironmentEvaluator$LWS(_record$LWS, getVirtualEnvironment$LWS) {
    let virtualEnvironment$LWS;
    return (_sourceText$LWS) => {
      if (virtualEnvironment$LWS === void 0) {
        virtualEnvironment$LWS = getVirtualEnvironment$LWS();
        const _context$LWS = clearEvalContext$LWS();
        setEvalContext$LWS((redEvalHelpersFactory$LWS) => {
          const helpers$LWS = ReflectApply$LWS$1(redEvalHelpersFactory$LWS, void 0, createEvalHelpersFactoryArgs$LWS(_record$LWS));
          _record$LWS.helpers = helpers$LWS;
          setEvalHelpers$LWS(helpers$LWS);
        });
        virtualEnvironment$LWS.evaluate(EVAL_HELPERS_SOURCE_TEXT$LWS);
        if (typeof _context$LWS === "object" && _context$LWS !== null) {
          virtualEnvironment$LWS.trackAsFastTarget(_context$LWS);
          const ownKeys$LWS = ReflectOwnKeys$LWS$1(_context$LWS);
          for (let _i$LWS = 0, {
            length: _length$LWS
          } = ownKeys$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
            const __value$LWS = _context$LWS[ownKeys$LWS[_i$LWS]];
            if (typeof __value$LWS === "object" && __value$LWS !== null) {
              virtualEnvironment$LWS.trackAsFastTarget(__value$LWS);
            }
          }
        }
        setEvalContext$LWS(_context$LWS);
      }
      return virtualEnvironment$LWS.evaluate(_sourceText$LWS);
    };
  }
  function createSandboxEvaluator$LWS({
    LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: verboseInstrumentation$LWS,
    document: _document$LWS,
    globalObject: _globalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: __key$LWS,
    type: _type$LWS
  }) {
    return (_sourceText$LWS, evalContext$LWS, evalGlobalObject$LWS = _globalObject$LWS, evalDocument$LWS = _document$LWS) => internalEvaluateInSandbox$LWS({
      context: evalContext$LWS,
      document: evalDocument$LWS,
      endowments: EMPTY_OBJECT$LWS,
      globalObject: evalGlobalObject$LWS,
      instrumentation: instrumentation$LWS,
      key: __key$LWS,
      source: _sourceText$LWS,
      sourceType: 0,
      type: _type$LWS,
      verboseInstrumentation: verboseInstrumentation$LWS
    });
  }
  function createVirtualEnvironment$LWS(_record$LWS) {
    const {
      LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: verboseInstrumentation$LWS,
      distortions: overrideDistortions$LWS,
      endowments: endowments$LWS,
      globalObject: _globalObject$LWS,
      instrumentation: instrumentation$LWS,
      key: __key$LWS,
      root: root$LWS,
      root: {
        distortions: _distortions$LWS
      },
      type: _type$LWS
    } = _record$LWS;
    const isRootRecord$LWS = _record$LWS === root$LWS;
    return createIframeVirtualEnvironment$LWS(_globalObject$LWS, {
      distortionCallback(originalTarget$LWS) {
        const distortedTarget$LWS = _distortions$LWS.get(originalTarget$LWS);
        if (distortedTarget$LWS) {
          return isRootRecord$LWS ? distortedTarget$LWS : overrideDistortions$LWS.get(originalTarget$LWS) || distortedTarget$LWS;
        }
        if (typeof originalTarget$LWS === "function") {
          return originalTarget$LWS;
        }
        try {
          if (!ObjectHasOwn$LWS$1(originalTarget$LWS, "location")) {
            return originalTarget$LWS;
          }
        } catch (_unused36$LWS) {
          return originalTarget$LWS;
        }
        let originalTargetDocument$LWS;
        let originalTargetWindow$LWS;
        if (ObjectHasOwn$LWS$1(originalTarget$LWS, "window") && originalTarget$LWS.window === originalTarget$LWS) {
          try {
            originalTargetDocument$LWS = ReflectApply$LWS$1(WindowDocumentGetter$LWS, originalTarget$LWS, []);
            originalTargetWindow$LWS = originalTarget$LWS;
          } catch (_unused37$LWS) {
            try {
              if (ReflectApply$LWS$1(WindowLocationGetter$LWS, originalTarget$LWS, [])) {
                createOpaqueSecondaryWindowSandboxRecord$LWS({
                  globalObject: originalTarget$LWS,
                  key: __key$LWS,
                  type: _type$LWS
                }, root$LWS);
                return originalTarget$LWS;
              }
            } catch (_unused38$LWS) {
            }
          }
        } else if ("defaultView" in originalTarget$LWS) {
          let _defaultView$LWS;
          try {
            _defaultView$LWS = ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, originalTarget$LWS, []);
          } catch (_unused39$LWS) {
          }
          if (_defaultView$LWS) {
            originalTargetDocument$LWS = originalTarget$LWS;
            originalTargetWindow$LWS = _defaultView$LWS;
          }
        }
        if (originalTargetWindow$LWS) {
          createSecondaryWindowSandboxRecord$LWS({
            context: EMPTY_OBJECT$LWS,
            document: originalTargetDocument$LWS,
            globalObject: originalTargetWindow$LWS,
            key: __key$LWS,
            type: _type$LWS
          }, root$LWS);
        }
        return originalTarget$LWS;
      },
      endowments: endowments$LWS && endowments$LWS !== EMPTY_OBJECT$LWS ? ObjectAssign$LWS$1({}, DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS, ObjectGetOwnPropertyDescriptors$LWS(endowments$LWS)) : DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS,
      instrumentation: verboseInstrumentation$LWS ? instrumentation$LWS : void 0,
      keepAlive: IFRAME_KEEP_ALIVE_FLAG$LWS,
      liveTargetCallback: isTargetLive$LWS,
      signSourceCallback: (_sourceText$LWS) => trusted.createScript(_sourceText$LWS)
    });
  }
  function getDefaultType$LWS(__key$LWS) {
    return __key$LWS === CORE_SANDBOX_KEY$LWS ? 1 : 0;
  }
  function createRootWindowSandboxRecord$LWS({
    context: _context$LWS = EMPTY_OBJECT$LWS,
    endowments: endowments$LWS = EMPTY_OBJECT$LWS,
    instrumentation: instrumentation$LWS = EMPTY_OBJECT$LWS,
    key: __key$LWS,
    type: _type$LWS = getDefaultType$LWS(__key$LWS),
    verboseInstrumentation: verboseInstrumentation$LWS = false
  }) {
    let _record$LWS = rootSandboxRegistry$LWS[__key$LWS];
    if (_record$LWS) {
      return _record$LWS;
    }
    const LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS = instrumentation$LWS !== EMPTY_OBJECT$LWS && typeof instrumentation$LWS === "object" && instrumentation$LWS !== null;
    const _distortions$LWS = createDistortionMap$LWS(rootDistortionMapSeedEntries$LWS);
    _record$LWS = {
      BASIC_INSTRUMENTATION_DATA: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? {
        sandboxKey: __key$LWS
      } : EMPTY_OBJECT$LWS,
      LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
      LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: verboseInstrumentation$LWS && LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
      UNCOMPILED_CONTEXT: ROOT_UNCOMPILED_CONTEXT$LWS,
      context: _context$LWS,
      document: rootDocument$LWS,
      distortions: _distortions$LWS,
      endowments: endowments$LWS,
      globalObject: rootWindow$LWS$1,
      helpers: EMPTY_EVAL_HELPERS$LWS,
      instrumentation: instrumentation$LWS,
      key: __key$LWS,
      root: EMPTY_OBJECT$LWS,
      sandboxEvaluator: noop$LWS$1,
      trackAsFastTarget: noop$LWS$1,
      type: _type$LWS,
      virtualEnvironmentEvaluator: noop$LWS$1
    };
    const getVirtualEnvironment$LWS = createGetVirtualEnvironment$LWS(_record$LWS);
    _record$LWS.root = _record$LWS;
    _record$LWS.sandboxEvaluator = createSandboxEvaluator$LWS(_record$LWS);
    _record$LWS.trackAsFastTarget = createTrackAsFastTarget$LWS(getVirtualEnvironment$LWS);
    _record$LWS.virtualEnvironmentEvaluator = createVirtualEnvironmentEvaluator$LWS(_record$LWS, getVirtualEnvironment$LWS);
    const entries$LWS = createDistortionEntries$LWS(_record$LWS, getDistortionFactories$LWS(_record$LWS));
    for (let _i$LWS = 0, {
      length: _length$LWS
    } = entries$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      const {
        0: entryKey$LWS,
        1: entryValue$LWS
      } = entries$LWS[_i$LWS];
      _distortions$LWS.set(entryKey$LWS, entryValue$LWS);
    }
    rootSandboxRegistry$LWS[__key$LWS] = _record$LWS;
    return _record$LWS;
  }
  function createOpaqueSecondaryWindowSandboxRecord$LWS({
    globalObject: _globalObject$LWS,
    key: __key$LWS,
    type: _type$LWS = getDefaultType$LWS(__key$LWS)
  }, root$LWS) {
    const sandboxRegistry$LWS = getOpaqueSandboxRegistry$LWS(_globalObject$LWS);
    let _record$LWS = sandboxRegistry$LWS[__key$LWS];
    if (_record$LWS) {
      return _record$LWS;
    }
    const {
      BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
      LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
      LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
      distortions: _distortions$LWS,
      instrumentation: instrumentation$LWS
    } = root$LWS;
    _record$LWS = {
      BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
      LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
      LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
      UNCOMPILED_CONTEXT: EMPTY_OBJECT$LWS,
      context: EMPTY_OBJECT$LWS,
      document,
      distortions: EMPTY_DISTORTIONS_MAP$LWS,
      endowments: EMPTY_OBJECT$LWS,
      globalObject: _globalObject$LWS,
      helpers: EMPTY_EVAL_HELPERS$LWS,
      instrumentation: instrumentation$LWS,
      key: __key$LWS,
      root: root$LWS,
      sandboxEvaluator: noop$LWS$1,
      trackAsFastTarget: noop$LWS$1,
      type: _type$LWS,
      virtualEnvironmentEvaluator: noop$LWS$1
    };
    const {
      location: location$LWS
    } = _globalObject$LWS;
    _distortions$LWS.set(location$LWS, location$LWS);
    if (!seenGlobalObjects$LWS.has(_globalObject$LWS)) {
      _distortions$LWS.set(_globalObject$LWS, _globalObject$LWS);
    }
    const opaqueWindowPostMessageDistortionFactory$LWS = getOpaqueWindowPostMessageDistortionFactory$LWS(_record$LWS);
    const opaqueWindowPostMessageDistortionEntry$LWS = opaqueWindowPostMessageDistortionFactory$LWS(_record$LWS);
    const originalOpaqueWindowPostMessage$LWS = opaqueWindowPostMessageDistortionEntry$LWS[0];
    _distortions$LWS.set(originalOpaqueWindowPostMessage$LWS, proxyMaskFunctionDistortion$LWS(_record$LWS, opaqueWindowPostMessageDistortionFactory$LWS, opaqueWindowPostMessageDistortionEntry$LWS[1], originalOpaqueWindowPostMessage$LWS));
    sandboxRegistry$LWS[__key$LWS] = _record$LWS;
    return _record$LWS;
  }
  function createSecondaryWindowSandboxRecord$LWS({
    globalObject: _globalObject$LWS,
    document: _document$LWS,
    context: _context$LWS = EMPTY_OBJECT$LWS,
    key: __key$LWS,
    type: _type$LWS = getDefaultType$LWS(__key$LWS)
  }, root$LWS) {
    const sandboxRegistry$LWS = getSandboxRegistry$LWS(_document$LWS);
    let _record$LWS = sandboxRegistry$LWS[__key$LWS];
    if (_record$LWS) {
      return _record$LWS;
    }
    const {
      BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
      LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
      LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
      distortions: _distortions$LWS,
      instrumentation: instrumentation$LWS
    } = root$LWS;
    const {
      location: location$LWS
    } = _globalObject$LWS;
    const overrideDistortions$LWS = createDistortionMap$LWS();
    _record$LWS = {
      BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
      LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
      LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
      UNCOMPILED_CONTEXT: {
        [UNCOMPILED_LOCATION_NAME$LWS]: location$LWS,
        [UNCOMPILED_TOP_NAME$LWS]: _globalObject$LWS.top
      },
      context: _context$LWS,
      document: _document$LWS,
      distortions: overrideDistortions$LWS,
      endowments: EMPTY_OBJECT$LWS,
      globalObject: _globalObject$LWS,
      helpers: EMPTY_EVAL_HELPERS$LWS,
      instrumentation: instrumentation$LWS,
      key: __key$LWS,
      root: root$LWS,
      sandboxEvaluator: noop$LWS$1,
      trackAsFastTarget: noop$LWS$1,
      type: _type$LWS,
      virtualEnvironmentEvaluator: noop$LWS$1
    };
    const getVirtualEnvironment$LWS = createGetVirtualEnvironment$LWS(_record$LWS);
    _record$LWS.sandboxEvaluator = createSandboxEvaluator$LWS(_record$LWS);
    _record$LWS.trackAsFastTarget = createTrackAsFastTarget$LWS(getVirtualEnvironment$LWS);
    _record$LWS.virtualEnvironmentEvaluator = createVirtualEnvironmentEvaluator$LWS(_record$LWS, getVirtualEnvironment$LWS);
    _distortions$LWS.set(_document$LWS, _document$LWS);
    _distortions$LWS.set(location$LWS, location$LWS);
    const seenGlobalObject$LWS = seenGlobalObjects$LWS.has(_globalObject$LWS);
    if (!seenGlobalObject$LWS) {
      _distortions$LWS.set(_globalObject$LWS, _globalObject$LWS);
    }
    const entries$LWS = createDistortionEntries$LWS(_record$LWS, getDistortionFactories$LWS(_record$LWS));
    for (let _i$LWS = 0, {
      length: _length$LWS
    } = entries$LWS; _i$LWS < _length$LWS; _i$LWS += 1) {
      const {
        0: entryKey$LWS,
        1: entryValue$LWS
      } = entries$LWS[_i$LWS];
      _distortions$LWS.set(entryKey$LWS, entryValue$LWS);
    }
    const evalDistortionFactory$LWS = getEvalDistortionFactory$LWS(_record$LWS);
    const evalDistortionEntry$LWS = evalDistortionFactory$LWS(_record$LWS);
    const _originalEval$LWS = evalDistortionEntry$LWS[0];
    _distortions$LWS.set(_originalEval$LWS, proxyMaskFunctionDistortion$LWS(_record$LWS, evalDistortionFactory$LWS, evalDistortionEntry$LWS[1], _originalEval$LWS));
    overrideDistortions$LWS.set(_originalEval$LWS, _originalEval$LWS);
    sandboxRegistry$LWS[__key$LWS] = _record$LWS;
    if (seenGlobalObject$LWS) {
      return _record$LWS;
    }
    seenGlobalObjects$LWS.add(_globalObject$LWS);
    const onDOMContentLoadedOrWindowLoad$LWS = () => {
      try {
        const {
          document: newDocument$LWS
        } = _globalObject$LWS;
        if (_document$LWS !== newDocument$LWS) {
          createSecondaryWindowSandboxRecord$LWS({
            context: EMPTY_OBJECT$LWS,
            document: newDocument$LWS,
            globalObject: _globalObject$LWS,
            key: __key$LWS,
            type: _type$LWS
          }, root$LWS);
        }
      } catch (_unused40$LWS) {
        createOpaqueSecondaryWindowSandboxRecord$LWS({
          globalObject: _globalObject$LWS,
          key: __key$LWS,
          type: _type$LWS
        }, root$LWS);
      }
    };
    const frameElement$LWS = ReflectApply$LWS$1(WindowFrameElementGetter$LWS, _globalObject$LWS, []);
    if (frameElement$LWS) {
      ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, frameElement$LWS, [
        "load",
        onDOMContentLoadedOrWindowLoad$LWS,
        true
      ]);
    } else {
      ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, _globalObject$LWS, [
        "unload",
        function onWindowUnload$LWS() {
          WindowQueueMicrotask$LWS(() => {
            try {
              const {
                document: newDocument$LWS
              } = _globalObject$LWS;
              if (_document$LWS !== newDocument$LWS) {
                ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, _globalObject$LWS, ["DOMContentLoaded", onDOMContentLoadedOrWindowLoad$LWS, true]);
                ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, _globalObject$LWS, ["unload", onWindowUnload$LWS, true]);
              }
            } catch (_unused41$LWS) {
              createOpaqueSecondaryWindowSandboxRecord$LWS({
                globalObject: _globalObject$LWS,
                key: __key$LWS,
                type: _type$LWS
              }, root$LWS);
            }
          });
        },
        true
      ]);
    }
    return _record$LWS;
  }
  function internalEvaluateInSandbox$LWS(evaluateOptions$LWS) {
    const {
      document: _document$LWS,
      context: _context$LWS,
      endowments: endowments$LWS,
      globalObject: _globalObject$LWS,
      instrumentation: instrumentation$LWS,
      key: __key$LWS,
      source: source$LWS,
      sourceType: sourceType$LWS,
      type: _type$LWS,
      verboseInstrumentation: verboseInstrumentation$LWS
    } = evaluateOptions$LWS;
    if (typeof __key$LWS !== "string") {
      throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
    }
    const {
      BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
      LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG: LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS,
      helpers: helpers$LWS,
      virtualEnvironmentEvaluator: virtualEnvironmentEvaluator$LWS
    } = _globalObject$LWS === rootWindow$LWS$1 ? createRootWindowSandboxRecord$LWS({
      context: _context$LWS,
      endowments: endowments$LWS,
      instrumentation: instrumentation$LWS,
      key: __key$LWS,
      type: _type$LWS,
      verboseInstrumentation: verboseInstrumentation$LWS
    }) : createSecondaryWindowSandboxRecord$LWS({
      context: _context$LWS,
      document: _document$LWS,
      globalObject: _globalObject$LWS,
      key: __key$LWS,
      type: _type$LWS
    }, rootSandboxRegistry$LWS[__key$LWS]);
    if (_context$LWS !== EMPTY_OBJECT$LWS) {
      if (ObjectHasOwn$LWS$1(_context$LWS, "renderer") && ObjectHasOwn$LWS$1(_context$LWS, "rendererFactory")) {
        const {
          rendererFactory: rendererFactory$LWS
        } = _context$LWS;
        let sandboxedRenderer$LWS = rendererFactoryToRendererCache$LWS.get(rendererFactory$LWS);
        if (sandboxedRenderer$LWS === void 0) {
          sandboxedRenderer$LWS = virtualEnvironmentEvaluator$LWS(`'use strict';
                    (${ReflectApply$LWS$1(FunctionProtoToString$LWS, rendererFactory$LWS, [])})`)(_context$LWS.renderer);
          rendererFactoryToRendererCache$LWS.set(rendererFactory$LWS, sandboxedRenderer$LWS);
        }
        _context$LWS.renderer = sandboxedRenderer$LWS;
        ReflectDeleteProperty$LWS$1(_context$LWS, "rendererFactory");
      }
      setEvalContext$LWS(_context$LWS);
    }
    if (helpers$LWS !== EMPTY_EVAL_HELPERS$LWS) {
      setEvalHelpers$LWS(helpers$LWS);
    }
    let _result$LWS;
    const _sourceText$LWS = toSourceText$LWS(source$LWS, sourceType$LWS);
    const startActivity$LWS = LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS.startActivity : void 0;
    let activity$LWS;
    if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
      activity$LWS = startActivity$LWS("evaluateInSandbox", BASIC_INSTRUMENTATION_DATA$LWS);
    }
    try {
      _result$LWS = virtualEnvironmentEvaluator$LWS(_sourceText$LWS);
    } catch (error) {
      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
        activity$LWS.error({
          sandboxKey: __key$LWS,
          error
        });
      }
      throw error;
    } finally {
      clearEvalContext$LWS();
      clearEvalHelpers$LWS();
    }
    if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG$LWS) {
      activity$LWS.stop();
    }
    return _result$LWS;
  }
  function evaluateInSandbox$LWS(__key$LWS, source$LWS, _context$LWS = EMPTY_OBJECT$LWS, endowments$LWS = EMPTY_OBJECT$LWS, instrumentation$LWS = EMPTY_OBJECT$LWS, verboseInstrumentation$LWS = false) {
    return internalEvaluateInSandbox$LWS({
      context: _context$LWS,
      document: rootDocument$LWS,
      endowments: endowments$LWS,
      globalObject: rootWindow$LWS$1,
      instrumentation: instrumentation$LWS,
      key: __key$LWS,
      source: source$LWS,
      sourceType: 1,
      type: 0,
      verboseInstrumentation: verboseInstrumentation$LWS
    });
  }
  const loaderDefine = globalThis.LWR.define;
  function markLiveObject(object) {
    Reflect.defineProperty(object, Symbol.for("@@lockerLiveValue"), {});
    return object;
  }
  function vNextEvaluateModule(namespace, specifier, exporter) {
    let out;
    const src = `"use strict";$lockerEvalContext$(${exporter.toString()});
//# sourceURL=modules/${specifier}.js
`;
    evaluateInSandbox$LWS(namespace, src, (def) => {
      out = def;
    });
    return out;
  }
  function secureExporter(specifier, dependencies, exporter, trustedNamespaces) {
    const [namespace, name] = specifier.split("/");
    if (trustedNamespaces.includes(namespace) || trustedNamespaces.includes(`${namespace}/*`) || trustedNamespaces.includes(`${namespace}/${name}`)) {
      return exporter;
    }
    const out = vNextEvaluateModule(namespace, specifier, exporter);
    const exportsIndex = dependencies.indexOf("exports");
    if (exportsIndex >= 0) {
      return function(...args) {
        const modifiedArgs = args.map((arg, index) => {
          return index === exportsIndex && markLiveObject(arg) || arg;
        });
        return out.apply(this, modifiedArgs);
      };
    }
    return out;
  }
  function registerLockerDefine(trustedNamespaces) {
    globalThis.LWR = Object.freeze(Object.assign(Object.assign({}, globalThis.LWR), {
      define: function(specifier, dependencies, exporter, signature) {
        if (typeof dependencies === "function") {
          signature = exporter;
          exporter = dependencies;
          dependencies = [];
        }
        loaderDefine(specifier, dependencies, secureExporter(specifier, dependencies, exporter, trustedNamespaces), signature);
      }
    }));
  }
  exports.registerLockerDefine = registerLockerDefine;
  Object.defineProperty(exports, "__esModule", {value: true});
});
LWR.define("lwr/metrics/v/0_9_0", ["exports"], function(exports) {
  "use strict";
  const BOOTSTRAP_PREFIX = "lwr.bootstrap.";
  const BOOTSTRAP_END = `${BOOTSTRAP_PREFIX}end`;
  const BOOTSTRAP_ERROR = `${BOOTSTRAP_PREFIX}error`;
  const BOOTSTRAP_ERROR_COUNT = `${BOOTSTRAP_ERROR}.count`;
  const BOOTSTRAP_DURATION = `${BOOTSTRAP_PREFIX}duration`;
  const LOADER_PREFIX = "lwr.loader.";
  const MODULE_DEFINE = `${LOADER_PREFIX}module.define`;
  const MODULE_DEFINE_COUNT = `${MODULE_DEFINE}.count`;
  const MODULE_FETCH = `${LOADER_PREFIX}module.fetch`;
  const MODULE_FETCH_COUNT = `${MODULE_FETCH}.count`;
  const MODULE_FETCH_DURATION = `${MODULE_FETCH}.duration`;
  const MODULE_ERROR = `${LOADER_PREFIX}module.error`;
  const MODULE_ERROR_COUNT = `${MODULE_ERROR}.count`;
  const MAPPINGS_FETCH = `${LOADER_PREFIX}mappings.fetch`;
  const MAPPINGS_FETCH_COUNT = `${MAPPINGS_FETCH}.count`;
  const MAPPINGS_FETCH_DURATION = `${MAPPINGS_FETCH}.duration`;
  const MAPPINGS_ERROR = `${LOADER_PREFIX}mappings.error`;
  const MAPPINGS_ERROR_COUNT = `${MAPPINGS_ERROR}.count`;
  const ROUTER_PREFIX = "lwr.router.";
  const ROUTER_NAV = `${ROUTER_PREFIX}navigate`;
  const ROUTER_NAV_COUNT = `${ROUTER_NAV}.count`;
  const ROUTER_NAV_DURATION = `${ROUTER_NAV}.duration`;
  const ROUTER_VIEW = `${ROUTER_PREFIX}view`;
  const ROUTER_VIEW_DURATION = `${ROUTER_VIEW}.duration`;
  const ROUTER_ERROR = `${ROUTER_PREFIX}error`;
  const ROUTER_ERROR_COUNT = `${ROUTER_ERROR}.count`;
  exports.BOOTSTRAP_DURATION = BOOTSTRAP_DURATION;
  exports.BOOTSTRAP_END = BOOTSTRAP_END;
  exports.BOOTSTRAP_ERROR = BOOTSTRAP_ERROR;
  exports.BOOTSTRAP_ERROR_COUNT = BOOTSTRAP_ERROR_COUNT;
  exports.BOOTSTRAP_PREFIX = BOOTSTRAP_PREFIX;
  exports.LOADER_PREFIX = LOADER_PREFIX;
  exports.MAPPINGS_ERROR = MAPPINGS_ERROR;
  exports.MAPPINGS_ERROR_COUNT = MAPPINGS_ERROR_COUNT;
  exports.MAPPINGS_FETCH = MAPPINGS_FETCH;
  exports.MAPPINGS_FETCH_COUNT = MAPPINGS_FETCH_COUNT;
  exports.MAPPINGS_FETCH_DURATION = MAPPINGS_FETCH_DURATION;
  exports.MODULE_DEFINE = MODULE_DEFINE;
  exports.MODULE_DEFINE_COUNT = MODULE_DEFINE_COUNT;
  exports.MODULE_ERROR = MODULE_ERROR;
  exports.MODULE_ERROR_COUNT = MODULE_ERROR_COUNT;
  exports.MODULE_FETCH = MODULE_FETCH;
  exports.MODULE_FETCH_COUNT = MODULE_FETCH_COUNT;
  exports.MODULE_FETCH_DURATION = MODULE_FETCH_DURATION;
  exports.ROUTER_ERROR = ROUTER_ERROR;
  exports.ROUTER_ERROR_COUNT = ROUTER_ERROR_COUNT;
  exports.ROUTER_NAV = ROUTER_NAV;
  exports.ROUTER_NAV_COUNT = ROUTER_NAV_COUNT;
  exports.ROUTER_NAV_DURATION = ROUTER_NAV_DURATION;
  exports.ROUTER_PREFIX = ROUTER_PREFIX;
  exports.ROUTER_VIEW = ROUTER_VIEW;
  exports.ROUTER_VIEW_DURATION = ROUTER_VIEW_DURATION;
  Object.defineProperty(exports, "__esModule", {value: true});
});
LWR.define("lwr/init/v/0_9_0", ["exports", "lwr/metrics/v/0_9_0", "lwr/profiler/v/0_9_0", "lwc/v/2_41_4"], function(exports, _0_9_0$1, _0_9_0, _2_41_4) {
  "use strict";
  function initializeWebComponent(elementName, Ctor) {
    return _2_41_4.createElement(elementName, {
      is: Ctor
    });
  }
  function toKebabCase(specifier) {
    return specifier.replace(/\/v\/[a-zA-Z0-9-_.]+$/, "").replace("/", "-").replace(/([A-Z])/g, (c) => `-${c.toLowerCase()}`);
  }
  const CAMEL_REGEX = /-([a-z])/g;
  function getPropFromAttrName(propName) {
    return propName.replace(CAMEL_REGEX, (g) => g[1].toUpperCase());
  }
  function init(rootModules) {
    if (typeof customElements !== "undefined" && typeof document !== "undefined") {
      const container = document.querySelector("[lwr-root]");
      rootModules.forEach(([moduleSpecifier, ctor]) => {
        const elementName = toKebabCase(moduleSpecifier);
        let el = document.body.querySelector(elementName);
        if (!el) {
          el = initializeWebComponent(elementName, ctor);
          if (container) {
            container.appendChild(el);
          } else {
            document.body.appendChild(el);
          }
        } else {
          const customElements2 = document.querySelectorAll(elementName);
          customElements2.forEach((customElement) => {
            const newElement = initializeWebComponent(elementName, ctor);
            for (const {
              name,
              value
            } of customElement.attributes) {
              newElement.setAttribute(name, value);
              const prop = getPropFromAttrName(name);
              if (prop in newElement) {
                newElement[prop] = value;
              }
            }
            while (customElement.childNodes.length > 0) {
              newElement.appendChild(customElement.childNodes[0]);
            }
            customElement.parentElement.replaceChild(newElement, customElement);
          });
        }
      });
    }
    _0_9_0.logOperationStart({
      id: _0_9_0$1.BOOTSTRAP_END
    });
  }
  exports.getPropFromAttrName = getPropFromAttrName;
  exports.init = init;
  exports.toKebabCase = toKebabCase;
  Object.defineProperty(exports, "__esModule", {value: true});
});
LWR.define("webruntime/dynamicImportResourceHook/v/1_66_319-244_0", ["exports", "@app/basePath/v/1", "@app/versionKey/v/1"], function(exports, basePath, versionKey) {
  "use strict";
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : {default: e};
  }
  var basePath__default = /* @__PURE__ */ _interopDefaultLegacy(basePath);
  var versionKey__default = /* @__PURE__ */ _interopDefaultLegacy(versionKey);
  function DynamicImportResourceHook(serviceAPI) {
    const resourceUrlSpecifier = "@salesforce/resourceUrl/";
    const resourceUrlResolvedBaseUrl = "resourceUrl://";
    serviceAPI.addLoaderPlugin({
      resolveModule: async (id) => {
        if (id.startsWith(resourceUrlSpecifier)) {
          return {
            url: `${resourceUrlResolvedBaseUrl}${id}`
          };
        }
        return null;
      },
      loadModule: async (url) => {
        if (url.startsWith(resourceUrlResolvedBaseUrl)) {
          const parts = url.split("/");
          const name = parts[parts.length - 1];
          return {
            data: `LWR.define('${resourceUrlSpecifier}${name}', ['exports'], function(exports) {
                        exports.default = '${basePath__default["default"]}/webruntime/org-asset/${versionKey__default["default"]}/resource-name/${name}';
                    });`,
            status: 200
          };
        }
        return null;
      }
    });
  }
  exports.default = DynamicImportResourceHook;
  Object.defineProperty(exports, "__esModule", {value: true});
});
LWR.define("webruntime/o11yHook/v/1_66_319-244_0", ["exports", "lwr/loaderLegacy/v/0_9_0", "@app/basePath/v/1", "@app/apiBasePath/v/1", "@salesforce/i18n/lang/v/1", "webruntime/dispatcher/v/1", "@app/o11yConfiguration/v/1", "@app/o11yGuestToken/v/1", "@app/isDesignMode/v/1", "@app/isMobileAppMode/v/1", "@app/isPreviewMode/v/1", "@app/versionKey/v/1", "@salesforce/site/Id/v/1"], function(exports, _0_9_0, basePath, apiBasePath, language, dispatcher, srvConfigJson, guestTokenExt, isDesignMode, isMobileAppMode, isPreviewMode, versionKey, siteId) {
  "use strict";
  function _interopDefaultLegacy(e2) {
    return e2 && typeof e2 === "object" && "default" in e2 ? e2 : {default: e2};
  }
  var basePath__default = /* @__PURE__ */ _interopDefaultLegacy(basePath);
  var apiBasePath__default = /* @__PURE__ */ _interopDefaultLegacy(apiBasePath);
  var language__default = /* @__PURE__ */ _interopDefaultLegacy(language);
  var dispatcher__default = /* @__PURE__ */ _interopDefaultLegacy(dispatcher);
  var srvConfigJson__default = /* @__PURE__ */ _interopDefaultLegacy(srvConfigJson);
  var guestTokenExt__default = /* @__PURE__ */ _interopDefaultLegacy(guestTokenExt);
  var isDesignMode__default = /* @__PURE__ */ _interopDefaultLegacy(isDesignMode);
  var isMobileAppMode__default = /* @__PURE__ */ _interopDefaultLegacy(isMobileAppMode);
  var isPreviewMode__default = /* @__PURE__ */ _interopDefaultLegacy(isPreviewMode);
  var versionKey__default = /* @__PURE__ */ _interopDefaultLegacy(versionKey);
  var siteId__default = /* @__PURE__ */ _interopDefaultLegacy(siteId);
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const _o11y$1 = {};
  var webruntimeO11y = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    _o11y: _o11y$1
  });
  class LazyMapToList {
    constructor(maxSize) {
      this._lazyMap = new Map();
      if (maxSize !== void 0) {
        if (typeof maxSize === "number" && maxSize > 0) {
          this._maxSize = Math.ceil(maxSize);
          return;
        }
        throw new Error("maxSize must be a positive number");
      }
    }
    get maxSize() {
      return this._maxSize;
    }
    get size() {
      return this._lazyMap.size;
    }
    push(key, value) {
      let buffer = this._lazyMap.get(key);
      if (!buffer) {
        if (this.maxSize !== void 0 && this.size === this.maxSize) {
          return false;
        }
        buffer = new Array();
        this._lazyMap.set(key, buffer);
      }
      buffer.push(value);
      return true;
    }
    getMessages(key, extract) {
      const msgs = this._lazyMap.get(key);
      if (extract && this._lazyMap.has(key)) {
        this._lazyMap.set(key, []);
      }
      return msgs || [];
    }
    getAllMessages(extract) {
      const map = new Map();
      for (const [key, value] of this._lazyMap.entries()) {
        if (value.length) {
          map.set(key, this.getMessages(key, extract));
        }
      }
      return map;
    }
    extractMessages(key) {
      return this.getMessages(key, true);
    }
    extractAllMessages() {
      return this.getAllMessages(true);
    }
    get totalItemCount() {
      let count = 0;
      for (const array of this._lazyMap.values()) {
        count += array.length;
      }
      return count;
    }
  }
  class Utility {
    constructor() {
      this.notImplemented = "Method not implemented.";
      const performanceExists = typeof performance !== "undefined";
      if (performanceExists) {
        if (performance.timeOrigin) {
          this._timeOrigin = performance.timeOrigin;
        } else {
          this._timeOrigin = Date.now();
        }
      } else {
        this._timeOrigin = Date.now();
      }
      const timeOrigin = this._timeOrigin;
      if (performanceExists && typeof performance.now === "function") {
        this.perfNow = performance.now.bind(performance);
        this.time = () => {
          const perfNow = this.perfNow();
          return {
            tsNow: timeOrigin + perfNow,
            perfNow,
            timeOrigin
          };
        };
      } else {
        this.perfNow = () => {
          return Date.now() - timeOrigin;
        };
        this.time = () => {
          const perfNow = this.perfNow();
          return {
            tsNow: Date.now(),
            perfNow,
            timeOrigin
          };
        };
      }
    }
    get isProduction() {
      return Utility._isProduction;
    }
    markProduction() {
      Utility._isProduction = true;
    }
    _checkArgument(argument, argKind) {
      if (typeof argKind === "string") {
        return typeof argument === argKind;
      }
      if (typeof argKind === "function") {
        return argument instanceof argKind;
      }
      if (Array.isArray(argKind)) {
        return argKind.some((arg) => this._checkArgument(argument, arg));
      }
      throw new Error(`Invalid argKind ${argKind}`);
    }
    requireArgument(argument, argumentName, argKind) {
      let disallowed = argument === void 0 || argument === null || argument === "";
      const kindSpecified = argKind !== void 0;
      if (!disallowed && kindSpecified) {
        disallowed = !this._checkArgument(argument, argKind);
      }
      if (disallowed) {
        throw new Error(`${argumentName} argument is required${kindSpecified ? " and must be of a supported type." : "."}`);
      }
    }
    requireArgumentIfDefined(argument, argumentName, argKind) {
      if (argument === void 0) {
        return false;
      }
      const disallowed = argument === null || argument === "" || !this._checkArgument(argument, argKind);
      if (disallowed) {
        throw new Error(`${argumentName} argument, if defined, must be of a supported type.`);
      }
      return true;
    }
    checkForDenyListedValues(argument, argumentName, denyList) {
      if (denyList.some((x) => argument === x)) {
        throw new Error(`The value ${argument} isn't allowed for ${argumentName} argument.`);
      }
    }
    checkForReservedCharacters(argument, argumentName, reservedChars) {
      if (argument && reservedChars.some((c2) => argument.indexOf(c2) >= 0)) {
        throw new Error(`The argument ${argumentName} isn't allowed to contain characters from ['${reservedChars.join(", ")}']. Received: ${argument}.`);
      }
    }
    generateUniqueId(length = 16) {
      const chars = [];
      const digits = "0123456789abcdef";
      if (!(length === void 0 || length > 0)) {
        throw new Error('If specified, the argument "length" must be a positive integer');
      }
      for (let i2 = 0; i2 < length; i2++) {
        const rand = Math.floor(Math.random() * 16);
        chars.push(digits[rand]);
      }
      return chars.join("");
    }
    getXpath(_element) {
      function hasSameSibs(elm) {
        const name = elm.localName;
        while (elm.nextElementSibling) {
          elm = elm.nextElementSibling;
          if (elm.localName === name) {
            return true;
          }
        }
        return false;
      }
      function idx(sib, name) {
        if (sib) {
          return idx(sib.previousElementSibling, name || sib.localName) + (sib.localName === name ? 1 : 0);
        }
        return 1;
      }
      function segs(elm) {
        if (!elm || elm.nodeType !== 1) {
          return [""];
        }
        const nodeValue = idx(elm) > 1 || hasSameSibs(elm) ? `${elm.localName.toLowerCase()}[${idx(elm)}]` : elm.localName.toLowerCase();
        return [...segs(elm.parentNode), nodeValue];
      }
      return segs(_element).join("/");
    }
    getAge(timestamp) {
      return timestamp - this._timeOrigin;
    }
    getConnectionType() {
      var _a;
      let connectionType;
      if (typeof navigator !== "undefined") {
        const expNav = navigator;
        connectionType = (_a = expNav === null || expNav === void 0 ? void 0 : expNav.connection) === null || _a === void 0 ? void 0 : _a.effectiveType;
      }
      return connectionType;
    }
    clone(value) {
      return JSON.parse(JSON.stringify(value));
    }
    definedValueOrDefault(value, defaultValue) {
      return value !== void 0 ? value : defaultValue;
    }
    getGlobal() {
      if (typeof globalThis === "object") {
        return globalThis;
      }
      if (typeof self === "object") {
        return self;
      }
      throw new Error("Unable to locate globalThis or self");
    }
    getIsBeaconSupported() {
      var _a;
      const g2 = this.getGlobal();
      return typeof ((_a = g2.navigator) === null || _a === void 0 ? void 0 : _a.sendBeacon) === "function" && typeof g2.Blob === "function";
    }
    estimateObjectSize(object) {
      const objectSet = new Set();
      const stack = [object];
      let bytes = 0;
      while (stack.length) {
        const value = stack.pop();
        if (typeof value === "boolean") {
          bytes += 4;
        } else if (typeof value === "string") {
          bytes += value.length * 2;
        } else if (typeof value === "number") {
          bytes += 8;
        } else if (value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Uint16Array || value instanceof Uint32Array || value instanceof Int8Array || value instanceof Int16Array || value instanceof Int32Array || value instanceof Float32Array || value instanceof Float64Array) {
          bytes += value.byteLength;
        } else if (typeof value === "object") {
          const obj = value;
          if (!objectSet.has(obj)) {
            objectSet.add(obj);
            for (const key in obj) {
              stack.push(obj[key]);
            }
          }
        }
      }
      return bytes;
    }
    noProdThrow(e2) {
      if (utility.isProduction) {
        return;
      }
      throw e2;
    }
  }
  Utility._isProduction = false;
  const utility = Object.freeze(new Utility());
  class PublicSafety {
    constructor(_errorCounter) {
      this._errorCounter = _errorCounter;
      this._safeCatchMode = false;
    }
    tryCatch(fn) {
      try {
        fn();
      } catch (err) {
        this._prodSafeCatch(err);
      }
    }
    tryCatchReturn(fn, noopValue) {
      try {
        utility.requireArgument(noopValue, "noopValue");
        return fn();
      } catch (err) {
        this._prodSafeCatch(err);
        return noopValue;
      }
    }
    _prodSafeCatch(error2) {
      let allowThrow;
      try {
        allowThrow = !utility.isProduction;
        if (allowThrow) {
          throw error2;
        }
        if (this._safeCatchMode) {
          this._safeCatchMode = false;
          throw new Error("Internal error in prodSafeCatch.");
        }
        this._safeCatchMode = true;
        if (this._errorCounter) {
          this._errorCounter.increment();
        }
        if (!(error2 instanceof Error)) {
          const errorText = error2 && error2.message || (typeof error2.toString === "function" ? error2.toString() : "");
          error2 = new Error(errorText);
        }
        this._safeCatchMode = false;
      } catch (internalError) {
        if (allowThrow) {
          throw internalError;
        }
        if (internalError && console && typeof console.error === "function") {
          try {
            console.error(internalError);
          } catch (_a) {
          }
        }
        this._safeCatchMode = false;
      }
    }
  }
  class SchemaUtil {
    getSchemaId(schema) {
      return `${schema.namespace}.${schema.name}`;
    }
    isInternal(schema) {
      return (schema === null || schema === void 0 ? void 0 : schema.namespace) === "sf.instrumentation";
    }
    makePayload(schema, data, onlyIfBoth = true) {
      if (!onlyIfBoth || schema !== void 0 && data !== void 0) {
        return {
          schema,
          payload: data
        };
      }
      return void 0;
    }
    checkSchema(schema) {
      utility.requireArgument(schema, "schema", "object");
      utility.requireArgument(schema.namespace, "schema.namespace", "string");
      utility.requireArgument(schema.name, "schema.name", "string");
      utility.requireArgument(schema.pbjsSchema, "schema.pbjsSchema", "object");
      const parts = schema.namespace.split(".");
      if (parts.length !== 2) {
        throw new Error(`Schema "${this.getSchemaId(schema)}" must have a namespace of the form "domain.feature".`);
      }
      return {
        domain: parts[0],
        feature: parts[1],
        message: schema.name
      };
    }
    _getAnyNestedObject(schema, scopes) {
      return scopes.reduce((prev, currentScope) => {
        const descriptor = prev.nested;
        if (descriptor) {
          const ano = descriptor[currentScope];
          if (ano) {
            return ano;
          }
        }
        throw new Error(`Cannot locate ${scopes.join(".")} in schema with ID ${this.getSchemaId(schema)}`);
      }, schema.pbjsSchema);
    }
    getTypes(schema) {
      const schemaTokens = this.checkSchema(schema);
      const namespace = this._getAnyNestedObject(schema, [schemaTokens.domain, schemaTokens.feature]);
      const descriptor = namespace.nested;
      if (!descriptor) {
        throw new Error(`Cannot parse schema with ID ${this.getSchemaId(schema)}`);
      }
      return descriptor;
    }
    getType(schema, messageName) {
      utility.requireArgument(messageName, "messageName", "string");
      const descriptor = this.getTypes(schema);
      const message = descriptor[messageName];
      if (!message) {
        throw new Error(`Cannot locate message ${messageName} in schema with ID ${this.getSchemaId(schema)}`);
      }
      return message;
    }
    getOptions(schema, messageName, fieldName) {
      if (fieldName) {
        utility.requireArgument(messageName, "messageName", "string");
      }
      const schemaTokens = this.checkSchema(schema);
      if (!messageName) {
        const namespace = this._getAnyNestedObject(schema, [schemaTokens.domain, schemaTokens.feature]);
        return namespace.options;
      }
      const type = this.getType(schema, messageName);
      if (!fieldName) {
        return type.options;
      }
      const field = type.fields[fieldName];
      if (!field) {
        const schemaId = this.getSchemaId(schema);
        throw new Error(`Cannot locate field ${fieldName} in message ${messageName} in schema with ID ${schemaId}`);
      }
      return field.options;
    }
  }
  const schemaUtil = new SchemaUtil();
  var o11yShared = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    LazyMapToList,
    PublicSafety,
    schemaUtil,
    utility
  });
  const activity = {
    namespace: "sf.instrumentation",
    name: "Activity",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            instrumentation: {
              nested: {
                Activity: {
                  reserved: [[5, 5], [7, 7]],
                  fields: {
                    duration: {
                      id: 3,
                      type: "double"
                    },
                    stopReason: {
                      id: 6,
                      type: "string"
                    },
                    isRoot: {
                      id: 8,
                      type: "bool"
                    },
                    timerOverridden: {
                      id: 12,
                      type: "uint32"
                    },
                    name: {
                      options: {
                        "(meta.max_length)": 25
                      },
                      id: 2,
                      type: "string"
                    },
                    isSampled: {
                      id: 11,
                      type: "bool"
                    },
                    preRootId: {
                      id: 9,
                      type: "string"
                    },
                    id: {
                      id: 1,
                      type: "string"
                    },
                    userPayload: {
                      id: 4,
                      type: "Payload"
                    },
                    errorCount: {
                      id: 10,
                      type: "uint32"
                    },
                    parentId: {
                      id: 13,
                      type: "string"
                    }
                  }
                },
                Payload: {
                  fields: {
                    payload: {
                      id: 2,
                      type: "bytes"
                    },
                    schemaName: {
                      id: 1,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const error = {
    namespace: "sf.instrumentation",
    name: "Error",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            instrumentation: {
              nested: {
                Error: {
                  reserved: [[5, 5], [7, 7]],
                  fields: {
                    activityId: {
                      id: 6,
                      type: "string"
                    },
                    stack: {
                      id: 3,
                      type: "string"
                    },
                    name: {
                      id: 1,
                      type: "string"
                    },
                    message: {
                      options: {
                        "(meta.max_length)": 200
                      },
                      id: 2,
                      type: "string"
                    },
                    userPayload: {
                      id: 4,
                      type: "Payload"
                    }
                  }
                },
                Payload: {
                  fields: {
                    payload: {
                      id: 2,
                      type: "bytes"
                    },
                    schemaName: {
                      id: 1,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const idle_detector_report = {
    namespace: "sf.instrumentation",
    name: "IdleDetectorReport",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            instrumentation: {
              nested: {
                IdleDetectorReport: {
                  fields: {
                    listenerCount: {
                      id: 3,
                      type: "uint32"
                    },
                    busyTasks: {
                      rule: "repeated",
                      id: 5,
                      type: "string"
                    },
                    busyDurations: {
                      rule: "repeated",
                      id: 6,
                      type: "double"
                    },
                    pollableCount: {
                      id: 4,
                      type: "uint32"
                    },
                    pollCounts: {
                      rule: "repeated",
                      id: 8,
                      type: "double"
                    },
                    logThreshold: {
                      id: 2,
                      type: "double"
                    },
                    maxDuration: {
                      id: 1,
                      type: "double"
                    },
                    pollables: {
                      rule: "repeated",
                      id: 7,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const instrumented_event = {
    namespace: "sf.instrumentation",
    name: "InstrumentedEvent",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            instrumentation: {
              nested: {
                MouseEvent: {
                  fields: {
                    cancelable: {
                      id: 5,
                      type: "bool"
                    },
                    ctrlKey: {
                      id: 9,
                      type: "bool"
                    },
                    type: {
                      id: 25,
                      type: "string"
                    },
                    button: {
                      id: 3,
                      type: "uint32"
                    },
                    offsetX: {
                      id: 17,
                      type: "uint32"
                    },
                    eventPhase: {
                      id: 12,
                      type: "uint32"
                    },
                    shiftKey: {
                      id: 23,
                      type: "bool"
                    },
                    offsetY: {
                      id: 18,
                      type: "uint32"
                    },
                    composed: {
                      id: 8,
                      type: "bool"
                    },
                    altKey: {
                      id: 1,
                      type: "bool"
                    },
                    isTrusted: {
                      id: 13,
                      type: "bool"
                    },
                    buttons: {
                      id: 4,
                      type: "uint32"
                    },
                    movementY: {
                      id: 16,
                      type: "uint32"
                    },
                    clientY: {
                      id: 7,
                      type: "uint32"
                    },
                    clientX: {
                      id: 6,
                      type: "uint32"
                    },
                    movementX: {
                      id: 15,
                      type: "uint32"
                    },
                    defaultPrevented: {
                      id: 10,
                      type: "bool"
                    },
                    metaKey: {
                      id: 14,
                      type: "bool"
                    },
                    timeStamp: {
                      id: 24,
                      type: "double"
                    },
                    bubbles: {
                      id: 2,
                      type: "bool"
                    },
                    detail: {
                      id: 11,
                      type: "int64"
                    },
                    pageY: {
                      id: 20,
                      type: "uint32"
                    },
                    pageX: {
                      id: 19,
                      type: "uint32"
                    },
                    screenX: {
                      id: 21,
                      type: "uint32"
                    },
                    screenY: {
                      id: 22,
                      type: "uint32"
                    }
                  }
                },
                InstrumentedEvent: {
                  oneofs: {
                    event: {
                      oneof: ["mouseEvent"]
                    }
                  },
                  reserved: [[4, 4], "xpath", [6, 6], [8, 8]],
                  fields: {
                    mouseEvent: {
                      id: 7,
                      type: "MouseEvent"
                    },
                    auto: {
                      id: 3,
                      type: "bool"
                    },
                    parentComponent: {
                      id: 2,
                      type: "string"
                    },
                    ownerComponent: {
                      id: 1,
                      type: "string"
                    },
                    userPayload: {
                      id: 5,
                      type: "Payload"
                    },
                    simplePath: {
                      id: 9,
                      type: "string"
                    }
                  }
                },
                Payload: {
                  fields: {
                    payload: {
                      id: 2,
                      type: "bytes"
                    },
                    schemaName: {
                      id: 1,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const simple = {
    namespace: "sf.instrumentation",
    name: "Simple",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            instrumentation: {
              nested: {
                Simple: {
                  fields: {
                    text: {
                      options: {
                        "(meta.max_length)": 25
                      },
                      id: 1,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  class TaskerImpl {
    get isBusy() {
      return this._isOk ? this._busyCount > 0 : void 0;
    }
    constructor(name, initialCount, _doneCallback, _overDoneCallback) {
      this.name = name;
      this._doneCallback = _doneCallback;
      this._overDoneCallback = _overDoneCallback;
      this._busyCount = 0;
      this._isOk = true;
      this._busyCount = initialCount;
    }
    add() {
      if (this._isOk) {
        this._busyCount += 1;
      }
    }
    done() {
      if (this._isOk) {
        if (this._busyCount > 0) {
          this._busyCount -= 1;
          if (!this._busyCount) {
            this._doneCallback();
          }
        } else {
          this._isOk = false;
          this._overDoneCallback();
        }
      }
    }
  }
  const defaultLogThreshold = 300;
  class IdleDetectorImpl {
    constructor(options) {
      this._taskers = new Map();
      this._listeners = new Set();
      this._busyCheckers = new Map();
      this._logThreshold = defaultLogThreshold;
      this._endedTasks = new Array();
      this._pollableReport = new Array();
      if (utility.requireArgumentIfDefined(options === null || options === void 0 ? void 0 : options.logThreshold, "options.logThreshold", "number")) {
        this._logThreshold = options.logThreshold;
      }
      if (utility.requireArgumentIfDefined(options === null || options === void 0 ? void 0 : options.reportListener, "options.reportListener", "function")) {
        this._reportListener = options.reportListener;
      }
      if (utility.requireArgumentIfDefined(options === null || options === void 0 ? void 0 : options.errorListener, "options.errorListener", "function")) {
        this._errorListener = options.errorListener;
      }
    }
    requestIdleDetectedCallback(callback) {
      utility.requireArgument(callback, "callback", "function");
      if (this._listeners.size === 0) {
        this._firstCallbackTime = utility.time().perfNow;
      }
      this._listeners.add(callback);
      this._checkIfLoaded();
    }
    _reportTaskEnded(tasker) {
      if (this._listeners.size) {
        const snapshot = Object.assign({}, this._taskers.get(tasker));
        this._endedTasks.push(snapshot);
      }
    }
    declareNotifierTaskSingle(name) {
      utility.requireArgument(name, "name", "string");
      const tasker = this._addTasker(name, 1);
      const retVal = {
        get isBusy() {
          return tasker.isBusy;
        },
        done: () => {
          tasker.done();
          this._taskers.delete(tasker);
        }
      };
      return retVal;
    }
    declareNotifierTaskMulti(name, existingBusyCount = 0) {
      utility.requireArgument(name, "name", "string");
      if (existingBusyCount !== void 0) {
        utility.requireArgument(existingBusyCount, "existingBusyCount", "number");
        if (!Number.isInteger(existingBusyCount) || existingBusyCount < 0) {
          throw new Error("existingBusyCount accepts only non-negative integers");
        }
      }
      const tasker = this._addTasker(name, existingBusyCount);
      const retVal = {
        get isBusy() {
          return tasker.isBusy;
        },
        add: () => {
          if (!tasker.isBusy) {
            const meta = this._taskers.get(tasker);
            meta.start = utility.time().perfNow;
            meta.end = void 0;
          }
          tasker.add();
        },
        done: tasker.done.bind(tasker)
      };
      return retVal;
    }
    declarePollableTaskMulti(name, isBusyChecker) {
      utility.requireArgument(name, "name", "string");
      utility.requireArgument(isBusyChecker, "isBusyChecker", "function");
      this._busyCheckers.set(isBusyChecker, name);
    }
    _addTasker(name, existingBusyCount) {
      const tasker = new TaskerImpl(name, existingBusyCount, () => {
        this._taskers.get(tasker).end = utility.time().perfNow;
        this._reportTaskEnded(tasker);
        this._checkIfLoaded();
      }, () => {
        var _a;
        (_a = this._errorListener) === null || _a === void 0 ? void 0 : _a.call(this, `Overdone: ${tasker.name}`);
        utility.noProdThrow(`Tasker '${tasker.name}' is done too many times.`);
      });
      this._taskers.set(tasker, {
        name,
        start: existingBusyCount > 0 ? utility.time().perfNow : void 0,
        end: void 0
      });
      return tasker;
    }
    _areAllNotifiersIdle() {
      return !Array.from(this._taskers.keys()).some((t2) => t2.isBusy);
    }
    _getFirstBusyPollable() {
      const entry = Array.from(this._busyCheckers).find((entry2) => {
        var _a;
        const isBusyChecker = entry2[0];
        const name = entry2[1];
        try {
          return isBusyChecker();
        } catch (e2) {
          (_a = this._errorListener) === null || _a === void 0 ? void 0 : _a.call(this, e2, `BusyChecker ${name}`);
          utility.noProdThrow(e2);
          return false;
        }
      });
      return entry ? entry[1] : void 0;
    }
    _checkIfLoaded() {
      if (!this._listeners.size) {
        return;
      }
      if (this._timerCheckQueued) {
        clearTimeout(this._timerCheckQueued);
      }
      if (this._areAllNotifiersIdle()) {
        this._timerCheckQueued = setTimeout(() => {
          this._timerCheckQueued = setTimeout(() => {
            this._doubleCheck();
          }, 40);
        }, 0);
      }
    }
    _doubleCheck() {
      this._timerCheckQueued = void 0;
      if (this._areAllNotifiersIdle()) {
        const pollableName = this._getFirstBusyPollable();
        if (pollableName !== void 0) {
          this._addToPollableReport(pollableName);
          this._timerCheckQueued = setTimeout(() => {
            this._doubleCheck();
          }, 15);
        } else {
          const maxDuration = utility.time().perfNow - this._firstCallbackTime;
          const listeners = Array.from(this._listeners.values());
          this._listeners.clear();
          this._firstCallbackTime = void 0;
          const endedTasks = this._endedTasks.splice(0);
          const pollableReport = this._pollableReport.splice(0);
          this._notify(listeners, maxDuration, endedTasks, pollableReport);
        }
      }
    }
    _addToPollableReport(name) {
      const lastEntry = this._pollableReport.length ? this._pollableReport[this._pollableReport.length - 1] : void 0;
      if ((lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.name) === name) {
        lastEntry.count += 1;
      } else {
        this._pollableReport.push({
          name,
          count: 1
        });
      }
    }
    _notify(listeners, maxDuration, taskReport, pollableReport) {
      var _a;
      if (maxDuration >= this._logThreshold && this._reportListener) {
        const logData = this._getReport(maxDuration, listeners.length, taskReport, pollableReport);
        this._reportListener(logData);
      }
      listeners.reverse();
      const tsNow = utility.time().tsNow;
      for (const [index2, listener] of listeners.entries()) {
        try {
          listener(tsNow);
        } catch (e2) {
          (_a = this._errorListener) === null || _a === void 0 ? void 0 : _a.call(this, e2, `Listener #${listeners.length - 1 - index2}`);
          utility.noProdThrow(e2);
        }
      }
    }
    getReport() {
      const perfNow = utility.time().perfNow;
      const maxDuration = this._firstCallbackTime > 0 ? perfNow - this._firstCallbackTime : void 0;
      const onGoingTasks = Array.from(this._taskers.entries()).filter((e2) => e2[0].isBusy).map((e2) => ({
        name: e2[1].name,
        start: e2[1].start,
        end: perfNow
      }));
      return this._getReport(maxDuration, this._listeners.size, this._endedTasks.concat(onGoingTasks), this._pollableReport);
    }
    _getReport(maxDuration, listenerCount, taskReport, pollableReport) {
      const sortedTaskers = taskReport.map((t2) => ({
        name: t2.name,
        duration: t2.end - t2.start
      })).sort((a2, b2) => b2.duration - a2.duration);
      return {
        logThreshold: this._logThreshold,
        maxDuration,
        listenerCount,
        pollableCount: this._busyCheckers.size,
        busyTasks: sortedTaskers.map((t2) => t2.name),
        busyDurations: sortedTaskers.map((t2) => t2.duration),
        pollables: pollableReport.map((p2) => p2.name),
        pollCounts: pollableReport.map((p2) => p2.count)
      };
    }
  }
  const defaultTraceIdLengthW3 = 32;
  const defaultTraceIdLengthB3 = 16;
  const defaultSpanIdLength = 16;
  const headerTraceParent = "traceparent";
  const headerB3 = "b3";
  const headerTraceId = "X-B3-TraceId";
  const headerSpanId = "X-B3-SpanId";
  const headerSampled = "X-B3-Sampled";
  const headerParentSpanId = "X-B3-ParentSpanId";
  const defaultActivityNameForFetch = "fetch";
  const defaultActivityNameForXhrSend = "xhr_send";
  class Tracing {
    constructor(_instr, _idleDetector) {
      this._instr = _instr;
      this._idleDetector = _idleDetector;
      utility.requireArgument(_instr, "_instr", "object");
      utility.requireArgument(_idleDetector, "_idleDetector", "object");
    }
    static _getB3CompactFormat(traceId, spanId, isSampled, parentSpanId) {
      let b3 = `${traceId}-${spanId}`;
      if (isSampled !== void 0 || parentSpanId !== void 0) {
        b3 += isSampled ? "-1" : "-0";
        if (parentSpanId !== void 0) {
          b3 += `-${parentSpanId}`;
        }
      }
      return b3;
    }
    static _getW3CompactFormat(traceId, spanId, isSampled) {
      return `00-${traceId}-${spanId}-${isSampled ? "01" : "00"}`;
    }
    static _conformTextAsId(text, numChars) {
      text = text.toLowerCase();
      const len = text.length;
      for (let i2 = 0; i2 < len; i2 += 1) {
        const c2 = text[i2];
        if (!(c2 >= "a" && c2 <= "f") && !(c2 >= "0" && c2 <= "9")) {
          throw new Error(`The text '${text}' has an invalid character at index #${i2}`);
        }
      }
      if (len > numChars) {
        return text.substr(len - numChars);
      }
      if (len < numChars) {
        return text.padStart(numChars, "0");
      }
      return text;
    }
    static getHeaders(traceId, spanId, isSampled, options) {
      utility.requireArgument(traceId, "traceId", "string");
      utility.requireArgument(spanId, "spanId", "string");
      const useB3Headers = options === null || options === void 0 ? void 0 : options.useB3Headers;
      traceId = this._conformTextAsId(traceId, (options === null || options === void 0 ? void 0 : options.traceIdEffectiveLength) !== void 0 ? options.traceIdEffectiveLength : useB3Headers ? defaultTraceIdLengthB3 : defaultTraceIdLengthW3);
      spanId = this._conformTextAsId(spanId, defaultSpanIdLength);
      const parentSpanId = options && options.parentSpanId !== void 0 && this._conformTextAsId(options.parentSpanId, defaultSpanIdLength) || void 0;
      const headers = {};
      if (useB3Headers) {
        const isCompact = options === null || options === void 0 ? void 0 : options.useCompactHeader;
        if (isCompact) {
          headers[headerB3] = this._getB3CompactFormat(traceId, spanId, isSampled, parentSpanId);
        } else {
          headers[headerTraceId] = traceId;
          headers[headerSpanId] = spanId;
          if (parentSpanId !== void 0) {
            headers[headerParentSpanId] = parentSpanId;
          }
          if (isSampled !== void 0) {
            headers[headerSampled] = isSampled ? "1" : "0";
          }
        }
      } else {
        headers[headerTraceParent] = this._getW3CompactFormat(traceId, spanId, isSampled);
      }
      return headers;
    }
    _disableNetworkInstrumentation() {
      if (Tracing._isNetworkInstrumentationEnabled) {
        if (Tracing._originalFetch) {
          Tracing._global.fetch = Tracing._originalFetch;
          Tracing._originalFetch = void 0;
        }
        if (Tracing._originalXhr) {
          Tracing._global.XMLHttpRequest = Tracing._originalXhr;
          Tracing._originalXhr = void 0;
        }
        if (Tracing._originalXhrOpen) {
          Tracing._global.XMLHttpRequest.prototype.open = Tracing._originalXhrOpen;
          Tracing._originalXhrOpen = void 0;
        }
        if (Tracing._originalXhrSend) {
          Tracing._global.XMLHttpRequest.prototype.send = Tracing._originalXhrSend;
          Tracing._originalXhrSend = void 0;
        }
        Tracing._isNetworkInstrumentationEnabled = false;
      }
    }
    _enableNetworkInstrumentation(instr, logErrors, activityName, useTracing, options, tasker) {
      if (typeof Tracing._global.fetch === "function") {
        this._overrideFetch(instr, logErrors, activityName, useTracing, options, tasker);
        Tracing._isNetworkInstrumentationEnabled = true;
      }
      if (typeof Tracing._global.XMLHttpRequest === "function") {
        this._overrideXhr(instr, logErrors, activityName, useTracing, options, tasker);
        Tracing._isNetworkInstrumentationEnabled = true;
      }
    }
    static _getTraceHeaders(activity2, options, method, url) {
      let traceHeaders = (activity2 === null || activity2 === void 0 ? void 0 : activity2.getTraceHeaders(options)) || {};
      if (typeof (options === null || options === void 0 ? void 0 : options.headerProcessor) === "function") {
        traceHeaders = options.headerProcessor({
          method,
          url,
          defaultHeaders: traceHeaders
        });
      } else if (typeof window === "object") {
        let newUrl;
        try {
          newUrl = new URL(url);
        } catch (_a) {
        }
        if (newUrl && newUrl.host !== window.location.host) {
          traceHeaders = void 0;
        }
      }
      return traceHeaders || {};
    }
    _overrideFetch(instr, logErrors, activityName, useTracing, tracingHeadersOptions, tasker) {
      Tracing._originalFetch = Tracing._global.fetch;
      const o11yFetch = async (resource, options, ...restArgs) => {
        let activity2;
        try {
          tasker === null || tasker === void 0 ? void 0 : tasker.add();
          const ofo = options === null || options === void 0 ? void 0 : options.o11y;
          if (!(ofo === null || ofo === void 0 ? void 0 : ofo.skipInstr)) {
            activity2 = instr.startActivity(activityName || defaultActivityNameForFetch);
          } else {
            Tracing._reqIndex += 1;
            try {
              if (resource instanceof URL) {
                resource.searchParams.append("o11y", Tracing._reqIndex.toString());
              } else if (typeof resource === "string") {
                const urlObj = new URL(resource);
                const kv = `o11y=${Tracing._reqIndex}`;
                urlObj.search += urlObj.search.startsWith("?") ? `&${kv}` : kv;
                resource = urlObj.toString();
              }
            } catch (_a) {
            }
          }
          options === null || options === void 0 ? true : delete options.o11y;
          if (useTracing) {
            let method = options === null || options === void 0 ? void 0 : options.method;
            let url = resource === null || resource === void 0 ? void 0 : resource.toString();
            if (resource instanceof Request) {
              if (!method) {
                method = resource.method;
              }
              url = resource.url;
            }
            const traceHeaders = Tracing._getTraceHeaders(activity2, tracingHeadersOptions, method, url);
            if (!this._applyTraceHeaders(resource, options, traceHeaders) && options === void 0) {
              options = {
                headers: traceHeaders
              };
            }
          }
          return await Tracing._originalFetch.call(Tracing._global, resource, options, ...restArgs);
        } catch (ex) {
          if (logErrors) {
            if (activity2) {
              activity2.error(ex);
            } else {
              instr.error(ex);
            }
          }
          throw ex;
        } finally {
          activity2 === null || activity2 === void 0 ? void 0 : activity2.stop();
          tasker === null || tasker === void 0 ? void 0 : tasker.done();
        }
      };
      Tracing._global.fetch = o11yFetch;
    }
    _overrideXhr(instr, logErrors, activityName, useTracing, options, tasker) {
      Tracing._originalXhr = Tracing._global.XMLHttpRequest;
      Tracing._originalXhrOpen = Tracing._originalXhr.prototype.open;
      Tracing._originalXhrSend = Tracing._originalXhr.prototype.send;
      Tracing._originalXhr.prototype.open = function(method, url, async, username, password) {
        this._o11y = {
          method,
          url: url === null || url === void 0 ? void 0 : url.toString()
        };
        Tracing._originalXhrOpen.call(this, method, url, async, username, password);
      };
      Tracing._originalXhr.prototype.send = function(...args) {
        let activity2;
        try {
          tasker === null || tasker === void 0 ? void 0 : tasker.add();
          const xhr = this;
          xhr._o11y = xhr._o11y || {};
          xhr._o11y.activity = activity2 = instr.startActivity(activityName || defaultActivityNameForXhrSend);
          if (useTracing) {
            const traceHeaders = Tracing._getTraceHeaders(activity2, options, xhr._o11y.method, xhr._o11y.url);
            Object.entries(traceHeaders).forEach((entry) => {
              xhr.setRequestHeader(entry[0], entry[1]);
            });
          }
          Tracing._originalXhrSend.call(this, ...args);
        } catch (ex) {
          if (logErrors) {
            if (activity2) {
              activity2.error(ex);
            } else {
              instr.error(ex);
            }
          }
          activity2 === null || activity2 === void 0 ? void 0 : activity2.stop();
          tasker === null || tasker === void 0 ? void 0 : tasker.done();
          throw ex;
        }
      };
      const xhrProxy = new Proxy(Tracing._originalXhr, {
        construct(target) {
          const newXhr = new target();
          newXhr.addEventListener("load", () => {
            var _a, _b;
            (_b = (_a = newXhr._o11y) === null || _a === void 0 ? void 0 : _a.activity) === null || _b === void 0 ? void 0 : _b.stop();
            tasker === null || tasker === void 0 ? void 0 : tasker.done();
          });
          newXhr.addEventListener("error", (__err) => {
            var _a;
            const error2 = new Error("XHR Network-Level Error");
            const activity2 = (_a = newXhr._o11y) === null || _a === void 0 ? void 0 : _a.activity;
            if (activity2) {
              if (logErrors) {
                activity2.error(error2);
              }
              activity2.stop();
            } else if (logErrors) {
              instr.error(error2);
            }
            tasker === null || tasker === void 0 ? void 0 : tasker.done();
          });
          newXhr.addEventListener("abort", () => {
            var _a, _b;
            (_b = (_a = newXhr._o11y) === null || _a === void 0 ? void 0 : _a.activity) === null || _b === void 0 ? void 0 : _b.discard();
            tasker === null || tasker === void 0 ? void 0 : tasker.done();
          });
          return newXhr;
        }
      });
      Tracing._global.XMLHttpRequest = xhrProxy;
    }
    networkInstrumentation(options) {
      var _a;
      utility.requireArgument(options, "options", ["boolean", "object"]);
      this._disableNetworkInstrumentation();
      if (options) {
        const tracingOptions = typeof options === "object" ? options : {};
        let tasker = void 0;
        if (utility.definedValueOrDefault(tracingOptions.useTasker, true)) {
          tasker = (_a = this._idleDetector) === null || _a === void 0 ? void 0 : _a.declareNotifierTaskMulti("o11y network");
        }
        this._enableNetworkInstrumentation(utility.definedValueOrDefault(tracingOptions.instrumentation, this._instr), utility.definedValueOrDefault(tracingOptions.logErrors, true), tracingOptions.activityName, utility.definedValueOrDefault(tracingOptions.useTracing, true), tracingOptions.tracingHeadersOptions, tasker);
      }
    }
    resetRequestCounter() {
      Tracing._reqIndex = 0;
    }
    _applyTraceHeaders(resource, options, traceHeaders) {
      if ((options === null || options === void 0 ? void 0 : options.headers) !== void 0) {
        if (options.headers instanceof Headers && typeof options.headers.set === "function") {
          Object.entries(traceHeaders).forEach(([key, value]) => {
            options.headers.set(key, value);
          });
          return true;
        }
        if (Array.isArray(options.headers)) {
          Object.entries(traceHeaders).forEach((entry) => {
            options.headers.push(entry);
          });
          return true;
        }
        if (typeof options.headers === "object") {
          options.headers = Object.assign(options.headers, traceHeaders);
          return true;
        }
      } else if (resource instanceof Request && resource.headers instanceof Headers) {
        Object.entries(traceHeaders).forEach(([key, value]) => {
          resource.headers.set(key, value);
        });
        return true;
      } else if (options) {
        options.headers = Object.assign({}, traceHeaders);
        return true;
      }
      return false;
    }
  }
  Tracing._global = utility.getGlobal();
  Tracing._isNetworkInstrumentationEnabled = false;
  Tracing._reqIndex = 0;
  var TimerOverride;
  (function(TimerOverride2) {
    TimerOverride2[TimerOverride2["none"] = 0] = "none";
    TimerOverride2[TimerOverride2["start"] = 1] = "start";
    TimerOverride2[TimerOverride2["stop"] = 2] = "stop";
    TimerOverride2[TimerOverride2["both"] = 3] = "both";
  })(TimerOverride || (TimerOverride = {}));
  const timedout = "timedout";
  const terminated = "terminated";
  const discarded = "discarded";
  const stopReason = {
    timedout,
    terminated,
    discarded
  };
  class ActivityImpl {
    constructor(_name, _rootId, _onStopped, _onError, timeout, id2, _isSampled) {
      this._name = _name;
      this._rootId = _rootId;
      this._onStopped = _onStopped;
      this._onError = _onError;
      this._isSampled = _isSampled;
      this._errorCount = 0;
      this._timerOverridden = TimerOverride.none;
      const {
        tsNow,
        perfNow
      } = utility.time();
      ActivityImpl._count += 1;
      this._id = id2 || utility.generateUniqueId();
      this._usePerf = typeof performance !== "undefined" && typeof performance.mark === "function" && typeof performance.measure === "function";
      if (this._usePerf) {
        this._perfName = `${this._name}__${ActivityImpl._count}`;
        this._perfId = `${this._name}__${this.id}`;
        try {
          performance.mark(this._perfId);
        } catch (_a) {
          this._usePerf = false;
        }
      }
      this._startTimestamp = tsNow;
      this._startPerfTime = perfNow;
      if (timeout > 0) {
        this._timer = setTimeout(() => {
          this._stopReason = this._stopReason || stopReason.timedout;
          this.stop();
        }, timeout);
      }
      this._safety = new PublicSafety();
    }
    get id() {
      return this._id;
    }
    getId() {
      return this.id;
    }
    getRootId() {
      return this._rootId;
    }
    get stopReason() {
      return this._stopReason;
    }
    error(error2, userSchemaOrText, userData) {
      this._safety.tryCatch(() => {
        this._errorCount += 1;
        if (typeof error2 === "string") {
          error2 = new Error(error2);
        }
        this._onError(error2, this._getDetail(userSchemaOrText, userData));
      });
    }
    stop(userSchemaOrText, userData, options) {
      this._safety.tryCatch(() => {
        utility.requireArgumentIfDefined(userSchemaOrText, "userSchemaOrText", ["object", "string"]);
        utility.requireArgumentIfDefined(userData, "userData", "object");
        if (options) {
          const perfStart = options.perfStartOverride;
          const isStartTimeDefined = utility.requireArgumentIfDefined(perfStart, "options.perfStartOverride", "number");
          const perfStop = options.perfStopOverride;
          const isStopTimeDefined = utility.requireArgumentIfDefined(perfStop, "options.perfStopOverride", "number");
          if (isStartTimeDefined && perfStart < 0) {
            throw new Error("perfStartOverride, if defined, must be >= 0");
          }
          if (isStopTimeDefined && (perfStop < 0 || perfStop < (isStartTimeDefined ? perfStart : this._startPerfTime))) {
            throw new Error("perfStopOverride, if defined, must be >= 0 and >= startTime");
          }
        }
        this._stopInternal(userSchemaOrText, userData, options);
      });
    }
    _overrideTimer(perfStartTime, perfStopTime) {
      if (perfStartTime !== void 0) {
        this._startTimestamp = Math.round(this._startTimestamp - (this._startPerfTime - perfStartTime));
        this._startPerfTime = perfStartTime;
        this._setTimerOverride(TimerOverride.start);
      }
      if (perfStopTime !== void 0) {
        this._stopPerfTime = perfStopTime;
        this._setTimerOverride(TimerOverride.stop);
      }
    }
    _setTimerOverride(value) {
      if (this._timerOverridden === TimerOverride.both || this._timerOverridden === value || value === TimerOverride.none) {
        return;
      }
      this._timerOverridden = this._timerOverridden === TimerOverride.none ? value : TimerOverride.both;
    }
    _stopInternal(userSchemaOrText, userData, options) {
      const stopPerfTime = utility.perfNow();
      if (this._usePerf) {
        try {
          if (this._stopReason !== stopReason.discarded) {
            performance.measure(this._perfName, this._perfId);
          }
          performance.clearMarks(this._perfId);
          performance.clearMeasures(this._perfName);
        } catch (_a) {
        }
      }
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = void 0;
      }
      if (this.isStopped) {
        return;
      }
      if (options) {
        this._overrideTimer(options.perfStartOverride, options.perfStopOverride);
      }
      this._stopPerfTime = this._timerOverridden === TimerOverride.none || this._timerOverridden === TimerOverride.start ? stopPerfTime : this._stopPerfTime;
      const activityDetail = this._getDetail(userSchemaOrText, userData);
      this._onStopped(activityDetail);
    }
    get isStopped() {
      return this._stopPerfTime !== void 0;
    }
    discard() {
      this._safety.tryCatch(() => {
        this._stopReason = this._stopReason || stopReason.discarded;
        this.stop();
      });
    }
    terminate(userSchemaOrText, userData, options) {
      this._safety.tryCatch(() => {
        this._stopReason = this._stopReason || stopReason.terminated;
        this.stop(userSchemaOrText, userData, options);
      });
    }
    getIsSampled() {
      return this._isSampled || false;
    }
    _getDetail(userSchemaOrText, userData) {
      return {
        id: this._id,
        rootId: this._rootId,
        name: this._name,
        userSchemaOrText,
        userData,
        stopReason: this._stopReason,
        startTimestamp: this._startTimestamp,
        startPerfTime: this._startPerfTime,
        stopPerfTime: this._stopPerfTime,
        errorCount: this._errorCount,
        isSampled: this.getIsSampled(),
        timerOverridden: this._timerOverridden
      };
    }
    getTraceHeaders(options) {
      const spanId = this.id;
      const traceId = this._rootId || spanId;
      return Tracing.getHeaders(traceId, spanId, this.getIsSampled(), options);
    }
    getStartTimestamp() {
      return this._startTimestamp;
    }
    getStartPerfTime() {
      return this._startPerfTime;
    }
    getStopPerfTime() {
      return this._stopPerfTime;
    }
  }
  ActivityImpl._count = 0;
  const id = new Array(16).fill(0).join("");
  class ActivityNoOp {
    getId() {
      return id;
    }
    getRootId() {
      return void 0;
    }
    error() {
    }
    stop() {
    }
    discard() {
    }
    terminate() {
    }
    getIsSampled() {
      return false;
    }
    getTraceHeaders(__options) {
      return {};
    }
    getStartTimestamp() {
      return void 0;
    }
    getStartPerfTime() {
      return void 0;
    }
    getStopPerfTime() {
      return void 0;
    }
  }
  const activityNoOp = Object.freeze(new ActivityNoOp());
  class DomEventHelpers {
    getInstrumentedEventData(eventData, handledBy, userPayload) {
      var _a;
      const instrumentedEvent = {
        ownerComponent: handledBy.tagName,
        parentComponent: ((_a = handledBy.parentElement) === null || _a === void 0 ? void 0 : _a.tagName) || void 0,
        event: eventData,
        simplePath: utility.getXpath(handledBy)
      };
      if (userPayload) {
        instrumentedEvent.userPayload = schemaUtil.makePayload(userPayload.schema, userPayload.payload, true);
      }
      return instrumentedEvent;
    }
    getMouseEventData(e2) {
      return {
        altKey: e2.altKey,
        bubbles: e2.bubbles,
        button: e2.button,
        buttons: e2.buttons,
        cancelable: e2.cancelable,
        clientX: e2.clientX,
        clientY: e2.clientY,
        composed: e2.composed,
        defaultPrevented: e2.defaultPrevented,
        detail: e2.detail,
        eventPhase: e2.eventPhase,
        isTrusted: e2.isTrusted,
        timeStamp: e2.timeStamp,
        type: e2.type,
        ctrlKey: e2.ctrlKey,
        metaKey: e2.metaKey,
        movementX: e2.movementX,
        movementY: e2.movementY,
        offsetX: e2.offsetX,
        offsetY: e2.offsetY,
        pageX: e2.pageX,
        pageY: e2.pageY,
        screenX: e2.screenX,
        screenY: e2.screenY,
        shiftKey: e2.shiftKey
      };
    }
  }
  const singleton = new DomEventHelpers();
  const domEventHelpers = singleton;
  const maxStringLengthAppLimit = 1e4;
  const maxItemCountAppLimit = 1e4;
  const minUnsigned = 0;
  const maxFourBytes = 2147483647;
  const minFourBytes = -2147483648;
  const maxFourBytesUnsigned = 4294967295;
  const maxEightBytes = 9223372036854776e3;
  const minEightBytes = -9223372036854776e3;
  const maxEightBytesUnsigned = 18446744073709552e3;
  class ValidationEntry {
    constructor(errorCode, fields, expected, received) {
      this.errorCode = errorCode;
      this.fields = fields;
      this.expected = expected;
      this.received = received;
    }
    asMessage(schemaId) {
      const key = this.fields[0] + this.fields.slice(1).reduce((prev, current) => Number(current) >= 0 ? `${prev}[${current}]` : `${prev}.${current}`, "");
      let msg;
      switch (this.errorCode) {
        case 1:
          msg = "Repeated field must be an array";
          break;
        case 2:
          msg = `Expected type ${this.expected} but received type ${this.received}`;
          break;
        case 3:
          msg = "Value must be finite";
          break;
        case 4:
          msg = "Value is out of range for its type";
          break;
        case 5:
          msg = "Bytes array is malformed";
          break;
        case 6:
          msg = "Exceeded app limit for maximum string length";
          break;
        case 7:
          msg = "Exceeded app limit for item count";
          break;
        case 12:
          msg = "Value must be an integer";
          break;
        case 13:
          msg = "Values like null or undefined are not allowed for items in repeated fields";
          break;
        default:
          msg = `Unknown error code: ${this.errorCode}`;
          break;
      }
      return `Schema ${schemaId} on field "${key}": ${msg}`;
    }
  }
  class LogValidator {
    validate(schema, data, noThrow = false) {
      const schemaTokens = schemaUtil.checkSchema(schema);
      utility.requireArgument(data, "data", "object");
      const schemaId = schemaUtil.getSchemaId(schema);
      const errorInfos = new Array();
      const nestedSchema = schemaUtil.getTypes(schema);
      this._validateFields(errorInfos, [], data, nestedSchema[schemaTokens.message], nestedSchema, schemaId);
      if (errorInfos.length && !noThrow) {
        throw new Error(errorInfos[0].asMessage(schemaId));
      }
      return errorInfos;
    }
    _validateFields(errorInfos, fieldNames, data, message, descriptor, schemaId) {
      const oneofs = message.oneofs || {};
      const fields = message.fields || {};
      for (const key in data) {
        const value = data[key];
        if (value !== void 0 && value !== null) {
          const mft = (fieldType, isRepeated, isItem) => this._matchFieldTypes(errorInfos, [...fieldNames, key], value, fieldType, descriptor, schemaId, key, isRepeated, isItem);
          if (oneofs[key]) {
            mft(fields[oneofs[key].oneof[0]].type);
          } else if (fields[key]) {
            mft(fields[key].type, fields[key].rule === "repeated");
          }
        }
      }
    }
    _matchFieldTypes(errorInfos, fieldNames, fieldDataValue, protobufType, descriptor, schemaId, key, isRepeated, isItem) {
      let errorCode;
      if (isRepeated) {
        if (Array.isArray(fieldDataValue)) {
          if (fieldDataValue.length > maxItemCountAppLimit) {
            errorCode = 7;
          }
          fieldDataValue.forEach((value, index2) => {
            this._matchFieldTypes(errorInfos, [...fieldNames, index2.toString()], value, protobufType, descriptor, schemaId, key, void 0, true);
          });
        } else {
          errorCode = 1;
        }
      } else if (fieldDataValue == null || fieldDataValue === void 0) {
        if (isItem) {
          errorCode = 13;
        }
      } else {
        let numOpts;
        let javaScriptType;
        switch (protobufType) {
          case "string":
            javaScriptType = "string";
            if (fieldDataValue.length > maxStringLengthAppLimit) {
              errorCode = 6;
            }
            break;
          case "bytes":
            javaScriptType = "object";
            if (!(fieldDataValue instanceof Uint8Array)) {
              errorCode = 5;
            }
            break;
          case "bool":
            javaScriptType = "boolean";
            break;
          case "uint32":
            javaScriptType = "number";
            numOpts = {
              min: minUnsigned,
              max: maxFourBytesUnsigned,
              isInt: true,
              isItem
            };
            break;
          case "int32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            javaScriptType = "number";
            numOpts = {
              min: minFourBytes,
              max: maxFourBytes,
              isInt: true,
              isItem
            };
            break;
          case "uint64":
            javaScriptType = "number";
            numOpts = {
              min: minUnsigned,
              max: maxEightBytesUnsigned,
              isInt: true,
              isItem
            };
            break;
          case "fixed64":
          case "sfixed64":
          case "int64":
          case "sint64":
            javaScriptType = "number";
            numOpts = {
              min: minEightBytes,
              max: maxEightBytes,
              isInt: true,
              isItem
            };
            break;
          case "double":
          case "float":
            javaScriptType = "number";
            numOpts = {
              min: Number.NEGATIVE_INFINITY,
              max: Number.POSITIVE_INFINITY,
              isInt: false,
              isItem
            };
            break;
          default:
            if (new Set(Object.keys(descriptor)).has(protobufType)) {
              this._validateFields(errorInfos, fieldNames, fieldDataValue, descriptor[protobufType], descriptor, schemaId);
              javaScriptType = "object";
            }
            break;
        }
        if (typeof fieldDataValue !== javaScriptType) {
          errorInfos.push(new ValidationEntry(2, fieldNames, protobufType, typeof fieldDataValue));
        } else if (numOpts) {
          if (numOpts.isInt && !Number.isFinite(fieldDataValue)) {
            errorCode = 3;
          } else if (numOpts.isInt && !Number.isInteger(fieldDataValue)) {
            errorCode = 12;
          } else if (!(!numOpts.isInt && Number.isNaN(fieldDataValue)) && !(fieldDataValue >= numOpts.min && fieldDataValue <= numOpts.max)) {
            errorCode = 4;
          }
        }
      }
      if (errorCode) {
        errorInfos.push(new ValidationEntry(errorCode, fieldNames));
      }
    }
  }
  const logValidator = new LogValidator();
  class BucketHistogramImpl {
    constructor(_name, _ownerName, _ownerAppName, _tags, _buckets) {
      this._name = _name;
      this._ownerName = _ownerName;
      this._ownerAppName = _ownerAppName;
      this._tags = _tags;
      this._buckets = _buckets;
      this._values = new Array();
      this._createdOn = utility.time().tsNow;
    }
    getName() {
      return this._name;
    }
    getCreatedOn() {
      return this._createdOn;
    }
    getLastUpdatedOn() {
      return this._lastUpdatedOn;
    }
    getData() {
      return this.values;
    }
    getBuckets() {
      return this.buckets;
    }
    get buckets() {
      return this._buckets.slice(0, this._buckets.length);
    }
    get values() {
      return this._values.slice(0, this._values.length);
    }
    record(value) {
      if (typeof value === "number") {
        this._values.push(value);
        this._lastUpdatedOn = utility.time().tsNow;
        return;
      }
      throw new Error("BucketHistogram can only record numbers.");
    }
    reset() {
      this._lastUpdatedOn = void 0;
      this._values = [];
    }
    getOwnerName() {
      return this._ownerName;
    }
    getOwnerAppName() {
      return this._ownerAppName;
    }
    getTags() {
      return this._tags;
    }
  }
  class UpCounterImpl {
    constructor(_name, _ownerName, _ownerAppName, _tags) {
      this._name = _name;
      this._ownerName = _ownerName;
      this._ownerAppName = _ownerAppName;
      this._tags = _tags;
      this._value = 0;
      this._createdOn = utility.time().tsNow;
    }
    getName() {
      return this._name;
    }
    getCreatedOn() {
      return this._createdOn;
    }
    getLastUpdatedOn() {
      return this._lastUpdatedOn;
    }
    getData() {
      return this._value;
    }
    increment(value = 1) {
      if (typeof value === "number" && value > 0) {
        this._value += Math.round(value);
        this._lastUpdatedOn = utility.time().tsNow;
        return;
      }
      throw new Error("UpCounter can only increment positive numbers.");
    }
    reset() {
      this._lastUpdatedOn = void 0;
      this._value = 0;
    }
    getOwnerName() {
      return this._ownerName;
    }
    getOwnerAppName() {
      return this._ownerAppName;
    }
    getTags() {
      return this._tags;
    }
  }
  class ValueRecorderImpl {
    constructor(_name, _ownerName, _ownerAppName, _tags) {
      this._name = _name;
      this._ownerName = _ownerName;
      this._ownerAppName = _ownerAppName;
      this._tags = _tags;
      this._values = new Array();
      this._createdOn = utility.time().tsNow;
    }
    getName() {
      return this._name;
    }
    getCreatedOn() {
      return this._createdOn;
    }
    getLastUpdatedOn() {
      return this._lastUpdatedOn;
    }
    getData() {
      return this.values;
    }
    get values() {
      return this._values.slice(0, this._values.length);
    }
    record(value) {
      if (typeof value === "number") {
        this._values.push(value);
        this._lastUpdatedOn = utility.time().tsNow;
        return;
      }
      throw new Error("ValueRecorder can only record numbers.");
    }
    reset() {
      this._lastUpdatedOn = void 0;
      this._values = [];
    }
    getOwnerName() {
      return this._ownerName;
    }
    getOwnerAppName() {
      return this._ownerAppName;
    }
    getTags() {
      return this._tags;
    }
  }
  class SizeLimitedMap {
    constructor(maxSize) {
      this._map = new Map();
      if (typeof maxSize === "number" && maxSize > 0) {
        this._maxSize = Math.ceil(maxSize);
        return;
      }
      throw new Error("maxSize must be a positive number");
    }
    get maxSize() {
      return this._maxSize;
    }
    get(key) {
      return this._map.get(key);
    }
    has(key) {
      return this._map.has(key);
    }
    set(key, value) {
      if (this.has(key) || this._map.size < this.maxSize) {
        this._map.set(key, value);
        return true;
      }
      return false;
    }
    getElements() {
      return Array.from(this._map.values());
    }
    clear() {
      this._map.clear();
    }
  }
  const maxCounters = 1e3;
  const maxValueRecorders = 500;
  const maxBucketHistograms = 500;
  var MetricType;
  (function(MetricType2) {
    MetricType2[MetricType2["Counter"] = 0] = "Counter";
    MetricType2[MetricType2["Percentile"] = 1] = "Percentile";
    MetricType2[MetricType2["BucketHistogram"] = 2] = "BucketHistogram";
  })(MetricType || (MetricType = {}));
  class MetricsImpl {
    constructor(_ownerName, _getOwnerAppName) {
      this._ownerName = _ownerName;
      this._getOwnerAppName = _getOwnerAppName;
      this._upCounters = new SizeLimitedMap(maxCounters);
      this._valueRecorders = new SizeLimitedMap(maxValueRecorders);
      this._bucketHistograms = new SizeLimitedMap(maxBucketHistograms);
    }
    incrementCounter(operation, increment, hasError = false, tags = {}) {
      this._tagError(tags, hasError);
      this._upCounter(operation, tags).increment(increment);
    }
    trackValue(operation, value, hasError = false, tags = {}) {
      this._tagError(tags, hasError);
      this._valueRecorder(operation, tags).record(value);
    }
    bucketValue(operation, value, buckets, hasError = false, tags = {}) {
      this._tagError(tags, hasError);
      this._bucketHistogram(operation, tags, buckets).record(value);
    }
    _bucketHistogram(name, tags, buckets) {
      const {
        key,
        sortedTags
      } = this._getKeyAndSortedTags(name, tags, MetricType.BucketHistogram);
      let instrument = this._bucketHistograms.get(key);
      if (!instrument) {
        instrument = new BucketHistogramImpl(name, this._ownerName, this._getOwnerAppName(), sortedTags, buckets);
        if (!this._bucketHistograms.set(key, instrument)) {
          throw new Error(`Max size of ${maxBucketHistograms} exceeded for BucketHistograms`);
        }
      }
      return instrument;
    }
    _upCounter(name, tags) {
      const {
        key,
        sortedTags
      } = this._getKeyAndSortedTags(name, tags, MetricType.Counter);
      let instrument = this._upCounters.get(key);
      if (!instrument) {
        instrument = new UpCounterImpl(name, this._ownerName, this._getOwnerAppName(), sortedTags);
        if (!this._upCounters.set(key, instrument)) {
          throw new Error(`Max size of ${maxCounters} exceeded for UpCounters`);
        }
      }
      return instrument;
    }
    _valueRecorder(name, tags) {
      const {
        key,
        sortedTags
      } = this._getKeyAndSortedTags(name, tags, MetricType.Percentile);
      let instrument = this._valueRecorders.get(key);
      if (!instrument) {
        instrument = new ValueRecorderImpl(name, this._ownerName, this._getOwnerAppName(), sortedTags);
        if (!this._valueRecorders.set(key, instrument)) {
          throw new Error(`Max size of ${maxValueRecorders} exceeded for ValueRecorders`);
        }
      }
      return instrument;
    }
    getUpCounters() {
      return this._upCounters.getElements();
    }
    getValueRecorders() {
      return this._valueRecorders.getElements();
    }
    getBucketHistograms() {
      return this._bucketHistograms.getElements();
    }
    _tagError(tags, hasError) {
      tags.status = hasError === true ? "error" : "success";
    }
    _getKeyAndSortedTags(operation, tags, metricType) {
      const sortedTags = Object.keys(tags).sort().reduce((prev, curr) => {
        prev[curr] = tags[curr];
        return prev;
      }, {});
      const key = `${MetricType[metricType]}:${operation}${JSON.stringify(sortedTags)}`;
      return {
        key,
        sortedTags
      };
    }
  }
  class MockBase {
    constructor() {
      this.isMock = true;
    }
  }
  const maxActivityDurationMsecs = void 0;
  const reservedMetricCharacters = ["`"];
  const reservedMetricNames = {
    internalError: "o11y-error"
  };
  const denyListMetricNames = Object.freeze(Array.from(Object.values(reservedMetricNames)));
  class InstrumentationImpl {
    constructor(_nextGen, _name) {
      this._nextGen = _nextGen;
      this._name = _name;
      this._onActivityStoppedCallback = this._handleActivityStop.bind(this);
      this._onActivityErrorCallback = this._handleActivityError.bind(this);
      for (const reservedChar of reservedMetricCharacters) {
        if (this._name.indexOf(reservedChar) >= 0) {
          throw new Error(`Name cannot include the reserved character "${reservedChar}"`);
        }
      }
      this._safety = new PublicSafety({
        increment: (increment) => this._incrementError(increment)
      });
      this._metrics = this._initMetrics();
      const simpleTextOptions = schemaUtil.getOptions(simple, "Simple", "text");
      this._simpleTextMaxLength = simpleTextOptions ? simpleTextOptions["(meta.max_length)"] : maxStringLengthAppLimit;
    }
    _initMetrics() {
      return new MetricsImpl(this.name, () => this._nextGen.appName || InstrumentationImpl.defaultAppName);
    }
    _incrementError(increment = 1) {
      this._metrics.incrementCounter(reservedMetricNames.internalError, increment, false);
    }
    get name() {
      return this._name;
    }
    _wrapUserPayload(userSchemaOrText, userData, onlyIfBoth = false) {
      let userSchema;
      if (typeof userSchemaOrText === "string") {
        userSchema = simple;
        if (userSchemaOrText) {
          userData = {
            text: userSchemaOrText.substring(0, this._simpleTextMaxLength)
          };
        } else {
          userData = void 0;
        }
      } else {
        userSchema = userSchemaOrText;
      }
      return schemaUtil.makePayload(userSchema, userData, onlyIfBoth);
    }
    _getEffectiveRootId(options) {
      var _a, _b;
      return (_b = (_a = options === null || options === void 0 ? void 0 : options.instrumentationContext) === null || _a === void 0 ? void 0 : _a.rootId) !== null && _b !== void 0 ? _b : this._nextGen.getDefaultInstrumentationContext().rootId;
    }
    log(userSchemaOrText, userData, options) {
      this._safety.tryCatch(() => {
        const timestamp = utility.time().tsNow;
        utility.requireArgument(userSchemaOrText, "userSchemaOrText", ["object", "string"]);
        utility.requireArgumentIfDefined(userData, "userData", "object");
        utility.requireArgumentIfDefined(options, "options", "object");
        const userPayload = this._wrapUserPayload(userSchemaOrText, userData);
        if (userPayload === null || userPayload === void 0 ? void 0 : userPayload.payload) {
          this._logInternal(this.name, userPayload.schema, userPayload.payload, timestamp, this._getEffectiveRootId(options));
        }
      });
    }
    _logInternal(loggerName, schema, data, timestamp, rootId2) {
      this._checkInputs(schema, data);
      const appPayload = this._getPayloadFromProvider(this._nextGen.appPayloadProvider);
      const pagePayload = this._getPayloadFromProvider(this._nextGen.pagePayloadProvider);
      return this._nextGen.addLog(loggerName, schema, data, timestamp, rootId2, pagePayload, appPayload);
    }
    error(error2, userSchemaOrText, userData, options) {
      return this._safety.tryCatch(() => {
        utility.requireArgumentIfDefined(userSchemaOrText, "userSchemaOrText", ["object", "string"]);
        utility.requireArgumentIfDefined(userData, "userData", "object");
        utility.requireArgumentIfDefined(options, "options", "object");
        const rootId2 = this._getEffectiveRootId(options);
        this._errorInternal(error2, userSchemaOrText, userData, void 0, rootId2);
      });
    }
    _errorInternal(err, userSchemaOrText, userData, activityId, rootActivityId) {
      const loggedTimestamp = utility.time().tsNow;
      let error$1;
      if (err instanceof Error) {
        error$1 = err;
      } else {
        let msg;
        if (err === void 0 || err === null || typeof err.toString !== "function") {
          msg = "UNKNOWN";
        } else {
          msg = err.toString();
        }
        error$1 = new Error(msg);
      }
      const userPayload = this._wrapUserPayload(userSchemaOrText, userData, true);
      const errorData = {
        name: error$1.name,
        message: error$1.message,
        stack: error$1.stack,
        userPayload,
        activityId
      };
      return this._logInternal(this.name, error, errorData, loggedTimestamp, rootActivityId);
    }
    startActivity(name, options) {
      return this._safety.tryCatchReturn(() => {
        var _a;
        utility.requireArgument(name, "name");
        utility.requireArgumentIfDefined(options, "options", "object");
        let context;
        const rootId2 = (_a = options === null || options === void 0 ? void 0 : options.instrumentationContext) === null || _a === void 0 ? void 0 : _a.rootId;
        if (rootId2) {
          context = {
            rootId: rootId2,
            isRootActivitySampled: options.instrumentationContext.isRootActivitySampled
          };
        } else {
          context = this._nextGen.getDefaultInstrumentationContext();
        }
        const activity2 = new ActivityImpl(name, context.rootId, this._onActivityStoppedCallback, this._onActivityErrorCallback, maxActivityDurationMsecs, void 0, context.isRootActivitySampled);
        return activity2;
      }, activityNoOp);
    }
    _getActivityData(detail) {
      const userPayload = this._wrapUserPayload(detail.userSchemaOrText, detail.userData, true);
      return {
        id: detail.id,
        name: detail.name,
        duration: detail.stopPerfTime - detail.startPerfTime,
        stopReason: detail.stopReason,
        userPayload,
        errorCount: detail.errorCount,
        isSampled: detail.isSampled,
        timerOverridden: detail.timerOverridden
      };
    }
    _handleActivityStop(detail) {
      if (detail.stopReason === discarded) {
        return;
      }
      const activityData = this._getActivityData(detail);
      this._logActivity(activityData, detail.startTimestamp, detail.rootId);
    }
    _logActivity(activityData, startTimestamp, rootId2) {
      this._logInternal(this.name, activity, activityData, startTimestamp, rootId2);
    }
    _handleActivityError(error2, detail) {
      this._errorInternal(error2, detail.userSchemaOrText, detail.userData, detail.id, detail.rootId);
    }
    _getPayloadFromProvider(provider) {
      const payload = (provider === null || provider === void 0 ? void 0 : provider.getPayload()) || void 0;
      if (payload) {
        this._checkInputs(payload.schema, payload.payload);
      }
      return payload;
    }
    domEvent(event, handledBy, userSchemaOrText, userData, options) {
      this._safety.tryCatch(() => {
        var _a;
        const tsNow = utility.time().tsNow;
        utility.requireArgument(event, "event", [Event, MockBase]);
        utility.requireArgument(handledBy, "handledBy", [HTMLElement, "object"]);
        let htmlElement;
        if (handledBy instanceof HTMLElement) {
          htmlElement = handledBy;
        } else {
          handledBy = handledBy;
          if (((_a = handledBy.template) === null || _a === void 0 ? void 0 : _a.host) instanceof HTMLElement) {
            htmlElement = handledBy.template.host;
          } else {
            utility.requireArgument(void 0, "handledBy");
          }
        }
        const userPayload = this._wrapUserPayload(userSchemaOrText, userData, true);
        const rootId2 = this._getEffectiveRootId(options);
        switch (event.type) {
          case "click": {
            const mouseEvent = event;
            const acd = this._nextGen.getClickTracker();
            if (acd) {
              acd.markEventHandled(mouseEvent);
            }
            const mouseEventData = domEventHelpers.getMouseEventData(mouseEvent);
            const instrumentedEvent = domEventHelpers.getInstrumentedEventData(mouseEventData, htmlElement, userPayload);
            instrumentedEvent.auto = options === null || options === void 0 ? void 0 : options._auto;
            this._logInternal(this.name, instrumented_event, instrumentedEvent, tsNow, rootId2);
            break;
          }
          default:
            throw new Error(utility.notImplemented);
        }
      });
    }
    incrementCounter(operation, increment = 1, hasError = false, tags = {}) {
      this._safety.tryCatch(() => {
        utility.requireArgument(operation, "operation", "string");
        utility.checkForDenyListedValues(operation, "operation", denyListMetricNames);
        utility.checkForReservedCharacters(operation, "operation", reservedMetricCharacters);
        utility.requireArgument(increment, "increment", "number");
        utility.requireArgument(hasError, "hasError", "boolean");
        utility.requireArgument(tags, "tags", "object");
        Object.entries(tags).forEach((entry) => {
          utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, ["string", "number", "boolean"]);
        });
        this._metrics.incrementCounter(operation, increment, hasError, tags);
      });
    }
    trackValue(operation, value, hasError = false, tags = {}) {
      this._safety.tryCatch(() => {
        utility.requireArgument(operation, "operation", "string");
        utility.checkForDenyListedValues(operation, "operation", denyListMetricNames);
        utility.checkForReservedCharacters(operation, "operation", reservedMetricCharacters);
        utility.requireArgument(value, "value", "number");
        utility.requireArgument(hasError, "hasError", "boolean");
        utility.requireArgument(tags, "tags", "object");
        Object.entries(tags).forEach((entry) => {
          utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, ["string", "number", "boolean"]);
        });
        this._metrics.trackValue(operation, value, hasError, tags);
      });
    }
    bucketValue(operation, value, buckets = [], hasError = false, tags = {}) {
      this._safety.tryCatch(() => {
        utility.requireArgument(operation, "operation", "string");
        utility.checkForDenyListedValues(operation, "operation", denyListMetricNames);
        utility.checkForReservedCharacters(operation, "operation", reservedMetricCharacters);
        utility.requireArgument(value, "value", "number");
        utility.requireArgument(buckets, "buckets", Array);
        Object.entries(buckets).forEach((entry) => {
          utility.requireArgument(entry[1], `Bucket value for '${entry[0]}'`, "number");
        });
        utility.requireArgument(hasError, "hasError", "boolean");
        utility.requireArgument(tags, "tags", "object");
        Object.entries(tags).forEach((entry) => {
          utility.requireArgument(entry[1], `Tag value for '${entry[0]}'`, ["string", "number", "boolean"]);
        });
        this._metrics.bucketValue(operation, value, buckets, hasError, tags);
      });
    }
    _checkInputs(schema, data) {
      schemaUtil.checkSchema(schema);
      utility.requireArgument(data, "data", "object");
      let vEntries;
      let savedUserPayload;
      if (data.userPayload !== void 0 && schemaUtil.isInternal(schema)) {
        savedUserPayload = data.userPayload;
        vEntries = logValidator.validate(savedUserPayload.schema, savedUserPayload.payload, true);
        this._processValidationResults(schemaUtil.getSchemaId(savedUserPayload.schema), savedUserPayload.payload, vEntries);
        data.userPayload = void 0;
      }
      vEntries = logValidator.validate(schema, data, true);
      this._processValidationResults(schemaUtil.getSchemaId(schema), data, vEntries);
      if (savedUserPayload !== void 0) {
        data.userPayload = savedUserPayload;
      }
    }
    _processValidationResults(schemaId, data, ventries) {
      for (let i2 = 0; i2 < ventries.length; i2 += 1) {
        const ei = ventries[i2];
        if (ei.errorCode == 6 || ei.errorCode == 7) {
          const lfi = ei.fields.length - 1;
          const obj = this._traverseFields(data, ei.fields.slice(0, lfi));
          const field = ei.fields[lfi];
          if (ei.errorCode == 6) {
            obj[field] = obj[field].substring(0, maxStringLengthAppLimit);
          } else {
            obj[field].splice(maxItemCountAppLimit);
          }
        } else {
          throw new Error(ei.asMessage(schemaId));
        }
      }
    }
    _traverseFields(data, fields) {
      if (!fields.length) {
        return data;
      }
      return this._traverseFields(data[fields[0]], fields.slice(1));
    }
    getUpCounters() {
      return this._metrics.getUpCounters().filter((m2) => m2.getLastUpdatedOn());
    }
    getValueRecorders() {
      return this._metrics.getValueRecorders().filter((m2) => m2.getLastUpdatedOn());
    }
    getBucketHistograms() {
      return this._metrics.getBucketHistograms().filter((m2) => m2.getLastUpdatedOn());
    }
    registerForLogPrompt(listener) {
      utility.requireArgument(listener, "listener", "function");
      this._nextGen.registerForLogPrompt(listener);
    }
    activity(name, execute, options) {
      var _a, _b, _c, _d;
      const act = this.startActivity(name, options);
      try {
        return execute(act);
      } catch (err) {
        act.error(err, (_a = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _a === void 0 ? void 0 : _a.schema, (_b = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _b === void 0 ? void 0 : _b.payload);
        throw err;
      } finally {
        act.stop((_c = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _c === void 0 ? void 0 : _c.schema, (_d = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _d === void 0 ? void 0 : _d.payload);
      }
    }
    async activityAsync(name, execute, options) {
      var _a, _b, _c, _d;
      const act = this.startActivity(name, options);
      try {
        return await execute(act);
      } catch (err) {
        act.error(err, (_a = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _a === void 0 ? void 0 : _a.schema, (_b = options === null || options === void 0 ? void 0 : options.errorPayload) === null || _b === void 0 ? void 0 : _b.payload);
        throw err;
      } finally {
        act.stop((_c = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _c === void 0 ? void 0 : _c.schema, (_d = options === null || options === void 0 ? void 0 : options.stopPayload) === null || _d === void 0 ? void 0 : _d.payload);
      }
    }
  }
  InstrumentationImpl.defaultAppName = "APP_NOT_REGISTERED";
  class RootActivityImpl extends ActivityImpl {
    constructor(name, onStopped, onError, rootId2, _isSampled) {
      super(name, void 0, onStopped, onError, void 0, rootId2 || utility.generateUniqueId(32), _isSampled);
    }
    get preRootId() {
      return this._preRootId;
    }
    set preRootId(value) {
      this._preRootId = value;
    }
    _getDetail(userSchema, userData) {
      const detail = super._getDetail(userSchema, userData);
      detail.isRoot = true;
      detail.preRootId = this.preRootId;
      return detail;
    }
  }
  const rootId = new Array(32).fill(0).join("");
  class RootActivityNoOp {
    getId() {
      return rootId;
    }
    getRootId() {
      return void 0;
    }
    error() {
    }
    stop() {
    }
    discard() {
    }
    terminate() {
    }
    getIsSampled() {
      return false;
    }
    getTraceHeaders(__options) {
      return {};
    }
    getStartTimestamp() {
      return void 0;
    }
    getStartPerfTime() {
      return void 0;
    }
    getStopPerfTime() {
      return void 0;
    }
  }
  const rootActivityNoOp = Object.freeze(new RootActivityNoOp());
  class AppInstrumentationImpl extends InstrumentationImpl {
    constructor(_nextGen, _name, _allowMulti) {
      super(_nextGen, _name);
      this._allowMulti = _allowMulti;
      this._onRootActivityStoppedCallback = this._handleRootActivityStop.bind(this);
    }
    startRootActivity(name, rootId2, isSampled) {
      return this._safety.tryCatchReturn(() => {
        utility.requireArgument(name, "name");
        const newRootActivity = new RootActivityImpl(name, this._onRootActivityStoppedCallback, this._onActivityErrorCallback, rootId2, isSampled);
        if (!this._allowMulti) {
          if (this._singleRootActivity && !this._singleRootActivity.isStopped) {
            const preRootId = this._singleRootActivity.getId();
            this._singleRootActivity.terminate();
            newRootActivity.preRootId = preRootId;
          }
          this._singleRootActivity = newRootActivity;
        }
        return newRootActivity;
      }, rootActivityNoOp);
    }
    _handleRootActivityStop(detail) {
      if (detail.stopReason === discarded) {
        return;
      }
      const activityData = this._getActivityData(detail);
      this._logActivity(activityData, detail.startTimestamp);
      this._singleRootActivity = void 0;
    }
    _getActivityData(detail) {
      const activityData = super._getActivityData(detail);
      activityData.isRoot = detail.isRoot;
      activityData.preRootId = detail.preRootId;
      return activityData;
    }
    getSingleRootActivityId() {
      var _a;
      return (_a = this._singleRootActivity) === null || _a === void 0 ? void 0 : _a.getId();
    }
    isSingleRootActivitySampled() {
      var _a;
      return (_a = this._singleRootActivity) === null || _a === void 0 ? void 0 : _a.getIsSampled();
    }
    _initMetrics() {
      return new MetricsImpl(this.name, () => this.name);
    }
  }
  const pathLimit = 5;
  class AutomaticClickTracker {
    constructor(_instr, _doc) {
      this._instr = _instr;
      this._doc = _doc;
      this._isActive = false;
      this._boundClickListener = this._clickListener.bind(this);
      utility.requireArgument(_instr, "_instr");
      utility.requireArgument(_doc, "_doc");
    }
    activate() {
      if (!this._isActive) {
        this._doc.addEventListener("click", this._boundClickListener, true);
        this._isActive = true;
      }
    }
    deactivate() {
      if (this._isActive) {
        this._doc.removeEventListener("click", this._boundClickListener, true);
        this._isActive = false;
      }
    }
    markEventHandled(event) {
      this._ignoredEvent = event;
    }
    _clickListener(event) {
      var _a;
      let eventTargets = (_a = event.composedPath) === null || _a === void 0 ? void 0 : _a.call(event);
      if (!eventTargets || !eventTargets.length) {
        eventTargets = event.path;
      }
      const handledBy = this._getClickableElement(eventTargets);
      if (handledBy) {
        setTimeout(() => {
          if (event !== this._ignoredEvent) {
            this._instr.domEvent(event, handledBy, void 0, void 0, {
              _auto: true
            });
          }
        });
      }
    }
    _getClickableElement(path) {
      var _a, _b;
      const limit = path ? Math.min(path.length, pathLimit) : 0;
      for (let x = 0; x < limit; x += 1) {
        const currentElement = path[x];
        const tagName = (_a = currentElement.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (tagName === "a" || tagName === "button") {
          return currentElement;
        }
        if (tagName === "input") {
          const inputElement = currentElement;
          if (((_b = inputElement.type) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === "button") {
            return inputElement;
          }
        }
      }
      return void 0;
    }
  }
  const maxInstrumentationLength = 80;
  const truncatedText = "_CUT";
  const maxInstrumentationLengthBeforeTruncated = maxInstrumentationLength - truncatedText.length;
  class NextgenImpl {
    get pagePayloadProvider() {
      return this._pagePayloadProvider;
    }
    set pagePayloadProvider(provider) {
      this._pagePayloadProvider = provider;
    }
    get appPayloadProvider() {
      return this._appPayloadProvider;
    }
    set appPayloadProvider(provider) {
      this._appPayloadProvider = provider;
    }
    constructor(_idleDetector) {
      this._idleDetector = _idleDetector;
      this._logCollectors = new Set();
      this._instruments = new Map();
      this._seqBySchema = new Map();
      this._sequence = 0;
      this._forceDisabledLogCollectors = new Set();
      this._logCollectorFailures = new Map();
      this._isBufferingEnabled = false;
      this._buffer = [];
      this._logCollectionListeners = new Set();
    }
    registerApp(name, options) {
      var _a;
      utility.requireArgument(name, "name", "string");
      if (this._appInstr) {
        throw new Error("An app has already been registered with instrumentation.");
      }
      const instr = this._instruments.get(name);
      if (instr) {
        throw new Error(`The instrumentation name ${name} is already taken`);
      }
      this._clientSessionId = ((_a = options === null || options === void 0 ? void 0 : options.clientSessionId) === null || _a === void 0 ? void 0 : _a.toString()) || utility.generateUniqueId();
      this._appInstr = new AppInstrumentationImpl(this, name, options === null || options === void 0 ? void 0 : options.allowMultipleRootActivities);
      this._instruments.set(name, this._appInstr);
      this._isBufferingEnabled = options === null || options === void 0 ? void 0 : options.enableBuffering;
      const tracing = new Tracing(this.getInstrumentation("Network"), this._idleDetector);
      return {
        log: this._appInstr.log.bind(this._appInstr),
        error: this._appInstr.error.bind(this._appInstr),
        startActivity: this._appInstr.startActivity.bind(this._appInstr),
        domEvent: this._appInstr.domEvent.bind(this._appInstr),
        incrementCounter: this._appInstr.incrementCounter.bind(this._appInstr),
        trackValue: this._appInstr.trackValue.bind(this._appInstr),
        bucketValue: this._appInstr.bucketValue.bind(this._appInstr),
        networkInstrumentation: tracing.networkInstrumentation.bind(tracing),
        registerForLogPrompt: this._appInstr.registerForLogPrompt.bind(this._appInstr),
        activity: this._appInstr.activity.bind(this._appInstr),
        activityAsync: this._appInstr.activityAsync.bind(this._appInstr),
        startRootActivity: this._appInstr.startRootActivity.bind(this._appInstr),
        registerLogCollector: this.registerLogCollector.bind(this),
        registerMetricsCollector: this.registerMetricsCollector.bind(this),
        activateClickTracker: this.activateClickTracker.bind(this),
        deactivateClickTracker: this.deactivateClickTracker.bind(this),
        disableBuffering: this.disableBuffering.bind(this),
        promptLogCollection: this.promptLogCollection.bind(this),
        getClientSessionId: this.getClientSessionId.bind(this)
      };
    }
    getInstrumentation(name) {
      utility.requireArgument(name, "name", "string");
      if (name.length > maxInstrumentationLength) {
        name = name.substr(0, maxInstrumentationLengthBeforeTruncated) + truncatedText;
      }
      let instr = this._instruments.get(name);
      if (!instr) {
        instr = new InstrumentationImpl(this, name);
        this._instruments.set(name, instr);
      } else if (instr === this._appInstr) {
        throw new Error(`The instrumentation name ${name} is being used by the app.`);
      }
      return instr;
    }
    get appName() {
      var _a;
      return (_a = this._appInstr) === null || _a === void 0 ? void 0 : _a.name;
    }
    addLog(loggerName, schema, data, timestamp, rootId2, pagePayload, appPayload) {
      this._sequence += 1;
      const userSchema = schemaUtil.isInternal(schema) && (data === null || data === void 0 ? void 0 : data.userPayload) ? data.userPayload.schema : schema;
      const schemaId = schemaUtil.getSchemaId(userSchema);
      let schemaSequence = this._seqBySchema.get(schemaId) || 0;
      schemaSequence += 1;
      this._seqBySchema.set(schemaId, schemaSequence);
      const logMeta = {
        timestamp,
        rootId: rootId2,
        sequence: this._sequence,
        schemaSequence,
        loggerName,
        pagePayload: pagePayload ? utility.clone(pagePayload) : void 0,
        appPayload: appPayload ? utility.clone(appPayload) : void 0,
        loggerAppName: this.appName,
        connectionType: utility.getConnectionType(),
        clientSessionId: this._clientSessionId
      };
      if (this._isBufferingEnabled) {
        this._buffer.push({
          schema,
          data: utility.clone(data),
          logMeta
        });
      }
      const eligibleCollectors = Array.from(this._logCollectors).filter((collector) => {
        var _a;
        return !this._forceDisabledLogCollectors.has(collector) && !((_a = collector.getIsCollectDisabled) === null || _a === void 0 ? void 0 : _a.call(collector));
      });
      if (eligibleCollectors.length > 0) {
        for (const collector of eligibleCollectors) {
          const dataClone = utility.clone(data);
          let failures = this._logCollectorFailures.get(collector) || 0;
          try {
            collector.collect(schema, dataClone, logMeta);
            if (failures > 0) {
              this._logCollectorFailures.set(collector, failures - 1);
            }
          } catch (err) {
            failures += 1;
            if (failures >= NextgenImpl._collectorFailureLimit) {
              this._forceDisabledLogCollectors.add(collector);
              if (this._appInstr && (typeof err === "string" || err instanceof Error)) {
                this._appInstr.error(err);
              }
            } else {
              this._logCollectorFailures.set(collector, failures);
            }
          }
        }
      }
      return this._sequence;
    }
    getBuffer() {
      return this._buffer;
    }
    disableBuffering() {
      this._isBufferingEnabled = false;
      this._buffer = [];
    }
    getClickTracker() {
      return this._autoClickTracker;
    }
    getDefaultInstrumentationContext() {
      var _a, _b;
      return {
        rootId: (_a = this._appInstr) === null || _a === void 0 ? void 0 : _a.getSingleRootActivityId(),
        isRootActivitySampled: (_b = this._appInstr) === null || _b === void 0 ? void 0 : _b.isSingleRootActivitySampled()
      };
    }
    activateClickTracker() {
      if (typeof document !== "undefined") {
        if (!this._autoClickTracker) {
          this._autoClickTracker = new AutomaticClickTracker(this._appInstr, document);
        }
        this._autoClickTracker.activate();
      }
    }
    deactivateClickTracker() {
      if (this._autoClickTracker) {
        this._autoClickTracker.deactivate();
        this._autoClickTracker = void 0;
      }
    }
    registerLogCollector(collector, options) {
      utility.requireArgument(collector, "collector");
      if (this._logCollectors.has(collector)) {
        return;
      }
      this._logCollectors.add(collector);
      this._logCollectorFailures.set(collector, 0);
      if ((!collector.getIsCollectDisabled || !collector.getIsCollectDisabled()) && options && options.retroactive) {
        for (const log of this._buffer) {
          collector.collect(log.schema, log.data, log.logMeta);
        }
      }
    }
    registerMetricsCollector(collector) {
      utility.requireArgument(collector, "collector");
      if (this._metricsCollector) {
        throw new Error("A metrics Collector is already registered.");
      }
      this._metricsCollector = collector;
      this._metricsCollector.receiveMetricsExtractors({
        getAllUpCounters: this._getAllUpCounters.bind(this),
        getAllValueRecorders: this._getAllValueRecorders.bind(this),
        getAllBucketHistograms: this._getAllBucketHistograms.bind(this)
      });
    }
    _getAllUpCounters() {
      const arrOfArrs = Array.from(this._instruments.values()).map((instr) => instr.getUpCounters());
      return arrOfArrs.reduce((pv, cv) => pv.concat(cv), []);
    }
    _getAllValueRecorders() {
      const arrOfArrs = Array.from(this._instruments.values()).map((instr) => instr.getValueRecorders());
      return arrOfArrs.reduce((pv, cv) => pv.concat(cv), []);
    }
    _getAllBucketHistograms() {
      const arrOfArrs = Array.from(this._instruments.values()).map((instr) => instr.getBucketHistograms());
      return arrOfArrs.reduce((pv, cv) => pv.concat(cv), []);
    }
    registerForLogPrompt(listener) {
      this._logCollectionListeners.add(listener);
    }
    promptLogCollection(reason) {
      for (const listener of this._logCollectionListeners.keys()) {
        try {
          listener(reason);
        } catch (err) {
          if (!utility.isProduction) {
            throw err;
          }
        }
      }
    }
    getClientSessionId() {
      return this._clientSessionId;
    }
  }
  NextgenImpl._collectorFailureLimit = 5;
  class Index {
    get _lazyNextGen() {
      if (!this._nextgen) {
        this._nextgen = new NextgenImpl(this._idleDetector);
      }
      return this._nextgen;
    }
    constructor(_idleDetector) {
      this._idleDetector = _idleDetector;
      utility.requireArgument(_idleDetector, "_idleDetector");
    }
    registerInstrumentedApp(name, options) {
      if (!options || options.isProduction !== false) {
        utility.markProduction();
      }
      const retVal = this._lazyNextGen.registerApp(name, options);
      if (options) {
        this._nextgen.appPayloadProvider = options.appPayloadProvider;
        this._nextgen.pagePayloadProvider = options.pagePayloadProvider;
      }
      return retVal;
    }
    getInstrumentation(name) {
      return this._lazyNextGen.getInstrumentation(name);
    }
  }
  const time = utility.time.bind(utility);
  const bgColorMap = {
    Error: "Crimson",
    Activity: "CadetBlue",
    InstrumentedEvent: "DarkOliveGreen",
    O11ySample: "BlueViolet"
  };
  const colorMap = {
    Error: "white",
    Activity: "white",
    InstrumentedEvent: "white",
    O11ySample: "white"
  };
  const defaultColor = "black";
  const defaultBgColor = "Gainsboro";
  let ConsoleCollector$1 = class ConsoleCollector {
    constructor(environment) {
      if (environment) {
        this._log("ConsoleCollector", environment);
      }
    }
    collect(schema, data, logMeta) {
      let label, color, bgColor;
      if (schema.namespace === "sf.instrumentation") {
        label = schema.name;
        color = colorMap[schema.name] || defaultColor;
        bgColor = bgColorMap[schema.name] || defaultBgColor;
      } else {
        label = schemaUtil.getSchemaId(schema);
      }
      this._log(label, data, logMeta, color, bgColor);
    }
    _log(label, first, second, color = defaultColor, bgColor = defaultBgColor) {
      const css = `color:${color};background-color:${bgColor}`;
      console.log(`%cO11Y%c ${label}`, "color:white;background-color:#FF6600;font-weight:bold", css, first || "", second || "");
    }
  };
  const version$1 = "244.9.0";
  const idleDetector$1 = new IdleDetectorImpl({
    logThreshold: 300,
    reportListener: (report) => {
      idleDetectorInstr === null || idleDetectorInstr === void 0 ? void 0 : idleDetectorInstr.log(idle_detector_report, report);
    },
    errorListener: (e2, text) => {
      idleDetectorInstr === null || idleDetectorInstr === void 0 ? void 0 : idleDetectorInstr.error(e2, text);
    }
  });
  const index = new Index(idleDetector$1);
  const registerInstrumentedApp$1 = index.registerInstrumentedApp.bind(index);
  const getInstrumentation = index.getInstrumentation.bind(index);
  const idleDetectorInstr = getInstrumentation("IdleDetector");
  var o11yClient = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ConsoleCollector: ConsoleCollector$1,
    _version: version$1,
    getInstrumentation,
    idleDetector: idleDetector$1,
    registerInstrumentedApp: registerInstrumentedApp$1,
    time
  });
  const version = "244.39.0";
  const web_vitals = {
    namespace: "sf.instrumentation",
    name: "WebVitals",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            instrumentation: {
              nested: {
                WebVitals: {
                  fields: {
                    name: {
                      id: 1,
                      type: "string"
                    },
                    delta: {
                      id: 3,
                      type: "double"
                    },
                    value: {
                      id: 2,
                      type: "double"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  var e, t, n, i, r = function(e2, t2) {
    return {
      name: e2,
      value: t2 === void 0 ? -1 : t2,
      delta: 0,
      entries: [],
      id: "v2-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12)
    };
  }, a = function(e2, t2) {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(e2)) {
        if (e2 === "first-input" && !("PerformanceEventTiming" in self))
          return;
        var n2 = new PerformanceObserver(function(e3) {
          return e3.getEntries().map(t2);
        });
        return n2.observe({
          type: e2,
          buffered: true
        }), n2;
      }
    } catch (e3) {
    }
  }, o = function(e2, t2) {
    var n2 = function n3(i2) {
      i2.type !== "pagehide" && document.visibilityState !== "hidden" || (e2(i2), t2 && (removeEventListener("visibilitychange", n3, true), removeEventListener("pagehide", n3, true)));
    };
    addEventListener("visibilitychange", n2, true), addEventListener("pagehide", n2, true);
  }, u = function(e2) {
    addEventListener("pageshow", function(t2) {
      t2.persisted && e2(t2);
    }, true);
  }, c = function(e2, t2, n2) {
    var i2;
    return function(r2) {
      t2.value >= 0 && (r2 || n2) && (t2.delta = t2.value - (i2 || 0), (t2.delta || i2 === void 0) && (i2 = t2.value, e2(t2)));
    };
  }, f = -1, s = function() {
    return document.visibilityState === "hidden" ? 0 : 1 / 0;
  }, m = function() {
    o(function(e2) {
      var t2 = e2.timeStamp;
      f = t2;
    }, true);
  }, v = function() {
    return f < 0 && (f = s(), m(), u(function() {
      setTimeout(function() {
        f = s(), m();
      }, 0);
    })), {
      get firstHiddenTime() {
        return f;
      }
    };
  }, d = function(e2, t2) {
    var n2, i2 = v(), o2 = r("FCP"), f2 = function(e3) {
      e3.name === "first-contentful-paint" && (m2 && m2.disconnect(), e3.startTime < i2.firstHiddenTime && (o2.value = e3.startTime, o2.entries.push(e3), n2(true)));
    }, s2 = window.performance && performance.getEntriesByName && performance.getEntriesByName("first-contentful-paint")[0], m2 = s2 ? null : a("paint", f2);
    (s2 || m2) && (n2 = c(e2, o2, t2), s2 && f2(s2), u(function(i3) {
      o2 = r("FCP"), n2 = c(e2, o2, t2), requestAnimationFrame(function() {
        requestAnimationFrame(function() {
          o2.value = performance.now() - i3.timeStamp, n2(true);
        });
      });
    }));
  }, p = false, l = -1, h = function(e2, t2) {
    p || (d(function(e3) {
      l = e3.value;
    }), p = true);
    var n2, i2 = function(t3) {
      l > -1 && e2(t3);
    }, f2 = r("CLS", 0), s2 = 0, m2 = [], v2 = function(e3) {
      if (!e3.hadRecentInput) {
        var t3 = m2[0], i3 = m2[m2.length - 1];
        s2 && e3.startTime - i3.startTime < 1e3 && e3.startTime - t3.startTime < 5e3 ? (s2 += e3.value, m2.push(e3)) : (s2 = e3.value, m2 = [e3]), s2 > f2.value && (f2.value = s2, f2.entries = m2, n2());
      }
    }, h2 = a("layout-shift", v2);
    h2 && (n2 = c(i2, f2, t2), o(function() {
      h2.takeRecords().map(v2), n2(true);
    }), u(function() {
      s2 = 0, l = -1, f2 = r("CLS", 0), n2 = c(i2, f2, t2);
    }));
  }, T = {
    passive: true,
    capture: true
  }, y = new Date(), g = function(i2, r2) {
    e || (e = r2, t = i2, n = new Date(), w(removeEventListener), E());
  }, E = function() {
    if (t >= 0 && t < n - y) {
      var r2 = {
        entryType: "first-input",
        name: e.type,
        target: e.target,
        cancelable: e.cancelable,
        startTime: e.timeStamp,
        processingStart: e.timeStamp + t
      };
      i.forEach(function(e2) {
        e2(r2);
      }), i = [];
    }
  }, S = function(e2) {
    if (e2.cancelable) {
      var t2 = (e2.timeStamp > 1e12 ? new Date() : performance.now()) - e2.timeStamp;
      e2.type == "pointerdown" ? function(e3, t3) {
        var n2 = function() {
          g(e3, t3), r2();
        }, i2 = function() {
          r2();
        }, r2 = function() {
          removeEventListener("pointerup", n2, T), removeEventListener("pointercancel", i2, T);
        };
        addEventListener("pointerup", n2, T), addEventListener("pointercancel", i2, T);
      }(t2, e2) : g(t2, e2);
    }
  }, w = function(e2) {
    ["mousedown", "keydown", "touchstart", "pointerdown"].forEach(function(t2) {
      return e2(t2, S, T);
    });
  }, L = function(n2, f2) {
    var s2, m2 = v(), d2 = r("FID"), p2 = function(e2) {
      e2.startTime < m2.firstHiddenTime && (d2.value = e2.processingStart - e2.startTime, d2.entries.push(e2), s2(true));
    }, l2 = a("first-input", p2);
    s2 = c(n2, d2, f2), l2 && o(function() {
      l2.takeRecords().map(p2), l2.disconnect();
    }, true), l2 && u(function() {
      var a2;
      d2 = r("FID"), s2 = c(n2, d2, f2), i = [], t = -1, e = null, w(addEventListener), a2 = p2, i.push(a2), E();
    });
  }, b = {}, F = function(e2, t2) {
    var n2, i2 = v(), f2 = r("LCP"), s2 = function(e3) {
      var t3 = e3.startTime;
      t3 < i2.firstHiddenTime && (f2.value = t3, f2.entries.push(e3), n2());
    }, m2 = a("largest-contentful-paint", s2);
    if (m2) {
      n2 = c(e2, f2, t2);
      var d2 = function() {
        b[f2.id] || (m2.takeRecords().map(s2), m2.disconnect(), b[f2.id] = true, n2(true));
      };
      ["keydown", "click"].forEach(function(e3) {
        addEventListener(e3, d2, {
          once: true,
          capture: true
        });
      }), o(d2, true), u(function(i3) {
        f2 = r("LCP"), n2 = c(e2, f2, t2), requestAnimationFrame(function() {
          requestAnimationFrame(function() {
            f2.value = performance.now() - i3.timeStamp, b[f2.id] = true, n2(true);
          });
        });
      });
    }
  }, P = function(e2) {
    var t2, n2 = r("TTFB");
    t2 = function() {
      try {
        var t3 = performance.getEntriesByType("navigation")[0] || function() {
          var e3 = performance.timing, t4 = {
            entryType: "navigation",
            startTime: 0
          };
          for (var n3 in e3)
            n3 !== "navigationStart" && n3 !== "toJSON" && (t4[n3] = Math.max(e3[n3] - e3.navigationStart, 0));
          return t4;
        }();
        if (n2.value = n2.delta = t3.responseStart, n2.value < 0 || n2.value > performance.now())
          return;
        n2.entries = [t3], e2(n2);
      } catch (e3) {
      }
    }, document.readyState === "complete" ? setTimeout(t2, 0) : addEventListener("load", function() {
      return setTimeout(t2, 0);
    });
  };
  var WebVitalsMetrics;
  (function(WebVitalsMetrics2) {
    WebVitalsMetrics2[WebVitalsMetrics2["CLS"] = 0] = "CLS";
    WebVitalsMetrics2[WebVitalsMetrics2["FCP"] = 1] = "FCP";
    WebVitalsMetrics2[WebVitalsMetrics2["FID"] = 2] = "FID";
    WebVitalsMetrics2[WebVitalsMetrics2["LCP"] = 3] = "LCP";
    WebVitalsMetrics2[WebVitalsMetrics2["TBT"] = 4] = "TBT";
    WebVitalsMetrics2[WebVitalsMetrics2["TTFB"] = 5] = "TTFB";
  })(WebVitalsMetrics || (WebVitalsMetrics = {}));
  const defaultMetrics = [WebVitalsMetrics.CLS, WebVitalsMetrics.FCP, WebVitalsMetrics.FID, WebVitalsMetrics.LCP, WebVitalsMetrics.TTFB];
  class WebVitals {
    constructor() {
      this._isInitialized = false;
      this._safety = new PublicSafety();
      this._instr = getInstrumentation("WebVitals");
    }
    activate(__instr, metrics) {
      this._safety.tryCatch(() => {
        if (this._isInitialized) {
          throw new Error("WebVitals is already activated.");
        }
        utility.requireArgumentIfDefined(metrics, "metrics", Array);
        this._isInitialized = true;
        const metricSet = new Set(metrics || defaultMetrics);
        if (metricSet.delete(WebVitalsMetrics.CLS)) {
          h(this._logHandler.bind(this));
        }
        if (metricSet.delete(WebVitalsMetrics.FCP)) {
          d(this._activityHandler.bind(this));
        }
        if (metricSet.delete(WebVitalsMetrics.FID)) {
          L(this._logHandler.bind(this));
        }
        if (metricSet.delete(WebVitalsMetrics.LCP)) {
          F(this._activityHandler.bind(this));
        }
        if (metricSet.delete(WebVitalsMetrics.TTFB)) {
          P(this._activityHandler.bind(this));
        }
        if (metricSet.size > 0) {
          const unsupported = JSON.stringify(Array.from(metricSet.keys()));
          this._instr.error(`Unsupported WebVital metrics: ${unsupported}`);
        }
      });
    }
    _logHandler(metric) {
      this._instr.log(web_vitals, {
        name: metric.name,
        value: metric.value,
        delta: metric.delta
      });
    }
    _activityHandler(metric) {
      this._instr.startActivity(metric.name).stop(void 0, void 0, {
        perfStartOverride: 0,
        perfStopOverride: metric.value
      });
    }
  }
  const webVitals = new WebVitals();
  function assert(assertion, message) {
    if (!assertion) {
      throw new Error(message);
    }
  }
  const CLIENT_ERROR_TYPES = {
    APEX_ACTION_ERROR: "APEX_ACTION_ERROR",
    FAILED_TO_LOAD_RESOURCE: "FAILED_TO_LOAD_RESOURCE",
    TOO_MANY_REQUESTS: "TOO_MANY_REQUESTS",
    UNKNOWN_ERROR: "UNKNOWN_ERROR"
  };
  const METHODS_WITH_CSRF = ["POST", "PATCH", "PUT", "DELETE"];
  const SFDC_REQUEST_ID_HEADER = "X-SFDC-Request-Id";
  const TOO_MANY_REQUESTS_RESPONSE_HEADER = "X-Salesforce-Too-Many-Requests";
  const PUBLIC_SIGIL_QUERY_PARAM_NAME = "asGuest";
  const LOCALE_SIGIL_QUERY_PARAM_NAME = "language";
  const ENCODE_SIGIL_QUERY_PARAM_NAME = "htmlEncode";
  const {
    location,
    navigator: navigator$1
  } = globalThis;
  async function webruntimeFetch(path, init = {}) {
    assert(typeof path === "string", "Valid path not provided for fetch request");
    const initParams = _objectSpread(_objectSpread({}, init), {}, {
      headers: _objectSpread({}, init.headers),
      credentials: init.credentials || "same-origin"
    });
    if (init.credentials === null) {
      delete initParams.credentials;
    }
    const isNonApiRequest = initParams.isNonApiRequest === true;
    const asGuest = initParams.asGuest === true || await getIsGuest();
    const actualBasePath = initParams.basePath !== void 0 ? initParams.basePath : apiBasePath__default["default"];
    const url = new URL(actualBasePath + path, location);
    if (!isNonApiRequest) {
      const sp = url.searchParams;
      if (!sp.has(LOCALE_SIGIL_QUERY_PARAM_NAME)) {
        sp.append(LOCALE_SIGIL_QUERY_PARAM_NAME, language__default["default"]);
      }
      if (!sp.has(PUBLIC_SIGIL_QUERY_PARAM_NAME)) {
        sp.append(PUBLIC_SIGIL_QUERY_PARAM_NAME, asGuest);
      }
      if (!sp.has(ENCODE_SIGIL_QUERY_PARAM_NAME)) {
        sp.append(ENCODE_SIGIL_QUERY_PARAM_NAME, false);
      }
    }
    const contentType = initParams.headers["Content-Type"];
    if (contentType === null) {
      delete initParams.headers["Content-Type"];
    } else {
      if (contentType) {
        initParams.headers["Content-Type"] = contentType;
      } else if (init.body) {
        initParams.headers["Content-Type"] = "application/json; charset=utf-8";
      }
    }
    initParams.headers[SFDC_REQUEST_ID_HEADER] = generateRequestId();
    await addCSRFToken(initParams);
    const response = await globalThis.fetch(url.toString(), initParams);
    if (hasTooManyRequestsHeader(response)) {
      dispatchTooManyRequestsClientError();
    }
    return response;
  }
  function dispatchTooManyRequestsClientError() {
    document.dispatchEvent(new CustomEvent("client-error", {
      detail: {
        type: CLIENT_ERROR_TYPES.TOO_MANY_REQUESTS
      }
    }));
  }
  function hasTooManyRequestsHeader(response) {
    if (response.status === 503 || response.status === 429) {
      if (response.headers.get(TOO_MANY_REQUESTS_RESPONSE_HEADER)) {
        return true;
      }
    }
    return false;
  }
  async function addCSRFToken(params) {
    if (params.method && METHODS_WITH_CSRF.includes(params.method)) {
      const {
        default: user
      } = await _0_9_0.load("@app/user/v/1");
      params.headers["CSRF-Token"] = user.csrfToken;
    }
  }
  async function sendBeacon({
    path,
    payload,
    contentType
  }) {
    const url = basePath__default["default"] + path;
    const sentBeacon = navigator$1 && navigator$1.sendBeacon && navigator$1.sendBeacon(url, payload);
    if (!sentBeacon) {
      await globalThis.fetch(path, {
        headers: {
          "Content-Type": contentType
        },
        basePath: basePath__default["default"],
        body: payload,
        method: "POST",
        isNonApiRequest: true
      });
    }
  }
  function generateRequestId() {
    return (Date.now() + guid() + Math.round(Math.random() * 1e8)).substring(0, 18);
  }
  function guid() {
    function s4() {
      return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
    }
    return s4() + s4();
  }
  async function getIsGuest() {
    const {
      default: user
    } = await _0_9_0.load("@app/user/v/1");
    return user.isGuest;
  }
  var transport = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fetch: webruntimeFetch,
    sendBeacon
  });
  const app_payload = {
    namespace: "sf.clwr",
    name: "AppPayload",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            clwr: {
              nested: {
                AppPayload: {
                  fields: {
                    visd: {
                      id: 1,
                      type: "double"
                    },
                    isPreview: {
                      id: 4,
                      type: "bool"
                    },
                    siteId: {
                      id: 6,
                      type: "string"
                    },
                    isMobile: {
                      id: 3,
                      type: "bool"
                    },
                    lang: {
                      id: 5,
                      type: "string"
                    },
                    isDesign: {
                      id: 2,
                      type: "bool"
                    },
                    vKey: {
                      id: 7,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const nav = {
    namespace: "sf.clwr",
    name: "Nav",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            clwr: {
              nested: {
                Nav: {
                  fields: {
                    isIdleHit: {
                      id: 1,
                      type: "bool"
                    },
                    isManual: {
                      id: 2,
                      type: "bool"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const nav_transition = {
    namespace: "sf.clwr",
    name: "NavTransition",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            clwr: {
              nested: {
                NavTransition: {
                  fields: {
                    code: {
                      id: 4,
                      type: "string"
                    },
                    isSsr: {
                      id: 3,
                      type: "bool"
                    },
                    level: {
                      id: 5,
                      type: "string"
                    },
                    nextUrl: {
                      id: 1,
                      type: "string"
                    },
                    type: {
                      id: 2,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const page_payload = {
    namespace: "sf.clwr",
    name: "PagePayload",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            clwr: {
              nested: {
                PagePayload: {
                  fields: {
                    isSsr: {
                      id: 3,
                      type: "bool"
                    },
                    type: {
                      id: 2,
                      type: "string"
                    },
                    url: {
                      id: 1,
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const root = {
    namespace: "sf.clwr",
    name: "Root",
    pbjsSchema: {
      nested: {
        sf: {
          nested: {
            clwr: {
              nested: {
                Root: {
                  fields: {
                    sequence: {
                      id: 1,
                      type: "uint32"
                    },
                    navCount: {
                      id: 2,
                      type: "uint32"
                    },
                    clickCount: {
                      id: 3,
                      type: "uint32"
                    },
                    isManual: {
                      id: 4,
                      type: "bool"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  const CORE_UPLOAD_THRESHOLD = 5e4;
  const MAX_IDLE_WAIT_MSECS = 3e3;
  const MIN_ROOT_ACTIVITY_DURATION_MSECS = 300;
  const INVALID_API_ENDPOINT = "O11Y_ENDPOINT_NOT_CONFIGURED";
  const randomPerApp = Math.random();
  const config = {
    coreEnabled: false,
    coreSamplingRate: 0,
    coreRelativeEndpoint: "",
    falconEnabled: false,
    falconSamplingRate: 0,
    falconAbsoluteEndpoint: "",
    guestToken: "",
    traceSamplingRate: 0
  };
  const isProduction = false;
  if (isProduction) {
    utility.markProduction();
  }
  let guestInfo;
  let disallowCoreAccess;
  new PublicSafety().tryCatch(() => {
    const srvConfig = JSON.parse(srvConfigJson__default["default"]);
    Object.keys(config).forEach((key) => {
      const value = srvConfig[key];
      const expectedType = typeof config[key];
      if (expectedType === "string" && value === "" || utility.requireArgumentIfDefined(value, `srvConfig.${key}`, expectedType)) {
        config[key] = srvConfig[key];
      }
    });
    guestInfo = parseGuestTokenExt(guestTokenExt__default["default"]);
    config.guestToken = guestInfo.guestToken;
  });
  function getRawConfig() {
    return config;
  }
  function canUploadToEndpoint(enabled, apiEndpoint) {
    return enabled && apiEndpoint !== "" && apiEndpoint !== INVALID_API_ENDPOINT;
  }
  function willSampleLog(sampleRate) {
    return !isProduction || sampleRate > 0 && sampleRate >= randomPerApp;
  }
  function shouldUploadToCore() {
    return !disallowCoreAccess && canUploadToEndpoint(config.coreEnabled, config.coreRelativeEndpoint) && willSampleLog(config.coreSamplingRate);
  }
  function shouldUploadToFalcon() {
    return canUploadToEndpoint(config.falconEnabled, config.falconAbsoluteEndpoint) && willSampleLog(config.falconSamplingRate);
  }
  function parseGuestTokenExt(guestTokenExt2) {
    if (!guestTokenExt2) {
      throw new Error("o11yGuestToken not set");
    }
    const options = {};
    const barIndex = guestTokenExt2.indexOf("|");
    if (barIndex >= 0) {
      options.guestToken = guestTokenExt2.substring(0, barIndex);
      options.meta = JSON.parse(guestTokenExt2.substring(barIndex + 1));
    } else {
      options.guestToken = guestTokenExt2;
    }
    return options;
  }
  function usesConnectApi() {
    const index2 = config.coreRelativeEndpoint?.indexOf("services/data/");
    return index2 === 0 || index2 === 1;
  }
  function useApiBasePath() {
    const ep = config.coreRelativeEndpoint || "";
    return usesConnectApi() && ep.length > 1 && ep[0] !== "/";
  }
  async function checkCoreUserAccess() {
    if (disallowCoreAccess === void 0) {
      disallowCoreAccess = false;
      if (usesConnectApi() && !guestInfo.meta?.isGuestApiAccessEnabled) {
        const {
          default: user
        } = await _0_9_0.load("@app/user/v/1");
        if (user.isGuest) {
          disallowCoreAccess = true;
        }
      }
    }
  }
  function sampleRootActivity() {
    const randomPerInvocation = Math.random();
    const rate = config.traceSamplingRate || 0;
    return rate > 0 && rate >= randomPerInvocation;
  }
  const actOptionsStartAtZero = {
    perfStartOverride: 0
  };
  let debugMsg;
  class O11yRoutingSupport {
    constructor(o11yApp) {
      this._rootPayload = {
        sequence: 0,
        navCount: 0,
        clickCount: 0,
        isManual: false
      };
      this._navPayload = {
        isIdleHit: false,
        isManual: false
      };
      this._hadRootActivity = false;
      this._hadNavActivity = false;
      this._isFirstNavActivity = true;
      const debugMode = true;
      debugMsg = (msg) => debugMode && console.log(`O11YR ${msg}`);
      debugMsg("Started");
      this._o11yApp = o11yApp;
      this._startRoot();
      document.body.addEventListener("click", this._handleClick.bind(this), {
        capture: true,
        passive: true
      });
      window.addEventListener("visibilitychange", this._handleVisibilityChange.bind(this));
    }
    _handleClick() {
      if (!this._rootActivity) {
        this._startRoot();
      } else {
        this._rootPayload.clickCount += 1;
      }
    }
    _handleVisibilityChange() {
      const isHide = document.visibilityState === "hidden";
      debugMsg(isHide ? "Hide" : "Show");
      if (isHide) {
        this._stopNavTransition();
        this._stopNav();
        this._stopRoot(false);
      } else {
        if (this._hadRootActivity) {
          this._startRoot(true);
        }
        if (this._hadNavActivity && !this._navActivity) {
          this._startNav(this._navData, true);
        }
      }
    }
    get _isFirstRootActivity() {
      return this._rootPayload.sequence === 1;
    }
    _startRoot(isManual = false) {
      if (this._rootActivity) {
        this._stopRoot(false);
      }
      this._rootPayload.clickCount = 0;
      this._rootPayload.navCount = 0;
      this._rootPayload.sequence += 1;
      this._rootPayload.isManual = isManual;
      this._rootActivity = this._o11yApp.startRootActivity("root", void 0, sampleRootActivity());
      this._hadRootActivity = true;
      debugMsg(`Root Started ${this._rootActivity.getId()}`);
      idleDetector$1.requestIdleDetectedCallback(() => {
        this._stopRoot(true);
      });
    }
    _stopRoot(idleStop) {
      if (!this._rootActivity) {
        return;
      }
      debugMsg(`Root Stop ${idleStop ? "idle" : "busy"} ${this._rootActivity.getId()}`);
      try {
        if (!this._isFirstRootActivity && this._rootPayload.navCount === 0 && time().perfNow - this._rootActivity.getStartPerfTime() < MIN_ROOT_ACTIVITY_DURATION_MSECS) {
          this._rootActivity.discard();
          this._rootPayload.sequence -= 1;
          return;
        }
        const options = this._isFirstRootActivity ? actOptionsStartAtZero : void 0;
        if (idleStop) {
          this._rootActivity.stop(root, this._rootPayload, options);
        } else {
          this._rootActivity.terminate(root, this._rootPayload, options);
        }
      } finally {
        this._rootActivity = void 0;
        this._hadRootActivity = false;
      }
    }
    _startNav(data, isManual) {
      this._stopNav();
      this._navPayload.isIdleHit = false;
      this._navPayload.isManual = isManual;
      this._rootPayload.navCount += 1;
      this._navData = data ? {
        url: data.url,
        pageRef: data.pageRef,
        isSsr: data.isSsr
      } : void 0;
      this._navActivity = this._o11yApp.startActivity("navigation");
      this._hadNavActivity = true;
      debugMsg(`Nav Started ${this._navActivity.getId()}`);
      idleDetector$1.requestIdleDetectedCallback(() => {
        debugMsg(`Nav Idle ${this._navActivity?.getId()}`);
        this._navPayload.isIdleHit = true;
      });
    }
    _stopNav() {
      if (this._navActivity) {
        debugMsg(`Nav Stop ${this._navActivity.getId()}`);
        try {
          const options = this._isFirstNavActivity ? actOptionsStartAtZero : void 0;
          this._isFirstNavActivity = false;
          this._navActivity.stop(nav, this._navPayload, options);
        } finally {
          this._navActivity = void 0;
        }
      }
    }
    _startNavTransition(data) {
      if (this._navTransitionActivity) {
        this._stopNavTransition(void 0, true);
      }
      this._navTransitionData = data;
      this._navTransitionActivity = this._o11yApp.startActivity("navigation transition");
      debugMsg(`Trans Started ${this._navTransitionActivity.getId()}`);
    }
    _stopNavTransition(errorData, shouldTerminate = false) {
      if (this._navTransitionActivity) {
        debugMsg(`Trans ${shouldTerminate ? "Terminate" : "Stop"} ${this._navTransitionActivity.getId()}`);
        try {
          if (errorData) {
            const {
              code,
              message,
              level
            } = errorData;
            const levelText = ["Fatal", "Error", "Warning", "Log"][level];
            this._navTransitionActivity.error(message, nav_transition, {
              code: code?.toString(),
              level: levelText
            });
          }
          const payload = this._navTransitionData ? {
            nextUrl: this._navTransitionData.url,
            type: this._navTransitionData.pageRef?.type,
            isSsr: this._navTransitionData.isSsr
          } : void 0;
          if (shouldTerminate) {
            this._navTransitionActivity.terminate(nav_transition, payload);
          } else {
            this._navTransitionActivity.stop(nav_transition, payload);
          }
        } finally {
          this._navTransitionActivity = void 0;
          this._navTransitionData = void 0;
        }
      }
    }
    preNavigate(data) {
      this._startNavTransition({
        url: data.next.url,
        pageRef: data.next.route.pageReference,
        isSsr: data.next.routeDefinition?.bootstrap?.ssr
      });
    }
    postNavigate(data) {
      this._stopNavTransition();
      this._startNav({
        url: data.url,
        pageRef: data.route.pageReference,
        isSsr: data.routeDefinition?.bootstrap?.ssr
      }, false);
    }
    errorNavigate(data) {
      debugMsg(`Err level ${data?.level}: ${data?.code}`);
      this._stopNavTransition(data);
    }
    getCurrentPageData() {
      if (this._navData) {
        const {
          pageRef,
          url,
          isSsr
        } = this._navData;
        return {
          url,
          type: pageRef?.type,
          isSsr
        };
      }
      return void 0;
    }
  }
  class O11yAppPayloadProvider {
    constructor() {
      this._totalVisibleDuration = 0;
      this._isVisible = document?.visibilityState === "visible";
      if (this._isVisible) {
        this._lastVisibleTime = 0;
      }
      window?.addEventListener("visibilitychange", this._handleVisibilityChange.bind(this));
    }
    _handleVisibilityChange() {
      if (document.visibilityState === "hidden") {
        this._isVisible = false;
        if (this._lastVisibleTime !== void 0) {
          const perfNow = time().perfNow;
          this._totalVisibleDuration += perfNow - this._lastVisibleTime;
          this._lastVisibleTime = perfNow;
        }
      } else {
        this._isVisible = true;
        this._lastVisibleTime = time().perfNow;
      }
    }
    getPayload() {
      const _durationSinceLastRecorded = this._isVisible && this._lastVisibleTime !== void 0 ? time().perfNow - this._lastVisibleTime : 0;
      const payload = {
        isDesign: isDesignMode__default["default"],
        isMobile: isMobileAppMode__default["default"],
        isPreview: isPreviewMode__default["default"],
        lang: language__default["default"],
        siteId: siteId__default["default"],
        vKey: versionKey__default["default"],
        visd: this._totalVisibleDuration + _durationSinceLastRecorded
      };
      return {
        schema: app_payload,
        payload
      };
    }
  }
  class O11yPagePayloadProvider {
    linkWithRouterSupport(routerSupport) {
      this._routingSupport = routerSupport;
    }
    getPayload() {
      if (this._routingSupport) {
        const payload = this._routingSupport.getCurrentPageData();
        if (payload)
          return {
            schema: page_payload,
            payload
          };
      }
      return void 0;
    }
  }
  const {
    ConsoleCollector,
    idleDetector,
    registerInstrumentedApp,
    _version
  } = o11yClient;
  const INSTR_APP_NAME = "lwr_experience";
  let simpleCollector;
  let protoEncoderFunc;
  const _o11y = _o11y$1;
  _o11y.clientVersion = _version;
  _o11y.schemaVersion = version;
  const versionLabel = `${_version}:${version}`;
  const transportFetch = webruntimeFetch;
  if (globalThis.LWR?.define) {
    globalThis.LWR.define("o11y/shared", [], () => o11yShared);
    globalThis.LWR.define("o11y/client", [], () => o11yClient);
    globalThis.LWR.define("transport", [], () => transport);
    globalThis.LWR.define("webruntime/o11y", [], () => webruntimeO11y);
  }
  async function hookO11ySetup(serviceApi) {
    const isProduction2 = false;
    try {
      if (typeof window === "undefined") {
        _o11y.isUnavailable = true;
        return;
      }
      const moduleFetchTasker = idleDetector.declareNotifierTaskMulti("o11y LWR module fetch");
      _o11y.willUpload = shouldUploadToCore() || shouldUploadToFalcon();
      const appPayloadProvider = new O11yAppPayloadProvider();
      const pagePayloadProvider = new O11yPagePayloadProvider();
      _o11y.app = registerInstrumentedApp(INSTR_APP_NAME, {
        isProduction: isProduction2,
        enableBuffering: true,
        appPayloadProvider,
        pagePayloadProvider
      });
      dispatcher__default["default"]?.((info) => {
        if (info.id === "lwr.loader.module.fetch") {
          if (info.phase === 0) {
            moduleFetchTasker.add();
          } else {
            moduleFetchTasker.done();
          }
        }
      });
      _o11y.app.networkInstrumentation({
        tracingHeadersOptions: {
          useB3Headers: true
        }
      });
      webVitals.activate();
      _o11y.routingSupport = new O11yRoutingSupport(_o11y.app);
      pagePayloadProvider.linkWithRouterSupport(_o11y.routingSupport);
      let isConsoleInitialized = false;
      _o11y.initConsole = (options) => {
        if (!isConsoleInitialized && _o11y.app) {
          const consoleCollector = new ConsoleCollector();
          _o11y.app.registerLogCollector(consoleCollector, options);
          isConsoleInitialized = true;
        }
      };
      if (!isProduction2) {
        _o11y.initConsole();
        _o11y.app.log(`o11y ${versionLabel}`);
      }
      _o11y.upload = uploadAsNeededAsync;
      if (_o11y.willUpload) {
        await waitForLoad();
        await checkCoreUserAccess();
        _o11y.willUpload = shouldUploadToCore() || shouldUploadToFalcon();
        if (!_o11y.willUpload) {
          return;
        }
        await initSimpleCollector(_o11y.app, {
          appName: serviceApi.appMetadata.bootstrapModule,
          sdkVersion: `o11y ${versionLabel}`
        });
        addEventListenersForUpload();
        await uploadAsNeededAsync(true);
      }
    } catch (err) {
      if (!isProduction2) {
        throw err;
      }
      try {
        console?.error("Failed to start o11y", err);
      } catch {
      }
    } finally {
      try {
        _o11y.app?.disableBuffering();
      } catch {
      }
    }
  }
  function addEventListenersForUpload() {
    window.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        uploadAsNeededAsync(true);
      }
    });
  }
  async function waitForLoad() {
    const waitForIdleWithTimeout = (resolve) => {
      let resolved = false;
      setTimeout(() => {
        if (!resolved) {
          resolved = true;
          resolve();
        }
      }, MAX_IDLE_WAIT_MSECS);
      idleDetector.requestIdleDetectedCallback(() => {
        if (!resolved) {
          resolved = true;
          resolve();
        }
      });
    };
    return new Promise((resolve) => {
      if (document.readyState === "complete") {
        waitForIdleWithTimeout(resolve);
      } else {
        window.addEventListener("load", () => waitForIdleWithTimeout(resolve));
      }
    });
  }
  async function initSimpleCollector(o11yApp, environment) {
    const [simpleCollectorModule, collectorsModule] = await Promise.all([_0_9_0.load("o11y/simple_collector/v/244_9_0"), _0_9_0.load("o11y/collectors/v/244_9_0")]);
    protoEncoderFunc = (collectorsModule.default || collectorsModule).encodeCoreEnvelopeContentsRaw;
    simpleCollector = new (simpleCollectorModule.default || simpleCollectorModule).SimpleCollector({
      environment
    });
    o11yApp.registerLogCollector(simpleCollector, {
      retroactive: true
    });
    o11yApp.registerMetricsCollector(simpleCollector);
  }
  function uploadAsNeededAsync(ignoreThreshold = false) {
    const promises = [];
    const doCore = shouldUploadToCore();
    const doFalcon = shouldUploadToFalcon();
    if (simpleCollector?.hasData && (doCore || doFalcon) && (ignoreThreshold || simpleCollector.estimatedByteSize >= CORE_UPLOAD_THRESHOLD)) {
      const rawContents = simpleCollector.getRawContentsOfCoreEnvelope();
      const binary = protoEncoderFunc(rawContents);
      if (doCore) {
        promises.push(uploadToCoreAsync(binary));
      }
      if (doFalcon) {
        promises.push(uploadToFalconAsync(binary));
      }
    }
    return Promise.allSettled(promises);
  }
  function uploadToCoreAsync(binary) {
    const fromCharCode = String.fromCharCode;
    const output = [];
    for (let i2 = 0, length = binary.length; i2 < length; i2++) {
      output.push(fromCharCode(binary[i2]));
    }
    const b64 = window.btoa(output.join(""));
    const options = {
      method: "POST",
      body: JSON.stringify({
        base64Env: b64
      }),
      keepalive: true,
      isNonApiRequest: !usesConnectApi(),
      o11y: {
        skipInstr: true
      }
    };
    let path = getRawConfig().coreRelativeEndpoint;
    if (useApiBasePath()) {
      if (path[0] !== "/") {
        path = `/${path}`;
      }
    } else {
      options.basePath = basePath__default["default"];
    }
    return transportFetch(path, options);
  }
  function uploadToFalconAsync(binary) {
    const config2 = getRawConfig();
    const reqInit = {
      method: "POST",
      body: binary,
      headers: {
        "x-sfdc-o11y-token": config2.guestToken || "",
        "Content-Type": "application/octet-stream"
      },
      keepalive: true,
      o11y: {
        skipInstr: true
      }
    };
    return fetch(config2.falconAbsoluteEndpoint, reqInit);
  }
  exports.default = hookO11ySetup;
  Object.defineProperty(exports, "__esModule", {value: true});
});
LWR.define("webruntime/hook/v/1_66_319-244_0", ["exports"], function(exports) {
  "use strict";
  var inlinedModules = ["@app/apexApiBasePath", "@app/apiBasePath", "@app/authenticationCookieName", "@app/basePath", "@app/guestUuidCookieName", "@app/isDesignMode", "@app/isPreviewMode", "@app/isMobileAppMode", "@app/loginPath", "@app/o11yGuestToken", "@app/o11yConfiguration", "@app/routes", "@app/extraRouteParams", "@app/uiBasePath", "@app/versionKey", "@app/viewToThemeLayoutMap", "@app/views", "@salesforce/community/basePath", "@salesforce/i18n/lang", "@salesforce/site/Id", "@salesforce/webstore/Id", "webruntime/dispatcher"];
  var bundled = ["@salesforce/cssvars/customProperties", "aura-instrumentation", "aura-storage", "aura", "instrumentation/service", "instrumentation/utility", "lightning/configProvider", "lightning/navigation", "transport", "webruntime/transport", "logger", "assert", "o11y/shared", "o11y/client", "webruntime/o11y", "webruntime_navigation/link", "webruntime/expressions", "webruntime/routerContainer", "webruntime/componentContainer", "webruntime/slotContainer", "webruntime/visibilityContainer", "webruntime/routingService", "webruntime/overrides", "webruntimedesign/componentWrapper", "webruntimedesign/regionWrapper", "webruntimedesign/dropRegion", "webruntimedesign/componentService", "webruntimedesign/designComponent", "mobileruntime/hybridAppManager", "wire-service", "@salesforce/client/formFactor"];
  const designBundled = ["webruntimedesign/componentWrapper", "webruntimedesign/regionWrapper", "webruntimedesign/dropRegion", "webruntimedesign/componentService", "webruntimedesign/designComponent"];
  function communitiesHook(serviceAPI) {
    serviceAPI.addLoaderPlugin({
      resolveModule: async (id) => {
        const [specifier] = id.split("/v/");
        if (specifier === "webruntime/transport") {
          return "transport";
        }
        if (specifier && (bundled.includes(specifier) || designBundled.includes(specifier) || inlinedModules.includes(specifier))) {
          return specifier;
        }
        if (specifier === "@salesforce/loader") {
          return "lwr/loaderLegacy/v/0_9_0";
        }
        return null;
      }
    });
  }
  exports.default = communitiesHook;
  Object.defineProperty(exports, "__esModule", {value: true});
});
LWR.define("@lwc/synthetic-shadow/v/2_41_4", function() {
  "use strict";
  function invariant(value, msg) {
    if (!value) {
      throw new Error(`Invariant Violation: ${msg}`);
    }
  }
  function isTrue$1(value, msg) {
    if (!value) {
      throw new Error(`Assert Violation: ${msg}`);
    }
  }
  function isFalse$1(value, msg) {
    if (value) {
      throw new Error(`Assert Violation: ${msg}`);
    }
  }
  function fail(msg) {
    throw new Error(msg);
  }
  var assert = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fail,
    invariant,
    isFalse: isFalse$1,
    isTrue: isTrue$1
  });
  const {
    assign,
    create,
    defineProperties,
    defineProperty,
    freeze,
    getOwnPropertyDescriptor,
    getOwnPropertyNames,
    getPrototypeOf,
    hasOwnProperty,
    isFrozen,
    keys,
    seal,
    setPrototypeOf
  } = Object;
  const {
    isArray
  } = Array;
  const {
    concat: ArrayConcat,
    copyWithin: ArrayCopyWithin,
    fill: ArrayFill,
    filter: ArrayFilter,
    find: ArrayFind,
    indexOf: ArrayIndexOf,
    join: ArrayJoin,
    map: ArrayMap,
    pop: ArrayPop,
    push: ArrayPush,
    reduce: ArrayReduce,
    reverse: ArrayReverse,
    shift: ArrayShift,
    slice: ArraySlice,
    some: ArraySome,
    sort: ArraySort,
    splice: ArraySplice,
    unshift: ArrayUnshift,
    forEach
  } = Array.prototype;
  const {
    charCodeAt: StringCharCodeAt,
    replace: StringReplace,
    split: StringSplit,
    slice: StringSlice,
    toLowerCase: StringToLowerCase
  } = String.prototype;
  function isUndefined(obj) {
    return obj === void 0;
  }
  function isNull(obj) {
    return obj === null;
  }
  function isTrue(obj) {
    return obj === true;
  }
  function isFalse(obj) {
    return obj === false;
  }
  function isFunction(obj) {
    return typeof obj === "function";
  }
  function isObject(obj) {
    return typeof obj === "object";
  }
  const OtS = {}.toString;
  function toString(obj) {
    if (obj && obj.toString) {
      if (isArray(obj)) {
        return ArrayJoin.call(ArrayMap.call(obj, toString), ",");
      }
      return obj.toString();
    } else if (typeof obj === "object") {
      return OtS.call(obj);
    } else {
      return obj + "";
    }
  }
  const _globalThis = typeof globalThis === "object" ? globalThis : window;
  const KEY__IS_NATIVE_SHADOW_ROOT_DEFINED = "$isNativeShadowRootDefined$";
  const KEY__SHADOW_RESOLVER = "$shadowResolver$";
  const KEY__SHADOW_RESOLVER_PRIVATE = "$$ShadowResolverKey$$";
  const KEY__SHADOW_STATIC = "$shadowStaticNode$";
  const KEY__SHADOW_STATIC_PRIVATE = "$shadowStaticNodeKey$";
  const KEY__SHADOW_TOKEN = "$shadowToken$";
  const KEY__SHADOW_TOKEN_PRIVATE = "$$ShadowTokenKey$$";
  const KEY__SYNTHETIC_MODE = "$$lwc-synthetic-mode";
  const KEY__NATIVE_GET_ELEMENT_BY_ID = "$nativeGetElementById$";
  const KEY__NATIVE_QUERY_SELECTOR_ALL = "$nativeQuerySelectorAll$";
  const hasNativeSymbolSupport = /* @__PURE__ */ (() => Symbol("x").toString() === "Symbol(x)")();
  if (!_globalThis.lwcRuntimeFlags) {
    Object.defineProperty(_globalThis, "lwcRuntimeFlags", {
      value: create(null)
    });
  }
  const _Node = Node;
  const nodePrototype = _Node.prototype;
  const {
    DOCUMENT_POSITION_CONTAINED_BY,
    DOCUMENT_POSITION_CONTAINS,
    DOCUMENT_POSITION_PRECEDING,
    DOCUMENT_POSITION_FOLLOWING,
    ELEMENT_NODE,
    TEXT_NODE,
    CDATA_SECTION_NODE,
    PROCESSING_INSTRUCTION_NODE,
    COMMENT_NODE,
    DOCUMENT_FRAGMENT_NODE
  } = _Node;
  const {
    appendChild,
    cloneNode,
    compareDocumentPosition,
    insertBefore,
    removeChild,
    replaceChild,
    hasChildNodes
  } = nodePrototype;
  const {
    contains
  } = HTMLElement.prototype;
  const firstChildGetter = getOwnPropertyDescriptor(nodePrototype, "firstChild").get;
  const lastChildGetter = getOwnPropertyDescriptor(nodePrototype, "lastChild").get;
  const textContentGetter = getOwnPropertyDescriptor(nodePrototype, "textContent").get;
  const parentNodeGetter = getOwnPropertyDescriptor(nodePrototype, "parentNode").get;
  const ownerDocumentGetter = getOwnPropertyDescriptor(nodePrototype, "ownerDocument").get;
  const parentElementGetter = hasOwnProperty.call(nodePrototype, "parentElement") ? getOwnPropertyDescriptor(nodePrototype, "parentElement").get : getOwnPropertyDescriptor(HTMLElement.prototype, "parentElement").get;
  const textContextSetter = getOwnPropertyDescriptor(nodePrototype, "textContent").set;
  const childNodesGetter = hasOwnProperty.call(nodePrototype, "childNodes") ? getOwnPropertyDescriptor(nodePrototype, "childNodes").get : getOwnPropertyDescriptor(HTMLElement.prototype, "childNodes").get;
  const isConnected = hasOwnProperty.call(nodePrototype, "isConnected") ? getOwnPropertyDescriptor(nodePrototype, "isConnected").get : function() {
    const doc = ownerDocumentGetter.call(this);
    return doc === null || (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  };
  const {
    getAttribute,
    getBoundingClientRect,
    getElementsByTagName: getElementsByTagName$1,
    getElementsByTagNameNS: getElementsByTagNameNS$1,
    hasAttribute,
    querySelector,
    querySelectorAll: querySelectorAll$1,
    removeAttribute,
    setAttribute
  } = Element.prototype;
  const attachShadow$1 = hasOwnProperty.call(Element.prototype, "attachShadow") ? Element.prototype.attachShadow : () => {
    throw new TypeError("attachShadow() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill and use Lightning Web Components");
  };
  const childElementCountGetter = getOwnPropertyDescriptor(Element.prototype, "childElementCount").get;
  const firstElementChildGetter = getOwnPropertyDescriptor(Element.prototype, "firstElementChild").get;
  const lastElementChildGetter = getOwnPropertyDescriptor(Element.prototype, "lastElementChild").get;
  const innerTextDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, "innerText");
  const innerTextGetter = innerTextDescriptor ? innerTextDescriptor.get : null;
  const innerTextSetter = innerTextDescriptor ? innerTextDescriptor.set : null;
  const outerTextDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, "outerText");
  const outerTextGetter = outerTextDescriptor ? outerTextDescriptor.get : null;
  const outerTextSetter = outerTextDescriptor ? outerTextDescriptor.set : null;
  const innerHTMLDescriptor = hasOwnProperty.call(Element.prototype, "innerHTML") ? getOwnPropertyDescriptor(Element.prototype, "innerHTML") : getOwnPropertyDescriptor(HTMLElement.prototype, "innerHTML");
  const innerHTMLGetter = innerHTMLDescriptor.get;
  const innerHTMLSetter = innerHTMLDescriptor.set;
  const outerHTMLDescriptor = hasOwnProperty.call(Element.prototype, "outerHTML") ? getOwnPropertyDescriptor(Element.prototype, "outerHTML") : getOwnPropertyDescriptor(HTMLElement.prototype, "outerHTML");
  const outerHTMLGetter = outerHTMLDescriptor.get;
  const outerHTMLSetter = outerHTMLDescriptor.set;
  const tagNameGetter = getOwnPropertyDescriptor(Element.prototype, "tagName").get;
  const tabIndexDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, "tabIndex");
  const tabIndexGetter = tabIndexDescriptor.get;
  const tabIndexSetter = tabIndexDescriptor.set;
  const matches = hasOwnProperty.call(Element.prototype, "matches") ? Element.prototype.matches : Element.prototype.msMatchesSelector;
  const childrenGetter = hasOwnProperty.call(Element.prototype, "children") ? getOwnPropertyDescriptor(Element.prototype, "children").get : getOwnPropertyDescriptor(HTMLElement.prototype, "children").get;
  const {
    getElementsByClassName: getElementsByClassName$1
  } = HTMLElement.prototype;
  const shadowRootGetter = hasOwnProperty.call(Element.prototype, "shadowRoot") ? getOwnPropertyDescriptor(Element.prototype, "shadowRoot").get : () => null;
  const assignedSlotGetter$1 = hasOwnProperty.call(Element.prototype, "assignedSlot") ? getOwnPropertyDescriptor(Element.prototype, "assignedSlot").get : () => null;
  let assignedNodes, assignedElements;
  if (typeof HTMLSlotElement !== "undefined") {
    assignedNodes = HTMLSlotElement.prototype.assignedNodes;
    assignedElements = HTMLSlotElement.prototype.assignedElements;
  } else {
    assignedNodes = () => {
      throw new TypeError("assignedNodes() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
    };
    assignedElements = () => {
      throw new TypeError("assignedElements() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
    };
  }
  const eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, "target").get;
  const eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, "currentTarget").get;
  const focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, "relatedTarget").get;
  const composedPath = hasOwnProperty.call(Event.prototype, "composedPath") ? Event.prototype.composedPath : () => [];
  const DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, "activeElement").get;
  const elementFromPoint = hasOwnProperty.call(Document.prototype, "elementFromPoint") ? Document.prototype.elementFromPoint : Document.prototype.msElementFromPoint;
  const elementsFromPoint = hasOwnProperty.call(Document.prototype, "elementsFromPoint") ? Document.prototype.elementsFromPoint : Document.prototype.msElementsFromPoint;
  const defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, "defaultView").get;
  const {
    createComment,
    querySelectorAll,
    getElementById,
    getElementsByClassName,
    getElementsByTagName,
    getElementsByTagNameNS
  } = Document.prototype;
  const {
    getElementsByName
  } = HTMLDocument.prototype;
  const {
    addEventListener: windowAddEventListener,
    removeEventListener: windowRemoveEventListener,
    getComputedStyle: windowGetComputedStyle,
    getSelection: windowGetSelection
  } = window;
  const MO = MutationObserver;
  const MutationObserverObserve = MO.prototype.observe;
  let NativeShadowRoot = null;
  if (typeof ShadowRoot !== "undefined") {
    NativeShadowRoot = ShadowRoot;
  }
  const isNativeShadowRootDefined = !isNull(NativeShadowRoot);
  const isInstanceOfNativeShadowRoot = isNull(NativeShadowRoot) ? () => false : (node) => node instanceof NativeShadowRoot;
  function detect$4() {
    return typeof HTMLSlotElement === "undefined";
  }
  const {
    createElement
  } = Document.prototype;
  const CHAR_S = 115;
  const CHAR_L = 108;
  const CHAR_O = 111;
  const CHAR_T = 116;
  function apply$4() {
    class HTMLSlotElement2 {
    }
    setPrototypeOf(HTMLSlotElement2, HTMLElement.constructor);
    setPrototypeOf(HTMLSlotElement2.prototype, HTMLElement.prototype);
    Window.prototype.HTMLSlotElement = HTMLSlotElement2;
    defineProperty(Document.prototype, "createElement", {
      value: function(tagName, _options) {
        const elm = createElement.apply(this, ArraySlice.call(arguments));
        if (tagName.length === 4 && StringCharCodeAt.call(tagName, 0) === CHAR_S && StringCharCodeAt.call(tagName, 1) === CHAR_L && StringCharCodeAt.call(tagName, 2) === CHAR_O && StringCharCodeAt.call(tagName, 3) === CHAR_T) {
          setPrototypeOf(elm, HTMLSlotElement2.prototype);
        }
        return elm;
      }
    });
  }
  if (detect$4()) {
    apply$4();
  }
  function getOwnerDocument(node) {
    const doc = ownerDocumentGetter.call(node);
    return doc === null ? node : doc;
  }
  function getOwnerWindow(node) {
    const doc = getOwnerDocument(node);
    const win = defaultViewGetter.call(doc);
    if (win === null) {
      throw new TypeError();
    }
    return win;
  }
  let skipGlobalPatching;
  function isGlobalPatchingSkipped(node) {
    if (isUndefined(skipGlobalPatching)) {
      const ownerDocument = getOwnerDocument(node);
      skipGlobalPatching = ownerDocument.body && getAttribute.call(ownerDocument.body, "data-global-patching-bypass") === "temporary-bypass";
    }
    return isTrue(skipGlobalPatching);
  }
  function arrayFromCollection(collection) {
    const size = collection.length;
    const cloned = [];
    if (size > 0) {
      for (let i = 0; i < size; i++) {
        cloned[i] = collection[i];
      }
    }
    return cloned;
  }
  const eventTargetPrototype = typeof EventTarget !== "undefined" ? EventTarget.prototype : _Node.prototype;
  const {
    addEventListener: addEventListener2,
    dispatchEvent,
    removeEventListener: removeEventListener2
  } = eventTargetPrototype;
  const HostElementKey = "$$HostElementKey$$";
  const ShadowedNodeKey = "$$ShadowedNodeKey$$";
  function fastDefineProperty(node, propName, config) {
    const shadowedNode = node;
    if (true) {
      defineProperty(shadowedNode, propName, config);
    } else {
      const {
        value
      } = config;
      shadowedNode[propName] = value;
    }
  }
  function setNodeOwnerKey(node, value) {
    fastDefineProperty(node, HostElementKey, {
      value,
      configurable: true
    });
  }
  function setNodeKey(node, value) {
    fastDefineProperty(node, ShadowedNodeKey, {
      value
    });
  }
  function getNodeOwnerKey(node) {
    return node[HostElementKey];
  }
  function getNodeNearestOwnerKey(node) {
    let host = node;
    let hostKey;
    while (!isNull(host)) {
      hostKey = getNodeOwnerKey(host);
      if (!isUndefined(hostKey)) {
        return hostKey;
      }
      host = parentNodeGetter.call(host);
      if (!isNull(host) && isSyntheticSlotElement(host)) {
        return void 0;
      }
    }
  }
  function getNodeKey(node) {
    return node[ShadowedNodeKey];
  }
  function isNodeShadowed(node) {
    return !isUndefined(getNodeOwnerKey(node));
  }
  function foldSlotElement(slot) {
    let parent = parentElementGetter.call(slot);
    while (!isNull(parent) && isSlotElement(parent)) {
      slot = parent;
      parent = parentElementGetter.call(slot);
    }
    return slot;
  }
  function isNodeSlotted(host, node) {
    if (true) {
      assert.invariant(host instanceof HTMLElement, `isNodeSlotted() should be called with a host as the first argument instead of ${host}`);
      assert.invariant(node instanceof _Node, `isNodeSlotted() should be called with a node as the second argument instead of ${node}`);
      assert.invariant(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS, `isNodeSlotted() should never be called with a node that is not a child node of ${host}`);
    }
    const hostKey = getNodeKey(host);
    let currentElement = node instanceof Element ? node : parentElementGetter.call(node);
    while (!isNull(currentElement) && currentElement !== host) {
      const elmOwnerKey = getNodeNearestOwnerKey(currentElement);
      const parent = parentElementGetter.call(currentElement);
      if (elmOwnerKey === hostKey) {
        return isSlotElement(currentElement);
      } else if (parent === host) {
        return false;
      } else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
        if (isSlotElement(parent)) {
          currentElement = getNodeOwner(foldSlotElement(parent));
          if (!isNull(currentElement)) {
            if (currentElement === host) {
              return true;
            } else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
              return true;
            }
          }
        } else {
          return false;
        }
      } else {
        currentElement = parent;
      }
    }
    return false;
  }
  function getNodeOwner(node) {
    if (!(node instanceof _Node)) {
      return null;
    }
    const ownerKey = getNodeNearestOwnerKey(node);
    if (isUndefined(ownerKey)) {
      return null;
    }
    let nodeOwner = node;
    while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
      nodeOwner = parentNodeGetter.call(nodeOwner);
    }
    if (isNull(nodeOwner)) {
      return null;
    }
    return nodeOwner;
  }
  function isSyntheticSlotElement(node) {
    return isSlotElement(node) && isNodeShadowed(node);
  }
  function isSlotElement(node) {
    return node instanceof HTMLSlotElement;
  }
  function isNodeOwnedBy(owner, node) {
    if (true) {
      assert.invariant(owner instanceof HTMLElement, `isNodeOwnedBy() should be called with an element as the first argument instead of ${owner}`);
      assert.invariant(node instanceof _Node, `isNodeOwnedBy() should be called with a node as the second argument instead of ${node}`);
      assert.invariant(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS, `isNodeOwnedBy() should never be called with a node that is not a child node of ${owner}`);
    }
    const ownerKey = getNodeNearestOwnerKey(node);
    if (isUndefined(ownerKey)) {
      const host = parentNodeGetter.call(node);
      if (!isNull(host) && isSyntheticSlotElement(host)) {
        return false;
      }
      return true;
    }
    return getNodeKey(owner) === ownerKey;
  }
  function shadowRootChildNodes(root) {
    const elm = getHost(root);
    return getAllMatches(elm, arrayFromCollection(childNodesGetter.call(elm)));
  }
  function getAllSlottedMatches(host, nodeList) {
    const filteredAndPatched = [];
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];
      if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
        ArrayPush.call(filteredAndPatched, node);
      }
    }
    return filteredAndPatched;
  }
  function getFirstSlottedMatch(host, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];
      if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
        return node;
      }
    }
    return null;
  }
  function getAllMatches(owner, nodeList) {
    const filteredAndPatched = [];
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];
      const isOwned = isNodeOwnedBy(owner, node);
      if (isOwned) {
        ArrayPush.call(filteredAndPatched, node);
      }
    }
    return filteredAndPatched;
  }
  function getFirstMatch(owner, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      if (isNodeOwnedBy(owner, nodeList[i])) {
        return nodeList[i];
      }
    }
    return null;
  }
  function shadowRootQuerySelector(root, selector) {
    const elm = getHost(root);
    const nodeList = arrayFromCollection(querySelectorAll$1.call(elm, selector));
    return getFirstMatch(elm, nodeList);
  }
  function shadowRootQuerySelectorAll(root, selector) {
    const elm = getHost(root);
    const nodeList = querySelectorAll$1.call(elm, selector);
    return getAllMatches(elm, arrayFromCollection(nodeList));
  }
  function getFilteredChildNodes(node) {
    if (!isSyntheticShadowHost(node) && !isSlotElement(node)) {
      const children = childNodesGetter.call(node);
      return arrayFromCollection(children);
    }
    if (isSyntheticShadowHost(node)) {
      const slots = arrayFromCollection(querySelectorAll$1.call(node, "slot"));
      const resolver = getShadowRootResolver(getShadowRoot(node));
      return ArrayReduce.call(slots, (seed, slot) => {
        if (resolver === getShadowRootResolver(slot)) {
          ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
        }
        return seed;
      }, []);
    } else {
      const children = arrayFromCollection(childNodesGetter.call(node));
      const resolver = getShadowRootResolver(node);
      return ArrayFilter.call(children, (child) => resolver === getShadowRootResolver(child));
    }
  }
  function getFilteredSlotAssignedNodes(slot) {
    const owner = getNodeOwner(slot);
    if (isNull(owner)) {
      return [];
    }
    const childNodes = arrayFromCollection(childNodesGetter.call(slot));
    return ArrayFilter.call(childNodes, (child) => !isNodeShadowed(child) || !isNodeOwnedBy(owner, child));
  }
  function getInnerHTML(node) {
    let s = "";
    const childNodes = getFilteredChildNodes(node);
    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      s += getOuterHTML(childNodes[i]);
    }
    return s;
  }
  const escapeAttrRegExp = /[&\u00A0"]/g;
  const escapeDataRegExp = /[&\u00A0<>]/g;
  const {
    replace,
    toLowerCase
  } = String.prototype;
  function escapeReplace(c) {
    switch (c) {
      case "&":
        return "&amp;";
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case "\xA0":
        return "&nbsp;";
      default:
        return "";
    }
  }
  function escapeAttr(s) {
    return replace.call(s, escapeAttrRegExp, escapeReplace);
  }
  function escapeData(s) {
    return replace.call(s, escapeDataRegExp, escapeReplace);
  }
  const voidElements = new Set(["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "META", "PARAM", "SOURCE", "TRACK", "WBR"]);
  const plaintextParents = new Set(["STYLE", "SCRIPT", "XMP", "IFRAME", "NOEMBED", "NOFRAMES", "PLAINTEXT", "NOSCRIPT"]);
  function getOuterHTML(node) {
    switch (node.nodeType) {
      case ELEMENT_NODE: {
        const {
          attributes: attrs
        } = node;
        const tagName = tagNameGetter.call(node);
        let s = "<" + toLowerCase.call(tagName);
        for (let i = 0, attr; attr = attrs[i]; i++) {
          s += " " + attr.name + '="' + escapeAttr(attr.value) + '"';
        }
        s += ">";
        if (voidElements.has(tagName)) {
          return s;
        }
        return s + getInnerHTML(node) + "</" + toLowerCase.call(tagName) + ">";
      }
      case TEXT_NODE: {
        const {
          data,
          parentNode
        } = node;
        if (parentNode instanceof Element && plaintextParents.has(tagNameGetter.call(parentNode))) {
          return data;
        }
        return escapeData(data);
      }
      case CDATA_SECTION_NODE: {
        return `<!CDATA[[${node.data}]]>`;
      }
      case PROCESSING_INSTRUCTION_NODE: {
        return `<?${node.target} ${node.data}?>`;
      }
      case COMMENT_NODE: {
        return `<!--${node.data}-->`;
      }
      default: {
        return "";
      }
    }
  }
  function getTextContent(node) {
    switch (node.nodeType) {
      case ELEMENT_NODE: {
        const childNodes = getFilteredChildNodes(node);
        let content = "";
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          const currentNode = childNodes[i];
          if (currentNode.nodeType !== COMMENT_NODE) {
            content += getTextContent(currentNode);
          }
        }
        return content;
      }
      default:
        return node.nodeValue;
    }
  }
  const Items$1 = new WeakMap();
  function StaticNodeList() {
    throw new TypeError("Illegal constructor");
  }
  StaticNodeList.prototype = create(NodeList.prototype, {
    constructor: {
      writable: true,
      configurable: true,
      value: StaticNodeList
    },
    item: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(index) {
        return this[index];
      }
    },
    length: {
      enumerable: true,
      configurable: true,
      get() {
        return Items$1.get(this).length;
      }
    },
    forEach: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(cb, thisArg) {
        forEach.call(Items$1.get(this), cb, thisArg);
      }
    },
    entries: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        return ArrayMap.call(Items$1.get(this), (v, i) => [i, v]);
      }
    },
    keys: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        return ArrayMap.call(Items$1.get(this), (_v, i) => i);
      }
    },
    values: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        return Items$1.get(this);
      }
    },
    [Symbol.iterator]: {
      writable: true,
      configurable: true,
      value() {
        let nextIndex = 0;
        return {
          next: () => {
            const items = Items$1.get(this);
            return nextIndex < items.length ? {
              value: items[nextIndex++],
              done: false
            } : {
              done: true
            };
          }
        };
      }
    },
    [Symbol.toStringTag]: {
      configurable: true,
      get() {
        return "NodeList";
      }
    },
    toString: {
      writable: true,
      configurable: true,
      value() {
        return "[object NodeList]";
      }
    }
  });
  setPrototypeOf(StaticNodeList, NodeList);
  function createStaticNodeList(items) {
    const nodeList = create(StaticNodeList.prototype);
    Items$1.set(nodeList, items);
    forEach.call(items, (item, index) => {
      defineProperty(nodeList, index, {
        value: item,
        enumerable: true,
        configurable: true
      });
    });
    return nodeList;
  }
  function getAllRootNodes(node) {
    var _a;
    const rootNodes = [];
    let currentRootNode = node.getRootNode();
    while (!isUndefined(currentRootNode)) {
      rootNodes.push(currentRootNode);
      currentRootNode = (_a = currentRootNode.host) === null || _a === void 0 ? void 0 : _a.getRootNode();
    }
    return rootNodes;
  }
  const findAncestorHostInImmediateShadowRoot = (rootNode, targetRootNode) => {
    let host;
    while (!isUndefined(host = rootNode.host)) {
      const thisRootNode = host.getRootNode();
      if (thisRootNode === targetRootNode) {
        return host;
      }
      rootNode = thisRootNode;
    }
  };
  function fauxElementsFromPoint(context, doc, left, top) {
    const elements = elementsFromPoint.call(doc, left, top);
    const result = [];
    const rootNodes = getAllRootNodes(context);
    if (!isNull(elements)) {
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        if (isSyntheticSlotElement(element)) {
          continue;
        }
        const elementRootNode = element.getRootNode();
        if (ArrayIndexOf.call(rootNodes, elementRootNode) !== -1) {
          ArrayPush.call(result, element);
          continue;
        }
        const ancestorHost = findAncestorHostInImmediateShadowRoot(elementRootNode, rootNodes[0]);
        if (!isUndefined(ancestorHost) && ArrayIndexOf.call(elements, ancestorHost) === -1 && ArrayIndexOf.call(result, ancestorHost) === -1) {
          ArrayPush.call(result, ancestorHost);
        }
      }
    }
    return result;
  }
  const Items = new WeakMap();
  function StaticHTMLCollection() {
    throw new TypeError("Illegal constructor");
  }
  StaticHTMLCollection.prototype = create(HTMLCollection.prototype, {
    constructor: {
      writable: true,
      configurable: true,
      value: StaticHTMLCollection
    },
    item: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(index) {
        return this[index];
      }
    },
    length: {
      enumerable: true,
      configurable: true,
      get() {
        return Items.get(this).length;
      }
    },
    namedItem: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(name) {
        if (name === "") {
          return null;
        }
        const items = Items.get(this);
        for (let i = 0, len = items.length; i < len; i++) {
          const item = items[len];
          if (name === getAttribute.call(item, "id") || name === getAttribute.call(item, "name")) {
            return item;
          }
        }
        return null;
      }
    },
    [Symbol.toStringTag]: {
      configurable: true,
      get() {
        return "HTMLCollection";
      }
    },
    toString: {
      writable: true,
      configurable: true,
      value() {
        return "[object HTMLCollection]";
      }
    }
  });
  setPrototypeOf(StaticHTMLCollection, HTMLCollection);
  function createStaticHTMLCollection(items) {
    const collection = create(StaticHTMLCollection.prototype);
    Items.set(collection, items);
    forEach.call(items, (item, index) => {
      defineProperty(collection, index, {
        value: item,
        enumerable: true,
        configurable: true
      });
    });
    return collection;
  }
  function hasMountedChildren(node) {
    return isSyntheticSlotElement(node) || isSyntheticShadowHost(node);
  }
  function getShadowParent(node, value) {
    const owner = getNodeOwner(node);
    if (value === owner) {
      return getShadowRoot(owner);
    } else if (value instanceof Element) {
      if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
        return value;
      } else if (!isNull(owner) && isSlotElement(value)) {
        const slotOwner = getNodeOwner(value);
        if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
          return slotOwner;
        }
      }
    }
    return null;
  }
  function hasChildNodesPatched() {
    return getInternalChildNodes(this).length > 0;
  }
  function firstChildGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    return childNodes[0] || null;
  }
  function lastChildGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    return childNodes[childNodes.length - 1] || null;
  }
  function textContentGetterPatched() {
    return getTextContent(this);
  }
  function textContentSetterPatched(value) {
    textContextSetter.call(this, value);
  }
  function parentNodeGetterPatched() {
    const value = parentNodeGetter.call(this);
    if (isNull(value)) {
      return value;
    }
    return getShadowParent(this, value);
  }
  function parentElementGetterPatched() {
    const value = parentNodeGetter.call(this);
    if (isNull(value)) {
      return null;
    }
    const parentNode = getShadowParent(this, value);
    return parentNode instanceof Element ? parentNode : null;
  }
  function compareDocumentPositionPatched(otherNode) {
    if (this === otherNode) {
      return 0;
    } else if (this.getRootNode() === otherNode) {
      return 10;
    } else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
      return 35;
    }
    return compareDocumentPosition.call(this, otherNode);
  }
  function containsPatched(otherNode) {
    if (otherNode == null || getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
      return false;
    }
    return (compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  }
  function cloneNodePatched(deep) {
    const clone = cloneNode.call(this, false);
    if (!deep) {
      return clone;
    }
    const childNodes = getInternalChildNodes(this);
    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      clone.appendChild(childNodes[i].cloneNode(true));
    }
    return clone;
  }
  function childNodesGetterPatched() {
    if (isSyntheticShadowHost(this)) {
      const owner = getNodeOwner(this);
      const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
      if (isFalse(hasNativeSymbolSupport) && isExternalChildNodeAccessorFlagOn()) {
        ArrayUnshift.call(childNodes, getIE11FakeShadowRootPlaceholder(this));
      }
      return createStaticNodeList(childNodes);
    }
    return childNodesGetter.call(this);
  }
  const nativeGetRootNode = _Node.prototype.getRootNode;
  const getDocumentOrRootNode = !isUndefined(nativeGetRootNode) ? nativeGetRootNode : function() {
    let node = this;
    let nodeParent;
    while (!isNull(nodeParent = parentNodeGetter.call(node))) {
      node = nodeParent;
    }
    return node;
  };
  function getNearestRoot(node) {
    const ownerNode = getNodeOwner(node);
    if (isNull(ownerNode)) {
      return getDocumentOrRootNode.call(node);
    }
    return getShadowRoot(ownerNode);
  }
  function getRootNodePatched(options) {
    const composed = isUndefined(options) ? false : !!options.composed;
    return isTrue(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
  }
  defineProperties(_Node.prototype, {
    firstChild: {
      get() {
        if (hasMountedChildren(this)) {
          return firstChildGetterPatched.call(this);
        }
        return firstChildGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    lastChild: {
      get() {
        if (hasMountedChildren(this)) {
          return lastChildGetterPatched.call(this);
        }
        return lastChildGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    textContent: {
      get() {
        if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
          return textContentGetterPatched.call(this);
        }
        return textContentGetter.call(this);
      },
      set: textContentSetterPatched,
      enumerable: true,
      configurable: true
    },
    parentNode: {
      get() {
        if (isNodeShadowed(this)) {
          return parentNodeGetterPatched.call(this);
        }
        const parentNode = parentNodeGetter.call(this);
        if (!isNull(parentNode) && isSyntheticSlotElement(parentNode)) {
          return getNodeOwner(parentNode);
        }
        return parentNode;
      },
      enumerable: true,
      configurable: true
    },
    parentElement: {
      get() {
        if (isNodeShadowed(this)) {
          return parentElementGetterPatched.call(this);
        }
        const parentElement = parentElementGetter.call(this);
        if (!isNull(parentElement) && isSyntheticSlotElement(parentElement)) {
          return getNodeOwner(parentElement);
        }
        return parentElement;
      },
      enumerable: true,
      configurable: true
    },
    childNodes: {
      get() {
        if (hasMountedChildren(this)) {
          return childNodesGetterPatched.call(this);
        }
        return childNodesGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    hasChildNodes: {
      value() {
        if (hasMountedChildren(this)) {
          return hasChildNodesPatched.call(this);
        }
        return hasChildNodes.call(this);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    compareDocumentPosition: {
      value(otherNode) {
        if (isGlobalPatchingSkipped(this)) {
          return compareDocumentPosition.call(this, otherNode);
        }
        return compareDocumentPositionPatched.call(this, otherNode);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    contains: {
      value(otherNode) {
        if (this === otherNode) {
          return true;
        }
        if (otherNode == null) {
          return false;
        }
        if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
          return containsPatched.call(this, otherNode);
        }
        return contains.call(this, otherNode);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    cloneNode: {
      value(deep) {
        if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
          return cloneNodePatched.call(this, deep);
        }
        return cloneNode.call(this, deep);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    getRootNode: {
      value: getRootNodePatched,
      enumerable: true,
      configurable: true,
      writable: true
    },
    isConnected: {
      enumerable: true,
      configurable: true,
      get() {
        return isConnected.call(this);
      }
    }
  });
  let internalChildNodeAccessorFlag = false;
  function isExternalChildNodeAccessorFlagOn() {
    return !internalChildNodeAccessorFlag;
  }
  const getInternalChildNodes = isFalse(hasNativeSymbolSupport) ? function(node) {
    internalChildNodeAccessorFlag = true;
    let childNodes;
    let error = null;
    try {
      childNodes = node.childNodes;
    } catch (e) {
      error = e;
    } finally {
      internalChildNodeAccessorFlag = false;
      if (!isNull(error)) {
        throw error;
      }
    }
    return childNodes;
  } : function(node) {
    return node.childNodes;
  };
  if (hasOwnProperty.call(HTMLElement.prototype, "contains")) {
    defineProperty(HTMLElement.prototype, "contains", getOwnPropertyDescriptor(_Node.prototype, "contains"));
  }
  if (hasOwnProperty.call(HTMLElement.prototype, "parentElement")) {
    defineProperty(HTMLElement.prototype, "parentElement", getOwnPropertyDescriptor(_Node.prototype, "parentElement"));
  }
  const EventListenerMap = new WeakMap();
  const ComposedPathMap = new WeakMap();
  function isEventListenerOrEventListenerObject(fnOrObj) {
    return isFunction(fnOrObj) || isObject(fnOrObj) && !isNull(fnOrObj) && isFunction(fnOrObj.handleEvent);
  }
  function shouldInvokeListener(event, target, currentTarget) {
    if (target === currentTarget) {
      return true;
    }
    let composedPath2 = ComposedPathMap.get(event);
    if (isUndefined(composedPath2)) {
      composedPath2 = event.composedPath();
      ComposedPathMap.set(event, composedPath2);
    }
    return composedPath2.includes(currentTarget);
  }
  function getEventListenerWrapper(fnOrObj) {
    if (!isEventListenerOrEventListenerObject(fnOrObj)) {
      return fnOrObj;
    }
    let wrapperFn = EventListenerMap.get(fnOrObj);
    if (isUndefined(wrapperFn)) {
      wrapperFn = function(event) {
        const currentTarget = eventCurrentTargetGetter.call(event);
        if (true) {
          assert.invariant(isFalse(isSyntheticShadowHost(currentTarget)), "This routine should not be used to wrap event listeners for host elements and shadow roots.");
        }
        const actualTarget = getActualTarget(event);
        if (!shouldInvokeListener(event, actualTarget, currentTarget)) {
          return;
        }
        return isFunction(fnOrObj) ? fnOrObj.call(this, event) : fnOrObj.handleEvent && fnOrObj.handleEvent(event);
      };
      EventListenerMap.set(fnOrObj, wrapperFn);
    }
    return wrapperFn;
  }
  const eventToContextMap = new WeakMap();
  const customElementToWrappedListeners = new WeakMap();
  function getEventMap(elm) {
    let listenerInfo = customElementToWrappedListeners.get(elm);
    if (isUndefined(listenerInfo)) {
      listenerInfo = create(null);
      customElementToWrappedListeners.set(elm, listenerInfo);
    }
    return listenerInfo;
  }
  function getActualTarget(event) {
    var _a;
    return (_a = eventToShadowRootMap.get(event)) !== null && _a !== void 0 ? _a : eventTargetGetter.call(event);
  }
  const shadowRootEventListenerMap = new WeakMap();
  function getWrappedShadowRootListener(listener) {
    if (!isFunction(listener)) {
      throw new TypeError();
    }
    let shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);
    if (isUndefined(shadowRootWrappedListener)) {
      shadowRootWrappedListener = function(event) {
        let currentTarget = eventCurrentTargetGetter.call(event);
        if (!isInstanceOfNativeShadowRoot(currentTarget)) {
          currentTarget = getShadowRoot(currentTarget);
        }
        const actualTarget = getActualTarget(event);
        if (shouldInvokeListener(event, actualTarget, currentTarget)) {
          listener.call(currentTarget, event);
        }
      };
      shadowRootWrappedListener.placement = 1;
      shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
    }
    return shadowRootWrappedListener;
  }
  const customElementEventListenerMap = new WeakMap();
  function getWrappedCustomElementListener(listener) {
    if (!isFunction(listener)) {
      throw new TypeError();
    }
    let customElementWrappedListener = customElementEventListenerMap.get(listener);
    if (isUndefined(customElementWrappedListener)) {
      customElementWrappedListener = function(event) {
        const currentTarget = eventCurrentTargetGetter.call(event);
        const actualTarget = getActualTarget(event);
        if (shouldInvokeListener(event, actualTarget, currentTarget)) {
          listener.call(currentTarget, event);
        }
      };
      customElementWrappedListener.placement = 0;
      customElementEventListenerMap.set(listener, customElementWrappedListener);
    }
    return customElementWrappedListener;
  }
  function domListener(evt) {
    let immediatePropagationStopped = false;
    let propagationStopped = false;
    const {
      type,
      stopImmediatePropagation,
      stopPropagation
    } = evt;
    const currentTarget = eventCurrentTargetGetter.call(evt);
    const listenerMap = getEventMap(currentTarget);
    const listeners = listenerMap[type];
    defineProperty(evt, "stopImmediatePropagation", {
      value() {
        immediatePropagationStopped = true;
        stopImmediatePropagation.call(evt);
      },
      writable: true,
      enumerable: true,
      configurable: true
    });
    defineProperty(evt, "stopPropagation", {
      value() {
        propagationStopped = true;
        stopPropagation.call(evt);
      },
      writable: true,
      enumerable: true,
      configurable: true
    });
    const bookkeeping = ArraySlice.call(listeners);
    function invokeListenersByPlacement(placement) {
      forEach.call(bookkeeping, (listener) => {
        if (isFalse(immediatePropagationStopped) && listener.placement === placement) {
          if (ArrayIndexOf.call(listeners, listener) !== -1) {
            listener.call(void 0, evt);
          }
        }
      });
    }
    eventToContextMap.set(evt, 1);
    invokeListenersByPlacement(1);
    if (isFalse(immediatePropagationStopped) && isFalse(propagationStopped)) {
      eventToContextMap.set(evt, 0);
      invokeListenersByPlacement(0);
    }
    eventToContextMap.set(evt, 2);
  }
  function attachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let cmpEventHandlers = listenerMap[type];
    if (isUndefined(cmpEventHandlers)) {
      cmpEventHandlers = listenerMap[type] = [];
    }
    if (ArrayIndexOf.call(cmpEventHandlers, wrappedListener) !== -1) {
      return;
    }
    if (cmpEventHandlers.length === 0) {
      addEventListener2.call(elm, type, domListener);
    }
    ArrayPush.call(cmpEventHandlers, wrappedListener);
  }
  function detachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let p;
    let listeners;
    if (!isUndefined(listeners = listenerMap[type]) && (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
      ArraySplice.call(listeners, p, 1);
      if (listeners.length === 0) {
        removeEventListener2.call(elm, type, domListener);
      }
    }
  }
  function addCustomElementEventListener(type, listener, _options) {
    if (true) {
      if (!isFunction(listener)) {
        throw new TypeError(`Invalid second argument for Element.addEventListener() in ${toString(this)} for event "${type}". Expected an EventListener but received ${listener}.`);
      }
    }
    if (isFunction(listener)) {
      const wrappedListener = getWrappedCustomElementListener(listener);
      attachDOMListener(this, type, wrappedListener);
    }
  }
  function removeCustomElementEventListener(type, listener, _options) {
    if (isFunction(listener)) {
      const wrappedListener = getWrappedCustomElementListener(listener);
      detachDOMListener(this, type, wrappedListener);
    }
  }
  function addShadowRootEventListener(sr, type, listener, _options) {
    if (true) {
      if (!isFunction(listener)) {
        throw new TypeError(`Invalid second argument for ShadowRoot.addEventListener() in ${toString(sr)} for event "${type}". Expected an EventListener but received ${listener}.`);
      }
    }
    if (isFunction(listener)) {
      const elm = getHost(sr);
      const wrappedListener = getWrappedShadowRootListener(listener);
      attachDOMListener(elm, type, wrappedListener);
    }
  }
  function removeShadowRootEventListener(sr, type, listener, _options) {
    if (isFunction(listener)) {
      const elm = getHost(sr);
      const wrappedListener = getWrappedShadowRootListener(listener);
      detachDOMListener(elm, type, wrappedListener);
    }
  }
  const InternalSlot = new WeakMap();
  const {
    createDocumentFragment
  } = document;
  function hasInternalSlot(root) {
    return InternalSlot.has(root);
  }
  function getInternalSlot(root) {
    const record = InternalSlot.get(root);
    if (isUndefined(record)) {
      throw new TypeError();
    }
    return record;
  }
  defineProperty(_Node.prototype, KEY__SHADOW_RESOLVER, {
    set(fn) {
      if (isUndefined(fn))
        return;
      this[KEY__SHADOW_RESOLVER_PRIVATE] = fn;
      setNodeOwnerKey(this, fn.nodeKey);
    },
    get() {
      return this[KEY__SHADOW_RESOLVER_PRIVATE];
    },
    configurable: true,
    enumerable: true
  });
  defineProperty(_globalThis, KEY__IS_NATIVE_SHADOW_ROOT_DEFINED, {
    value: isNativeShadowRootDefined
  });
  if (isUndefined(_globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID])) {
    defineProperty(_globalThis, KEY__NATIVE_GET_ELEMENT_BY_ID, {
      value: getElementById,
      configurable: true
    });
  }
  if (isUndefined(_globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL])) {
    defineProperty(_globalThis, KEY__NATIVE_QUERY_SELECTOR_ALL, {
      value: querySelectorAll,
      configurable: true
    });
  }
  function getShadowRootResolver(node) {
    return node[KEY__SHADOW_RESOLVER];
  }
  function setShadowRootResolver(node, fn) {
    node[KEY__SHADOW_RESOLVER] = fn;
  }
  function isDelegatingFocus(host) {
    return getInternalSlot(host).delegatesFocus;
  }
  function getHost(root) {
    return getInternalSlot(root).host;
  }
  function getShadowRoot(elm) {
    return getInternalSlot(elm).shadowRoot;
  }
  function isSyntheticShadowHost(node) {
    const shadowRootRecord = InternalSlot.get(node);
    return !isUndefined(shadowRootRecord) && node === shadowRootRecord.host;
  }
  function isSyntheticShadowRoot(node) {
    const shadowRootRecord = InternalSlot.get(node);
    return !isUndefined(shadowRootRecord) && node === shadowRootRecord.shadowRoot;
  }
  let uid = 0;
  function attachShadow(elm, options) {
    if (InternalSlot.has(elm)) {
      throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);
    }
    const {
      mode,
      delegatesFocus
    } = options;
    const doc = getOwnerDocument(elm);
    const sr = createDocumentFragment.call(doc);
    const record = {
      mode,
      delegatesFocus: !!delegatesFocus,
      host: elm,
      shadowRoot: sr
    };
    InternalSlot.set(sr, record);
    InternalSlot.set(elm, record);
    const shadowResolver = () => sr;
    const x = shadowResolver.nodeKey = uid++;
    setNodeKey(elm, x);
    setShadowRootResolver(sr, shadowResolver);
    setPrototypeOf(sr, SyntheticShadowRoot.prototype);
    return sr;
  }
  const SyntheticShadowRootDescriptors = {
    constructor: {
      writable: true,
      configurable: true,
      value: SyntheticShadowRoot
    },
    toString: {
      writable: true,
      configurable: true,
      value() {
        return `[object ShadowRoot]`;
      }
    },
    synthetic: {
      writable: false,
      enumerable: false,
      configurable: false,
      value: true
    }
  };
  const ShadowRootDescriptors = {
    activeElement: {
      enumerable: true,
      configurable: true,
      get() {
        const host = getHost(this);
        const doc = getOwnerDocument(host);
        const activeElement = DocumentPrototypeActiveElement.call(doc);
        if (isNull(activeElement)) {
          return activeElement;
        }
        if ((compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) === 0) {
          return null;
        }
        let node = activeElement;
        while (!isNodeOwnedBy(host, node)) {
          node = parentElementGetter.call(node);
        }
        if (isSlotElement(node)) {
          return null;
        }
        return node;
      }
    },
    delegatesFocus: {
      configurable: true,
      get() {
        return getInternalSlot(this).delegatesFocus;
      }
    },
    elementFromPoint: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(left, top) {
        const host = getHost(this);
        const doc = getOwnerDocument(host);
        return fauxElementFromPoint(this, doc, left, top);
      }
    },
    elementsFromPoint: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(left, top) {
        const host = getHost(this);
        const doc = getOwnerDocument(host);
        return fauxElementsFromPoint(this, doc, left, top);
      }
    },
    getSelection: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        throw new Error('Disallowed method "getSelection" on ShadowRoot.');
      }
    },
    host: {
      enumerable: true,
      configurable: true,
      get() {
        return getHost(this);
      }
    },
    mode: {
      configurable: true,
      get() {
        return getInternalSlot(this).mode;
      }
    },
    styleSheets: {
      enumerable: true,
      configurable: true,
      get() {
        throw new Error();
      }
    }
  };
  const eventToShadowRootMap = new WeakMap();
  const NodePatchDescriptors = {
    insertBefore: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(newChild, refChild) {
        insertBefore.call(getHost(this), newChild, refChild);
        return newChild;
      }
    },
    removeChild: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(oldChild) {
        removeChild.call(getHost(this), oldChild);
        return oldChild;
      }
    },
    appendChild: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(newChild) {
        appendChild.call(getHost(this), newChild);
        return newChild;
      }
    },
    replaceChild: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(newChild, oldChild) {
        replaceChild.call(getHost(this), newChild, oldChild);
        return oldChild;
      }
    },
    addEventListener: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(type, listener, options) {
        addShadowRootEventListener(this, type, listener);
      }
    },
    dispatchEvent: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(evt) {
        eventToShadowRootMap.set(evt, this);
        return dispatchEvent.apply(getHost(this), arguments);
      }
    },
    removeEventListener: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(type, listener, options) {
        removeShadowRootEventListener(this, type, listener);
      }
    },
    baseURI: {
      enumerable: true,
      configurable: true,
      get() {
        return getHost(this).baseURI;
      }
    },
    childNodes: {
      enumerable: true,
      configurable: true,
      get() {
        return createStaticNodeList(shadowRootChildNodes(this));
      }
    },
    cloneNode: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        throw new Error('Disallowed method "cloneNode" on ShadowRoot.');
      }
    },
    compareDocumentPosition: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(otherNode) {
        const host = getHost(this);
        if (this === otherNode) {
          return 0;
        } else if (this.contains(otherNode)) {
          return 20;
        } else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
          return 37;
        } else {
          return 35;
        }
      }
    },
    contains: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(otherNode) {
        if (this === otherNode) {
          return true;
        }
        const host = getHost(this);
        return (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 && isNodeOwnedBy(host, otherNode);
      }
    },
    firstChild: {
      enumerable: true,
      configurable: true,
      get() {
        const childNodes = getInternalChildNodes(this);
        return childNodes[0] || null;
      }
    },
    lastChild: {
      enumerable: true,
      configurable: true,
      get() {
        const childNodes = getInternalChildNodes(this);
        return childNodes[childNodes.length - 1] || null;
      }
    },
    hasChildNodes: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        const childNodes = getInternalChildNodes(this);
        return childNodes.length > 0;
      }
    },
    isConnected: {
      enumerable: true,
      configurable: true,
      get() {
        return isConnected.call(getHost(this));
      }
    },
    nextSibling: {
      enumerable: true,
      configurable: true,
      get() {
        return null;
      }
    },
    previousSibling: {
      enumerable: true,
      configurable: true,
      get() {
        return null;
      }
    },
    nodeName: {
      enumerable: true,
      configurable: true,
      get() {
        return "#document-fragment";
      }
    },
    nodeType: {
      enumerable: true,
      configurable: true,
      get() {
        return 11;
      }
    },
    nodeValue: {
      enumerable: true,
      configurable: true,
      get() {
        return null;
      }
    },
    ownerDocument: {
      enumerable: true,
      configurable: true,
      get() {
        return getHost(this).ownerDocument;
      }
    },
    parentElement: {
      enumerable: true,
      configurable: true,
      get() {
        return null;
      }
    },
    parentNode: {
      enumerable: true,
      configurable: true,
      get() {
        return null;
      }
    },
    textContent: {
      enumerable: true,
      configurable: true,
      get() {
        const childNodes = getInternalChildNodes(this);
        let textContent = "";
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          const currentNode = childNodes[i];
          if (currentNode.nodeType !== COMMENT_NODE) {
            textContent += getTextContent(currentNode);
          }
        }
        return textContent;
      },
      set(v) {
        const host = getHost(this);
        textContextSetter.call(host, v);
      }
    },
    getRootNode: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(options) {
        return !isUndefined(options) && isTrue(options.composed) ? getHost(this).getRootNode(options) : this;
      }
    }
  };
  const ElementPatchDescriptors = {
    innerHTML: {
      enumerable: true,
      configurable: true,
      get() {
        const childNodes = getInternalChildNodes(this);
        let innerHTML = "";
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          innerHTML += getOuterHTML(childNodes[i]);
        }
        return innerHTML;
      },
      set(v) {
        const host = getHost(this);
        innerHTMLSetter.call(host, v);
      }
    }
  };
  const ParentNodePatchDescriptors = {
    childElementCount: {
      enumerable: true,
      configurable: true,
      get() {
        return this.children.length;
      }
    },
    children: {
      enumerable: true,
      configurable: true,
      get() {
        return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), (elm) => elm instanceof Element));
      }
    },
    firstElementChild: {
      enumerable: true,
      configurable: true,
      get() {
        return this.children[0] || null;
      }
    },
    lastElementChild: {
      enumerable: true,
      configurable: true,
      get() {
        const {
          children
        } = this;
        return children.item(children.length - 1) || null;
      }
    },
    getElementById: {
      writable: true,
      enumerable: true,
      configurable: true,
      value() {
        throw new Error('Disallowed method "getElementById" on ShadowRoot.');
      }
    },
    querySelector: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(selectors) {
        return shadowRootQuerySelector(this, selectors);
      }
    },
    querySelectorAll: {
      writable: true,
      enumerable: true,
      configurable: true,
      value(selectors) {
        return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
      }
    }
  };
  assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);
  function SyntheticShadowRoot() {
    throw new TypeError("Illegal constructor");
  }
  SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);
  defineProperty(SyntheticShadowRoot, Symbol.hasInstance, {
    value: function(object) {
      return isObject(object) && !isNull(object) && (isInstanceOfNativeShadowRoot(object) || getPrototypeOf(object) === SyntheticShadowRoot.prototype);
    }
  });
  function getIE11FakeShadowRootPlaceholder(host) {
    const shadowRoot = getShadowRoot(host);
    let c = shadowRoot.$$placeholder$$;
    if (!isUndefined(c)) {
      return c;
    }
    const doc = getOwnerDocument(host);
    c = shadowRoot.$$placeholder$$ = createComment.call(doc, "");
    defineProperties(c, {
      childNodes: {
        get() {
          return shadowRoot.childNodes;
        },
        enumerable: true,
        configurable: true
      },
      tagName: {
        get() {
          return `#shadow-root (${shadowRoot.mode})`;
        },
        enumerable: true,
        configurable: true
      }
    });
    return c;
  }
  function pathComposer(startNode, composed) {
    const composedPath2 = [];
    let startRoot;
    if (startNode instanceof Window) {
      startRoot = startNode;
    } else if (startNode instanceof _Node) {
      startRoot = startNode.getRootNode();
    } else {
      return composedPath2;
    }
    let current = startNode;
    while (!isNull(current)) {
      composedPath2.push(current);
      if (current instanceof Element || current instanceof Text) {
        const assignedSlot = current.assignedSlot;
        if (!isNull(assignedSlot)) {
          current = assignedSlot;
        } else {
          current = current.parentNode;
        }
      } else if ((isSyntheticShadowRoot(current) || isInstanceOfNativeShadowRoot(current)) && (composed || current !== startRoot)) {
        current = current.host;
      } else if (current instanceof _Node) {
        current = current.parentNode;
      } else {
        current = null;
      }
    }
    let doc;
    if (startNode instanceof Window) {
      doc = startNode.document;
    } else {
      doc = getOwnerDocument(startNode);
    }
    if (composedPath2[composedPath2.length - 1] === doc) {
      composedPath2.push(window);
    }
    return composedPath2;
  }
  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  function retarget(refNode, path) {
    if (isNull(refNode)) {
      return null;
    }
    const refNodePath = pathComposer(refNode, true);
    const p$ = path;
    for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
      ancestor = p$[i];
      root = ancestor instanceof Window ? ancestor : ancestor.getRootNode();
      if (root !== lastRoot) {
        rootIdx = refNodePath.indexOf(root);
        lastRoot = root;
      }
      if (!isSyntheticShadowRoot(root) || !isUndefined(rootIdx) && rootIdx > -1) {
        return ancestor;
      }
    }
    return null;
  }
  function fauxElementFromPoint(context, doc, left, top) {
    const element = elementFromPoint.call(doc, left, top);
    if (isNull(element)) {
      return element;
    }
    return retarget(context, pathComposer(element, true));
  }
  function elemFromPoint(left, top) {
    return fauxElementFromPoint(this, this, left, top);
  }
  Document.prototype.elementFromPoint = elemFromPoint;
  function elemsFromPoint(left, top) {
    return fauxElementsFromPoint(this, this, left, top);
  }
  Document.prototype.elementsFromPoint = elemsFromPoint;
  defineProperty(Document.prototype, "activeElement", {
    get() {
      let node = DocumentPrototypeActiveElement.call(this);
      if (isNull(node)) {
        return node;
      }
      while (!isUndefined(getNodeOwnerKey(node))) {
        node = parentElementGetter.call(node);
        if (isNull(node)) {
          return null;
        }
      }
      if (node.tagName === "HTML") {
        node = this.body;
      }
      return node;
    },
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, "getElementById", {
    value() {
      const elm = getElementById.apply(this, ArraySlice.call(arguments));
      if (isNull(elm)) {
        return null;
      }
      return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, "querySelector", {
    value() {
      const elements = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFind.call(elements, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return !isUndefined(filtered) ? filtered : null;
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, "querySelectorAll", {
    value() {
      const elements = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticNodeList(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, "getElementsByClassName", {
    value() {
      const elements = arrayFromCollection(getElementsByClassName.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, "getElementsByTagName", {
    value() {
      const elements = arrayFromCollection(getElementsByTagName.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, "getElementsByTagNameNS", {
    value() {
      const elements = arrayFromCollection(getElementsByTagNameNS.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(getOwnPropertyDescriptor(HTMLDocument.prototype, "getElementsByName") ? HTMLDocument.prototype : Document.prototype, "getElementsByName", {
    value() {
      const elements = arrayFromCollection(getElementsByName.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticNodeList(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(window, "ShadowRoot", {
    value: SyntheticShadowRoot,
    configurable: true,
    writable: true
  });
  const composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "composed");
  function detect$3() {
    if (!composedDescriptor) {
      return false;
    }
    let clickEvent = new Event("click");
    const button = document.createElement("button");
    button.addEventListener("click", (event) => clickEvent = event);
    button.click();
    return !composedDescriptor.get.call(clickEvent);
  }
  const originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "click");
  function handleClick(event) {
    Object.defineProperty(event, "composed", {
      configurable: true,
      enumerable: true,
      get() {
        return true;
      }
    });
  }
  function apply$3() {
    HTMLElement.prototype.click = function() {
      addEventListener2.call(this, "click", handleClick);
      try {
        originalClickDescriptor.value.call(this);
      } finally {
        removeEventListener2.call(this, "click", handleClick);
      }
    };
  }
  if (detect$3()) {
    apply$3();
  }
  function detect$2() {
    return new Event("test", {
      composed: true
    }).composed !== true;
  }
  function apply$2() {
    const composedEvents = assign(create(null), {
      beforeinput: 1,
      blur: 1,
      click: 1,
      compositionend: 1,
      compositionstart: 1,
      compositionupdate: 1,
      copy: 1,
      cut: 1,
      dblclick: 1,
      DOMActivate: 1,
      DOMFocusIn: 1,
      DOMFocusOut: 1,
      drag: 1,
      dragend: 1,
      dragenter: 1,
      dragleave: 1,
      dragover: 1,
      dragstart: 1,
      drop: 1,
      focus: 1,
      focusin: 1,
      focusout: 1,
      gotpointercapture: 1,
      input: 1,
      keydown: 1,
      keypress: 1,
      keyup: 1,
      lostpointercapture: 1,
      mousedown: 1,
      mouseenter: 1,
      mouseleave: 1,
      mousemove: 1,
      mouseout: 1,
      mouseover: 1,
      mouseup: 1,
      paste: 1,
      pointercancel: 1,
      pointerdown: 1,
      pointerenter: 1,
      pointerleave: 1,
      pointermove: 1,
      pointerout: 1,
      pointerover: 1,
      pointerup: 1,
      touchcancel: 1,
      touchend: 1,
      touchmove: 1,
      touchstart: 1,
      wheel: 1
    });
    const EventConstructor = Event;
    function PatchedEvent(type, eventInitDict) {
      const event = new EventConstructor(type, eventInitDict);
      const isComposed = !!(eventInitDict && eventInitDict.composed);
      Object.defineProperties(event, {
        composed: {
          get() {
            return isComposed;
          },
          configurable: true,
          enumerable: true
        }
      });
      return event;
    }
    PatchedEvent.prototype = EventConstructor.prototype;
    PatchedEvent.AT_TARGET = EventConstructor.AT_TARGET;
    PatchedEvent.BUBBLING_PHASE = EventConstructor.BUBBLING_PHASE;
    PatchedEvent.CAPTURING_PHASE = EventConstructor.CAPTURING_PHASE;
    PatchedEvent.NONE = EventConstructor.NONE;
    window.Event = PatchedEvent;
    Object.defineProperties(Event.prototype, {
      composed: {
        get() {
          const {
            type
          } = this;
          return composedEvents[type] === 1;
        },
        configurable: true,
        enumerable: true
      }
    });
  }
  if (detect$2()) {
    apply$2();
  }
  const CustomEventConstructor = CustomEvent;
  function PatchedCustomEvent(type, eventInitDict) {
    const event = new CustomEventConstructor(type, eventInitDict);
    const isComposed = !!(eventInitDict && eventInitDict.composed);
    Object.defineProperties(event, {
      composed: {
        get() {
          return isComposed;
        },
        configurable: true,
        enumerable: true
      }
    });
    return event;
  }
  PatchedCustomEvent.prototype = CustomEventConstructor.prototype;
  window.CustomEvent = PatchedCustomEvent;
  if (typeof ClipboardEvent !== "undefined") {
    const isComposedType = assign(create(null), {
      copy: 1,
      cut: 1,
      paste: 1
    });
    defineProperties(ClipboardEvent.prototype, {
      composed: {
        get() {
          const {
            type
          } = this;
          return isComposedType[type] === 1;
        },
        configurable: true,
        enumerable: true
      }
    });
  }
  function detect$1() {
    const hasIframe = typeof HTMLIFrameElement !== "undefined";
    const isCompat = typeof Proxy !== "undefined" && isTrue(Proxy.isCompat);
    return hasIframe && isCompat;
  }
  function apply$1() {
    const desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, "contentWindow");
    const {
      get: originalGetter
    } = desc;
    desc.get = function() {
      const original = originalGetter.call(this);
      if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {
        return original;
      }
      return wrapIframeWindow(original);
    };
    defineProperty(HTMLIFrameElement.prototype, "contentWindow", desc);
  }
  function wrapIframeWindow(win) {
    return {
      addEventListener() {
        return win.addEventListener.apply(win, arguments);
      },
      blur() {
        return win.blur.apply(win, arguments);
      },
      close() {
        return win.close.apply(win, arguments);
      },
      focus() {
        return win.focus.apply(win, arguments);
      },
      postMessage() {
        return win.postMessage.apply(win, arguments);
      },
      removeEventListener() {
        return win.removeEventListener.apply(win, arguments);
      },
      get closed() {
        return win.closed;
      },
      get frames() {
        return win.frames;
      },
      get length() {
        return win.length;
      },
      get location() {
        return win.location;
      },
      set location(value) {
        win.location = value;
      },
      get opener() {
        return win.opener;
      },
      get parent() {
        return win.parent;
      },
      get self() {
        return win.self;
      },
      get top() {
        return win.top;
      },
      get window() {
        return win.window;
      }
    };
  }
  if (detect$1()) {
    apply$1();
  }
  const OriginalMutationObserver = MutationObserver;
  const {
    disconnect: originalDisconnect,
    observe: originalObserve,
    takeRecords: originalTakeRecords
  } = OriginalMutationObserver.prototype;
  const wrapperLookupField = "$$lwcObserverCallbackWrapper$$";
  const observerLookupField = "$$lwcNodeObservers$$";
  const observerToNodesMap = new WeakMap();
  function getNodeObservers(node) {
    return node[observerLookupField];
  }
  function setNodeObservers(node, observers) {
    node[observerLookupField] = observers;
  }
  function retargetMutationRecord(originalRecord) {
    const {
      addedNodes,
      removedNodes,
      target,
      type
    } = originalRecord;
    const retargetedRecord = create(MutationRecord.prototype);
    defineProperties(retargetedRecord, {
      addedNodes: {
        get() {
          return addedNodes;
        },
        enumerable: true,
        configurable: true
      },
      removedNodes: {
        get() {
          return removedNodes;
        },
        enumerable: true,
        configurable: true
      },
      type: {
        get() {
          return type;
        },
        enumerable: true,
        configurable: true
      },
      target: {
        get() {
          return target.shadowRoot;
        },
        enumerable: true,
        configurable: true
      }
    });
    return retargetedRecord;
  }
  function isQualifiedObserver(observer2, target) {
    let parentNode = target;
    while (!isNull(parentNode)) {
      const parentNodeObservers = getNodeObservers(parentNode);
      if (!isUndefined(parentNodeObservers) && (parentNodeObservers[0] === observer2 || ArrayIndexOf.call(parentNodeObservers, observer2) !== -1)) {
        return true;
      }
      parentNode = parentNode.parentNode;
    }
    return false;
  }
  function filterMutationRecords(mutations, observer2) {
    return ArrayReduce.call(mutations, (filteredSet, record) => {
      const {
        target,
        addedNodes,
        removedNodes,
        type
      } = record;
      if (type === "childList" && !isUndefined(getNodeKey(target))) {
        if (addedNodes.length > 0) {
          const sampleNode = addedNodes[0];
          if (isQualifiedObserver(observer2, sampleNode)) {
            const nodeObservers = getNodeObservers(target);
            if (nodeObservers && (nodeObservers[0] === observer2 || ArrayIndexOf.call(nodeObservers, observer2) !== -1)) {
              ArrayPush.call(filteredSet, record);
            } else {
              ArrayPush.call(filteredSet, retargetMutationRecord(record));
            }
          }
        } else {
          const shadowRoot = target.shadowRoot;
          const sampleNode = removedNodes[0];
          if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) && isQualifiedObserver(observer2, target)) {
            ArrayPush.call(filteredSet, record);
          } else if (shadowRoot) {
            const shadowRootObservers = getNodeObservers(shadowRoot);
            if (shadowRootObservers && (shadowRootObservers[0] === observer2 || ArrayIndexOf.call(shadowRootObservers, observer2) !== -1)) {
              ArrayPush.call(filteredSet, retargetMutationRecord(record));
            }
          }
        }
      } else {
        if (isQualifiedObserver(observer2, target)) {
          ArrayPush.call(filteredSet, record);
        }
      }
      return filteredSet;
    }, []);
  }
  function getWrappedCallback(callback) {
    let wrappedCallback = callback[wrapperLookupField];
    if (isUndefined(wrappedCallback)) {
      wrappedCallback = callback[wrapperLookupField] = (mutations, observer2) => {
        const filteredRecords = filterMutationRecords(mutations, observer2);
        if (filteredRecords.length === 0) {
          return;
        }
        callback.call(observer2, filteredRecords, observer2);
      };
    }
    return wrappedCallback;
  }
  function PatchedMutationObserver(callback) {
    const wrappedCallback = getWrappedCallback(callback);
    const observer2 = new OriginalMutationObserver(wrappedCallback);
    return observer2;
  }
  function patchedDisconnect() {
    originalDisconnect.call(this);
    const observedNodes = observerToNodesMap.get(this);
    if (!isUndefined(observedNodes)) {
      forEach.call(observedNodes, (observedNode) => {
        const observers = observedNode[observerLookupField];
        if (!isUndefined(observers)) {
          const index = ArrayIndexOf.call(observers, this);
          if (index !== -1) {
            ArraySplice.call(observers, index, 1);
          }
        }
      });
      observedNodes.length = 0;
    }
  }
  function patchedObserve(target, options) {
    let targetObservers = getNodeObservers(target);
    if (isUndefined(targetObservers)) {
      targetObservers = [];
      setNodeObservers(target, targetObservers);
    }
    if (ArrayIndexOf.call(targetObservers, this) === -1) {
      ArrayPush.call(targetObservers, this);
    }
    if (isSyntheticShadowRoot(target)) {
      target = target.host;
    }
    if (observerToNodesMap.has(this)) {
      const observedNodes = observerToNodesMap.get(this);
      if (ArrayIndexOf.call(observedNodes, target) === -1) {
        ArrayPush.call(observedNodes, target);
      }
    } else {
      observerToNodesMap.set(this, [target]);
    }
    return originalObserve.call(this, target, options);
  }
  function patchedTakeRecords() {
    return filterMutationRecords(originalTakeRecords.call(this), this);
  }
  PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
  PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
  PatchedMutationObserver.prototype.observe = patchedObserve;
  PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
  defineProperty(window, "MutationObserver", {
    value: PatchedMutationObserver,
    configurable: true,
    writable: true
  });
  function patchedAddEventListener$1(type, listener, optionsOrCapture) {
    if (isSyntheticShadowHost(this)) {
      return addCustomElementEventListener.apply(this, arguments);
    }
    if (arguments.length < 2) {
      const args = ArraySlice.call(arguments);
      if (args.length > 1) {
        args[1] = getEventListenerWrapper(args[1]);
      }
      return addEventListener2.apply(this, args);
    }
    const wrappedListener = getEventListenerWrapper(listener);
    return addEventListener2.call(this, type, wrappedListener, optionsOrCapture);
  }
  function patchedRemoveEventListener$1(_type, _listener, _optionsOrCapture) {
    if (isSyntheticShadowHost(this)) {
      return removeCustomElementEventListener.apply(this, arguments);
    }
    const args = ArraySlice.call(arguments);
    if (arguments.length > 1) {
      args[1] = getEventListenerWrapper(args[1]);
    }
    removeEventListener2.apply(this, args);
    removeEventListener2.apply(this, arguments);
  }
  defineProperties(eventTargetPrototype, {
    addEventListener: {
      value: patchedAddEventListener$1,
      enumerable: true,
      writable: true,
      configurable: true
    },
    removeEventListener: {
      value: patchedRemoveEventListener$1,
      enumerable: true,
      writable: true,
      configurable: true
    }
  });
  function detect() {
    return typeof EventTarget === "undefined";
  }
  function patchedAddEventListener(_type, _listener, _options) {
    if (arguments.length > 1) {
      const args = ArraySlice.call(arguments);
      args[1] = getEventListenerWrapper(args[1]);
      return windowAddEventListener.apply(this, args);
    }
    return windowAddEventListener.apply(this, arguments);
  }
  function patchedRemoveEventListener(_type, _listener, _options) {
    if (arguments.length > 1) {
      const args = ArraySlice.call(arguments);
      args[1] = getEventListenerWrapper(args[1]);
      windowRemoveEventListener.apply(this, args);
    }
    windowRemoveEventListener.apply(this, arguments);
  }
  function apply() {
    defineProperties(Window.prototype, {
      addEventListener: {
        value: patchedAddEventListener,
        enumerable: true,
        writable: true,
        configurable: true
      },
      removeEventListener: {
        value: patchedRemoveEventListener,
        enumerable: true,
        writable: true,
        configurable: true
      }
    });
  }
  if (detect()) {
    apply();
  }
  function patchedCurrentTargetGetter() {
    const currentTarget = eventCurrentTargetGetter.call(this);
    if (isNull(currentTarget)) {
      return null;
    }
    if (eventToContextMap.get(this) === 1) {
      return getShadowRoot(currentTarget);
    }
    return currentTarget;
  }
  function patchedTargetGetter() {
    const originalTarget = eventTargetGetter.call(this);
    if (!(originalTarget instanceof _Node)) {
      return originalTarget;
    }
    const doc = getOwnerDocument(originalTarget);
    const composedPath2 = pathComposer(originalTarget, this.composed);
    const originalCurrentTarget = eventCurrentTargetGetter.call(this);
    if (!(originalCurrentTarget instanceof _Node)) {
      if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
        return originalTarget;
      }
      return retarget(doc, composedPath2);
    } else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
      if (isUndefined(getNodeOwnerKey(originalTarget))) {
        return originalTarget;
      }
      return retarget(doc, composedPath2);
    }
    let actualCurrentTarget = originalCurrentTarget;
    let actualPath = composedPath2;
    if (isSyntheticShadowHost(originalCurrentTarget)) {
      const context = eventToContextMap.get(this);
      if (context === 1) {
        actualCurrentTarget = getShadowRoot(originalCurrentTarget);
      }
    }
    if (isSyntheticShadowHost(originalTarget) && eventToShadowRootMap.has(this)) {
      actualPath = pathComposer(getShadowRoot(originalTarget), this.composed);
    }
    return retarget(actualCurrentTarget, actualPath);
  }
  function patchedComposedPathValue() {
    const originalTarget = eventTargetGetter.call(this);
    if (!(originalTarget instanceof _Node)) {
      return [];
    }
    const hasShadowRoot = Boolean(originalTarget.shadowRoot);
    const hasSyntheticShadowRootAttached = hasInternalSlot(originalTarget);
    if (hasShadowRoot && !hasSyntheticShadowRootAttached) {
      return composedPath.call(this);
    }
    const originalCurrentTarget = eventCurrentTargetGetter.call(this);
    if (isNull(originalCurrentTarget)) {
      return [];
    }
    let actualTarget = originalTarget;
    if (isSyntheticShadowHost(originalTarget) && eventToShadowRootMap.has(this)) {
      actualTarget = getShadowRoot(originalTarget);
    }
    return pathComposer(actualTarget, this.composed);
  }
  defineProperties(Event.prototype, {
    target: {
      get: patchedTargetGetter,
      enumerable: true,
      configurable: true
    },
    currentTarget: {
      get: patchedCurrentTargetGetter,
      enumerable: true,
      configurable: true
    },
    composedPath: {
      value: patchedComposedPathValue,
      writable: true,
      enumerable: true,
      configurable: true
    },
    srcElement: {
      get: patchedTargetGetter,
      enumerable: true,
      configurable: true
    },
    path: {
      get: patchedComposedPathValue,
      enumerable: true,
      configurable: true
    }
  });
  function retargetRelatedTarget(Ctor) {
    const relatedTargetGetter = getOwnPropertyDescriptor(Ctor.prototype, "relatedTarget").get;
    defineProperty(Ctor.prototype, "relatedTarget", {
      get() {
        const relatedTarget = relatedTargetGetter.call(this);
        if (isNull(relatedTarget)) {
          return null;
        }
        if (!(relatedTarget instanceof _Node) || !isNodeShadowed(relatedTarget)) {
          return relatedTarget;
        }
        let pointOfReference = eventCurrentTargetGetter.call(this);
        if (isNull(pointOfReference)) {
          pointOfReference = getOwnerDocument(relatedTarget);
        }
        return retarget(pointOfReference, pathComposer(relatedTarget, true));
      },
      enumerable: true,
      configurable: true
    });
  }
  retargetRelatedTarget(FocusEvent);
  retargetRelatedTarget(MouseEvent);
  const assignedSlotGetter = hasOwnProperty.call(Text.prototype, "assignedSlot") ? getOwnPropertyDescriptor(Text.prototype, "assignedSlot").get : () => null;
  let observer;
  const observerConfig = {
    childList: true
  };
  const SlotChangeKey = new WeakMap();
  function initSlotObserver() {
    return new MO((mutations) => {
      const slots = [];
      forEach.call(mutations, (mutation) => {
        if (true) {
          assert.invariant(mutation.type === "childList", `Invalid mutation type: ${mutation.type}. This mutation handler for slots should only handle "childList" mutations.`);
        }
        const {
          target: slot
        } = mutation;
        if (ArrayIndexOf.call(slots, slot) === -1) {
          ArrayPush.call(slots, slot);
          dispatchEvent.call(slot, new CustomEvent("slotchange"));
        }
      });
    });
  }
  function getFilteredSlotFlattenNodes(slot) {
    const childNodes = arrayFromCollection(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, (seed, child) => {
      if (child instanceof Element && isSlotElement(child)) {
        ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
      } else {
        ArrayPush.call(seed, child);
      }
      return seed;
    }, []);
  }
  function assignedSlotGetterPatched() {
    const parentNode = parentNodeGetter.call(this);
    if (parentNode instanceof Element) {
      const sr = shadowRootGetter.call(parentNode);
      if (isInstanceOfNativeShadowRoot(sr)) {
        if (this instanceof Text) {
          return assignedSlotGetter.call(this);
        }
        return assignedSlotGetter$1.call(this);
      }
    }
    if (!isNull(parentNode) && isSlotElement(parentNode) && getNodeOwnerKey(parentNode) !== getNodeOwnerKey(this)) {
      return parentNode;
    }
    return null;
  }
  defineProperties(HTMLSlotElement.prototype, {
    addEventListener: {
      value(type, listener, options) {
        HTMLElement.prototype.addEventListener.call(this, type, listener, options);
        if (type === "slotchange" && !SlotChangeKey.get(this)) {
          SlotChangeKey.set(this, true);
          if (!observer) {
            observer = initSlotObserver();
          }
          MutationObserverObserve.call(observer, this, observerConfig);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    assignedElements: {
      value(options) {
        if (isNodeShadowed(this)) {
          const flatten = !isUndefined(options) && isTrue(options.flatten);
          const nodes = flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
          return ArrayFilter.call(nodes, (node) => node instanceof Element);
        } else {
          return assignedElements.apply(this, ArraySlice.call(arguments));
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    assignedNodes: {
      value(options) {
        if (isNodeShadowed(this)) {
          const flatten = !isUndefined(options) && isTrue(options.flatten);
          return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
        } else {
          return assignedNodes.apply(this, ArraySlice.call(arguments));
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    name: {
      get() {
        const name = getAttribute.call(this, "name");
        return isNull(name) ? "" : name;
      },
      set(value) {
        setAttribute.call(this, "name", value);
      },
      enumerable: true,
      configurable: true
    },
    childNodes: {
      get() {
        if (isNodeShadowed(this)) {
          const owner = getNodeOwner(this);
          const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
          return createStaticNodeList(childNodes);
        }
        return childNodesGetter.call(this);
      },
      enumerable: true,
      configurable: true
    }
  });
  defineProperties(Text.prototype, {
    assignedSlot: {
      get: assignedSlotGetterPatched,
      enumerable: true,
      configurable: true
    }
  });
  function getNonPatchedFilteredArrayOfNodes(context, unfilteredNodes) {
    let filtered;
    const ownerKey = getNodeOwnerKey(context);
    if (!isUndefined(ownerKey)) {
      if (isSyntheticShadowHost(context)) {
        const owner = getNodeOwner(context);
        if (isNull(owner)) {
          filtered = [];
        } else if (getNodeKey(context)) {
          filtered = getAllSlottedMatches(context, unfilteredNodes);
        } else {
          filtered = getAllMatches(owner, unfilteredNodes);
        }
      } else {
        filtered = ArrayFilter.call(unfilteredNodes, (elm) => getNodeNearestOwnerKey(elm) === ownerKey);
      }
    } else if (context instanceof HTMLBodyElement) {
      filtered = ArrayFilter.call(unfilteredNodes, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
    } else {
      filtered = ArraySlice.call(unfilteredNodes);
    }
    return filtered;
  }
  function innerHTMLGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    let innerHTML = "";
    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      innerHTML += getOuterHTML(childNodes[i]);
    }
    return innerHTML;
  }
  function outerHTMLGetterPatched() {
    return getOuterHTML(this);
  }
  function attachShadowPatched(options) {
    if (options[KEY__SYNTHETIC_MODE]) {
      return attachShadow(this, options);
    }
    return attachShadow$1.call(this, options);
  }
  function shadowRootGetterPatched() {
    if (isSyntheticShadowHost(this)) {
      const shadow = getShadowRoot(this);
      if (shadow.mode === "open") {
        return shadow;
      }
    }
    return shadowRootGetter.call(this);
  }
  function childrenGetterPatched() {
    const owner = getNodeOwner(this);
    const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
    return createStaticHTMLCollection(ArrayFilter.call(childNodes, (node) => node instanceof Element));
  }
  function childElementCountGetterPatched() {
    return this.children.length;
  }
  function firstElementChildGetterPatched() {
    return this.children[0] || null;
  }
  function lastElementChildGetterPatched() {
    const {
      children
    } = this;
    return children.item(children.length - 1) || null;
  }
  defineProperties(Element.prototype, {
    innerHTML: {
      get() {
        if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
          return innerHTMLGetterPatched.call(this);
        }
        return innerHTMLGetter.call(this);
      },
      set(v) {
        innerHTMLSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    },
    outerHTML: {
      get() {
        if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {
          return outerHTMLGetterPatched.call(this);
        }
        return outerHTMLGetter.call(this);
      },
      set(v) {
        outerHTMLSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    },
    attachShadow: {
      value: attachShadowPatched,
      enumerable: true,
      writable: true,
      configurable: true
    },
    shadowRoot: {
      get: shadowRootGetterPatched,
      enumerable: true,
      configurable: true
    },
    children: {
      get() {
        if (hasMountedChildren(this)) {
          return childrenGetterPatched.call(this);
        }
        return childrenGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    childElementCount: {
      get() {
        if (hasMountedChildren(this)) {
          return childElementCountGetterPatched.call(this);
        }
        return childElementCountGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    firstElementChild: {
      get() {
        if (hasMountedChildren(this)) {
          return firstElementChildGetterPatched.call(this);
        }
        return firstElementChildGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    lastElementChild: {
      get() {
        if (hasMountedChildren(this)) {
          return lastElementChildGetterPatched.call(this);
        }
        return lastElementChildGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    assignedSlot: {
      get: assignedSlotGetterPatched,
      enumerable: true,
      configurable: true
    }
  });
  if (hasOwnProperty.call(HTMLElement.prototype, "innerHTML")) {
    defineProperty(HTMLElement.prototype, "innerHTML", getOwnPropertyDescriptor(Element.prototype, "innerHTML"));
  }
  if (hasOwnProperty.call(HTMLElement.prototype, "outerHTML")) {
    defineProperty(HTMLElement.prototype, "outerHTML", getOwnPropertyDescriptor(Element.prototype, "outerHTML"));
  }
  if (hasOwnProperty.call(HTMLElement.prototype, "children")) {
    defineProperty(HTMLElement.prototype, "children", getOwnPropertyDescriptor(Element.prototype, "children"));
  }
  function querySelectorPatched() {
    const nodeList = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
    if (isSyntheticShadowHost(this)) {
      const owner = getNodeOwner(this);
      if (!isUndefined(getNodeKey(this))) {
        return getFirstSlottedMatch(this, nodeList);
      } else if (isNull(owner)) {
        return null;
      } else {
        return getFirstMatch(owner, nodeList);
      }
    } else if (isNodeShadowed(this)) {
      const ownerKey = getNodeOwnerKey(this);
      if (!isUndefined(ownerKey)) {
        const elm = ArrayFind.call(nodeList, (elm2) => getNodeNearestOwnerKey(elm2) === ownerKey);
        return isUndefined(elm) ? null : elm;
      } else {
        return nodeList.length === 0 ? null : nodeList[0];
      }
    } else {
      if (!(this instanceof HTMLBodyElement)) {
        const elm2 = nodeList[0];
        return isUndefined(elm2) ? null : elm2;
      }
      const elm = ArrayFind.call(nodeList, (elm2) => isUndefined(getNodeOwnerKey(elm2)) || isGlobalPatchingSkipped(this));
      return isUndefined(elm) ? null : elm;
    }
  }
  function getFilteredArrayOfNodes(context, unfilteredNodes) {
    let filtered;
    if (isSyntheticShadowHost(context)) {
      const owner = getNodeOwner(context);
      if (!isUndefined(getNodeKey(context))) {
        filtered = getAllSlottedMatches(context, unfilteredNodes);
      } else if (isNull(owner)) {
        filtered = [];
      } else {
        filtered = getAllMatches(owner, unfilteredNodes);
      }
    } else if (isNodeShadowed(context)) {
      const ownerKey = getNodeOwnerKey(context);
      if (!isUndefined(ownerKey)) {
        filtered = ArrayFilter.call(unfilteredNodes, (elm) => getNodeNearestOwnerKey(elm) === ownerKey);
      } else {
        filtered = ArraySlice.call(unfilteredNodes);
      }
    } else {
      if (context instanceof HTMLBodyElement) {
        filtered = ArrayFilter.call(unfilteredNodes, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
      } else {
        filtered = ArraySlice.call(unfilteredNodes);
      }
    }
    return filtered;
  }
  defineProperties(Element.prototype, {
    querySelector: {
      value: querySelectorPatched,
      writable: true,
      enumerable: true,
      configurable: true
    },
    querySelectorAll: {
      value() {
        const nodeList = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
        const filteredResults = getFilteredArrayOfNodes(this, nodeList);
        return createStaticNodeList(filteredResults);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });
  if (true) {
    defineProperties(Element.prototype, {
      getElementsByClassName: {
        value() {
          const elements = arrayFromCollection(getElementsByClassName$1.apply(this, ArraySlice.call(arguments)));
          return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
        },
        writable: true,
        enumerable: true,
        configurable: true
      },
      getElementsByTagName: {
        value() {
          const elements = arrayFromCollection(getElementsByTagName$1.apply(this, ArraySlice.call(arguments)));
          return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
        },
        writable: true,
        enumerable: true,
        configurable: true
      },
      getElementsByTagNameNS: {
        value() {
          const elements = arrayFromCollection(getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments)));
          return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
        },
        writable: true,
        enumerable: true,
        configurable: true
      }
    });
  }
  if (hasOwnProperty.call(HTMLElement.prototype, "getElementsByClassName")) {
    defineProperty(HTMLElement.prototype, "getElementsByClassName", getOwnPropertyDescriptor(Element.prototype, "getElementsByClassName"));
  }
  const FocusableSelector = `
    [contenteditable],
    [tabindex],
    a[href],
    area[href],
    audio[controls],
    button,
    iframe,
    input,
    select,
    textarea,
    video[controls]
`;
  const formElementTagNames = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA"]);
  function filterSequentiallyFocusableElements(elements) {
    return elements.filter((element) => {
      if (hasAttribute.call(element, "tabindex")) {
        return getAttribute.call(element, "tabindex") === "0";
      }
      if (formElementTagNames.has(tagNameGetter.call(element))) {
        return !hasAttribute.call(element, "disabled");
      }
      return true;
    });
  }
  const DidAddMouseEventListeners = new WeakMap();
  function isVisible(element) {
    const {
      width,
      height
    } = getBoundingClientRect.call(element);
    const noZeroSize = width > 0 || height > 0;
    const isAreaElement = element.tagName === "AREA";
    return (noZeroSize || isAreaElement) && getComputedStyle(element).visibility !== "hidden";
  }
  function isTabbable(element) {
    if (isSyntheticShadowHost(element) && isDelegatingFocus(element)) {
      return false;
    }
    return matches.call(element, FocusableSelector) && isVisible(element);
  }
  function hostElementFocus() {
    const _rootNode = this.getRootNode();
    if (_rootNode === this) {
      const focusable = querySelector.call(this, FocusableSelector);
      if (!isNull(focusable)) {
        focusable.focus.apply(focusable, arguments);
      }
      return;
    }
    const rootNode = _rootNode;
    if (rootNode.activeElement === this) {
      return;
    }
    const focusables = arrayFromCollection(querySelectorAll$1.call(this, FocusableSelector));
    let didFocus = false;
    while (!didFocus && focusables.length !== 0) {
      const focusable = focusables.shift();
      focusable.focus.apply(focusable, arguments);
      const currentRootNode = focusable.getRootNode();
      didFocus = currentRootNode.activeElement === focusable;
    }
  }
  function getTabbableSegments(host) {
    const doc = getOwnerDocument(host);
    const all = filterSequentiallyFocusableElements(arrayFromCollection(querySelectorAll.call(doc, FocusableSelector)));
    const inner = filterSequentiallyFocusableElements(arrayFromCollection(querySelectorAll$1.call(host, FocusableSelector)));
    if (true) {
      assert.invariant(getAttribute.call(host, "tabindex") === "-1" || isDelegatingFocus(host), `The focusin event is only relevant when the tabIndex property is -1 on the host.`);
    }
    const firstChild = inner[0];
    const lastChild = inner[inner.length - 1];
    const hostIndex = ArrayIndexOf.call(all, host);
    const firstChildIndex = hostIndex > -1 ? hostIndex : ArrayIndexOf.call(all, firstChild);
    const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : ArrayIndexOf.call(all, lastChild) + 1;
    const prev = ArraySlice.call(all, 0, firstChildIndex);
    const next = ArraySlice.call(all, lastChildIndex);
    return {
      prev,
      inner,
      next
    };
  }
  function getActiveElement(host) {
    const doc = getOwnerDocument(host);
    const activeElement = DocumentPrototypeActiveElement.call(doc);
    if (isNull(activeElement)) {
      return activeElement;
    }
    return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 ? activeElement : null;
  }
  function relatedTargetPosition(host, relatedTarget) {
    const pos = compareDocumentPosition.call(host, relatedTarget);
    if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
      return 0;
    } else if (pos & DOCUMENT_POSITION_PRECEDING) {
      return 1;
    } else if (pos & DOCUMENT_POSITION_FOLLOWING) {
      return 2;
    }
    return -1;
  }
  function muteEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }
  function muteFocusEventsDuringExecution(win, func) {
    windowAddEventListener.call(win, "focusin", muteEvent, true);
    windowAddEventListener.call(win, "focusout", muteEvent, true);
    func();
    windowRemoveEventListener.call(win, "focusin", muteEvent, true);
    windowRemoveEventListener.call(win, "focusout", muteEvent, true);
  }
  function focusOnNextOrBlur(segment, target, relatedTarget) {
    const win = getOwnerWindow(relatedTarget);
    const next = getNextTabbable(segment, relatedTarget);
    if (isNull(next)) {
      muteFocusEventsDuringExecution(win, () => {
        target.blur();
      });
    } else {
      muteFocusEventsDuringExecution(win, () => {
        next.focus();
      });
    }
  }
  let letBrowserHandleFocus = false;
  function disableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = true;
  }
  function enableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = false;
  }
  function isKeyboardFocusNavigationRoutineEnabled() {
    return !letBrowserHandleFocus;
  }
  function skipHostHandler(event) {
    if (letBrowserHandleFocus) {
      return;
    }
    const host = eventCurrentTargetGetter.call(event);
    const target = eventTargetGetter.call(event);
    if (host !== target) {
      return;
    }
    const relatedTarget = focusEventRelatedTargetGetter.call(event);
    if (isNull(relatedTarget)) {
      return;
    }
    const segments = getTabbableSegments(host);
    const position = relatedTargetPosition(host, relatedTarget);
    if (position === 1) {
      const findTabbableElms = isTabbableFrom.bind(null, host.getRootNode());
      const first = ArrayFind.call(segments.inner, findTabbableElms);
      if (!isUndefined(first)) {
        const win = getOwnerWindow(first);
        muteFocusEventsDuringExecution(win, () => {
          first.focus();
        });
      } else {
        focusOnNextOrBlur(segments.next, target, relatedTarget);
      }
    } else if (host === target) {
      focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
  }
  function skipShadowHandler(event) {
    if (letBrowserHandleFocus) {
      return;
    }
    const relatedTarget = focusEventRelatedTargetGetter.call(event);
    if (isNull(relatedTarget)) {
      return;
    }
    const host = eventCurrentTargetGetter.call(event);
    const segments = getTabbableSegments(host);
    if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
      return;
    }
    const target = eventTargetGetter.call(event);
    const position = relatedTargetPosition(host, relatedTarget);
    if (position === 1) {
      focusOnNextOrBlur(segments.next, target, relatedTarget);
    }
    if (position === 2) {
      focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
  }
  function isTabbableFrom(fromRoot, toElm) {
    if (!isTabbable(toElm)) {
      return false;
    }
    const ownerDocument = getOwnerDocument(toElm);
    let root = toElm.getRootNode();
    while (root !== ownerDocument && root !== fromRoot) {
      const sr = root;
      const host = sr.host;
      if (getAttribute.call(host, "tabindex") === "-1") {
        return false;
      }
      root = host && host.getRootNode();
    }
    return true;
  }
  function getNextTabbable(tabbables, relatedTarget) {
    const len = tabbables.length;
    if (len > 0) {
      for (let i = 0; i < len; i += 1) {
        const next = tabbables[i];
        if (isTabbableFrom(relatedTarget.getRootNode(), next)) {
          return next;
        }
      }
    }
    return null;
  }
  function handleFocus(elm) {
    if (true) {
      assert.invariant(isDelegatingFocus(elm), `Invalid attempt to handle focus event for ${toString(elm)}. ${toString(elm)} should have delegates focus true, but is not delegating focus`);
    }
    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocusIn(elm);
    addEventListener2.call(elm, "focusin", skipHostHandler, true);
  }
  function ignoreFocus(elm) {
    removeEventListener2.call(elm, "focusin", skipHostHandler, true);
  }
  function bindDocumentMousedownMouseupHandlers(elm) {
    const ownerDocument = getOwnerDocument(elm);
    if (!DidAddMouseEventListeners.get(ownerDocument)) {
      DidAddMouseEventListeners.set(ownerDocument, true);
      addEventListener2.call(ownerDocument, "mousedown", disableKeyboardFocusNavigationRoutines, true);
      addEventListener2.call(ownerDocument, "mouseup", () => {
        setTimeout(enableKeyboardFocusNavigationRoutines);
      }, true);
      addEventListener2.call(ownerDocument, "dragstart", enableKeyboardFocusNavigationRoutines, true);
    }
  }
  function handleFocusIn(elm) {
    if (true) {
      assert.invariant(tabIndexGetter.call(elm) === -1, `Invalid attempt to handle focus in  ${toString(elm)}. ${toString(elm)} should have tabIndex -1, but has tabIndex ${tabIndexGetter.call(elm)}`);
    }
    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocus(elm);
    addEventListener2.call(elm, "focusin", skipShadowHandler, true);
  }
  function ignoreFocusIn(elm) {
    removeEventListener2.call(elm, "focusin", skipShadowHandler, true);
  }
  const {
    blur,
    focus
  } = HTMLElement.prototype;
  function tabIndexGetterPatched() {
    if (isDelegatingFocus(this) && isFalse(hasAttribute.call(this, "tabindex"))) {
      return 0;
    }
    return tabIndexGetter.call(this);
  }
  function tabIndexSetterPatched(value) {
    const delegatesFocus = isDelegatingFocus(this);
    const prevValue = tabIndexGetter.call(this);
    const prevHasAttr = hasAttribute.call(this, "tabindex");
    tabIndexSetter.call(this, value);
    const currValue = tabIndexGetter.call(this);
    const currHasAttr = hasAttribute.call(this, "tabindex");
    const didValueChange = prevValue !== currValue;
    if (prevHasAttr && (didValueChange || isFalse(currHasAttr))) {
      if (prevValue === -1) {
        ignoreFocusIn(this);
      }
      if (prevValue === 0 && delegatesFocus) {
        ignoreFocus(this);
      }
    }
    if (isFalse(currHasAttr)) {
      return;
    }
    if (prevHasAttr && currHasAttr && isFalse(didValueChange)) {
      return;
    }
    if (currValue === -1) {
      handleFocusIn(this);
    }
    if (currValue === 0 && delegatesFocus) {
      handleFocus(this);
    }
  }
  function blurPatched() {
    if (isDelegatingFocus(this)) {
      const currentActiveElement = getActiveElement(this);
      if (!isNull(currentActiveElement)) {
        currentActiveElement.blur();
        return;
      }
    }
    return blur.call(this);
  }
  function focusPatched() {
    const originallyEnabled = isKeyboardFocusNavigationRoutineEnabled();
    if (originallyEnabled) {
      disableKeyboardFocusNavigationRoutines();
    }
    if (isSyntheticShadowHost(this) && isDelegatingFocus(this)) {
      hostElementFocus.call(this);
      return;
    }
    focus.apply(this, arguments);
    if (originallyEnabled) {
      enableKeyboardFocusNavigationRoutines();
    }
  }
  defineProperties(HTMLElement.prototype, {
    tabIndex: {
      get() {
        if (isSyntheticShadowHost(this)) {
          return tabIndexGetterPatched.call(this);
        }
        return tabIndexGetter.call(this);
      },
      set(v) {
        if (isSyntheticShadowHost(this)) {
          return tabIndexSetterPatched.call(this, v);
        }
        return tabIndexSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    },
    blur: {
      value() {
        if (isSyntheticShadowHost(this)) {
          return blurPatched.call(this);
        }
        blur.call(this);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    focus: {
      value() {
        focusPatched.apply(this, arguments);
      },
      enumerable: true,
      writable: true,
      configurable: true
    }
  });
  if (innerTextGetter !== null && innerTextSetter !== null) {
    defineProperty(HTMLElement.prototype, "innerText", {
      get() {
        return innerTextGetter.call(this);
      },
      set(v) {
        innerTextSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    });
  }
  if (outerTextGetter !== null && outerTextSetter !== null) {
    defineProperty(HTMLElement.prototype, "outerText", {
      get() {
        return outerTextGetter.call(this);
      },
      set(v) {
        outerTextSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    });
  }
  function getShadowToken(node) {
    return node[KEY__SHADOW_TOKEN];
  }
  function setShadowToken(node, shadowToken) {
    node[KEY__SHADOW_TOKEN] = shadowToken;
  }
  defineProperty(Element.prototype, KEY__SHADOW_TOKEN, {
    set(shadowToken) {
      const oldShadowToken = this[KEY__SHADOW_TOKEN_PRIVATE];
      if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
        removeAttribute.call(this, oldShadowToken);
      }
      if (!isUndefined(shadowToken)) {
        setAttribute.call(this, shadowToken, "");
      }
      this[KEY__SHADOW_TOKEN_PRIVATE] = shadowToken;
    },
    get() {
      return this[KEY__SHADOW_TOKEN_PRIVATE];
    },
    configurable: true
  });
  function recursivelySetShadowResolver(node, fn) {
    node[KEY__SHADOW_RESOLVER] = fn;
    const childNodes = childNodesGetter.call(node);
    for (let i = 0, n = childNodes.length; i < n; i++) {
      recursivelySetShadowResolver(childNodes[i], fn);
    }
  }
  defineProperty(Element.prototype, KEY__SHADOW_STATIC, {
    set(v) {
      if (v) {
        const fn = this[KEY__SHADOW_RESOLVER];
        recursivelySetShadowResolver(this, fn);
      }
      this[KEY__SHADOW_STATIC_PRIVATE] = v;
    },
    get() {
      return this[KEY__SHADOW_STATIC_PRIVATE];
    },
    configurable: true
  });
  const DomManualPrivateKey = "$$DomManualKey$$";
  const DocumentResolverFn = function() {
  };
  let portalObserver;
  const portalObserverConfig = {
    childList: true
  };
  function adoptChildNode(node, fn, shadowToken) {
    const previousNodeShadowResolver = getShadowRootResolver(node);
    if (previousNodeShadowResolver === fn) {
      return;
    }
    setShadowRootResolver(node, fn);
    if (node instanceof Element) {
      setShadowToken(node, shadowToken);
      if (isSyntheticShadowHost(node)) {
        return;
      }
      if (isUndefined(previousNodeShadowResolver)) {
        MutationObserverObserve.call(portalObserver, node, portalObserverConfig);
      }
      const childNodes = childNodesGetter.call(node);
      for (let i = 0, len = childNodes.length; i < len; i += 1) {
        adoptChildNode(childNodes[i], fn, shadowToken);
      }
    }
  }
  function initPortalObserver() {
    return new MO((mutations) => {
      forEach.call(mutations, (mutation) => {
        const {
          target: elm,
          addedNodes,
          removedNodes
        } = mutation;
        const fn = getShadowRootResolver(elm);
        const shadowToken = getShadowToken(elm);
        for (let i = 0, len = removedNodes.length; i < len; i += 1) {
          const node = removedNodes[i];
          if (!(compareDocumentPosition.call(elm, node) & _Node.DOCUMENT_POSITION_CONTAINED_BY)) {
            adoptChildNode(node, DocumentResolverFn, void 0);
          }
        }
        for (let i = 0, len = addedNodes.length; i < len; i += 1) {
          const node = addedNodes[i];
          if (compareDocumentPosition.call(elm, node) & _Node.DOCUMENT_POSITION_CONTAINED_BY) {
            adoptChildNode(node, fn, shadowToken);
          }
        }
      });
    });
  }
  function markElementAsPortal(elm) {
    if (isUndefined(portalObserver)) {
      portalObserver = initPortalObserver();
    }
    if (isUndefined(getShadowRootResolver(elm))) {
      throw new Error(`Invalid Element`);
    }
    MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);
  }
  defineProperty(Element.prototype, "$domManual$", {
    set(v) {
      this[DomManualPrivateKey] = v;
      if (isTrue(v)) {
        markElementAsPortal(this);
      }
    },
    get() {
      return this[DomManualPrivateKey];
    },
    configurable: true
  });
});
LWR.define("@lwrjs/app-service/communities_app/module/amd/v/0_9_0", ["lwr/loaderLegacy/v/0_9_0", "@lwc/synthetic-shadow/v/2_41_4", "webruntime/hook/v/1_66_319-244_0", "webruntime/o11yHook/v/1_66_319-244_0", "webruntime/dynamicImportResourceHook/v/1_66_319-244_0", "lwr/init/v/0_9_0", "lwr/lockerDefine/v/0_9_0"], function(_0_9_0, _2_41_4, loaderService_webruntime_hook, loaderService_webruntime_o11yHook, loaderService_webruntime_dynamicImportResourceHook, _0_9_0$2, _0_9_0$1) {
  "use strict";
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : {default: e};
  }
  var loaderService_webruntime_hook__default = /* @__PURE__ */ _interopDefaultLegacy(loaderService_webruntime_hook);
  var loaderService_webruntime_o11yHook__default = /* @__PURE__ */ _interopDefaultLegacy(loaderService_webruntime_o11yHook);
  var loaderService_webruntime_dynamicImportResourceHook__default = /* @__PURE__ */ _interopDefaultLegacy(loaderService_webruntime_dynamicImportResourceHook);
  loaderService_webruntime_hook__default["default"](_0_9_0.services);
  loaderService_webruntime_o11yHook__default["default"](_0_9_0.services);
  loaderService_webruntime_dynamicImportResourceHook__default["default"](_0_9_0.services);
  _0_9_0$1.registerLockerDefine(["@locker/*", "lwr/*", "@lwrjs/*", "lwc", "@lwc/*", "lwr", "assert", "logger", "webruntime", "webruntime/*", "mobileruntime/hybridAppManager", "@view", "@view/*", "@app", "@app/*", "@design", "@design/*", "@lwrjs", "webruntimedesign", "webruntimedesign/*", "@luvio", "@luvio/*", "aura-instrumentation", "aura", "instrumentation/service", "instrumentation/utility", "aura-storage", "transport", "wire-service", "force/ldsAdaptersAnalyticsDataService", "force/ldsAdaptersAnalyticsSmartDataDiscovery", "force/ldsAdaptersAnalyticsWave", "force/ldsAdaptersAnalyticsWavePrivate", "force/ldsAdaptersApex", "force/ldsAdaptersCmsAuthoring", "force/ldsAdaptersCmsDelivery", "force/ldsAdaptersCmsType", "force/ldsAdaptersCommerceCatalog", "force/ldsAdaptersCommerceSearch", "force/ldsAdaptersCommerceStorePricing", "force/ldsAdaptersCommunityMicrobatching", "force/ldsAdaptersCommunityNavigationMenu", "force/ldsAdaptersCommunitySeo", "force/ldsAdaptersCommunitySitesSearch", "force/ldsAdaptersExperienceMarketingIntegration", "force/ldsAdaptersGraphql", "force/ldsAdaptersIndustriesCib", "force/ldsAdaptersIndustriesClm", "force/ldsAdaptersIndustriesDecisionMatrixDesigner", "force/ldsAdaptersIndustriesEinsteinAiaccelerator", "force/ldsAdaptersIndustriesExplainability", "force/ldsAdaptersIndustriesHealthcloudHpi", "force/ldsAdaptersIndustriesIdentityverification", "force/ldsAdaptersIndustriesInteresttagging", "force/ldsAdaptersIndustriesLoyaltyEngine", "force/ldsAdaptersIndustriesPublicSector", "force/ldsAdaptersIndustriesRcgTenantmanagement", "force/ldsAdaptersIndustriesRuleBuilder", "force/ldsAdaptersIndustriesSustainabilityBei", "force/ldsAdaptersIndustriesSustainabilityDgf", "force/ldsAdaptersIndustriesSustainabilityRecalculate", "force/ldsAdaptersIndustriesSustainabilityRecordLockunlock", "force/ldsAdaptersIndustriesSustainabilityReferenceData", "force/ldsAdaptersIndustriesTimeline", "force/ldsAdaptersIndustriesVideovisits", "force/ldsAdaptersMarketingAssetcreation", "force/ldsAdaptersPlatformAdminSuccessGuidance", "force/ldsAdaptersPlatformFlow", "force/ldsAdaptersPlatformFlowBuilder", "force/ldsAdaptersPlatformInteractionOrchestrator", "force/ldsAdaptersPlatformLearningContent", "force/ldsAdaptersPlatformScaleCenter", "force/ldsAdaptersRevenueBillingBatch", "force/ldsAdaptersUiapi", "force/ldsBindings", "force/ldsEngine", "force/ldsEngineCreator", "force/ldsEngineWebruntime", "force/ldsEnvironmentSettings", "force/ldsInstrumentation", "force/ldsNetwork", "force/ldsRecordData", "force/ldsStorage", "force/mobileCapabilities", "runtime_hybrid_capabilities/nativeCapabilities", "o11y", "o11y/*", "@o11y", "@o11y/*", "@salesforce", "@udd", "@perm", "@branding", "@salesforce/*", "@udd/*", "@perm/*", "@branding/*", "trustedDesign/shadowDomUtils", "community_builder/seoAssistant", "community_case/supportQuickActionLayout", "community_runtime/utils", "community_user/userSettings", "embeddedMessaging/container", "experience_messaging/embeddedMessaging", "community_login/checkEmail", "community_login/forgotPassword", "community_login/loginForm", "community_login/loginUtils", "community_login/selfRegister", "community_login/socialLogin", "b2c_lite_commerce/cartApi", "b2c_lite_commerce/checkout", "b2c_lite_commerce/checkoutApi", "b2c_lite_commerce/checkoutApiDataSource", "b2c_lite_commerce/checkoutRequestRetry", "b2c_lite_commerce/context", "b2c_lite_commerce/data", "b2c_lite_commerce/einsteinActivitiesApi", "b2c_lite_commerce/einsteinApi", "b2c_lite_commerce/einsteinProductAndPriceApi", "b2c_lite_commerce/heroBannerUi", "b2c_lite_commerce/myAccountMenu", "b2c_lite_commerce/orderSummary", "b2c_lite_commerce/store", "lightning", "lightning/*", "interop/button", "interop/buttonIcon", "dxp_page_layout/placeHolderDesign", "community_builder/richTextEditor", "dxp_form/baseForm", "dxp_form/contactForm", "dxp_form/dynamicForm", "dxp_form/layoutUtils", "dxp_form/leadForm", "dxp_base/languageSelector", "dxp_search/siteResults", "dxp_flowruntime", "dxp_flowruntime/*", "flowruntime", "flowruntime/*", "experience/store", "experience/data", "experience/util", "experience/cmsDeliveryApi", "experience/userApi"]);
  const clientBootstrapConfig = globalThis.LWR;
  const {rootComponents, ssrProps} = clientBootstrapConfig;
  Promise.all(rootComponents.map(async (rootSpecifier) => {
    const element = _0_9_0$2.toKebabCase(rootSpecifier);
    return _0_9_0.load(rootSpecifier, "@lwrjs/app-service/communities_app/module/amd/v/0_9_0").then(({default: Ctor}) => {
      _0_9_0$2.init([[element, Ctor]], ssrProps);
    });
  }));
  globalThis.LWR = Object.freeze({
    define: globalThis.LWR.define
  });
});
